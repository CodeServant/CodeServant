<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>JÄ™zyk programowania Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris-d33b75bf.css">
        <link rel="stylesheet" href="theme/2018-edition-4e126c62.css">
        <link rel="stylesheet" href="theme/semantic-notes-9b5766c0.css">
        <link rel="stylesheet" href="theme/listing-cab26221.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-773dca2f.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-039e37ba.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>â†</kbd> or <kbd>â†’</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">JÄ™zyk programowania Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="jÄ™zyk-programowania-rust"><a class="header" href="#jÄ™zyk-programowania-rust">JÄ™zyk programowania Rust</a></h1>
<p><em>autorzy: Steve Klabnik, Carol Nichols i Chris Krycho, Maciej Ostrowski (przekÅ‚ad pl gemini-2.5-pro sty 26 r.), przy
kontrybucjach SpoÅ‚ecznoÅ›ci Rusta</em></p>
<p>Ta wersja tekstu zakÅ‚ada, Å¼e uÅ¼ywasz Rusta w wersji 1.90.0 (wydanie 2025-09-18)
lub nowszej z <code>edition = "2024"</code> w pliku <em>Cargo.toml</em> wszystkich projektÃ³w, aby
skonfigurowaÄ‡ je do uÅ¼ywania idiomÃ³w wydania Rust 2024. Zobacz <a href="#instalacja-1">sekcjÄ™ â€Instalacjaâ€
w Rozdziale 1</a><!-- ignore -->, aby uzyskaÄ‡ instrukcje dotyczÄ…ce instalacji lub
aktualizacji Rusta, oraz <a href="#e---edycje">Dodatek E</a><!-- ignore -->, aby uzyskaÄ‡ informacje
o wydaniach.</p>
<p>Format HTML jest dostÄ™pny online pod adresem
<a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a>
oraz offline z instalacjami Rusta wykonanymi za pomocÄ… <code>rustup</code>; uruchom <code>rustup doc --book</code>, aby otworzyÄ‡.</p>
<p>DostÄ™pne sÄ… rÃ³wnieÅ¼ liczne [tÅ‚umaczenia] spoÅ‚ecznoÅ›ci.</p>
<p>Ten tekst jest dostÄ™pny w <a href="https://nostarch.com/rust-programming-language-3rd-edition">formacie papierowym i ebooku od No Starch
Press</a>.</p>
<blockquote>
<p><strong>ğŸš¨ Chcesz bardziej interaktywnego doÅ›wiadczenia edukacyjnego? WyprÃ³buj innÄ… wersjÄ™
KsiÄ…Å¼ki o RuÅ›cie, zawierajÄ…cÄ…: quizy, wyrÃ³Å¼nienia, wizualizacje i
wiele wiÄ™cej</strong>: <a href="https://rust-book.cs.brown.edu">https://rust-book.cs.brown.edu</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="przedmowa"><a class="header" href="#przedmowa">Przedmowa</a></h1>
<p>JÄ™zyk programowania Rust przeszedÅ‚ dÅ‚ugÄ… drogÄ™ w ciÄ…gu kilku krÃ³tkich lat, od
jego stworzenia i inkubacji przez maÅ‚Ä… i rodzÄ…cÄ… siÄ™ spoÅ‚ecznoÅ›Ä‡ entuzjastÃ³w,
aÅ¼ po stanie siÄ™ jednym z najbardziej lubianych i poszukiwanych jÄ™zykÃ³w
programowania na Å›wiecie. Z perspektywy czasu byÅ‚o nieuniknione, Å¼e moc i obietnica
Rusta przyciÄ…gnÄ… uwagÄ™ i zakorzeniÄ… siÄ™ w programowaniu systemowym. To, co nie
byÅ‚o nieuniknione, to globalny wzrost zainteresowania i innowacji, ktÃ³ry
przeniknÄ…Å‚ przez spoÅ‚ecznoÅ›ci open source i katalizowaÅ‚ szeroko zakrojonÄ…
adopcjÄ™ w rÃ³Å¼nych branÅ¼ach.</p>
<p>W tym momencie Å‚atwo jest wskazaÄ‡ wspaniaÅ‚e cechy, ktÃ³re Rust ma do zaoferowania,
aby wyjaÅ›niÄ‡ ten wybuch zainteresowania i adopcji. Kto nie chce bezpieczeÅ„stwa
pamiÄ™ci <em>i</em> szybkiej wydajnoÅ›ci, <em>i</em> przyjaznego kompilatora, <em>i</em>
wspaniaÅ‚ych narzÄ™dzi, poÅ›rÃ³d wielu innych wspaniaÅ‚ych funkcji? JÄ™zyk Rust,
ktÃ³ry widzisz dzisiaj, Å‚Ä…czy lata badaÅ„ w programowaniu systemowym z praktycznÄ…
mÄ…droÅ›ciÄ… tÄ™tniÄ…cej Å¼yciem i peÅ‚nej pasji spoÅ‚ecznoÅ›ci. Ten jÄ™zyk zostaÅ‚
zaprojektowany z myÅ›lÄ… o celu i starannie wykonany, oferujÄ…c deweloperom
narzÄ™dzie, ktÃ³re uÅ‚atwia pisanie bezpiecznego, szybkiego i niezawodnego kodu.</p>
<p>Ale to, co czyni Rusta naprawdÄ™ wyjÄ…tkowym, to jego korzenie w umoÅ¼liwianiu
tobie, uÅ¼ytkownikowi, osiÄ…gania twoich celÃ³w. Jest to jÄ™zyk, ktÃ³ry chce, abyÅ›
odniÃ³sÅ‚ sukces, a zasada wzmacniania pozycji przeplata siÄ™ przez rdzeÅ„
spoÅ‚ecznoÅ›ci, ktÃ³ra buduje, utrzymuje i promuje ten jÄ™zyk. Od poprzedniego
wydania tego definitywnego tekstu, Rust rozwinÄ…Å‚ siÄ™ w prawdziwie globalny i
zaufany jÄ™zyk. Projekt Rust jest teraz solidnie wspierany przez FundacjÄ™ Rust,
ktÃ³ra rÃ³wnieÅ¼ inwestuje w kluczowe inicjatywy, aby zapewniÄ‡, Å¼e Rust jest
bezpieczny, stabilny i zrÃ³wnowaÅ¼ony.</p>
<p>Niniejsze wydanie ksiÄ…Å¼ki <em>JÄ™zyk programowania Rust</em> jest kompleksowÄ…
aktualizacjÄ…, odzwierciedlajÄ…cÄ… ewolucjÄ™ jÄ™zyka na przestrzeni lat i dostarczajÄ…cÄ…
cennych nowych informacji. Ale to nie tylko przewodnik po skÅ‚adni i bibliotekach
â€” to zaproszenie do przyÅ‚Ä…czenia siÄ™ do spoÅ‚ecznoÅ›ci, ktÃ³ra ceni jakoÅ›Ä‡,
wydajnoÅ›Ä‡ i przemyÅ›lany projekt. NiezaleÅ¼nie od tego, czy jesteÅ› doÅ›wiadczonym
deweloperem, ktÃ³ry po raz pierwszy chce poznaÄ‡ Rusta, czy doÅ›wiadczonym
Rustaceanem, ktÃ³ry chce udoskonaliÄ‡ swoje umiejÄ™tnoÅ›ci, to wydanie oferuje
coÅ› dla kaÅ¼dego.</p>
<p>PodrÃ³Å¼ z Rustem to podrÃ³Å¼ wspÃ³Å‚pracy, nauki i iteracji. RozwÃ³j jÄ™zyka i jego
ekosystemu jest bezpoÅ›rednim odzwierciedleniem tÄ™tniÄ…cej Å¼yciem, rÃ³Å¼norodnej
spoÅ‚ecznoÅ›ci, ktÃ³ra za nim stoi. Kontrybucje tysiÄ™cy deweloperÃ³w, od
projektantÃ³w podstawowych jÄ™zykÃ³w po okazjonalnych kontrybutorÃ³w, sprawiajÄ…,
Å¼e Rust jest tak wyjÄ…tkowym i potÄ™Å¼nym narzÄ™dziem. BiorÄ…c tÄ™ ksiÄ…Å¼kÄ™ do rÄ™ki,
nie tylko uczysz siÄ™ nowego jÄ™zyka programowania â€” doÅ‚Ä…czasz do ruchu, ktÃ³ry
ma na celu ulepszanie oprogramowania, czynienie go bezpieczniejszym i przyjemniejszym
w obsÅ‚udze.</p>
<p>Witaj w spoÅ‚ecznoÅ›ci Rusta!</p>
<ul>
<li>Bec Rumbul, dyrektor wykonawcza Fundacji Rust</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wprowadzenie"><a class="header" href="#wprowadzenie">Wprowadzenie</a></h1>
<blockquote>
<p>Uwaga: To wydanie ksiÄ…Å¼ki jest takie samo jak <a href="https://nostarch.com/rust-programming-language-3rd-edition">JÄ™zyk programowania Rust</a>
dostÄ™pny w formie drukowanej i ebooka od <a href="https://nostarch.com/">No Starch Press</a>.</p>
</blockquote>
<p>Witaj w <em>JÄ™zyku programowania Rust</em>, ksiÄ…Å¼ce wprowadzajÄ…cej do Rusta.
JÄ™zyk programowania Rust pomaga pisaÄ‡ szybsze, bardziej niezawodne
oprogramowanie. Wysoka ergonomia i niska kontrola sÄ… czÄ™sto sprzeczne w
projektowaniu jÄ™zykÃ³w programowania; Rust kwestionuje ten konflikt. Poprzez
rÃ³wnowaÅ¼enie potÄ™Å¼nych moÅ¼liwoÅ›ci technicznych i wspaniaÅ‚ego doÅ›wiadczenia
deweloperskiego, Rust daje moÅ¼liwoÅ›Ä‡ kontrolowania niskopoziomowych szczegÃ³Å‚Ã³w
(takich jak uÅ¼ycie pamiÄ™ci) bez wszystkich kÅ‚opotÃ³w tradycyjnie
zwiÄ…zanych z takÄ… kontrolÄ….</p>
<h2 id="dla-kogo-jest-rust"><a class="header" href="#dla-kogo-jest-rust">Dla kogo jest Rust</a></h2>
<p>Rust jest idealny dla wielu osÃ³b z rÃ³Å¼nych powodÃ³w. Przyjrzyjmy siÄ™ kilku
najwaÅ¼niejszym grupom.</p>
<h3 id="zespoÅ‚y-deweloperskie"><a class="header" href="#zespoÅ‚y-deweloperskie">ZespoÅ‚y deweloperskie</a></h3>
<p>Rust okazuje siÄ™ byÄ‡ produktywnym narzÄ™dziem do wspÃ³Å‚pracy miÄ™dzy duÅ¼ymi
zespoÅ‚ami deweloperÃ³w o rÃ³Å¼nym poziomie znajomoÅ›ci programowania systemowego.
Niskopoziomowy kod jest podatny na rÃ³Å¼ne subtelne bÅ‚Ä™dy, ktÃ³re w wiÄ™kszoÅ›ci
innych jÄ™zykÃ³w moÅ¼na wykryÄ‡ jedynie poprzez obszerne testy i
starannÄ… weryfikacjÄ™ kodu przez doÅ›wiadczonych deweloperÃ³w. W RuÅ›cie
kompilator peÅ‚ni rolÄ™ straÅ¼nika, odmawiajÄ…c kompilacji kodu z tymi
nieuchwytnymi bÅ‚Ä™dami, w tym bÅ‚Ä™dami wspÃ³Å‚bieÅ¼noÅ›ci. PracujÄ…c obok
kompilatora, zespÃ³Å‚ moÅ¼e poÅ›wiÄ™ciÄ‡ swÃ³j czas na skupienie siÄ™ na logice
programu, zamiast Å›cigaÄ‡ bÅ‚Ä™dy.</p>
<p>Rust wprowadza rÃ³wnieÅ¼ nowoczesne narzÄ™dzia dla deweloperÃ³w do Å›wiata
programowania systemowego:</p>
<ul>
<li>Cargo, doÅ‚Ä…czony menedÅ¼er zaleÅ¼noÅ›ci i narzÄ™dzie do budowania, sprawia, Å¼e
dodawanie, kompilowanie i zarzÄ…dzanie zaleÅ¼noÅ›ciami jest bezbolesne i
spÃ³jne w caÅ‚ym ekosystemie Rusta.</li>
<li>NarzÄ™dzie formatujÄ…ce <code>rustfmt</code> zapewnia spÃ³jny styl kodowania wÅ›rÃ³d
deweloperÃ³w.</li>
<li>Rust Language Server zasila integracjÄ™ ze zintegrowanymi Å›rodowiskami
deweloperskimi (IDE) dla uzupeÅ‚niania kodu i wbudowanych komunikatÃ³w o
bÅ‚Ä™dach.</li>
</ul>
<p>DziÄ™ki tym i innym narzÄ™dziom w ekosystemie Rusta, deweloperzy mogÄ… byÄ‡
produktywni podczas pisania kodu na poziomie systemowym.</p>
<h3 id="studenci"><a class="header" href="#studenci">Studenci</a></h3>
<p>Rust jest dla studentÃ³w i tych, ktÃ³rzy sÄ… zainteresowani naukÄ… koncepcji
systemowych. UÅ¼ywajÄ…c Rusta, wiele osÃ³b uczyÅ‚o siÄ™ tematÃ³w takich jak rozwÃ³j
systemÃ³w operacyjnych. SpoÅ‚ecznoÅ›Ä‡ jest bardzo otwarta i chÄ™tnie odpowiada na
pytania studentÃ³w. Poprzez wysiÅ‚ki takie jak ta ksiÄ…Å¼ka, zespoÅ‚y Rusta chcÄ…
uczyniÄ‡ koncepcje systemowe bardziej dostÄ™pnymi dla wiÄ™kszej liczby osÃ³b,
szczegÃ³lnie dla tych, ktÃ³rzy dopiero zaczynajÄ… programowaÄ‡.</p>
<h3 id="firmy"><a class="header" href="#firmy">Firmy</a></h3>
<p>Setki firm, duÅ¼ych i maÅ‚ych, uÅ¼ywajÄ… Rusta w produkcji do rÃ³Å¼nych zadaÅ„,
w tym narzÄ™dzi wiersza poleceÅ„, usÅ‚ug sieciowych, narzÄ™dzi DevOps,
urzÄ…dzeÅ„ wbudowanych, analizy i transkodowania audio i wideo,
kryptowalut, bioinformatyki, wyszukiwarek, aplikacji Internetu Rzeczy,
uczenia maszynowego, a nawet gÅ‚Ã³wnych czÄ™Å›ci przeglÄ…darki internetowej
Firefox.</p>
<h3 id="deweloperzy-open-source"><a class="header" href="#deweloperzy-open-source">Deweloperzy open source</a></h3>
<p>Rust jest dla ludzi, ktÃ³rzy chcÄ… budowaÄ‡ jÄ™zyk programowania Rust, spoÅ‚ecznoÅ›Ä‡,
narzÄ™dzia deweloperskie i biblioteki. ChcielibyÅ›my, abyÅ› wniÃ³sÅ‚ swÃ³j wkÅ‚ad w
rozwÃ³j jÄ™zyka Rust.</p>
<h3 id="ludzie-ceniÄ…cy-szybkoÅ›Ä‡-i-stabilnoÅ›Ä‡"><a class="header" href="#ludzie-ceniÄ…cy-szybkoÅ›Ä‡-i-stabilnoÅ›Ä‡">Ludzie ceniÄ…cy szybkoÅ›Ä‡ i stabilnoÅ›Ä‡</a></h3>
<p>Rust jest dla ludzi, ktÃ³rzy pragnÄ… szybkoÅ›ci i stabilnoÅ›ci w jÄ™zyku. Przez
szybkoÅ›Ä‡ rozumiemy zarÃ³wno to, jak szybko moÅ¼e dziaÅ‚aÄ‡ kod Rusta, jak i szybkoÅ›Ä‡,
z jakÄ… Rust pozwala pisaÄ‡ programy. Kontrole kompilatora Rusta zapewniajÄ…
stabilnoÅ›Ä‡ poprzez dodawanie funkcji i refaktoryzacjÄ™. Jest to przeciwieÅ„stwo
kruchego starego kodu w jÄ™zykach bez tych kontroli, ktÃ³rego deweloperzy czÄ™sto
obawiajÄ… siÄ™ modyfikowaÄ‡. DÄ…Å¼Ä…c do abstrakcji zerokosztowych â€” funkcji
wyÅ¼szego poziomu, ktÃ³re kompilujÄ… siÄ™ do kodu niÅ¼szego poziomu tak szybko, jak
kod napisany rÄ™cznie â€” Rust stara siÄ™, aby bezpieczny kod byÅ‚ rÃ³wnieÅ¼ szybkim
kodem.</p>
<p>JÄ™zyk Rust ma nadziejÄ™ wspieraÄ‡ rÃ³wnieÅ¼ wielu innych uÅ¼ytkownikÃ³w; ci
wspomniani tutaj to tylko niektÃ³rzy z najwiÄ™kszych interesariuszy. OgÃ³lnie
rzecz biorÄ…c, najwiÄ™kszÄ… ambicjÄ… Rusta jest wyeliminowanie kompromisÃ³w,
ktÃ³re programiÅ›ci akceptowali przez dziesiÄ™ciolecia, zapewniajÄ…c bezpieczeÅ„stwo
<em>i</em> produktywnoÅ›Ä‡, szybkoÅ›Ä‡ <em>i</em> ergonomiÄ™. SprÃ³buj Rusta i zobacz, czy jego
wybory sprawdzÄ… siÄ™ dla Ciebie.</p>
<h2 id="dla-kogo-jest-ta-ksiÄ…Å¼ka"><a class="header" href="#dla-kogo-jest-ta-ksiÄ…Å¼ka">Dla kogo jest ta ksiÄ…Å¼ka</a></h2>
<p>Ta ksiÄ…Å¼ka zakÅ‚ada, Å¼e pisaÅ‚eÅ› juÅ¼ kod w innym jÄ™zyku programowania, ale nie
czyni Å¼adnych zaÅ‚oÅ¼eÅ„ co do tego, w jakim. StaraliÅ›my siÄ™, aby materiaÅ‚ byÅ‚
szeroko dostÄ™pny dla osÃ³b z rÃ³Å¼nych Å›rodowisk programistycznych. Nie spÄ™dzamy
wielu czasu na mÃ³wieniu o tym, czym <em>jest</em> programowanie ani jak o nim myÅ›leÄ‡.
JeÅ›li jesteÅ› zupeÅ‚nie poczÄ…tkujÄ…cy w programowaniu, lepiej bÄ™dzie, jeÅ›li
przeczytasz ksiÄ…Å¼kÄ™, ktÃ³ra specjalnie wprowadza w programowanie.</p>
<h2 id="jak-korzystaÄ‡-z-tej-ksiÄ…Å¼ki"><a class="header" href="#jak-korzystaÄ‡-z-tej-ksiÄ…Å¼ki">Jak korzystaÄ‡ z tej ksiÄ…Å¼ki</a></h2>
<p>OgÃ³lnie rzecz biorÄ…c, ta ksiÄ…Å¼ka zakÅ‚ada, Å¼e czytasz jÄ… sekwencyjnie od poczÄ…tku
do koÅ„ca. PÃ³Åºniejsze rozdziaÅ‚y bazujÄ… na koncepcjach z wczeÅ›niejszych
rozdziaÅ‚Ã³w, a wczeÅ›niejsze rozdziaÅ‚y mogÄ… nie zagÅ‚Ä™biaÄ‡ siÄ™ w szczegÃ³Å‚y
konkretnego tematu, ale powrÃ³cÄ… do niego w pÃ³Åºniejszym rozdziale.</p>
<p>W tej ksiÄ…Å¼ce znajdziesz dwa rodzaje rozdziaÅ‚Ã³w: rozdziaÅ‚y koncepcyjne i
rozdziaÅ‚y projektowe. W rozdziaÅ‚ach koncepcyjnych dowiesz siÄ™ o pewnym
aspekcie Rusta. W rozdziaÅ‚ach projektowych bÄ™dziemy wspÃ³lnie budowaÄ‡ maÅ‚e
programy, stosujÄ…c to, czego nauczyÅ‚eÅ› siÄ™ do tej pory. RozdziaÅ‚ 2, RozdziaÅ‚
12 i RozdziaÅ‚ 21 to rozdziaÅ‚y projektowe; pozostaÅ‚e to rozdziaÅ‚y koncepcyjne.</p>
<p><strong>RozdziaÅ‚ 1</strong> wyjaÅ›nia, jak zainstalowaÄ‡ Rusta, jak napisaÄ‡ program â€Witaj,
Å›wiecie!â€ i jak uÅ¼ywaÄ‡ Cargo, menedÅ¼era pakietÃ³w i narzÄ™dzia do budowania
Rusta. <strong>RozdziaÅ‚ 2</strong> to praktyczne wprowadzenie do pisania programu w RuÅ›cie,
polegajÄ…ce na budowaniu gry w zgadywanie liczb. Tutaj omawiamy koncepcje na
wysokim poziomie, a pÃ³Åºniejsze rozdziaÅ‚y dostarczÄ… dodatkowych szczegÃ³Å‚Ã³w.
JeÅ›li chcesz od razu zabraÄ‡ siÄ™ do pracy, RozdziaÅ‚ 2 jest do tego idealnym
miejscem. JeÅ›li jesteÅ› szczegÃ³lnie skrupulatnym uczniem, ktÃ³ry woli poznaÄ‡
kaÅ¼dy szczegÃ³Å‚ przed przejÅ›ciem do nastÄ™pnego, moÅ¼esz pominÄ…Ä‡ RozdziaÅ‚ 2 i
przejÅ›Ä‡ bezpoÅ›rednio do <strong>RozdziaÅ‚u 3</strong>, ktÃ³ry obejmuje funkcje Rusta
podobne do tych z innych jÄ™zykÃ³w programowania; nastÄ™pnie moÅ¼esz wrÃ³ciÄ‡ do
RozdziaÅ‚u 2, kiedy bÄ™dziesz chciaÅ‚ popracowaÄ‡ nad projektem, stosujÄ…c poznane
szczegÃ³Å‚y.</p>
<p>W <strong>Rozdziale 4</strong> dowiesz siÄ™ o systemie wÅ‚asnoÅ›ci Rusta. <strong>RozdziaÅ‚ 5</strong>
omawia struktury i metody. <strong>RozdziaÅ‚ 6</strong> obejmuje typy wyliczeniowe,
wyraÅ¼enia <code>match</code> oraz konstrukcje przepÅ‚ywu sterowania <code>if let</code> i <code>let...else</code>.
UÅ¼yjesz struktur i typÃ³w wyliczeniowych do tworzenia wÅ‚asnych typÃ³w.</p>
<p>W <strong>Rozdziale 7</strong> dowiesz siÄ™ o systemie moduÅ‚Ã³w Rusta i zasadach prywatnoÅ›ci
dotyczÄ…cych organizacji kodu i jego publicznego interfejsu programistycznego
(API). <strong>RozdziaÅ‚ 8</strong> omawia niektÃ³re popularne struktury danych kolekcji
dostÄ™pne w standardowej bibliotece: wektory, ciÄ…gi znakÃ³w i mapy haszujÄ…ce.
<strong>RozdziaÅ‚ 9</strong> bada filozofiÄ™ i techniki obsÅ‚ugi bÅ‚Ä™dÃ³w Rusta.</p>
<p><strong>RozdziaÅ‚ 10</strong> zagÅ‚Ä™bia siÄ™ w generyki, cechy i czasy Å¼ycia, ktÃ³re dajÄ… ci
moÅ¼liwoÅ›Ä‡ definiowania kodu, ktÃ³ry stosuje siÄ™ do wielu typÃ³w. <strong>RozdziaÅ‚ 11</strong>
polega na testowaniu, ktÃ³re nawet przy gwarancjach bezpieczeÅ„stwa Rusta jest
konieczne, aby upewniÄ‡ siÄ™, Å¼e logika programu jest poprawna. W <strong>Rozdziale
12</strong> zbudujemy naszÄ… wÅ‚asnÄ… implementacjÄ™ podzbioru funkcjonalnoÅ›ci narzÄ™dzia
wiersza poleceÅ„ <code>grep</code>, ktÃ³re wyszukuje tekst w plikach. W tym celu uÅ¼yjemy
wielu koncepcji, ktÃ³re omÃ³wiliÅ›my w poprzednich rozdziaÅ‚ach.</p>
<p><strong>RozdziaÅ‚ 13</strong> bada domkniÄ™cia i iteratory: cechy Rusta pochodzÄ…ce z
funkcyjnych jÄ™zykÃ³w programowania. W <strong>Rozdziale 14</strong> dokÅ‚adniej zbadamy Cargo
i porozmawiamy o najlepszych praktykach udostÄ™pniania bibliotek innym.
<strong>RozdziaÅ‚ 15</strong> omawia inteligentne wskaÅºniki dostÄ™pne w standardowej bibliotece
oraz cechy, ktÃ³re umoÅ¼liwiajÄ… ich funkcjonalnoÅ›Ä‡.</p>
<p>W <strong>Rozdziale 16</strong> omÃ³wimy rÃ³Å¼ne modele programowania wspÃ³Å‚bieÅ¼nego i
porozmawiamy o tym, jak Rust pomaga programowaÄ‡ w wielu wÄ…tkach bez obaw. W
<strong>Rozdziale 17</strong> rozbudujemy to, badajÄ…c skÅ‚adniÄ™ <code>async</code> i <code>await</code> Rusta, wraz
z zadaniami, futures i streams, oraz lekki model wspÃ³Å‚bieÅ¼noÅ›ci, ktÃ³ry
umoÅ¼liwiajÄ….</p>
<p><strong>RozdziaÅ‚ 18</strong> przyglÄ…da siÄ™, jak idiomy Rusta porÃ³wnujÄ… siÄ™ z zasadami
programowania obiektowego, ktÃ³re moÅ¼esz znaÄ‡. <strong>RozdziaÅ‚ 19</strong> to odniesienie do
wzorcÃ³w i dopasowywania wzorcÃ³w, ktÃ³re sÄ… potÄ™Å¼nymi sposobami wyraÅ¼ania idei
w programach Rusta. <strong>RozdziaÅ‚ 20</strong> zawiera zbiÃ³r zaawansowanych tematÃ³w
interesujÄ…cych, w tym niebezpieczny Rust, makra i wiÄ™cej o czasach Å¼ycia,
cechach, typach, funkcjach i domkniÄ™ciach.</p>
<p>W <strong>Rozdziale 21</strong> ukoÅ„czymy projekt, w ktÃ³rym zaimplementujemy niskopoziomowy,
wielowÄ…tkowy serwer WWW!</p>
<p>Na koniec, kilka dodatkÃ³w zawiera uÅ¼yteczne informacje o jÄ™zyku w formacie
bardziej przypominajÄ…cym referencje. <strong>Dodatek A</strong> obejmuje sÅ‚owa kluczowe
Rusta, <strong>Dodatek B</strong> obejmuje operatory i symbole Rusta, <strong>Dodatek C</strong> obejmuje
cechy moÅ¼liwe do wyprowadzenia dostarczane przez standardowÄ… bibliotekÄ™,
<strong>Dodatek D</strong> obejmuje niektÃ³re uÅ¼yteczne narzÄ™dzia programistyczne, a <strong>Dodatek E</strong>
wyjaÅ›nia wydania Rusta. W <strong>Dodatku F</strong> znajdziesz tÅ‚umaczenia ksiÄ…Å¼ki, a w
<strong>Dodatku G</strong> omÃ³wimy, jak powstaje Rust i czym jest Nightly Rust.</p>
<p>Nie ma zÅ‚ego sposobu na czytanie tej ksiÄ…Å¼ki: JeÅ›li chcesz przeskoczyÄ‡ do przodu,
zrÃ³b to! MoÅ¼e bÄ™dziesz musiaÅ‚ wrÃ³ciÄ‡ do wczeÅ›niejszych rozdziaÅ‚Ã³w, jeÅ›li
spotkasz siÄ™ z jakimkolwiek zamieszaniem. Ale rÃ³b to, co dziaÅ‚a dla ciebie.</p>
<p><span id="ferris"></span></p>
<p>WaÅ¼nÄ… czÄ™Å›ciÄ… procesu nauki Rusta jest nauka czytania komunikatÃ³w o bÅ‚Ä™dach
wyÅ›wietlanych przez kompilator: BÄ™dÄ… one prowadziÄ‡ CiÄ™ do dziaÅ‚ajÄ…cego kodu.
W zwiÄ…zku z tym, przedstawimy wiele przykÅ‚adÃ³w, ktÃ³re siÄ™ nie kompilujÄ…,
wraz z komunikatem o bÅ‚Ä™dzie, ktÃ³ry kompilator wyÅ›wietli w kaÅ¼dej sytuacji.
PamiÄ™taj, Å¼e jeÅ›li wpiszesz i uruchomisz przypadkowy przykÅ‚ad, moÅ¼e siÄ™ on
nie skompilowaÄ‡! Upewnij siÄ™, Å¼e przeczytaÅ‚eÅ› otaczajÄ…cy tekst, aby sprawdziÄ‡,
czy przykÅ‚ad, ktÃ³ry prÃ³bujesz uruchomiÄ‡, ma celowo wyÅ›wietliÄ‡ bÅ‚Ä…d. W wiÄ™kszoÅ›ci
sytuacji poprowadzimy CiÄ™ do poprawnej wersji kodu, ktÃ³ry siÄ™ nie kompiluje.
Ferris rÃ³wnieÅ¼ pomoÅ¼e Ci rozrÃ³Å¼niÄ‡ kod, ktÃ³ry nie ma dziaÅ‚aÄ‡:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Ferris</th><th>Znaczenie</th></tr>
</thead>
<tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain" alt="Ferris ze znakiem zapytania" /></td><td>Ten kod siÄ™ nie kompiluje!</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain" alt="Ferris z rÄ™kami uniesionymi w gÃ³rÄ™" /></td><td>Ten kod panikuje!</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="Ferris z jednym uniesionym pazurem, wzruszajÄ…cy ramionami" /></td><td>Ten kod nie daje poÅ¼Ä…danego zachowania.</td></tr>
</tbody>
</table>
</div>
<p>W wiÄ™kszoÅ›ci sytuacji poprowadzimy CiÄ™ do poprawnej wersji kodu, ktÃ³ry siÄ™ nie
kompiluje.</p>
<h2 id="kod-ÅºrÃ³dÅ‚owy"><a class="header" href="#kod-ÅºrÃ³dÅ‚owy">Kod ÅºrÃ³dÅ‚owy</a></h2>
<p>Pliki ÅºrÃ³dÅ‚owe, z ktÃ³rych generowana jest ta ksiÄ…Å¼ka, moÅ¼na znaleÅºÄ‡ na
<a href="https://github.com/rust-lang/book/tree/main/src">GitHubie</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pierwsze-kroki"><a class="header" href="#pierwsze-kroki">Pierwsze kroki</a></h1>
<p>Rozpocznij swojÄ… podrÃ³Å¼ z Rustem! Wiele jest do nauczenia, ale kaÅ¼da podrÃ³Å¼
zaczyna siÄ™ gdzieÅ›. W tym rozdziale omÃ³wimy:</p>
<ul>
<li>InstalacjÄ™ Rusta na Linuksie, macOS i Windows</li>
<li>Pisanie programu, ktÃ³ry wypisuje <code>Witaj, Å›wiecie!</code></li>
<li>UÅ¼ywanie <code>cargo</code>, menedÅ¼era pakietÃ³w i systemu budowania Rusta</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="instalacja-1"><a href="#instalacja-1" class="header">Instalacja</a></h1>
<h2 id="instalacja"><a class="header" href="#instalacja">Instalacja</a></h2>
<p>Pierwszym krokiem jest zainstalowanie Rusta. Pobierzemy Rusta za poÅ›rednictwem
<code>rustup</code>, narzÄ™dzia wiersza poleceÅ„ do zarzÄ…dzania wersjami Rusta i
powiÄ…zanymi narzÄ™dziami. Do pobrania bÄ™dziesz potrzebowaÄ‡ poÅ‚Ä…czenia z
internetem.</p>
<blockquote>
<p>Uwaga: JeÅ›li z jakiegoÅ› powodu wolisz nie uÅ¼ywaÄ‡ <code>rustup</code>, zapoznaj siÄ™ z
<a href="https://forge.rust-lang.org/infra/other-installation-methods.html">stronÄ… Inne metody instalacji Rusta</a> w celu uzyskania
dodatkowych opcji.</p>
</blockquote>
<p>PoniÅ¼sze kroki instalujÄ… najnowszÄ… stabilnÄ… wersjÄ™ kompilatora Rusta.
Gwarancje stabilnoÅ›ci Rusta zapewniajÄ…, Å¼e wszystkie przykÅ‚ady w ksiÄ…Å¼ce,
ktÃ³re siÄ™ kompilujÄ…, bÄ™dÄ… nadal kompilowaÄ‡ siÄ™ z nowszymi wersjami Rusta.
Wynik moÅ¼e nieznacznie rÃ³Å¼niÄ‡ siÄ™ miÄ™dzy wersjami, poniewaÅ¼ Rust czÄ™sto
poprawia komunikaty o bÅ‚Ä™dach i ostrzeÅ¼enia. Innymi sÅ‚owy, kaÅ¼da nowsza,
stabilna wersja Rusta zainstalowana za pomocÄ… tych krokÃ³w powinna dziaÅ‚aÄ‡
zgodnie z oczekiwaniami z treÅ›ciÄ… tej ksiÄ…Å¼ki.</p>
<blockquote>
<h3 id="notacja-wiersza-poleceÅ„"><a class="header" href="#notacja-wiersza-poleceÅ„">Notacja wiersza poleceÅ„</a></h3>
<p>W tym rozdziale i w caÅ‚ej ksiÄ…Å¼ce bÄ™dziemy pokazywaÄ‡ niektÃ³re polecenia
uÅ¼ywane w terminalu. Wiersze, ktÃ³re powinieneÅ› wpisaÄ‡ w terminalu, zaczynajÄ…
siÄ™ od <code>$</code>. Nie musisz wpisywaÄ‡ znaku <code>$</code>; jest to znak zachÄ™ty wiersza
poleceÅ„, ktÃ³ry wskazuje poczÄ…tek kaÅ¼dego polecenia. Wiersze, ktÃ³re nie
zaczynajÄ… siÄ™ od <code>$</code>, zazwyczaj pokazujÄ… wynik poprzedniego polecenia.
Dodatkowo, przykÅ‚ady specyficzne dla PowerShell bÄ™dÄ… uÅ¼ywaÄ‡ <code>&gt;</code> zamiast <code>$</code>.</p>
</blockquote>
<h3 id="instalacja-rustup-na-linuksie-lub-macos"><a class="header" href="#instalacja-rustup-na-linuksie-lub-macos">Instalacja <code>rustup</code> na Linuksie lub macOS</a></h3>
<p>JeÅ›li uÅ¼ywasz Linuksa lub macOS, otwÃ³rz terminal i wprowadÅº nastÄ™pujÄ…ce
polecenie:</p>
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Polecenie pobiera skrypt i rozpoczyna instalacjÄ™ narzÄ™dzia <code>rustup</code>, ktÃ³re
instaluje najnowszÄ… stabilnÄ… wersjÄ™ Rusta. MoÅ¼e zostaÄ‡ wyÅ›wietlony monit o
hasÅ‚o. JeÅ›li instalacja zakoÅ„czy siÄ™ pomyÅ›lnie, pojawi siÄ™ nastÄ™pujÄ…cy wiersz:</p>
<pre><code class="language-text">Rust jest juÅ¼ zainstalowany. Åšwietnie!
</code></pre>
<p>BÄ™dziesz takÅ¼e potrzebowaÅ‚ <em>linkera</em>, czyli programu, ktÃ³rego Rust uÅ¼ywa do
Å‚Ä…czenia skompilowanych wynikÃ³w w jeden plik. Prawdopodobnie juÅ¼ go masz.
JeÅ›li otrzymasz bÅ‚Ä™dy linkera, powinieneÅ› zainstalowaÄ‡ kompilator C, ktÃ³ry
zazwyczaj zawiera linker. Kompilator C jest rÃ³wnieÅ¼ przydatny, poniewaÅ¼
niektÃ³re popularne pakiety Rusta zaleÅ¼Ä… od kodu C i bÄ™dÄ… wymagaÅ‚y kompilatora C.</p>
<p>Na macOS moÅ¼esz uzyskaÄ‡ kompilator C, uruchamiajÄ…c:</p>
<pre><code class="language-console">$ xcode-select --install
</code></pre>
<p>UÅ¼ytkownicy Linuksa powinni zazwyczaj instalowaÄ‡ GCC lub Clang, zgodnie z
dokumentacjÄ… swojej dystrybucji. Na przykÅ‚ad, jeÅ›li uÅ¼ywasz Ubuntu, moÅ¼esz
zainstalowaÄ‡ pakiet <code>build-essential</code>.</p>
<h3 id="instalacja-rustup-na-windows"><a class="header" href="#instalacja-rustup-na-windows">Instalacja <code>rustup</code> na Windows</a></h3>
<p>Na Windows, przejdÅº na <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a><!--
ignore --> i postÄ™puj zgodnie z instrukcjami instalacji Rusta. W pewnym
momencie instalacji zostaniesz poproszony o zainstalowanie Visual Studio.
Zapewnia to linker i natywne biblioteki potrzebne do kompilowania programÃ³w.
JeÅ›li potrzebujesz wiÄ™cej pomocy w tym kroku, zobacz
<a href="https://rust-lang.github.io/rustup/installation/windows-msvc.html">https://rust-lang.github.io/rustup/installation/windows-msvc.html</a><!--
ignore -->.</p>
<p>Reszta tej ksiÄ…Å¼ki uÅ¼ywa poleceÅ„, ktÃ³re dziaÅ‚ajÄ… zarÃ³wno w <em>cmd.exe</em>, jak i
PowerShell. JeÅ›li wystÄ…piÄ… specyficzne rÃ³Å¼nice, wyjaÅ›nimy, ktÃ³rego uÅ¼yÄ‡.</p>
<h3 id="rozwiÄ…zywanie-problemÃ³w"><a class="header" href="#rozwiÄ…zywanie-problemÃ³w">RozwiÄ…zywanie problemÃ³w</a></h3>
<p>Aby sprawdziÄ‡, czy Rust jest poprawnie zainstalowany, otwÃ³rz powÅ‚okÄ™ i
wrowadÅº ten wiersz:</p>
<pre><code class="language-console">$ rustc --version
</code></pre>
<p>Ppowinien pojawiÄ‡ siÄ™ numer wersji, skrÃ³t commita i data commita dla
najnowszej stabilnej wersji, ktÃ³ra zostaÅ‚a wydana, w nastÄ™pujÄ…cym formacie:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>JeÅ›li widzisz te informacje, pomyÅ›lnie zainstalowaÅ‚eÅ› Rusta! JeÅ›li ich nie
widzisz, sprawdÅº, czy Rust znajduje siÄ™ w zmiennej systemowej <code>%PATH%</code> w
nastÄ™pujÄ…cy sposÃ³b.</p>
<p>W systemie Windows CMD uÅ¼yj:</p>
<pre><code class="language-console">&gt; echo %PATH%
</code></pre>
<p>W PowerShellu uÅ¼yj:</p>
<pre><code class="language-powershell">&gt; echo $env:Path
</code></pre>
<p>Na Linuksie i macOS uÅ¼yj:</p>
<pre><code class="language-console">$ echo $PATH
</code></pre>
<p>JeÅ›li wszystko jest w porzÄ…dku, a Rust nadal nie dziaÅ‚a, istnieje wiele miejsc,
w ktÃ³rych moÅ¼esz uzyskaÄ‡ pomoc. Dowiedz siÄ™, jak skontaktowaÄ‡ siÄ™ z innymi
Rustaceanami (tak siÄ™ nazywamy) na <a href="https://www.rust-lang.org/community">stronie spoÅ‚ecznoÅ›ci</a>.</p>
<h3 id="aktualizacja-i-deinstalacja"><a class="header" href="#aktualizacja-i-deinstalacja">Aktualizacja i deinstalacja</a></h3>
<p>Po zainstalowaniu Rusta za pomocÄ… <code>rustup</code>, aktualizacja do nowo wydanej
wersji jest Å‚atwa. Z poziomu powÅ‚oki uruchom nastÄ™pujÄ…cy skrypt aktualizacji:</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<p>Aby odinstalowaÄ‡ Rusta i <code>rustup</code>, uruchom nastÄ™pujÄ…cy skrypt odinstalowujÄ…cy
z poziomu powÅ‚oki:</p>
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="local-documentation"></a></p>
<h3 id="czytanie-lokalnej-dokumentacji"><a class="header" href="#czytanie-lokalnej-dokumentacji">Czytanie lokalnej dokumentacji</a></h3>
<p>Instalacja Rusta zawiera rÃ³wnieÅ¼ lokalnÄ… kopiÄ™ dokumentacji, dziÄ™ki czemu
moÅ¼esz czytaÄ‡ jÄ… offline. Uruchom <code>rustup doc</code>, aby otworzyÄ‡ lokalnÄ…
dokumentacjÄ™ w przeglÄ…darce.</p>
<p>Zawsze, gdy typ lub funkcja jest dostarczana przez bibliotekÄ™ standardowÄ…, a
nie masz pewnoÅ›ci, co robi lub jak jej uÅ¼ywaÄ‡, skorzystaj z dokumentacji
interfejsu programowania aplikacji (API), aby siÄ™ dowiedzieÄ‡!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="text-editors-and-integrated-development-environments"></a></p>
<h3 id="uÅ¼ywanie-edytorÃ³w-tekstu-i-Å›rodowisk-ide"><a class="header" href="#uÅ¼ywanie-edytorÃ³w-tekstu-i-Å›rodowisk-ide">UÅ¼ywanie edytorÃ³w tekstu i Å›rodowisk IDE</a></h3>
<p>Ta ksiÄ…Å¼ka nie czyni Å¼adnych zaÅ‚oÅ¼eÅ„ co do narzÄ™dzi, ktÃ³rych uÅ¼ywasz do
pisania kodu Rusta. Niemal kaÅ¼dy edytor tekstu speÅ‚ni swoje zadanie! JednakÅ¼e
wiele edytorÃ³w tekstu i zintegrowanych Å›rodowisk programistycznych (IDE)
posiada wbudowane wsparcie dla Rusta. Zawsze moÅ¼esz znaleÅºÄ‡ doÅ›Ä‡ aktualnÄ…
listÄ™ wielu edytorÃ³w i Å›rodowisk IDE na <a href="https://www.rust-lang.org/tools">stronie z narzÄ™dziami</a> na
stronie internetowej Rusta.</p>
<h3 id="praca-offline-z-tÄ…-ksiÄ…Å¼kÄ…"><a class="header" href="#praca-offline-z-tÄ…-ksiÄ…Å¼kÄ…">Praca offline z tÄ… ksiÄ…Å¼kÄ…</a></h3>
<p>W kilku przykÅ‚adach bÄ™dziemy uÅ¼ywaÄ‡ pakietÃ³w Rusta poza bibliotekÄ… standardowÄ….
Aby przeÄ‡wiczyÄ‡ te przykÅ‚ady, bÄ™dziesz potrzebowaÄ‡ poÅ‚Ä…czenia z internetem
lub wczeÅ›niejszego pobrania tych zaleÅ¼noÅ›ci. Aby pobraÄ‡ zaleÅ¼noÅ›ci wczeÅ›niej,
moÅ¼esz uruchomiÄ‡ nastÄ™pujÄ…ce polecenia. (WyjaÅ›nimy, czym jest <code>cargo</code> i co robi
kaÅ¼de z tych poleceÅ„ szczegÃ³Å‚owo pÃ³Åºniej.)</p>
<pre><code class="language-console">$ cargo new get-dependencies
$ cd get-dependencies
$ cargo add rand@0.8.5 trpl@0.2.0
</code></pre>
<p>Spowoduje to buforowanie pobraÅ„ tych pakietÃ³w, dziÄ™ki czemu nie bÄ™dziesz
musiaÅ‚ ich pÃ³Åºniej pobieraÄ‡. Po uruchomieniu tego polecenia nie musisz
zatrzymywaÄ‡ folderu <code>get-dependencies</code>. JeÅ›li uruchomiÅ‚eÅ› to polecenie,
moÅ¼esz uÅ¼yÄ‡ flagi <code>--offline</code> ze wszystkimi poleceniami <code>cargo</code> w pozostaÅ‚ej
czÄ™Å›ci ksiÄ…Å¼ki, aby uÅ¼yÄ‡ tych buforowanych wersji zamiast prÃ³bowaÄ‡ uÅ¼ywaÄ‡
sieci.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="witaj-Å›wiecie-1"><a href="#witaj-Å›wiecie-1" class="header">Witaj, Å›wiecie!</a></h1>
<h2 id="witaj-Å›wiecie"><a class="header" href="#witaj-Å›wiecie">Witaj, Å›wiecie!</a></h2>
<p>Skoro zainstalowaÅ‚eÅ› Rusta, czas napisaÄ‡ swÃ³j pierwszy program w tym jÄ™zyku.
Tradycyjnie, uczÄ…c siÄ™ nowego jÄ™zyka, pisze siÄ™ maÅ‚y program, ktÃ³ry wyÅ›wietla
tekst <code>Witaj, Å›wiecie!</code> na ekranie, wiÄ™c zrobimy to samo i tutaj!</p>
<blockquote>
<p>Uwaga: Ta ksiÄ…Å¼ka zakÅ‚ada podstawowÄ… znajomoÅ›Ä‡ wiersza poleceÅ„. Rust nie
stawia Å¼adnych specyficznych wymagaÅ„ dotyczÄ…cych edycji, narzÄ™dzi ani
miejsca przechowywania kodu, wiÄ™c jeÅ›li wolisz uÅ¼ywaÄ‡ IDE zamiast wiersza
poleceÅ„, Å›miaÅ‚o korzystaj ze swojego ulubionego IDE. Wiele Å›rodowisk IDE ma
obecnie pewne wsparcie dla Rusta; sprawdÅº dokumentacjÄ™ IDE, aby uzyskaÄ‡
szczegÃ³Å‚owe informacje. ZespÃ³Å‚ Rusta skupia siÄ™ na zapewnieniu
doskonaÅ‚ego wsparcia IDE za poÅ›rednictwem <code>rust-analyzer</code>. WiÄ™cej
szczegÃ³Å‚Ã³w znajdziesz w <a href="#d---przydatne-narzÄ™dzia-deweloperskie">Dodatku D</a><!-- ignore -->.</p>
</blockquote>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-a-project-directory"></a></p>
<h3 id="konfiguracja-katalogu-projektu"><a class="header" href="#konfiguracja-katalogu-projektu">Konfiguracja katalogu projektu</a></h3>
<p>Zaczniesz od utworzenia katalogu do przechowywania kodu Rusta. Dla Rusta nie ma
znaczenia, gdzie znajduje siÄ™ TwÃ³j kod, ale dla Ä‡wiczeÅ„ i projektÃ³w w tej
ksiÄ…Å¼ce sugerujemy utworzenie katalogu <em>projects</em> w katalogu domowym i
przechowywanie tam wszystkich swoich projektÃ³w.</p>
<p>OtwÃ³rz terminal i wprowadÅº nastÄ™pujÄ…ce polecenia, aby utworzyÄ‡ katalog
<em>projects</em> i katalog dla projektu â€Witaj, Å›wiecie!â€ w katalogu <em>projects</em>.</p>
<p>Na Linuksie, macOS i w PowerShell na Windows, wprowadÅº:</p>
<pre><code class="language-console">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>W systemie Windows CMD wprowadÅº:</p>
<pre><code class="language-cmd">&gt; mkdir "%USERPROFILE%\projects"
&gt; cd /d "%USERPROFILE%\projects"
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="writing-and-running-a-rust-program"></a></p>
<h3 id="podstawy-programu-w-ruÅ›cie"><a class="header" href="#podstawy-programu-w-ruÅ›cie">Podstawy programu w RuÅ›cie</a></h3>
<p>NastÄ™pnie utwÃ³rz nowy plik ÅºrÃ³dÅ‚owy i nazwij go <em>main.rs</em>. Pliki Rusta zawsze
koÅ„czÄ… siÄ™ rozszerzeniem <em>.rs</em>. JeÅ›li uÅ¼ywasz wiÄ™cej niÅ¼ jednego sÅ‚owa w
nazwie pliku, konwencjÄ… jest uÅ¼ywanie podkreÅ›lenia do ich rozdzielania.
Na przykÅ‚ad uÅ¼yj <em>hello_world.rs</em> zamiast <em>helloworld.rs</em>.</p>
<p>Teraz otwÃ³rz nowo utworzony plik <em>main.rs</em> i wprowadÅº kod z Listingu 1-1.</p>
<listing number="1-1" file-name="main.rs" caption="Program, ktÃ³ry wypisuje `Witaj, Å›wiecie!`">
<pre class="playground"><code class="language-rust edition2024">fn main() {
    println!("Hello, world!");
}</code></pre>
</listing>
<p>Zapisz plik i wrÃ³Ä‡ do okna terminala w katalogu <em>~/projects/hello_world</em>. Na
Linuksie lub macOS wprowadÅº nastÄ™pujÄ…ce polecenia, aby skompilowaÄ‡ i uruchomiÄ‡
plik:</p>
<pre><code class="language-console">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<p>Na Windows wprowadÅº polecenie <code>.\main</code> zamiast <code>./main</code>:</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main
Hello, world!
</code></pre>
<p>NiezaleÅ¼nie od systemu operacyjnego, w terminalu powinno pojawiÄ‡ siÄ™
<code>Witaj, Å›wiecie!</code>. JeÅ›li nie widzisz tego wyjÅ›cia, wrÃ³Ä‡ do <a href="#troubleshooting">czÄ™Å›ci â€RozwiÄ…zywanie
problemÃ³wâ€</a><!-- ignore --> w sekcji Instalacja, aby uzyskaÄ‡ pomoc.</p>
<p>JeÅ›li <code>Witaj, Å›wiecie!</code> zostaÅ‚o wypisane, gratulacje! Oficjalnie napisaÅ‚eÅ›
program w RuÅ›cie. To czyni CiÄ™ programistÄ… Rusta â€“ witaj!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="anatomy-of-a-rust-program"></a></p>
<h3 id="anatomia-programu-w-ruÅ›cie"><a class="header" href="#anatomia-programu-w-ruÅ›cie">Anatomia programu w RuÅ›cie</a></h3>
<p>Przejrzyjmy szczegÃ³Å‚owo ten program â€Witaj, Å›wiecie!â€. Oto pierwszy element
ukÅ‚adanki:</p>
<pre class="playground"><code class="language-rust edition2024">fn main() {

}</code></pre>
<p>Te wiersze definiujÄ… funkcjÄ™ o nazwie <code>main</code>. Funkcja <code>main</code> jest specjalna:
Zawsze jest pierwszym kodem, ktÃ³ry jest uruchamiany w kaÅ¼dym wykonywalnym
programie w RuÅ›cie. Tutaj pierwszy wiersz deklaruje funkcjÄ™ o nazwie <code>main</code>,
ktÃ³ra nie ma parametrÃ³w i nic nie zwraca. Gdyby byÅ‚y parametry, znalazÅ‚yby siÄ™
w nawiasach <code>()</code>.</p>
<p>CiaÅ‚o funkcji jest ujÄ™te w <code>{}</code>. Rust wymaga nawiasÃ³w klamrowych wokÃ³Å‚
wszystkich ciaÅ‚ funkcji. Dobrym stylem jest umieszczanie otwierajÄ…cego nawiasu
klamrowego w tym samym wierszu co deklaracja funkcji, dodajÄ…c jeden odstÄ™p
pomiÄ™dzy nimi.</p>
<blockquote>
<p>Uwaga: JeÅ›li chcesz trzymaÄ‡ siÄ™ standardowego stylu w projektach Rusta,
moÅ¼esz uÅ¼yÄ‡ automatycznego narzÄ™dzia formatujÄ…cego o nazwie <code>rustfmt</code> do
formatowania kodu w okreÅ›lonym stylu (wiÄ™cej o <code>rustfmt</code> w <a href="#d---przydatne-narzÄ™dzia-deweloperskie">Dodatku
D</a><!-- ignore -->). ZespÃ³Å‚ Rusta doÅ‚Ä…czyÅ‚ to narzÄ™dzie do
standardowej dystrybucji Rusta, podobnie jak <code>rustc</code>, wiÄ™c powinno byÄ‡ juÅ¼
zainstalowane na Twoim komputerze!</p>
</blockquote>
<p>CiaÅ‚o funkcji <code>main</code> zawiera nastÄ™pujÄ…cy kod:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("Hello, world!");
<span class="boring">}</span></code></pre>
<p>Ten wiersz wykonuje caÅ‚Ä… pracÄ™ w tym maÅ‚ym programie: wyÅ›wietla tekst na
ekranie. NaleÅ¼y zwrÃ³ciÄ‡ uwagÄ™ na trzy waÅ¼ne szczegÃ³Å‚y.</p>
<p>Po pierwsze, <code>println!</code> wywoÅ‚uje makro Rusta. Gdyby wywoÅ‚ywaÅ‚o funkcjÄ™, byÅ‚oby
wpisane jako <code>println</code> (bez <code>!</code>). Makra Rusta to sposÃ³b na pisanie kodu, ktÃ³ry
generuje kod w celu rozszerzenia skÅ‚adni Rusta, a omÃ³wimy je bardziej
szczegÃ³Å‚owo w <a href="#makra-1">Rozdziale 20</a><!-- ignore -->. Na razie wystarczy
wiedzieÄ‡, Å¼e uÅ¼ycie <code>!</code> oznacza wywoÅ‚anie makra zamiast normalnej funkcji, a
makra nie zawsze przestrzegajÄ… tych samych zasad co funkcje.</p>
<p>Po drugie, widzisz ciÄ…g znakÃ³w <code>"Hello, world!"</code>. Przekazujemy ten ciÄ…g jako
argument do <code>println!</code>, a ciÄ…g jest wyÅ›wietlany na ekranie.</p>
<p>Po trzecie, koÅ„czymy wiersz Å›rednikiem (<code>;</code>), co oznacza, Å¼e to wyraÅ¼enie
zostaÅ‚o zakoÅ„czone, a nastÄ™pne jest gotowe do rozpoczÄ™cia. WiÄ™kszoÅ›Ä‡ wierszy
kodu Rusta koÅ„czy siÄ™ Å›rednikiem.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="compiling-and-running-are-separate-steps"></a></p>
<h3 id="kompilacja-i-wykonanie"><a class="header" href="#kompilacja-i-wykonanie">Kompilacja i wykonanie</a></h3>
<p>WÅ‚aÅ›nie uruchomiÅ‚eÅ› nowo utworzony program, wiÄ™c przyjrzyjmy siÄ™ kaÅ¼demu
krokowi w tym procesie.</p>
<p>Przed uruchomieniem programu w RuÅ›cie musisz go skompilowaÄ‡ za pomocÄ…
kompilatora Rusta, wpisujÄ…c polecenie <code>rustc</code> i podajÄ…c nazwÄ™ pliku ÅºrÃ³dÅ‚owego,
w ten sposÃ³b:</p>
<pre><code class="language-console">$ rustc main.rs
</code></pre>
<p>JeÅ›li masz doÅ›wiadczenie z C lub C++, zauwaÅ¼ysz, Å¼e jest to podobne do <code>gcc</code>
lub <code>clang</code>. Po pomyÅ›lnej kompilacji Rust wypisuje plik wykonywalny.</p>
<p>Na Linuksie, macOS i w PowerShell na Windows, moÅ¼esz zobaczyÄ‡ plik wykonywalny,
wpisujÄ…c polecenie <code>ls</code> w swojej powÅ‚oce:</p>
<pre><code class="language-console">$ ls
main  main.rs
</code></pre>
<p>Na Linuksie i macOS zobaczysz dwa pliki. W PowerShell na Windows zobaczysz te
same trzy pliki, ktÃ³re zobaczyÅ‚byÅ› uÅ¼ywajÄ…c CMD. W CMD na Windows
wypisaÅ‚byÅ› nastÄ™pujÄ…ce polecenie:</p>
<pre><code class="language-cmd">&gt; dir /B %= opcja /B wyÅ›wietla tylko nazwy plikÃ³w =%
main.exe
main.pdb
main.rs
</code></pre>
<p>Pokazuje to plik kodu ÅºrÃ³dÅ‚owego z rozszerzeniem <em>.rs</em>, plik wykonywalny
(<em>main.exe</em> na Windows, ale <em>main</em> na wszystkich innych platformach) oraz, w
przypadku uÅ¼ywania Windows, plik zawierajÄ…cy informacje debugowania z
rozszerzeniem <em>.pdb</em>. StÄ…d uruchamiasz plik <em>main</em> lub <em>main.exe</em>, w ten sposÃ³b:</p>
<pre><code class="language-console">$ ./main # lub .\main na Windows
</code></pre>
<p>JeÅ›li twÃ³j <em>main.rs</em> to program â€Witaj, Å›wiecie!â€, ten wiersz wypisze <code>Witaj, Å›wiecie!</code> w twoim terminalu.</p>
<p>JeÅ›li jesteÅ› bardziej zaznajomiony z jÄ™zykami dynamicznymi, takimi jak Ruby,
Python lub JavaScript, moÅ¼esz nie byÄ‡ przyzwyczajony do kompilowania i
uruchamiania programu jako oddzielnych krokÃ³w. Rust jest jÄ™zykiem
<em>kompilowanym z wyprzedzeniem</em>, co oznacza, Å¼e moÅ¼esz skompilowaÄ‡ program i
przekazaÄ‡ plik wykonywalny komuÅ› innemu, a ta osoba moÅ¼e go uruchomiÄ‡ nawet
bez zainstalowanego Rusta. JeÅ›li przekaÅ¼esz komuÅ› plik <em>.rb</em>, <em>.py</em> lub
<em>.js</em>, ta osoba musi mieÄ‡ zainstalowanÄ… (odpowiednio) implementacjÄ™ Ruby,
Pythona lub JavaScriptu. Ale w tych jÄ™zykach potrzebujesz tylko jednego
polecenia, aby skompilowaÄ‡ i uruchomiÄ‡ program. Wszystko jest kompromisem w
projektowaniu jÄ™zyka.</p>
<p>Samo kompilowanie za pomocÄ… <code>rustc</code> jest wystarczajÄ…ce dla prostych programÃ³w,
ale w miarÄ™ rozrostu projektu bÄ™dziesz chciaÅ‚ zarzÄ…dzaÄ‡ wszystkimi opcjami i
uÅ‚atwiÄ‡ udostÄ™pnianie kodu. NastÄ™pnie przedstawimy narzÄ™dzie Cargo, ktÃ³re pomoÅ¼e
Ci pisaÄ‡ rzeczywiste programy w RuÅ›cie.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="witaj-cargo-1"><a href="#witaj-cargo-1" class="header">Witaj, Cargo!</a></h1>
<h2 id="witaj-cargo"><a class="header" href="#witaj-cargo">Witaj, Cargo!</a></h2>
<p>Cargo to system budowania i menedÅ¼er pakietÃ³w Rusta. WiÄ™kszoÅ›Ä‡ RustaceanÃ³w
uÅ¼ywa tego narzÄ™dzia do zarzÄ…dzania swoimi projektami w RuÅ›cie, poniewaÅ¼ Cargo
obsÅ‚uguje wiele zadaÅ„ za Ciebie, takich jak budowanie kodu, pobieranie
bibliotek, od ktÃ³rych zaleÅ¼y TwÃ³j kod, i budowanie tych bibliotek. (Biblioteki,
ktÃ³rych potrzebuje TwÃ³j kod, nazywamy <em>zaleÅ¼noÅ›ciami</em>.)</p>
<p>Najprostsze programy w RuÅ›cie, takie jak ten, ktÃ³ry do tej pory napisaliÅ›my,
nie majÄ… Å¼adnych zaleÅ¼noÅ›ci. GdybyÅ›my zbudowali projekt â€Witaj, Å›wiecie!â€ za
pomocÄ… Cargo, uÅ¼ywaÅ‚by on tylko czÄ™Å›ci Cargo, ktÃ³ra obsÅ‚uguje budowanie kodu.
W miarÄ™ pisania bardziej zÅ‚oÅ¼onych programÃ³w w RuÅ›cie, bÄ™dziesz dodawaÄ‡
zaleÅ¼noÅ›ci, a jeÅ›li rozpoczniesz projekt za pomocÄ… Cargo, dodawanie zaleÅ¼noÅ›ci
bÄ™dzie znacznie Å‚atwiejsze.</p>
<p>PoniewaÅ¼ zdecydowana wiÄ™kszoÅ›Ä‡ projektÃ³w w RuÅ›cie uÅ¼ywa Cargo, reszta tej
ksiÄ…Å¼ki zakÅ‚ada, Å¼e Ty rÃ³wnieÅ¼ uÅ¼ywasz Cargo. Cargo jest instalowane wraz z
Rustem, jeÅ›li uÅ¼yÅ‚eÅ› oficjalnych instalatorÃ³w omÃ³wionych w <a href="#installation">sekcji
â€Instalacjaâ€</a><!-- ignore -->. JeÅ›li zainstalowaÅ‚eÅ› Rusta innymi
sposobami, sprawdÅº, czy Cargo jest zainstalowane, wpisujÄ…c w terminalu:</p>
<pre><code class="language-console">$ cargo --version
</code></pre>
<p>JeÅ›li widzisz numer wersji, masz go! JeÅ›li widzisz bÅ‚Ä…d, taki jak <code>command not found</code>, poszukaj w dokumentacji swojej metody instalacji, aby ustaliÄ‡, jak
zainstalowaÄ‡ Cargo oddzielnie.</p>
<h3 id="tworzenie-projektu-za-pomocÄ…-cargo"><a class="header" href="#tworzenie-projektu-za-pomocÄ…-cargo">Tworzenie projektu za pomocÄ… Cargo</a></h3>
<p>UtwÃ³rzmy nowy projekt za pomocÄ… Cargo i przyjrzyjmy siÄ™, jak rÃ³Å¼ni siÄ™ od
naszego oryginalnego projektu â€Witaj, Å›wiecie!â€. WrÃ³Ä‡ do katalogu <em>projects</em>
(lub gdziekolwiek zdecydowaÅ‚eÅ› siÄ™ przechowywaÄ‡ swÃ³j kod). NastÄ™pnie, na
kaÅ¼dym systemie operacyjnym, uruchom:</p>
<pre><code class="language-console">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<p>Pierwsze polecenie tworzy nowy katalog i projekt o nazwie <em>hello_cargo</em>.
NazwaliÅ›my nasz projekt <em>hello_cargo</em>, a Cargo tworzy swoje pliki w katalogu
o tej samej nazwie.</p>
<p>PrzejdÅº do katalogu <em>hello_cargo</em> i wypisz pliki. Zobaczysz, Å¼e Cargo
wygenerowaÅ‚o dla nas dwa pliki i jeden katalog: plik <em>Cargo.toml</em> i katalog
<em>src</em> z plikiem <em>main.rs</em> w Å›rodku.</p>
<p>ZainicjowaÅ‚o rÃ³wnieÅ¼ nowe repozytorium Git wraz z plikiem <em>.gitignore</em>.
Pliki Git nie zostanÄ… wygenerowane, jeÅ›li uruchomisz <code>cargo new</code> w istniejÄ…cym
repozytorium Git; moÅ¼esz nadpisaÄ‡ to zachowanie, uÅ¼ywajÄ…c <code>cargo new --vcs=git</code>.</p>
<blockquote>
<p>Uwaga: Git to popularny system kontroli wersji. MoÅ¼esz zmieniÄ‡ <code>cargo new</code>,
aby uÅ¼ywaÄ‡ innego systemu kontroli wersji lub Å¼adnego, uÅ¼ywajÄ…c flagi
<code>--vcs</code>. Uruchom <code>cargo new --help</code>, aby zobaczyÄ‡ dostÄ™pne opcje.</p>
</blockquote>
<p>OtwÃ³rz <em>Cargo.toml</em> w swoim ulubionym edytorze tekstu. Powinien wyglÄ…daÄ‡
podobnie do kodu z Listingu 1-2.</p>
<listing number="1-2" file-name="Cargo.toml" caption="ZawartoÅ›Ä‡ *Cargo.toml* wygenerowana przez `cargo new`">
<pre><code class="language-toml">[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2024"

[dependencies]
</code></pre>
</listing>
<p>Ten plik jest w formacie <a href="https://toml.io"><em>TOML</em></a><!-- ignore --> (<em>Tomâ€™s Obvious, Minimal
Language</em>), ktÃ³ry jest formatem konfiguracyjnym Cargo.</p>
<p>Pierwszy wiersz, <code>[package]</code>, to nagÅ‚Ã³wek sekcji wskazujÄ…cy, Å¼e nastÄ™pne
instrukcje konfigurujÄ… pakiet. W miarÄ™ dodawania kolejnych informacji do tego
pliku, bÄ™dziemy dodawaÄ‡ inne sekcje.</p>
<p>Trzy nastÄ™pne wiersze ustawiajÄ… informacje konfiguracyjne, ktÃ³rych Cargo
potrzebuje do skompilowania programu: nazwÄ™, wersjÄ™ i wydanie Rusta do
uÅ¼ycia. OmÃ³wimy klucz <code>edition</code> w <a href="#e---edycje">Dodatku E</a><!-- ignore -->.</p>
<p>Ostatni wiersz, <code>[dependencies]</code>, to poczÄ…tek sekcji, w ktÃ³rej moÅ¼esz wymieniÄ‡
wszystkie zaleÅ¼noÅ›ci swojego projektu. W RuÅ›cie pakiety kodu sÄ… nazywane
<em>skrzynkami</em>. Nie bÄ™dziemy potrzebowaÄ‡ Å¼adnych innych skrzynek do tego projektu,
ale bÄ™dziemy potrzebowaÄ‡ ich w pierwszym projekcie w Rozdziale 2, wiÄ™c
skorzystamy z tej sekcji zaleÅ¼noÅ›ci wtedy.</p>
<p>Teraz otwÃ³rz <em>src/main.rs</em> i przyjrzyj siÄ™:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    println!("Hello, world!");
}</code></pre>
<p>Cargo wygenerowaÅ‚o dla Ciebie program â€Witaj, Å›wiecie!â€, dokÅ‚adnie taki jak ten,
ktÃ³ry napisaliÅ›my w Listingu 1-1! Do tej pory rÃ³Å¼nice miÄ™dzy naszym projektem
a projektem wygenerowanym przez Cargo polegaÅ‚y na tym, Å¼e Cargo umieÅ›ciÅ‚o
kod w katalogu <em>src</em>, a my mamy plik konfiguracyjny <em>Cargo.toml</em> w
najwyÅ¼szym katalogu.</p>
<p>Cargo oczekuje, Å¼e Twoje pliki ÅºrÃ³dÅ‚owe bÄ™dÄ… znajdowaÄ‡ siÄ™ w katalogu <em>src</em>.
Katalog projektu najwyÅ¼szego poziomu jest przeznaczony tylko na pliki README,
informacje licencyjne, pliki konfiguracyjne i wszystko inne, co nie jest
zwiÄ…zane z Twoim kodem. Korzystanie z Cargo pomaga w organizacji projektÃ³w.
Wszystko ma swoje miejsce i wszystko jest na swoim miejscu.</p>
<p>JeÅ›li rozpoczÄ…Å‚eÅ› projekt, ktÃ³ry nie uÅ¼ywa Cargo, tak jak to zrobiliÅ›my z
projektem â€Witaj, Å›wiecie!â€, moÅ¼esz przekonwertowaÄ‡ go na projekt, ktÃ³ry uÅ¼ywa
Cargo. PrzenieÅ› kod projektu do katalogu <em>src</em> i utwÃ³rz odpowiedni plik
<em>Cargo.toml</em>. Åatwym sposobem na uzyskanie pliku <em>Cargo.toml</em> jest uruchomienie
<code>cargo init</code>, ktÃ³re utworzy go dla Ciebie automatycznie.</p>
<h3 id="budowanie-i-uruchamianie-projektu-cargo"><a class="header" href="#budowanie-i-uruchamianie-projektu-cargo">Budowanie i uruchamianie projektu Cargo</a></h3>
<p>Teraz przyjrzyjmy siÄ™, co siÄ™ zmieni, gdy zbudujemy i uruchomimy program
â€Witaj, Å›wiecie!â€ za pomocÄ… Cargo! Z katalogu <em>hello_cargo</em> zbuduj swÃ³j projekt,
wypisujÄ…c nastÄ™pujÄ…ce polecenie:</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>To polecenie tworzy plik wykonywalny w <em>target/debug/hello_cargo</em> (lub
<em>target\debug\hello_cargo.exe</em> na Windows), a nie w bieÅ¼Ä…cym katalogu.
PoniewaÅ¼ domyÅ›lna kompilacja jest kompilacjÄ… debugowÄ…, Cargo umieszcza
plik binarny w katalogu o nazwie <em>debug</em>. MoÅ¼esz uruchomiÄ‡ plik wykonywalny
za pomocÄ… tego polecenia:</p>
<pre><code class="language-console">$ ./target/debug/hello_cargo # lub .\target\debug\hello_cargo.exe na Windows
Hello, world!
</code></pre>
<p>JeÅ›li wszystko pÃ³jdzie dobrze, w terminalu powinno zostaÄ‡ wyÅ›wietlone
<code>Witaj, Å›wiecie!</code>. Uruchomienie <code>cargo build</code> po raz pierwszy powoduje rÃ³wnieÅ¼,
Å¼e Cargo tworzy nowy plik na najwyÅ¼szym poziomie: <em>Cargo.lock</em>. Ten plik Å›ledzi
dokÅ‚adne wersje zaleÅ¼noÅ›ci w Twoim projekcie. Ten projekt nie ma zaleÅ¼noÅ›ci,
wiÄ™c plik jest nieco skÄ…py. Nigdy nie bÄ™dziesz musiaÅ‚ rÄ™cznie zmieniaÄ‡ tego
pliku; Cargo zarzÄ…dza jego zawartoÅ›ciÄ… za Ciebie.</p>
<p>WÅ‚aÅ›nie zbudowaliÅ›my projekt za pomocÄ… <code>cargo build</code> i uruchomiliÅ›my go za
pomocÄ… <code>./target/debug/hello_cargo</code>, ale moÅ¼emy rÃ³wnieÅ¼ uÅ¼yÄ‡ <code>cargo run</code>,
aby skompilowaÄ‡ kod, a nastÄ™pnie uruchomiÄ‡ wynikowy plik wykonywalny za
jednym poleceniem:</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>UÅ¼ywanie <code>cargo run</code> jest wygodniejsze niÅ¼ koniecznoÅ›Ä‡ pamiÄ™tania o
uruchamianiu <code>cargo build</code>, a nastÄ™pnie uÅ¼ywaniu peÅ‚nej Å›cieÅ¼ki do pliku
binearnego, wiÄ™c wiÄ™kszoÅ›Ä‡ deweloperÃ³w uÅ¼ywa <code>cargo run</code>.</p>
<p>ZauwaÅ¼, Å¼e tym razem nie widzieliÅ›my wyjÅ›cia wskazujÄ…cego, Å¼e Cargo kompiluje
<code>hello_cargo</code>. Cargo ustaliÅ‚o, Å¼e pliki nie ulegÅ‚y zmianie, wiÄ™c nie
przebudowywaÅ‚o, a jedynie uruchomiÅ‚o plik binarny. GdybyÅ› zmodyfikowaÅ‚ swÃ³j kod
ÅºrÃ³dÅ‚owy, Cargo przebudowaÅ‚oby projekt przed jego uruchomieniem, a Ty
zobaczyÅ‚byÅ› takie wyjÅ›cie:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Cargo udostÄ™pnia rÃ³wnieÅ¼ polecenie <code>cargo check</code>. To polecenie szybko
sprawdza TwÃ³j kod, aby upewniÄ‡ siÄ™, Å¼e kompiluje siÄ™, ale nie tworzy pliku
wykonywalnego:</p>
<pre><code class="language-console">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>Dlaczego nie chciaÅ‚byÅ› pliku wykonywalnego? CzÄ™sto <code>cargo check</code> jest
zauwaÅ¼alnie szybsze niÅ¼ <code>cargo build</code>, poniewaÅ¼ pomija krok tworzenia pliku
wykonywalnego. JeÅ›li stale sprawdzasz swojÄ… pracÄ™ podczas pisania kodu,
uÅ¼ycie <code>cargo check</code> przyspieszy proces informowania CiÄ™, czy TwÃ³j projekt
nadal siÄ™ kompiluje! W zwiÄ…zku z tym wielu RustaceanÃ³w uruchamia <code>cargo check</code>
periodycznie podczas pisania programu, aby upewniÄ‡ siÄ™, Å¼e siÄ™ kompiluje.
NastÄ™pnie uruchamiajÄ… <code>cargo build</code>, gdy sÄ… gotowi do uÅ¼ycia pliku
wykonywalnego.</p>
<p>Podsumujmy, czego do tej pory nauczyliÅ›my siÄ™ o Cargo:</p>
<ul>
<li>MoÅ¼emy utworzyÄ‡ projekt za pomocÄ… <code>cargo new</code>.</li>
<li>MoÅ¼emy zbudowaÄ‡ projekt za pomocÄ… <code>cargo build</code>.</li>
<li>MoÅ¼emy zbudowaÄ‡ i uruchomiÄ‡ projekt w jednym kroku za pomocÄ… <code>cargo run</code>.</li>
<li>MoÅ¼emy zbudowaÄ‡ projekt bez tworzenia pliku binarnego, aby sprawdziÄ‡ bÅ‚Ä™dy,
za pomocÄ… <code>cargo check</code>.</li>
<li>Zamiast zapisywaÄ‡ wynik kompilacji w tym samym katalogu co nasz kod, Cargo
przechowuje go w katalogu <em>target/debug</em>.</li>
</ul>
<p>DodatkowÄ… zaletÄ… uÅ¼ywania Cargo jest to, Å¼e polecenia sÄ… takie same,
niezaleÅ¼nie od systemu operacyjnego, na ktÃ³rym pracujesz. Tak wiÄ™c, w tym
momencie nie bÄ™dziemy juÅ¼ podawaÄ‡ konkretnych instrukcji dla Linuksa i macOS
w stosunku do Windows.</p>
<h3 id="budowanie-do-wersji-produkcyjnej"><a class="header" href="#budowanie-do-wersji-produkcyjnej">Budowanie do wersji produkcyjnej</a></h3>
<p>Kiedy TwÃ³j projekt jest wreszcie gotowy do wydania, moÅ¼esz uÅ¼yÄ‡ <code>cargo build --release</code>, aby skompilowaÄ‡ go z optymalizacjami. To polecenie utworzy plik
wykonywalny w <em>target/release</em> zamiast <em>target/debug</em>. Optymalizacje sprawiajÄ…,
Å¼e kod Rusta dziaÅ‚a szybciej, ale ich wÅ‚Ä…czenie wydÅ‚uÅ¼a czas kompilacji
programu. Dlatego istniejÄ… dwa rÃ³Å¼ne profile: jeden do rozwoju, gdy chcesz
szybko i czÄ™sto przebudowywaÄ‡, a drugi do budowania ostatecznego programu,
ktÃ³ry przekaÅ¼esz uÅ¼ytkownikowi, ktÃ³ry nie bÄ™dzie wielokrotnie przebudowywany i
ktÃ³ry bÄ™dzie dziaÅ‚aÅ‚ tak szybko, jak to moÅ¼liwe. JeÅ›li mierzysz czas
uruchamiania kodu, upewnij siÄ™, Å¼e uruchamiasz <code>cargo build --release</code> i
mierzysz wydajnoÅ›Ä‡ z plikiem wykonywalnym w <em>target/release</em>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="cargo-as-convention"></a></p>
<h3 id="wykorzystanie-konwencji-cargo"><a class="header" href="#wykorzystanie-konwencji-cargo">Wykorzystanie konwencji Cargo</a></h3>
<p>W przypadku prostych projektÃ³w Cargo nie zapewnia duÅ¼ej wartoÅ›ci w porÃ³wnaniu
z samym uÅ¼ywaniem <code>rustc</code>, ale udowodni swojÄ… wartoÅ›Ä‡, gdy Twoje programy
stanÄ… siÄ™ bardziej zÅ‚oÅ¼one. Gdy programy rozrosnÄ… siÄ™ do wielu plikÃ³w lub
bÄ™dÄ… wymagaÅ‚y zaleÅ¼noÅ›ci, znacznie Å‚atwiej jest pozwoliÄ‡ Cargo
koordynowaÄ‡ budowanie.</p>
<p>Mimo Å¼e projekt <code>hello_cargo</code> jest prosty, wykorzystuje teraz wiele
rzeczywistych narzÄ™dzi, ktÃ³rych bÄ™dziesz uÅ¼ywaÄ‡ w pozostaÅ‚ej czÄ™Å›ci swojej
kariery z Rustem. W rzeczywistoÅ›ci, aby pracowaÄ‡ nad istniejÄ…cymi projektami,
moÅ¼esz uÅ¼yÄ‡ nastÄ™pujÄ…cych poleceÅ„, aby pobraÄ‡ kod za pomocÄ… Git, przejÅ›Ä‡ do
katalogu tego projektu i zbudowaÄ‡:</p>
<pre><code class="language-console">$ git clone example.org/someproject
$ cd someproject
$ cargo build
</code></pre>
<p>WiÄ™cej informacji na temat Cargo znajdziesz w <a href="https://doc.rust-lang.org/cargo/">jego dokumentacji</a>.</p>
<h2 id="podsumowanie"><a class="header" href="#podsumowanie">Podsumowanie</a></h2>
<p>JuÅ¼ Å›wietnie zaczÄ…Å‚eÅ› swojÄ… podrÃ³Å¼ z Rustem! W tym rozdziale nauczyÅ‚eÅ› siÄ™:</p>
<ul>
<li>Jak zainstalowaÄ‡ najnowszÄ… stabilnÄ… wersjÄ™ Rusta za pomocÄ… <code>rustup</code>.</li>
<li>Jak zaktualizowaÄ‡ Rusta do nowszej wersji.</li>
<li>Jak otworzyÄ‡ lokalnie zainstalowanÄ… dokumentacjÄ™.</li>
<li>Jak napisaÄ‡ i uruchomiÄ‡ program â€Witaj, Å›wiecie!â€ bezpoÅ›rednio za pomocÄ…
<code>rustc</code>.</li>
<li>Jak utworzyÄ‡ i uruchomiÄ‡ nowy projekt, korzystajÄ…c z konwencji Cargo.</li>
</ul>
<p>To Å›wietny moment, aby zbudowaÄ‡ bardziej rozbudowany program, aby przyzwyczaiÄ‡
siÄ™ do czytania i pisania kodu w RuÅ›cie. Tak wiÄ™c, w Rozdziale 2 zbudujemy
program do zgadywania liczb. JeÅ›li wolisz zaczÄ…Ä‡ od nauki, jak dziaÅ‚ajÄ…
powszechne koncepcje programistyczne w RuÅ›cie, zobacz RozdziaÅ‚ 3, a nastÄ™pnie
wrÃ³Ä‡ do RozdziaÅ‚u 2.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="programowanie-gry-w-zgadywanie"><a class="header" href="#programowanie-gry-w-zgadywanie">Programowanie gry w zgadywanie</a></h1>
<p>Zanurzmy siÄ™ w Rust, realizujÄ…c wspÃ³lnie praktyczny projekt! Ten rozdziaÅ‚
wprowadza ciÄ™ w kilka popularnych koncepcji Rusta, pokazujÄ…c, jak uÅ¼ywaÄ‡ ich
w prawdziwym programie. Dowiesz siÄ™ o <code>let</code>, <code>match</code>, metodach, funkcjach
skojarzonych, zewnÄ™trznych â€œcrateâ€™achâ€ i wielu innych! W kolejnych
rozdziaÅ‚ach bÄ™dziemy badaÄ‡ te idee bardziej szczegÃ³Å‚owo. W tym rozdziale
bÄ™dziesz Ä‡wiczyÄ‡ tylko podstawy.</p>
<p>Zaimplementujemy klasyczny problem programistyczny dla poczÄ…tkujÄ…cych: grÄ™ w
zgadywanie. DziaÅ‚a to tak: program wygeneruje losowÄ… liczbÄ™ caÅ‚kowitÄ… od 1 do
100. NastÄ™pnie poprosi gracza o podanie strzaÅ‚u. Po wprowadzeniu strzaÅ‚u,
program wskaÅ¼e, czy strzaÅ‚ jest za niski, czy za wysoki. JeÅ›li strzaÅ‚ jest
prawidÅ‚owy, gra wyÅ›wietli komunikat gratulacyjny i zakoÅ„czy siÄ™.</p>
<h2 id="konfiguracja-nowego-projektu"><a class="header" href="#konfiguracja-nowego-projektu">Konfiguracja nowego projektu</a></h2>
<p>Aby skonfigurowaÄ‡ nowy projekt, przejdÅº do katalogu <em>projects</em>, ktÃ³ry utworzyÅ‚eÅ›
w Rozdziale 1, i utwÃ³rz nowy projekt za pomocÄ… Cargo, w nastÄ™pujÄ…cy sposÃ³b:</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>Pierwsze polecenie, <code>cargo new</code>, przyjmuje nazwÄ™ projektu (<code>guessing_game</code>) jako
pierwszy argument. Drugie polecenie zmienia katalog na katalog nowego projektu.</p>
<p>SpÃ³jrz na wygenerowany plik <em>Cargo.toml</em>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->
<p><span class="filename">Nazwa pliku: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2024"

[dependencies]
</code></pre>
<p>Jak widziaÅ‚eÅ› w Rozdziale 1, <code>cargo new</code> generuje program â€œHello, world!â€ dla
Ciebie. SprawdÅº plik <em>src/main.rs</em>:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    println!("Hello, world!");
}</code></pre>
<p>Teraz skompilujmy ten program â€œHello, world!â€ i uruchommy go w tym samym kroku,
uÅ¼ywajÄ…c polecenia <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>Polecenie <code>run</code> przydaje siÄ™, gdy trzeba szybko iterowaÄ‡ nad projektem, tak
jak bÄ™dziemy to robiÄ‡ w tej grze, szybko testujÄ…c kaÅ¼dÄ… iteracjÄ™, zanim
przejdziemy do nastÄ™pnej.</p>
<p>OtwÃ³rz ponownie plik <em>src/main.rs</em>. CaÅ‚y kod bÄ™dziesz pisaÄ‡ w tym pliku.</p>
<h2 id="przetwarzanie-strzaÅ‚u"><a class="header" href="#przetwarzanie-strzaÅ‚u">Przetwarzanie strzaÅ‚u</a></h2>
<p>Pierwsza czÄ™Å›Ä‡ programu do zgadywania liczb poprosi o dane wejÅ›ciowe od
uÅ¼ytkownika, przetworzy je i sprawdzi, czy dane sÄ… w oczekiwanej formie. Na
poczÄ…tek pozwolimy graczowi wprowadziÄ‡ strzaÅ‚. WprowadÅº kod z Listingu 2-1 do
<em>src/main.rs</em>.</p>
<figure class="listing" id="listing-2-1">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}</code></pre>
<figcaption><a href="#listing-2-1">Listing 2-1</a>: Kod, ktÃ³ry pobiera strzaÅ‚ od uÅ¼ytkownika i go wyÅ›wietla</figcaption>
</figure>
<p>Ten kod zawiera wiele informacji, wiÄ™c przeanalizujmy go linia po linii. Aby
pobraÄ‡ dane od uÅ¼ytkownika, a nastÄ™pnie wyÅ›wietliÄ‡ wynik, musimy wprowadziÄ‡
bibliotekÄ™ wejÅ›cia/wyjÅ›cia <code>io</code> do zakresu. Biblioteka <code>io</code> pochodzi ze
standardowej biblioteki, znanej jako <code>std</code>:</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">}</span></code></pre>
<p>DomyÅ›lnie Rust ma zestaw elementÃ³w zdefiniowanych w standardowej bibliotece,
ktÃ³re sÄ… wprowadzane do zakresu kaÅ¼dego programu. Ten zestaw nazywa siÄ™
<em>preludium</em>, a wszystko w nim moÅ¼esz zobaczyÄ‡ <a href="../std/prelude/index.html">w dokumentacji biblioteki
standardowej</a>.</p>
<p>JeÅ›li typ, ktÃ³rego chcesz uÅ¼yÄ‡, nie znajduje siÄ™ w preludium, musisz
explicitnie wprowadziÄ‡ ten typ do zakresu za pomocÄ… instrukcji <code>use</code>. UÅ¼ycie
biblioteki <code>std::io</code> zapewnia wiele przydatnych funkcji, w tym moÅ¼liwoÅ›Ä‡
przyjmowania danych wejÅ›ciowych od uÅ¼ytkownika.</p>
<p>Jak widziaÅ‚eÅ› w Rozdziale 1, funkcja <code>main</code> jest punktem wejÅ›cia do programu:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">}</span></code></pre>
<p>SkÅ‚adnia <code>fn</code> deklaruje nowÄ… funkcjÄ™; nawiasy <code>()</code> wskazujÄ…, Å¼e nie ma
parametrÃ³w; a nawias klamrowy <code>{</code> rozpoczyna ciaÅ‚o funkcji.</p>
<p>Jak rÃ³wnieÅ¼ dowiedziaÅ‚eÅ› siÄ™ w Rozdziale 1, <code>println!</code> to makro, ktÃ³re
wyÅ›wietla ciÄ…g znakÃ³w na ekranie:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!("Guess the number!");

    println!("Please input your guess.");
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">}</span></code></pre>
<p>Ten kod wyÅ›wietla komunikat informujÄ…cy, czym jest gra, i prosi uÅ¼ytkownika
o wprowadzenie danych.</p>
<h3 id="przechowywanie-wartoÅ›ci-w-zmiennych"><a class="header" href="#przechowywanie-wartoÅ›ci-w-zmiennych">Przechowywanie wartoÅ›ci w zmiennych</a></h3>
<p>NastÄ™pnie utworzymy <em>zmiennÄ…</em> do przechowywania danych wprowadzonych przez
uÅ¼ytkownika, w ten sposÃ³b:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">}</span></code></pre>
<p>Teraz program staje siÄ™ ciekawszy! W tej krÃ³tkiej linii dzieje siÄ™ duÅ¼o. UÅ¼ywamy
instrukcji <code>let</code> do utworzenia zmiennej. Oto inny przykÅ‚ad:</p>
<pre><code class="language-rust ignore">let apples = 5;</code></pre>
<p>Ta linia tworzy nowÄ… zmiennÄ… o nazwie <code>apples</code> i wiÄ…Å¼e jÄ… z wartoÅ›ciÄ… <code>5</code>.
W Rust zmienne sÄ… domyÅ›lnie niezmienne, co oznacza, Å¼e gdy raz nadamy
zmiennej wartoÅ›Ä‡, wartoÅ›Ä‡ ta nie ulegnie zmianie. OmÃ³wimy tÄ™ koncepcjÄ™
szczegÃ³Å‚owo w sekcji <a href="#variables-and-mutability">â€Zmienne i mutowalnoÅ›Ä‡â€</a></p>
<!-- ignore --> w Rozdziale 3. Aby zmienna byÅ‚a mutowalna, dodajemy `mut` przed
<p>nazwÄ… zmiennej:</p>
<pre><code class="language-rust ignore">let apples = 5; // niezmienna
let mut bananas = 5; // mutowalna</code></pre>
<section class="note" aria-role="note">
<p>Uwaga: SkÅ‚adnia <code>//</code> rozpoczyna komentarz, ktÃ³ry trwa do koÅ„ca linii. Rust
ignoruje wszystko, co znajduje siÄ™ w komentarzach. OmÃ³wimy komentarze
szczegÃ³Å‚owo w <a href="#komentarze-1">Rozdziale 3</a><!-- ignore -->.</p>
</section>
<p>WracajÄ…c do programu gry w zgadywanie, wiesz juÅ¼, Å¼e <code>let mut guess</code> wprowadzi
mutowalnÄ… zmiennÄ… o nazwie <code>guess</code>. Znak rÃ³wnoÅ›ci (<code>=</code>) mÃ³wi Rustowi, Å¼e
chcemy teraz powiÄ…zaÄ‡ coÅ› ze zmiennÄ…. Po prawej stronie znaku rÃ³wnoÅ›ci
znajduje siÄ™ wartoÅ›Ä‡, z ktÃ³rÄ… <code>guess</code> jest powiÄ…zane, czyli wynik wywoÅ‚ania
<code>String::new</code>, funkcji, ktÃ³ra zwraca nowÄ… instancjÄ™ typu <code>String</code>.
<a href="../std/string/struct.String.html"><code>String</code></a><!-- ignore --> to typ ciÄ…gu znakÃ³w dostarczony przez
standardowÄ… bibliotekÄ™, ktÃ³ry jest rozszerzalnym, kodowanym UTF-8 fragmentem
tekstu.</p>
<p>SkÅ‚adnia <code>::</code> w linii <code>::new</code> wskazuje, Å¼e <code>new</code> jest funkcjÄ… skojarzonÄ… z
typem <code>String</code>. <em>Funkcja skojarzona</em> to funkcja zaimplementowana dla danego
typu, w tym przypadku <code>String</code>. Ta funkcja <code>new</code> tworzy nowy, pusty ciÄ…g
znakÃ³w. FunkcjÄ™ <code>new</code> znajdziesz na wielu typach, poniewaÅ¼ jest to
powszechna nazwa dla funkcji, ktÃ³ra tworzy nowÄ… wartoÅ›Ä‡ jakiegoÅ› rodzaju.</p>
<p>PodsumowujÄ…c, linia <code>let mut guess = String::new();</code> utworzyÅ‚a mutowalnÄ…
zmiennÄ…, ktÃ³ra jest obecnie powiÄ…zana z nowÄ…, pustÄ… instancjÄ… <code>String</code>. Uff!</p>
<h3 id="odbieranie-danych-od-uÅ¼ytkownika"><a class="header" href="#odbieranie-danych-od-uÅ¼ytkownika">Odbieranie danych od uÅ¼ytkownika</a></h3>
<p>Przypomnijmy, Å¼e na poczÄ…tku programu doÅ‚Ä…czyliÅ›my funkcjonalnoÅ›Ä‡ wejÅ›cia/
wyjÅ›cia ze standardowej biblioteki za pomocÄ… <code>use std::io;</code>. Teraz wywoÅ‚amy
funkcjÄ™ <code>stdin</code> z moduÅ‚u <code>io</code>, co pozwoli nam obsÅ‚ugiwaÄ‡ dane wejÅ›ciowe od
uÅ¼ytkownika:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">}</span></code></pre>
<p>GdybyÅ›my nie zaimportowali moduÅ‚u <code>io</code> za pomocÄ… <code>use std::io;</code> na poczÄ…tku
programu, nadal moglibyÅ›my uÅ¼yÄ‡ funkcji, piszÄ…c wywoÅ‚anie funkcji jako
<code>std::io::stdin</code>. Funkcja <code>stdin</code> zwraca instancjÄ™
<a href="../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->, ktÃ³ra jest typem
reprezentujÄ…cym uchwyt do standardowego wejÅ›cia dla Twojego terminala.</p>
<p>NastÄ™pnie, linia <code>.read_line(&amp;mut guess)</code> wywoÅ‚uje metodÄ™
<a href="../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore --> na uchwycie standardowego wejÅ›cia
w celu pobrania danych od uÅ¼ytkownika. Przekazujemy rÃ³wnieÅ¼ <code>&amp;mut guess</code> jako
argument do <code>read_line</code>, aby powiedzieÄ‡ jej, w ktÃ³rym ciÄ…gu znakÃ³w ma
przechowywaÄ‡ dane wejÅ›ciowe od uÅ¼ytkownika. PeÅ‚nym zadaniem <code>read_line</code> jest
pobranie wszystkiego, co uÅ¼ytkownik wpisze do standardowego wejÅ›cia, i
dodanie tego do ciÄ…gu znakÃ³w (bez nadpisywania jego zawartoÅ›ci), dlatego
przekazujemy ten ciÄ…g znakÃ³w jako argument. Argument ciÄ…gu znakÃ³w musi byÄ‡
mutowalny, aby metoda mogÅ‚a zmieniaÄ‡ zawartoÅ›Ä‡ ciÄ…gu znakÃ³w.</p>
<p>Znak <code>&amp;</code> wskazuje, Å¼e ten argument jest <em>referencjÄ…</em>, co pozwala wielu
czÄ™Å›ciom Twojego kodu uzyskaÄ‡ dostÄ™p do jednego fragmentu danych bez
koniecznoÅ›ci wielokrotnego kopiowania tych danych do pamiÄ™ci. Referencje sÄ…
zÅ‚oÅ¼onÄ… funkcjÄ…, a jednÄ… z gÅ‚Ã³wnych zalet Rusta jest to, jak bezpieczne i
Å‚atwe jest uÅ¼ywanie referencji. Nie musisz znaÄ‡ wielu z tych szczegÃ³Å‚Ã³w, aby
zakoÅ„czyÄ‡ ten program. Na razie wystarczy wiedzieÄ‡, Å¼e podobnie jak zmienne,
referencje sÄ… domyÅ›lnie niezmienne. Dlatego musisz napisaÄ‡ <code>&amp;mut guess</code> zamiast
<code>&amp;guess</code>, aby uczyniÄ‡ jÄ… mutowalnÄ…. (RozdziaÅ‚ 4 wyjaÅ›ni referencje bardziej
dokÅ‚adnie).</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="handling-potential-failure-with-the-result-type"></a></p>
<h3 id="obsÅ‚uga-potencjalnych-bÅ‚Ä™dÃ³w-za-pomocÄ…-result"><a class="header" href="#obsÅ‚uga-potencjalnych-bÅ‚Ä™dÃ³w-za-pomocÄ…-result">ObsÅ‚uga potencjalnych bÅ‚Ä™dÃ³w za pomocÄ… <code>Result</code></a></h3>
<p>Nadal pracujemy nad tÄ… liniÄ… kodu. Teraz omawiamy trzeciÄ… liniÄ™ tekstu,
ale zwrÃ³Ä‡ uwagÄ™, Å¼e jest to nadal czÄ™Å›Ä‡ jednej logicznej linii kodu. NastÄ™pna
czÄ™Å›Ä‡ to ta metoda:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect("Failed to read line");
<span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">}</span></code></pre>
<p>Ten kod mogliÅ›my napisaÄ‡ jako:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect("Failed to read line");</code></pre>
<p>Jednak jedna dÅ‚uga linia jest trudna do odczytania, wiÄ™c najlepiej jest jÄ…
podzieliÄ‡. CzÄ™sto rozsÄ…dne jest wprowadzenie nowej linii i innych biaÅ‚ych
znakÃ³w, aby uÅ‚atwiÄ‡ czytanie dÅ‚ugich linii, gdy wywoÅ‚ujesz metodÄ™ za pomocÄ…
skÅ‚adni <code>.method_name()</code>. Teraz omÃ³wmy, co ta linia robi.</p>
<p>Jak wspomniano wczeÅ›niej, <code>read_line</code> umieszcza wszystko, co uÅ¼ytkownik
wprowadzi, w przekazanym jej ciÄ…gu znakÃ³w, ale zwraca rÃ³wnieÅ¼ wartoÅ›Ä‡ <code>Result</code>.
<a href="../std/result/enum.Result.html"><code>Result</code></a><!-- ignore --> to <em>wyliczenie</em> <a href="#typy-wyliczeniowe-enum-i-dopasowywanie-wzorcÃ³w">enums</a><!-- ignore -->,
czÄ™sto nazywane <em>enum</em>, ktÃ³re jest typem mogÄ…cym przyjmowaÄ‡ jeden z wielu
moÅ¼liwych stanÃ³w. KaÅ¼dy moÅ¼liwy stan nazywamy <em>wariantem</em>.</p>
<p><a href="#typy-wyliczeniowe-enum-i-dopasowywanie-wzorcÃ³w">RozdziaÅ‚ 6</a><!-- ignore --> omÃ³wi szczegÃ³Å‚owo enums. Celem tych
typÃ³w <code>Result</code> jest kodowanie informacji o obsÅ‚udze bÅ‚Ä™dÃ³w.</p>
<p>Wariantami <code>Result</code> sÄ… <code>Ok</code> i <code>Err</code>. Wariant <code>Ok</code> wskazuje, Å¼e operacja
zakoÅ„czyÅ‚a siÄ™ sukcesem i zawiera pomyÅ›lnie wygenerowanÄ… wartoÅ›Ä‡. Wariant <code>Err</code>
oznacza, Å¼e operacja zakoÅ„czyÅ‚a siÄ™ niepowodzeniem i zawiera informacje o tym,
jak lub dlaczego operacja siÄ™ nie powiodÅ‚a.</p>
<p>WartoÅ›ci typu <code>Result</code>, podobnie jak wartoÅ›ci kaÅ¼dego typu, majÄ… zdefiniowane
na nich metody. Instancja <code>Result</code> ma metodÄ™ <a href="../std/result/enum.Result.html#method.expect"><code>expect</code></a><!-- ignore -->,
ktÃ³rÄ… moÅ¼esz wywoÅ‚aÄ‡. JeÅ›li ta instancja <code>Result</code> jest wartoÅ›ciÄ… <code>Err</code>,
<code>expect</code> spowoduje awariÄ™ programu i wyÅ›wietli komunikat, ktÃ³ry przekazaÅ‚eÅ›
jako argument do <code>expect</code>. JeÅ›li metoda <code>read_line</code> zwrÃ³ci <code>Err</code>, bÄ™dzie to
prawdopodobnie wynikiem bÅ‚Ä™du pochodzÄ…cego z bazowego systemu operacyjnego.
JeÅ›li ta instancja <code>Result</code> jest wartoÅ›ciÄ… <code>Ok</code>, <code>expect</code> pobierze wartoÅ›Ä‡
zwracanÄ…, ktÃ³rÄ… przechowuje <code>Ok</code>, i zwrÃ³ci ci tylko tÄ™ wartoÅ›Ä‡, abyÅ› mÃ³gÅ‚ jej
uÅ¼yÄ‡. W tym przypadku ta wartoÅ›Ä‡ to liczba bajtÃ³w w danych wejÅ›ciowych
uÅ¼ytkownika.</p>
<p>JeÅ›li nie wywoÅ‚asz <code>expect</code>, program skompiluje siÄ™, ale otrzymasz ostrzeÅ¼enie:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&amp;mut guess);
   |     +++++++

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Rust ostrzega, Å¼e nie uÅ¼yÅ‚eÅ› wartoÅ›ci <code>Result</code> zwrÃ³conej z <code>read_line</code>,
wskazujÄ…c, Å¼e program nie obsÅ‚uÅ¼yÅ‚ moÅ¼liwego bÅ‚Ä™du.</p>
<p>WÅ‚aÅ›ciwym sposobem na stÅ‚umienie ostrzeÅ¼enia jest faktyczne napisanie kodu
do obsÅ‚ugi bÅ‚Ä™dÃ³w, ale w naszym przypadku chcemy po prostu, aby ten program
ulegÅ‚ awarii, gdy wystÄ…pi problem, wiÄ™c moÅ¼emy uÅ¼yÄ‡ <code>expect</code>. Dowiesz siÄ™ o
recoverowaniu z bÅ‚Ä™dÃ³w w <a href="#bÅ‚Ä™dy-odzyskiwalne-za-pomocÄ…-result-1">Rozdziale 9</a><!-- ignore -->.</p>
<h3 id="wyÅ›wietlanie-wartoÅ›ci-za-pomocÄ…-znacznikÃ³w-println"><a class="header" href="#wyÅ›wietlanie-wartoÅ›ci-za-pomocÄ…-znacznikÃ³w-println">WyÅ›wietlanie wartoÅ›ci za pomocÄ… znacznikÃ³w <code>println!</code></a></h3>
<p>Poza koÅ„cowym nawiasem klamrowym, pozostaÅ‚a tylko jedna linia do omÃ³wienia w
dotychczasowym kodzie:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span>    println!("You guessed: {guess}");
<span class="boring">}</span></code></pre>
<p>Ta linia wyÅ›wietla ciÄ…g znakÃ³w, ktÃ³ry teraz zawiera dane wejÅ›ciowe
uÅ¼ytkownika. Zestaw nawiasÃ³w klamrowych <code>{}</code> to znacznik miejsca:
WyobraÅº sobie <code>{}</code> jako maÅ‚e szczypce kraba, ktÃ³re trzymajÄ… wartoÅ›Ä‡ na miejscu.
Podczas wyÅ›wietlania wartoÅ›ci zmiennej nazwa zmiennej moÅ¼e znajdowaÄ‡ siÄ™ w
Å›rodku nawiasÃ³w klamrowych. Podczas wyÅ›wietlania wyniku oceny wyraÅ¼enia,
umieÅ›Ä‡ puste nawiasy klamrowe w ciÄ…gu formatujÄ…cym, a nastÄ™pnie po ciÄ…gu
formatujÄ…cym umieÅ›Ä‡ listÄ™ wyraÅ¼eÅ„ oddzielonych przecinkami, ktÃ³re majÄ… byÄ‡
wyÅ›wietlone w kaÅ¼dym pustym znaczniku miejsca w tej samej kolejnoÅ›ci.
WyÅ›wietlanie zmiennej i wyniku wyraÅ¼enia w jednym wywoÅ‚aniu <code>println!</code>
wyglÄ…daÅ‚oby tak:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2);
<span class="boring">}</span></code></pre>
<p>Ten kod wydrukowaÅ‚by <code>x = 5 and y + 2 = 12</code>.</p>
<h3 id="testowanie-pierwszej-czÄ™Å›ci"><a class="header" href="#testowanie-pierwszej-czÄ™Å›ci">Testowanie pierwszej czÄ™Å›ci</a></h3>
<p>Przetestujmy pierwszÄ… czÄ™Å›Ä‡ gry w zgadywanie. Uruchom jÄ… za pomocÄ… <code>cargo run</code>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>W tym momencie pierwsza czÄ™Å›Ä‡ gry jest gotowa: pobieramy dane z klawiatury,
a nastÄ™pnie je wyÅ›wietlamy.</p>
<h2 id="generowanie-tajnej-liczby"><a class="header" href="#generowanie-tajnej-liczby">Generowanie tajnej liczby</a></h2>
<p>NastÄ™pnie musimy wygenerowaÄ‡ tajnÄ… liczbÄ™, ktÃ³rÄ… uÅ¼ytkownik bÄ™dzie prÃ³bowaÅ‚
zgadnÄ…Ä‡. Tajna liczba powinna byÄ‡ inna za kaÅ¼dym razem, aby gra byÅ‚a zabawna
do wielokrotnego grania. UÅ¼yjemy losowej liczby od 1 do 100, aby gra nie byÅ‚a
zbyt trudna. Rust nie zawiera jeszcze funkcji do generowania liczb losowych w
standardowej bibliotece. Jednak zespÃ³Å‚ Rusta udostÄ™pnia pakiet <a href="https://crates.io/crates/rand"><code>rand</code>
crate</a> z tÄ… funkcjonalnoÅ›ciÄ….</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="using-a-crate-to-get-more-functionality"></a></p>
<h3 id="zwiÄ™kszanie-funkcjonalnoÅ›ci-za-pomocÄ…-pakietu"><a class="header" href="#zwiÄ™kszanie-funkcjonalnoÅ›ci-za-pomocÄ…-pakietu">ZwiÄ™kszanie funkcjonalnoÅ›ci za pomocÄ… pakietu</a></h3>
<p>PamiÄ™taj, Å¼e <em>crate</em> to zbiÃ³r plikÃ³w ÅºrÃ³dÅ‚owych Rusta. Projekt, ktÃ³ry budujemy,
jest <em>binary crate</em>, czyli plikiem wykonywalnym. <em>Crate</em> <code>rand</code> to <em>library
crate</em>, ktÃ³ry zawiera kod przeznaczony do uÅ¼ycia w innych programach i nie moÅ¼e
byÄ‡ wykonywany samodzielnie.</p>
<p>Koordynacja zewnÄ™trznych <code>crate'Ã³w</code> przez Cargo to miejsce, w ktÃ³rym Cargo
naprawdÄ™ bÅ‚yszczy. Zanim bÄ™dziemy mogli napisaÄ‡ kod, ktÃ³ry uÅ¼ywa <code>rand</code>,
musimy zmodyfikowaÄ‡ plik <em>Cargo.toml</em>, aby dodaÄ‡ <code>rand</code> jako zaleÅ¼noÅ›Ä‡.
OtwÃ³rz ten plik teraz i dodaj nastÄ™pujÄ…cÄ… liniÄ™ na dole, pod nagÅ‚Ã³wkiem
sekcji <code>[dependencies]</code>, ktÃ³ry Cargo dla Ciebie utworzyÅ‚. Upewnij siÄ™, Å¼e
okreÅ›lasz <code>rand</code> dokÅ‚adnie tak, jak tutaj, z tym numerem wersji, w przeciwnym
razie przykÅ‚ady kodu w tym samouczku mogÄ… nie dziaÅ‚aÄ‡:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">Nazwa pliku: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = "0.8.5"
</code></pre>
<p>W pliku <em>Cargo.toml</em> wszystko, co nastÄ™puje po nagÅ‚Ã³wku, jest czÄ™Å›ciÄ… tej
sekcji, ktÃ³ra trwa, dopÃ³ki nie rozpocznie siÄ™ inna sekcja. W <code>[dependencies]</code>
informujesz Cargo, od ktÃ³rych zewnÄ™trznych pakietÃ³w zaleÅ¼y TwÃ³j projekt i
ktÃ³rych wersji tych pakietÃ³w potrzebujesz. W tym przypadku okreÅ›lamy pakiet
<code>rand</code> ze specyfikatorem wersji semantycznej <code>0.8.5</code>. Cargo rozumie <a href="http://semver.org">Semantic
Versioning</a><!-- ignore --> (czasami nazywane <em>SemVer</em>), ktÃ³ry jest
standardem zapisu numerÃ³w wersji. Specyfikator <code>0.8.5</code> jest w rzeczywistoÅ›ci
skrÃ³tem od <code>^0.8.5</code>, co oznacza dowolnÄ… wersjÄ™ co najmniej 0.8.5, ale
padajÄ…cÄ… poniÅ¼ej 0.9.0.</p>
<p>Cargo uwaÅ¼a, Å¼e te wersje majÄ… publiczne API kompatybilne z wersjÄ… 0.8.5, a ta
specyfikacja gwarantuje, Å¼e otrzymasz najnowszÄ… wersjÄ™ poprawki, ktÃ³ra nadal
bÄ™dzie kompilowaÄ‡ siÄ™ z kodem w tym rozdziale. Å»adna wersja 0.9.0 lub
wiÄ™ksza nie gwarantuje tego samego API, co w poniÅ¼szych przykÅ‚adach.</p>
<p>Teraz, bez zmiany kodu, zbudujmy projekt, jak pokazano w Listingu 2-2.</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->
<figure class="listing" id="listing-2-2">
<pre><code class="language-console">$ cargo build
  Updating crates.io index
   Locking 15 packages to latest Rust 1.85.0 compatible versions
    Adding rand v0.8.5 (available: v0.9.0)
 Compiling proc-macro2 v1.0.93
 Compiling unicode-ident v1.0.17
 Compiling libc v0.2.170
 Compiling cfg-if v1.0.0
 Compiling byteorder v1.5.0
 Compiling getrandom v0.2.15
 Compiling rand_core v0.6.4
 Compiling quote v1.0.38
 Compiling syn v2.0.98
 Compiling zerocopy-derive v0.7.35
 Compiling zerocopy v0.7.35
 Compiling ppv-lite86 v0.2.20
 Compiling rand_chacha v0.3.1
 Compiling rand v0.8.5
 Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
  Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.48s
</code></pre>
<figcaption><a href="#listing-2-2">Listing 2-2</a>: Wynik uruchomienia <code>cargo build</code> po dodaniu <code>rand</code> jako zaleÅ¼noÅ›ci</figcaption>
</figure>
<p>MoÅ¼esz zobaczyÄ‡ rÃ³Å¼ne numery wersji (ale wszystkie bÄ™dÄ… kompatybilne z kodem,
dziÄ™ki SemVer!) i rÃ³Å¼ne linie (w zaleÅ¼noÅ›ci od systemu operacyjnego), a linie
mogÄ… byÄ‡ w innej kolejnoÅ›ci.</p>
<p>Gdy doÅ‚Ä…czamy zewnÄ™trznÄ… zaleÅ¼noÅ›Ä‡, Cargo pobiera najnowsze wersje wszystkiego,
czego ta zaleÅ¼noÅ›Ä‡ potrzebuje, z <em>rejestru</em>, ktÃ³ry jest kopiÄ… danych z
<a href="https://crates.io/">Crates.io</a>. Crates.io to miejsce, w ktÃ³rym ludzie w ekosystemie
Rusta publikujÄ… swoje projekty Rust open source, aby inni mogli z nich
korzystaÄ‡.</p>
<p>Po zaktualizowaniu rejestru Cargo sprawdza sekcjÄ™ <code>[dependencies]</code> i pobiera
wszystkie wymienione pakiety, ktÃ³re nie zostaÅ‚y jeszcze pobrane. W tym
przypadku, choÄ‡ wymieniliÅ›my tylko <code>rand</code> jako zaleÅ¼noÅ›Ä‡, Cargo pobraÅ‚ rÃ³wnieÅ¼
inne pakiety, od ktÃ³rych zaleÅ¼y <code>rand</code>, aby dziaÅ‚aÅ‚. Po pobraniu pakietÃ³w
Rust kompiluje je, a nastÄ™pnie kompiluje projekt z dostÄ™pnymi zaleÅ¼noÅ›ciami.</p>
<p>JeÅ›li natychmiast ponownie uruchomisz <code>cargo build</code> bez wprowadzania Å¼adnych
zmian, nie otrzymasz Å¼adnych danych wyjÅ›ciowych poza liniÄ… <code>Finished</code>.
Cargo wie, Å¼e juÅ¼ pobraÅ‚ i skompilowaÅ‚ zaleÅ¼noÅ›ci, a Ty nie zmieniÅ‚eÅ› nic
w pliku <em>Cargo.toml</em>. Cargo wie rÃ³wnieÅ¼, Å¼e nie zmieniÅ‚eÅ› nic w swoim kodzie,
wiÄ™c nie kompiluje go ponownie. Nie majÄ…c nic do zrobienia, po prostu
koÅ„czy dziaÅ‚anie.</p>
<p>JeÅ›li otworzysz plik <em>src/main.rs</em>, dokonasz trywialnej zmiany, a nastÄ™pnie
zapiszesz go i ponownie zbudujesz, zobaczysz tylko dwie linie danych
wyjÅ›ciowych:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
</code></pre>
<p>Te linie pokazujÄ…, Å¼e Cargo aktualizuje kompilacjÄ™ tylko o TwojÄ… drobnÄ… zmianÄ™
w pliku <em>src/main.rs</em>. Twoje zaleÅ¼noÅ›ci nie ulegÅ‚y zmianie, wiÄ™c Cargo wie,
Å¼e moÅ¼e ponownie wykorzystaÄ‡ to, co juÅ¼ pobraÅ‚ i skompilowaÅ‚ dla nich.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="ensuring-reproducible-builds-with-the-cargo-lock-file"></a></p>
<h4 id="zapewnianie-powtarzalnych-kompilacji-za-pomocÄ…-pliku-cargolock"><a class="header" href="#zapewnianie-powtarzalnych-kompilacji-za-pomocÄ…-pliku-cargolock">Zapewnianie powtarzalnych kompilacji za pomocÄ… pliku Cargo.lock</a></h4>
<p>Cargo posiada mechanizm, ktÃ³ry zapewnia, Å¼e moÅ¼esz odbudowaÄ‡ ten sam artefakt
za kaÅ¼dym razem, gdy Ty lub ktokolwiek inny buduje TwÃ³j kod: Cargo bÄ™dzie uÅ¼ywaÄ‡
tylko tych wersji zaleÅ¼noÅ›ci, ktÃ³re okreÅ›liÅ‚eÅ›, chyba Å¼e wskaÅ¼esz inaczej. Na
przykÅ‚ad, powiedzmy, Å¼e w przyszÅ‚ym tygodniu zostanie wydana wersja 0.8.6 pakietu
<code>rand</code>, a ta wersja zawiera waÅ¼nÄ… poprawkÄ™ bÅ‚Ä™du, ale zawiera rÃ³wnieÅ¼ regresjÄ™,
ktÃ³ra zepsuje TwÃ³j kod. Aby temu zaradziÄ‡, Rust tworzy plik <em>Cargo.lock</em> za
pierwszym razem, gdy uruchamiasz <code>cargo build</code>, wiÄ™c teraz mamy go w katalogu
<em>guessing_game</em>.</p>
<p>Kiedy budujesz projekt po raz pierwszy, Cargo ustala wszystkie wersje
zaleÅ¼noÅ›ci, ktÃ³re speÅ‚niajÄ… kryteria, a nastÄ™pnie zapisuje je do pliku
<em>Cargo.lock</em>. Kiedy budujesz swÃ³j projekt w przyszÅ‚oÅ›ci, Cargo zobaczy, Å¼e plik
<em>Cargo.lock</em> istnieje i uÅ¼yje tam okreÅ›lonych wersji, zamiast ponownie wykonywaÄ‡
caÅ‚ej pracy zwiÄ…zanej z ustalaniem wersji. Pozwala to na automatyczne
powtarzalne budowanie. Innymi sÅ‚owy, TwÃ³j projekt pozostanie w wersji 0.8.5,
dopÃ³ki wyraÅºnie go nie zaktualizujesz, dziÄ™ki plikowi <em>Cargo.lock</em>. PoniewaÅ¼
plik <em>Cargo.lock</em> jest waÅ¼ny dla powtarzalnych kompilacji, czÄ™sto jest
dodawany do kontroli wersji wraz z resztÄ… kodu w Twoim projekcie.</p>
<h4 id="aktualizacja-cratea-aby-uzyskaÄ‡-nowÄ…-wersjÄ™"><a class="header" href="#aktualizacja-cratea-aby-uzyskaÄ‡-nowÄ…-wersjÄ™">Aktualizacja â€œcrateâ€™aâ€, aby uzyskaÄ‡ nowÄ… wersjÄ™</a></h4>
<p>Kiedy <em>chcesz</em> zaktualizowaÄ‡ pakiet, Cargo udostÄ™pnia polecenie <code>update</code>, ktÃ³re
zignoruje plik <em>Cargo.lock</em> i ustali wszystkie najnowsze wersje, ktÃ³re pasujÄ…
do twoich specyfikacji w <em>Cargo.toml</em>. Cargo nastÄ™pnie zapisze te wersje do
pliku <em>Cargo.lock</em>. W przeciwnym razie, domyÅ›lnie, Cargo bÄ™dzie szukaÄ‡ tylko
wersji wiÄ™kszych niÅ¼ 0.8.5 i mniejszych niÅ¼ 0.9.0. JeÅ›li pakiet <code>rand</code> wydaÅ‚
dwie nowe wersje 0.8.6 i 0.999.0, zobaczyÅ‚byÅ› nastÄ™pujÄ…ce, gdybyÅ› uruchomiÅ‚
<code>cargo update</code>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
     Locking 1 package to latest Rust 1.85.0 compatible version
    Updating rand v0.8.5 -&gt; v0.8.6 (available: v0.999.0)
</code></pre>
<p>Cargo ignoruje wydanie 0.999.0. W tym momencie zauwaÅ¼yÅ‚byÅ› rÃ³wnieÅ¼ zmianÄ™ w
pliku <em>Cargo.lock</em>, wskazujÄ…cÄ…, Å¼e wersja pakietu <code>rand</code>, ktÃ³rej teraz uÅ¼ywasz,
to 0.8.6. Aby uÅ¼yÄ‡ wersji <code>rand</code> 0.999.0 lub dowolnej wersji z serii 0.999.<em>x</em>,
musiaÅ‚byÅ› zamiast tego zaktualizowaÄ‡ plik <em>Cargo.toml</em>, aby wyglÄ…daÅ‚ tak (nie
wprowadzaj tej zmiany, poniewaÅ¼ poniÅ¼sze przykÅ‚ady zakÅ‚adajÄ…, Å¼e uÅ¼ywasz <code>rand</code>
0.8):</p>
<pre><code class="language-toml">[dependencies]
rand = "0.999.0"
</code></pre>
<p>NastÄ™pnym razem, gdy uruchomisz <code>cargo build</code>, Cargo zaktualizuje rejestr
dostÄ™pnych pakietÃ³w i ponownie oceni Twoje wymagania dotyczÄ…ce <code>rand</code> zgodnie z
nowÄ… wersjÄ…, ktÃ³rÄ… okreÅ›liÅ‚eÅ›.</p>
<p>Wiele jest do powiedzenia na temat <a href="https://doc.rust-lang.org/cargo/">Cargo</a><!-- ignore --> i <a href="https://doc.rust-lang.org/cargo/reference/publishing.html">jego
ekosystemu</a><!-- ignore -->, ktÃ³re omÃ³wimy w Rozdziale 14, ale na
razie to wszystko, co musisz wiedzieÄ‡. Cargo bardzo uÅ‚atwia ponowne uÅ¼ywanie
bibliotek, wiÄ™c Rustowcy mogÄ… pisaÄ‡ mniejsze projekty, ktÃ³re sÄ… montowane z
wielu pakietÃ³w.</p>
<h3 id="generowanie-liczby-losowej"><a class="header" href="#generowanie-liczby-losowej">Generowanie liczby losowej</a></h3>
<p>Zacznijmy uÅ¼ywaÄ‡ <code>rand</code> do generowania liczby do zgadniÄ™cia. NastÄ™pnym krokiem
jest aktualizacja <em>src/main.rs</em>, jak pokazano w Listingu 2-3.</p>
<figure class="listing" id="listing-2-3">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore">use std::io;

use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("The secret number is: {secret_number}");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}</code></pre>
<figcaption><a href="#listing-2-3">Listing 2-3</a>: Dodawanie kodu do generowania liczby losowej</figcaption>
</figure>
<p>Najpierw dodajemy liniÄ™ <code>use rand::Rng;</code>. Cecha <code>Rng</code> definiuje metody,
ktÃ³re implementujÄ… generatory liczb losowych, i ta cecha musi byÄ‡ w zakresie,
abyÅ›my mogli uÅ¼ywaÄ‡ tych metod. RozdziaÅ‚ 10 szczegÃ³Å‚owo omÃ³wi cechy.</p>
<p>NastÄ™pnie dodajemy dwie linie w Å›rodku. W pierwszej linii wywoÅ‚ujemy funkcjÄ™
<code>rand::thread_rng</code>, ktÃ³ra daje nam konkretny generator liczb losowych, ktÃ³rego
bÄ™dziemy uÅ¼ywaÄ‡: taki, ktÃ³ry jest lokalny dla bieÅ¼Ä…cego wÄ…tku wykonawczego
i jest inicjowany przez system operacyjny. NastÄ™pnie wywoÅ‚ujemy metodÄ™
<code>gen_range</code> na generatorze liczb losowych. Ta metoda jest zdefiniowana przez
cechÄ™ <code>Rng</code>, ktÃ³rÄ… wprowadziliÅ›my do zakresu za pomocÄ… instrukcji
<code>use rand::Rng;</code>. Metoda <code>gen_range</code> przyjmuje wyraÅ¼enie zakresu jako argument
i generuje liczbÄ™ losowÄ… w tym zakresie. Rodzaj wyraÅ¼enia zakresu, ktÃ³rego tu
uÅ¼ywamy, ma postaÄ‡ <code>start..=end</code> i jest inkluzywny na dolnej i gÃ³rnej granicy,
wiÄ™c musimy okreÅ›liÄ‡ <code>1..=100</code>, aby zaÅ¼Ä…daÄ‡ liczby od 1 do 100.</p>
<section class="note" aria-role="note">
<p>Uwaga: Nie bÄ™dziesz po prostu wiedziaÅ‚, ktÃ³rych cech uÅ¼ywaÄ‡ i ktÃ³re metody
i funkcje wywoÅ‚ywaÄ‡ z â€œcrateâ€™aâ€, wiÄ™c kaÅ¼dy â€œcrateâ€ ma dokumentacjÄ™ z
instrukcjami jego uÅ¼ywania. InnÄ… fajnÄ… funkcjÄ… Cargo jest to, Å¼e uruchomienie
polecenia <code>cargo doc --open</code> zbuduje dokumentacjÄ™ dostarczonÄ… przez wszystkie
Twoje zaleÅ¼noÅ›ci lokalnie i otworzy jÄ… w Twojej przeglÄ…darce. JeÅ›li interesuje
CiÄ™ inna funkcjonalnoÅ›Ä‡ w â€œcrateâ€™cieâ€ <code>rand</code>, na przykÅ‚ad, uruchom
<code>cargo doc --open</code> i kliknij <code>rand</code> na pasku bocznym po lewej stronie.</p>
</section>
<p>Druga nowa linia wyÅ›wietla tajnÄ… liczbÄ™. Jest to przydatne podczas
opracowywania programu, aby mÃ³c go przetestowaÄ‡, ale usuniemy jÄ… z ostatecznej
wersji. Nie ma sensu graÄ‡, jeÅ›li program wyÅ›wietla odpowiedÅº zaraz po
uruchomieniu!</p>
<p>SprÃ³buj uruchomiÄ‡ program kilka razy:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>PowinieneÅ› otrzymaÄ‡ rÃ³Å¼ne liczby losowe, i wszystkie powinny byÄ‡ liczbami
pomiÄ™dzy 1 a 100. Åšwietna robota!</p>
<h2 id="porÃ³wnywanie-strzaÅ‚u-z-tajnÄ…-liczbÄ…"><a class="header" href="#porÃ³wnywanie-strzaÅ‚u-z-tajnÄ…-liczbÄ…">PorÃ³wnywanie strzaÅ‚u z tajnÄ… liczbÄ…</a></h2>
<p>Teraz, gdy mamy dane wejÅ›ciowe od uÅ¼ytkownika i liczbÄ™ losowÄ…, moÅ¼emy je
porÃ³wnaÄ‡. Ten krok jest pokazany w Listingu 2-4. ZauwaÅ¼, Å¼e ten kod na razie
siÄ™ nie skompiluje, co wyjaÅ›nimy.</p>
<figure class="listing" id="listing-2-4">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use std::cmp::Ordering;
use std::io;

use rand::Rng;

fn main() {
    // --snip--
<span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span>
    println!("You guessed: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
}</code></pre>
<figcaption><a href="#listing-2-4">Listing 2-4</a>: ObsÅ‚uga moÅ¼liwych wartoÅ›ci zwracanych przez porÃ³wnywanie dwÃ³ch liczb</figcaption>
</figure>
<p>Najpierw dodajemy kolejnÄ… instrukcjÄ™ <code>use</code>, wprowadzajÄ…c typ o nazwie
<code>std::cmp::Ordering</code> do zakresu ze standardowej biblioteki. Typ <code>Ordering</code> to
kolejne wyliczenie (<code>enum</code>) i ma warianty <code>Less</code>, <code>Greater</code> i <code>Equal</code>. SÄ… to
trzy moÅ¼liwe wyniki porÃ³wnania dwÃ³ch wartoÅ›ci.</p>
<p>NastÄ™pnie dodajemy piÄ™Ä‡ nowych linii na dole, ktÃ³re uÅ¼ywajÄ… typu <code>Ordering</code>.
Metoda <code>cmp</code> porÃ³wnuje dwie wartoÅ›ci i moÅ¼e byÄ‡ wywoÅ‚ana na wszystkim, co
moÅ¼na porÃ³wnaÄ‡. Przyjmuje referencjÄ™ do tego, z czym chcesz porÃ³wnaÄ‡: tutaj
porÃ³wnuje <code>guess</code> z <code>secret_number</code>. NastÄ™pnie zwraca wariant wyliczenia
<code>Ordering</code>, ktÃ³re wprowadziliÅ›my do zakresu za pomocÄ… instrukcji <code>use</code>.
UÅ¼ywamy wyraÅ¼enia <a href="#konstrukcja-kontroli-przepÅ‚ywu-match-1"><code>match</code></a><!-- ignore -->, aby zdecydowaÄ‡, co zrobiÄ‡
dalej, w oparciu o to, ktÃ³ry wariant <code>Ordering</code> zostaÅ‚ zwrÃ³cony z wywoÅ‚ania
<code>cmp</code> z wartoÅ›ciami w <code>guess</code> i <code>secret_number</code>.</p>
<p>WyraÅ¼enie <code>match</code> skÅ‚ada siÄ™ z <em>ramion</em>. RamiÄ™ skÅ‚ada siÄ™ z <em>wzorca</em>, z ktÃ³rym
ma byÄ‡ dopasowywana wartoÅ›Ä‡, oraz kodu, ktÃ³ry powinien zostaÄ‡ uruchomiony, jeÅ›li
wartoÅ›Ä‡ podana do <code>match</code> pasuje do wzorca tego ramienia. Rust pobiera wartoÅ›Ä‡
podanÄ… do <code>match</code> i kolejno przeglÄ…da wzorce kaÅ¼dego ramienia. Patrzy na
wzorzec pierwszego ramienia, <code>Ordering::Less</code>, i widzi, Å¼e wartoÅ›Ä‡
<code>Ordering::Greater</code> nie pasuje do <code>Ordering::Less</code>, wiÄ™c ignoruje kod w tym
ramieniu i przechodzi do nastÄ™pnego ramienia. Wzorzec nastÄ™pnego ramienia to
<code>Ordering::Greater</code>, ktÃ³ry <em>pasuje</em> do <code>Ordering::Greater</code>! PowiÄ…zany kod w
tym ramieniu zostanie wykonany i wyÅ›wietli na ekranie <code>Too big!</code>. WyraÅ¼enie
<code>match</code> koÅ„czy siÄ™ po pierwszym udanym dopasowaniu, wiÄ™c w tym scenariuszu
nie bÄ™dzie patrzeÄ‡ na ostatnie ramiÄ™.</p>
<p>Jednak kod w Listingu 2-4 jeszcze siÄ™ nie skompiluje. SprÃ³bujmy:</p>
<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:23:21
   |
23 |     match guess.cmp(&amp;secret_number) {
   |                 --- ^^^^^^^^^^^^^^ expected `&amp;String`, found `&amp;{integer}`
   |                 |
   |                 arguments to this method are incorrect
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`
note: method defined here
  --&gt; /rustc/1159e78c4747b02ef996e55082b704c09b970588/library/core/src/cmp.rs:979:8

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` (bin "guessing_game") due to 1 previous error
</code></pre>
<p>RdzeÅ„ bÅ‚Ä™du stwierdza, Å¼e wystÄ™pujÄ… <em>niezgodne typy</em>. Rust ma silny, statyczny
system typÃ³w. Jednak ma rÃ³wnieÅ¼ inferencjÄ™ typÃ³w. Kiedy napisaliÅ›my
<code>let mut guess = String::new()</code>, Rust byÅ‚ w stanie wywnioskowaÄ‡, Å¼e <code>guess</code>
powinno byÄ‡ <code>String</code> i nie kazaÅ‚ nam pisaÄ‡ tego typu. <code>secret_number</code> natomiast
jest typem liczbowym. Kilka typÃ³w liczbowych Rusta moÅ¼e mieÄ‡ wartoÅ›Ä‡ pomiÄ™dzy
1 a 100: <code>i32</code>, liczba 32-bitowa; <code>u32</code>, niepodpisana liczba 32-bitowa; <code>i64</code>,
liczba 64-bitowa; oraz inne. O ile nie okreÅ›lono inaczej, Rust domyÅ›lnie uÅ¼ywa
<code>i32</code>, ktÃ³ry jest typem <code>secret_number</code>, chyba Å¼e dodasz informacje o typie w
innym miejscu, co spowodowaÅ‚oby, Å¼e Rust wywnioskowaÅ‚by inny typ liczbowy.
Powodem bÅ‚Ä™du jest to, Å¼e Rust nie moÅ¼e porÃ³wnywaÄ‡ ciÄ…gu znakÃ³w i typu
liczbowego.</p>
<p>Ostatecznie chcemy przekonwertowaÄ‡ <code>String</code>, ktÃ³rÄ… program odczytuje jako dane
wejÅ›ciowe, na typ liczbowy, abyÅ›my mogli porÃ³wnaÄ‡ jÄ… numerycznie z tajnÄ…
liczbÄ…. Robimy to, dodajÄ…c tÄ™ liniÄ™ do ciaÅ‚a funkcji <code>main</code>:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span>    // --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
<span class="boring">}</span></code></pre>
<p>Linia to:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect("Please type a number!");</code></pre>
<p>Tworzymy zmiennÄ… o nazwie <code>guess</code>. Ale chwila, czy program nie ma juÅ¼ zmiennej
o nazwie <code>guess</code>? Tak, ale Rust pozwala nam w korzystny sposÃ³b zacieniÄ‡
poprzedniÄ… wartoÅ›Ä‡ <code>guess</code> nowÄ…. <em>Zacienianie</em> pozwala nam ponownie uÅ¼yÄ‡ nazwy
zmiennej <code>guess</code>, zamiast zmuszaÄ‡ nas do tworzenia dwÃ³ch unikalnych zmiennych,
takich jak <code>guess_str</code> i <code>guess</code>, na przykÅ‚ad. OmÃ³wimy to szczegÃ³Å‚owo w
<a href="#shadowing">Rozdziale 3</a><!-- ignore -->, ale na razie wiedz, Å¼e ta funkcja jest
czÄ™sto uÅ¼ywana, gdy chcesz przekonwertowaÄ‡ wartoÅ›Ä‡ z jednego typu na inny.</p>
<p>WiÄ…zamy tÄ™ nowÄ… zmiennÄ… z wyraÅ¼eniem <code>guess.trim().parse()</code>. <code>guess</code> w
wyraÅ¼eniu odnosi siÄ™ do oryginalnej zmiennej <code>guess</code>, ktÃ³ra zawieraÅ‚a dane
wejÅ›ciowe jako ciÄ…g znakÃ³w. Metoda <code>trim</code> na instancji <code>String</code> usunie
wszelkie biaÅ‚e znaki na poczÄ…tku i na koÅ„cu, co musimy zrobiÄ‡, zanim
przekonwertujemy ciÄ…g znakÃ³w na <code>u32</code>, ktÃ³ry moÅ¼e zawieraÄ‡ tylko dane
liczbowe. UÅ¼ytkownik musi nacisnÄ…Ä‡ <kbd>enter</kbd>, aby zadowoliÄ‡ <code>read_line</code> i
wprowadziÄ‡ swÃ³j strzaÅ‚, co dodaje znak nowej linii do ciÄ…gu znakÃ³w. Na
przykÅ‚ad, jeÅ›li uÅ¼ytkownik wpisze <kbd>5</kbd> i naciÅ›nie <kbd>enter</kbd>, <code>guess</code>
bÄ™dzie wyglÄ…daÅ‚o tak: <code>5\n</code>. <code>\n</code> oznacza â€œnowÄ… liniÄ™â€. (W systemie Windows
naciÅ›niÄ™cie <kbd>enter</kbd> powoduje powrÃ³t karetki i nowÄ… liniÄ™, <code>\r\n</code>.) Metoda
<code>trim</code> usuwa <code>\n</code> lub <code>\r\n</code>, pozostawiajÄ…c tylko <code>5</code>.</p>
<p>Metoda <a href="../std/primitive.str.html#method.parse"><code>parse</code> na ciÄ…gach znakÃ³w</a><!-- ignore --> konwertuje ciÄ…g
znakÃ³w na inny typ. Tutaj uÅ¼ywamy jej do konwersji z ciÄ…gu znakÃ³w na liczbÄ™.
Musimy powiedzieÄ‡ Rustowi dokÅ‚adny typ liczbowy, ktÃ³rego chcemy, uÅ¼ywajÄ…c
<code>let guess: u32</code>. Dwukropek (<code>:</code>) po <code>guess</code> mÃ³wi Rustowi, Å¼e bÄ™dziemy
anotowaÄ‡ typ zmiennej. Rust ma kilka wbudowanych typÃ³w liczbowych; <code>u32</code>
widziane tutaj to niepodpisana, 32-bitowa liczba caÅ‚kowita. Jest to dobry
domyÅ›lny wybÃ³r dla maÅ‚ej liczby dodatniej. O innych typach liczbowych dowiesz
siÄ™ w <a href="#integer-types">Rozdziale 3</a><!-- ignore -->.</p>
<p>Dodatkowo, adnotacja <code>u32</code> w tym przykÅ‚adzie programu i porÃ³wnanie z
<code>secret_number</code> oznacza, Å¼e Rust wywnioskuje, iÅ¼ <code>secret_number</code> rÃ³wnieÅ¼
powinno byÄ‡ <code>u32</code>. Tak wiÄ™c, teraz porÃ³wnanie bÄ™dzie dotyczyÅ‚o dwÃ³ch wartoÅ›ci
tego samego typu!</p>
<p>Metoda <code>parse</code> bÄ™dzie dziaÅ‚aÄ‡ tylko na znakach, ktÃ³re moÅ¼na logicznie
przeksztaÅ‚ciÄ‡ na liczby i dlatego moÅ¼e Å‚atwo powodowaÄ‡ bÅ‚Ä™dy. Gdyby, na
przykÅ‚ad, ciÄ…g znakÃ³w zawieraÅ‚ <code>AğŸ‘%</code>, nie byÅ‚oby sposobu na przeksztaÅ‚cenie
tego na liczbÄ™. PoniewaÅ¼ moÅ¼e to zakoÅ„czyÄ‡ siÄ™ niepowodzeniem, metoda <code>parse</code>
zwraca typ <code>Result</code>, podobnie jak metoda <code>read_line</code> (omÃ³wiona wczeÅ›niej w
sekcji <a href="#handling-potential-failure-with-the-result-type">â€ObsÅ‚uga potencjalnych bÅ‚Ä™dÃ³w za pomocÄ… <code>Result</code>â€</a><!-- ignore -->).
BÄ™dziemy traktowaÄ‡ ten <code>Result</code> w ten sam sposÃ³b, ponownie uÅ¼ywajÄ…c metody
<code>expect</code>. JeÅ›li <code>parse</code> zwrÃ³ci wariant <code>Err</code> <code>Result</code>, poniewaÅ¼ nie udaÅ‚o siÄ™
utworzyÄ‡ liczby z ciÄ…gu znakÃ³w, wywoÅ‚anie <code>expect</code> spowoduje awariÄ™ gry i
wyÅ›wietli komunikat, ktÃ³ry mu podamy. JeÅ›li <code>parse</code> z powodzeniem przekonwertuje
ciÄ…g znakÃ³w na liczbÄ™, zwrÃ³ci wariant <code>Ok</code> <code>Result</code>, a <code>expect</code> zwrÃ³ci liczbÄ™,
ktÃ³rej chcemy z wartoÅ›ci <code>Ok</code>.</p>
<p>Uruchommy teraz program:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
touch src/main.rs
cargo run
  76
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.26s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>Åšwietnie! Mimo Å¼e przed zgadywanÄ… liczbÄ… dodano spacje, program nadal
rozpoznaÅ‚, Å¼e uÅ¼ytkownik zgadÅ‚ 76. Uruchom program kilka razy, aby sprawdziÄ‡
rÃ³Å¼ne zachowania z rÃ³Å¼nymi rodzajami danych wejÅ›ciowych: zgadnij liczbÄ™
poprawnie, zgadnij liczbÄ™, ktÃ³ra jest za wysoka, i zgadnij liczbÄ™, ktÃ³ra jest
za niska.</p>
<p>Mamy juÅ¼ wiÄ™kszoÅ›Ä‡ gry dziaÅ‚ajÄ…cÄ…, ale uÅ¼ytkownik moÅ¼e wykonaÄ‡ tylko jeden
strzaÅ‚. ZmieÅ„my to, dodajÄ…c pÄ™tlÄ™!</p>
<h2 id="zezwalanie-na-wielokrotne-zgadywanie-za-pomocÄ…-pÄ™tli"><a class="header" href="#zezwalanie-na-wielokrotne-zgadywanie-za-pomocÄ…-pÄ™tli">Zezwalanie na wielokrotne zgadywanie za pomocÄ… pÄ™tli</a></h2>
<p>SÅ‚owo kluczowe <code>loop</code> tworzy nieskoÅ„czonÄ… pÄ™tlÄ™. Dodamy pÄ™tlÄ™, aby daÄ‡
uÅ¼ytkownikom wiÄ™cej szans na odgadniÄ™cie liczby:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    // --snip--

    println!("The secret number is: {secret_number}");

    loop {
        println!("Please input your guess.");

        // --snip--

<span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("Please type a number!");
</span><span class="boring">
</span><span class="boring">        println!("You guessed: {guess}");
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; println!("You win!"),
        }
    }
}</code></pre>
<p>Jak widaÄ‡, przenieÅ›liÅ›my wszystko od monitu o wprowadzenie zgadywanej liczby
dalej do pÄ™tli. Upewnij siÄ™, Å¼e wciÅ›niesz kaÅ¼dÄ… liniÄ™ wewnÄ…trz pÄ™tli o kolejne
cztery spacje i ponownie uruchom program. Program bÄ™dzie teraz prosiÅ‚ o kolejny
strzaÅ‚ w nieskoÅ„czonoÅ›Ä‡, co wprowadza nowy problem. WyglÄ…da na to, Å¼e
uÅ¼ytkownik nie moÅ¼e wyjÅ›Ä‡!</p>
<p>UÅ¼ytkownik zawsze mÃ³gÅ‚ przerwaÄ‡ program za pomocÄ… skrÃ³tu klawiaturowego
<kbd>ctrl</kbd>-<kbd>C</kbd>. Ale jest inny sposÃ³b na ucieczkÄ™ przed tym
nienasyconym potworem, jak wspomniano w dyskusji o <code>parse</code> w sekcji
<a href="#comparing-the-guess-to-the-secret-number">â€PorÃ³wnywanie strzaÅ‚u z tajnÄ… liczbÄ…â€</a><!-- ignore -->: jeÅ›li uÅ¼ytkownik wprowadzi
dane nieliczbowe, program ulegnie awarii. MoÅ¼emy to wykorzystaÄ‡, aby pozwoliÄ‡
uÅ¼ytkownikowi wyjÅ›Ä‡, jak pokazano tutaj:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
touch src/main.rs
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit

thread 'main' panicked at src/main.rs:28:47:
Please type a number!: ParseIntError { kind: InvalidDigit }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Wpisanie <code>quit</code> spowoduje wyjÅ›cie z gry, ale jak zauwaÅ¼ysz, tak samo zadziaÅ‚a
wprowadzenie dowolnych innych danych nieliczbowych. Jest to, delikatnie mÃ³wiÄ…c,
nieoptymalne; chcemy, aby gra zatrzymywaÅ‚a siÄ™ rÃ³wnieÅ¼ po odgadniÄ™ciu
prawidÅ‚owej liczby.</p>
<h3 id="zakoÅ„czenie-po-prawidÅ‚owym-strzale"><a class="header" href="#zakoÅ„czenie-po-prawidÅ‚owym-strzale">ZakoÅ„czenie po prawidÅ‚owym strzale</a></h3>
<p>Zaprogramujmy grÄ™ tak, aby koÅ„czyÅ‚a siÄ™, gdy uÅ¼ytkownik wygra, dodajÄ…c instrukcjÄ™
<code>break</code>:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("Please type a number!");
</span><span class="boring">
</span><span class="boring">        println!("You guessed: {guess}");
</span><span class="boring">
</span>        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}</code></pre>
<p>Dodanie linii <code>break</code> po <code>You win!</code> powoduje, Å¼e program wychodzi z pÄ™tli, gdy
uÅ¼ytkownik poprawnie odgadnie tajnÄ… liczbÄ™. WyjÅ›cie z pÄ™tli oznacza rÃ³wnieÅ¼
wyjÅ›cie z programu, poniewaÅ¼ pÄ™tla jest ostatniÄ… czÄ™Å›ciÄ… <code>main</code>.</p>
<h3 id="obsÅ‚uga-nieprawidÅ‚owych-danych-wejÅ›ciowych"><a class="header" href="#obsÅ‚uga-nieprawidÅ‚owych-danych-wejÅ›ciowych">ObsÅ‚uga nieprawidÅ‚owych danych wejÅ›ciowych</a></h3>
<p>Aby jeszcze bardziej dopracowaÄ‡ zachowanie gry, zamiast zawieszaÄ‡ program,
gdy uÅ¼ytkownik wprowadzi dane nieliczbowe, niech gra ignoruje takie dane,
umoÅ¼liwiajÄ…c uÅ¼ytkownikowi dalsze zgadywanie. MoÅ¼emy to zrobiÄ‡, zmieniajÄ…c
liniÄ™, w ktÃ³rej <code>guess</code> jest konwertowane z <code>String</code> na <code>u32</code>, jak pokazano
w Listingu 2-5.</p>
<figure class="listing" id="listing-2-5">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --snip--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("You guessed: {guess}");

        // --snip--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("You win!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-2-5">Listing 2-5</a>: Ignorowanie zgadywanej liczby nieliczbowej i proÅ›ba o kolejnÄ… zgadywanÄ… liczbÄ™ zamiast zawieszenia programu</figcaption>
</figure>
<p>Zmieniamy wywoÅ‚anie <code>expect</code> na wyraÅ¼enie <code>match</code>, aby zamiast zawieszenia
w przypadku bÅ‚Ä™du, obsÅ‚uÅ¼yÄ‡ bÅ‚Ä…d. PamiÄ™taj, Å¼e <code>parse</code> zwraca typ <code>Result</code>,
a <code>Result</code> jest wyliczeniem, ktÃ³re ma warianty <code>Ok</code> i <code>Err</code>. UÅ¼ywamy tutaj
wyraÅ¼enia <code>match</code>, tak jak to robiliÅ›my z wynikiem <code>Ordering</code> metody <code>cmp</code>.</p>
<p>JeÅ›li <code>parse</code> jest w stanie pomyÅ›lnie przeksztaÅ‚ciÄ‡ ciÄ…g znakÃ³w w liczbÄ™,
zwrÃ³ci wartoÅ›Ä‡ <code>Ok</code>, ktÃ³ra bÄ™dzie zawieraÄ‡ wynikowÄ… liczbÄ™. Ta wartoÅ›Ä‡ <code>Ok</code>
bÄ™dzie pasowaÄ‡ do wzorca pierwszego ramienia, a wyraÅ¼enie <code>match</code> po prostu
zwrÃ³ci wartoÅ›Ä‡ <code>num</code>, ktÃ³rÄ… <code>parse</code> wyprodukowaÅ‚o i umieÅ›ciÅ‚o w wartoÅ›ci <code>Ok</code>.
Ta liczba trafi dokÅ‚adnie tam, gdzie chcemy, do nowej zmiennej <code>guess</code>, ktÃ³rÄ…
tworzymy.</p>
<p>JeÅ›li <code>parse</code> <em>nie</em> jest w stanie przeksztaÅ‚ciÄ‡ ciÄ…gu znakÃ³w w liczbÄ™,
zwrÃ³ci wartoÅ›Ä‡ <code>Err</code>, ktÃ³ra zawiera wiÄ™cej informacji o bÅ‚Ä™dzie. WartoÅ›Ä‡ <code>Err</code>
nie pasuje do wzorca <code>Ok(num)</code> w pierwszym ramieniu <code>match</code>, ale pasuje do
wzorca <code>Err(_)</code> w drugim ramieniu. PodkreÅ›lnik <code>_</code> to wartoÅ›Ä‡
â€chwyÄ‡-wszystkoâ€; w tym przykÅ‚adzie mÃ³wimy, Å¼e chcemy dopasowaÄ‡ wszystkie
wartoÅ›ci <code>Err</code>, niezaleÅ¼nie od tego, jakie informacje zawierajÄ…. Zatem program
wykona kod drugiego ramienia, <code>continue</code>, co nakazuje programowi przejÅ›Ä‡ do
nastÄ™pnej iteracji <code>loop</code> i poprosiÄ‡ o kolejny strzaÅ‚. Tak wiÄ™c, efektywnie,
program ignoruje wszystkie bÅ‚Ä™dy, jakie <code>parse</code> moÅ¼e napotkaÄ‡!</p>
<p>Teraz wszystko w programie powinno dziaÅ‚aÄ‡ zgodnie z oczekiwaniami. SprÃ³bujmy:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>Cudownie! Z drobnÄ…, ostatniÄ… poprawkÄ…, zakoÅ„czymy grÄ™ w zgadywanie. Przypomnij
sobie, Å¼e program nadal wyÅ›wietla tajnÄ… liczbÄ™. To dobrze dziaÅ‚aÅ‚o podczas
testowania, ale psuje grÄ™. UsuÅ„my <code>println!</code>, ktÃ³re wyÅ›wietla tajnÄ… liczbÄ™.
Listing 2-6 pokazuje ostateczny kod.</p>
<figure class="listing" id="listing-2-6">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore">use std::cmp::Ordering;
use std::io;

use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("You guessed: {guess}");

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}</code></pre>
<figcaption><a href="#listing-2-6">Listing 2-6</a>: Kompletny kod gry w zgadywanie</figcaption>
</figure>
<p>W tym momencie pomyÅ›lnie zbudowaÅ‚eÅ› grÄ™ w zgadywanie. Gratulacje!</p>
<h2 id="podsumowanie-1"><a class="header" href="#podsumowanie-1">Podsumowanie</a></h2>
<p>Ten projekt byÅ‚ praktycznym sposobem na wprowadzenie ciÄ™ w wiele nowych
koncepcji Rusta: <code>let</code>, <code>match</code>, funkcje, uÅ¼ycie zewnÄ™trznych pakietÃ³w i
wiele innych. W kolejnych rozdziaÅ‚ach dowiesz siÄ™ o tych koncepcjach bardziej
szczegÃ³Å‚owo. RozdziaÅ‚ 3 obejmuje koncepcje, ktÃ³re posiadajÄ… wiÄ™kszoÅ›Ä‡ jÄ™zykÃ³w
programowania, takie jak zmienne, typy danych i funkcje, i pokazuje, jak ich
uÅ¼ywaÄ‡ w RuÅ›cie. RozdziaÅ‚ 4 bada wÅ‚asnoÅ›Ä‡, cechÄ™, ktÃ³ra odrÃ³Å¼nia Rusta od
innych jÄ™zykÃ³w. RozdziaÅ‚ 5 omawia struktury i skÅ‚adniÄ™ metod, a RozdziaÅ‚ 6
wyjaÅ›nia, jak dziaÅ‚ajÄ… wyliczenia (enums).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="podstawowe-koncepcje-programowania"><a class="header" href="#podstawowe-koncepcje-programowania">Podstawowe koncepcje programowania</a></h1>
<p>Ten rozdziaÅ‚ obejmuje koncepcje, ktÃ³re pojawiajÄ… siÄ™ w prawie kaÅ¼dym jÄ™zyku
programowania i sposÃ³b, w jaki dziaÅ‚ajÄ… w RuÅ›cie. Wiele jÄ™zykÃ³w
programowania ma ze sobÄ… wiele wspÃ³lnego w swoim rdzeniu. Å»adna z koncepcji
przedstawionych w tym rozdziale nie jest unikalna dla Rusta, ale omÃ³wimy je w
kontekÅ›cie Rusta i wyjaÅ›nimy konwencje dotyczÄ…ce ich uÅ¼ywania.</p>
<p>Konkretnie, dowiesz siÄ™ o zmiennych, podstawowych typach, funkcjach,
komentarzach i przepÅ‚ywie sterowania. Te podstawy znajdÄ… siÄ™ w kaÅ¼dym
programie Rusta, a wczesne ich poznanie da Ci solidny rdzeÅ„, od ktÃ³rego moÅ¼esz
zaczÄ…Ä‡.</p>
<blockquote>
<h4 id="sÅ‚owa-kluczowe"><a class="header" href="#sÅ‚owa-kluczowe">SÅ‚owa kluczowe</a></h4>
<p>JÄ™zyk Rust ma zestaw <em>sÅ‚Ã³w kluczowych</em>, ktÃ³re sÄ… zarezerwowane wyÅ‚Ä…cznie dla
jÄ™zyka, podobnie jak w innych jÄ™zykach. PamiÄ™taj, Å¼e nie moÅ¼esz uÅ¼ywaÄ‡ tych
sÅ‚Ã³w jako nazw zmiennych ani funkcji. WiÄ™kszoÅ›Ä‡ sÅ‚Ã³w kluczowych ma
specjalne znaczenia, a bÄ™dziesz ich uÅ¼ywaÄ‡ do wykonywania rÃ³Å¼nych zadaÅ„ w
swoich programach w RuÅ›cie; kilka nie ma obecnie Å¼adnej zwiÄ…zanej z nimi
funkcjonalnoÅ›ci, ale zostaÅ‚y zarezerwowane dla funkcjonalnoÅ›ci, ktÃ³ra moÅ¼e
zostaÄ‡ dodana do Rusta w przyszÅ‚oÅ›ci. ListÄ™ sÅ‚Ã³w kluczowych znajdziesz w
<a href="#a---sÅ‚owa-kluczowe">Dodatku A</a><!-- ignore -->.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="zmienne-i-mutowalnoÅ›Ä‡-1"><a href="#zmienne-i-mutowalnoÅ›Ä‡-1" class="header">Zmienne i mutowalnoÅ›Ä‡</a></h1>
<h2 id="zmienne-i-mutowalnoÅ›Ä‡"><a class="header" href="#zmienne-i-mutowalnoÅ›Ä‡">Zmienne i mutowalnoÅ›Ä‡</a></h2>
<p>Jak wspomniano w <a href="#storing-values-with-variables">sekcji â€Przechowywanie wartoÅ›ci w
zmiennychâ€</a><!-- ignore -->, zmienne sÄ… domyÅ›lnie
niezmienne. Jest to jedna z wielu wskazÃ³wek, ktÃ³re Rust daje Ci, abyÅ› pisaÅ‚
swÃ³j kod w sposÃ³b, ktÃ³ry wykorzystuje bezpieczeÅ„stwo i Å‚atwÄ… wspÃ³Å‚bieÅ¼noÅ›Ä‡,
jakie oferuje Rust. Jednak nadal masz moÅ¼liwoÅ›Ä‡ uczynienia swoich zmiennych
mutowalnymi. Przyjrzyjmy siÄ™, jak i dlaczego Rust zachÄ™ca do preferowania
niezmiennoÅ›ci i dlaczego czasami moÅ¼esz chcieÄ‡ zrezygnowaÄ‡ z tej opcji.</p>
<p>Kiedy zmienna jest niezmienna, po powiÄ…zaniu wartoÅ›ci z nazwÄ… nie moÅ¼na
zmieniÄ‡ tej wartoÅ›ci. Aby to zilustrowaÄ‡, wygeneruj nowy projekt o nazwie
<em>variables</em> w swoim katalogu <em>projects</em> za pomocÄ… <code>cargo new variables</code>.</p>
<p>NastÄ™pnie, w nowym katalogu <em>variables</em>, otwÃ³rz <em>src/main.rs</em> i zastÄ…p jego
kod nastÄ™pujÄ…cym kodem, ktÃ³ry jeszcze siÄ™ nie skompiluje:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!("WartoÅ›Ä‡ x to: {x}");
    x = 6;
    println!("WartoÅ›Ä‡ x to: {x}");
}</code></pre>
<p>Zapisz i uruchom program za pomocÄ… <code>cargo run</code>. PowinieneÅ› otrzymaÄ‡ komunikat
o bÅ‚Ä™dzie dotyczÄ…cy bÅ‚Ä™du niezmiennoÅ›ci, jak pokazano w tym wyjÅ›ciu:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("The value of x is: {x}");
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
  |
help: consider making this binding mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` (bin "variables") due to 1 previous error
</code></pre>
<p>Ten przykÅ‚ad pokazuje, jak kompilator pomaga znaleÅºÄ‡ bÅ‚Ä™dy w Twoich
programach. BÅ‚Ä™dy kompilatora mogÄ… byÄ‡ frustrujÄ…ce, ale tak naprawdÄ™
oznaczajÄ… tylko, Å¼e TwÃ³j program nie dziaÅ‚a jeszcze bezpiecznie tak, jak
chcesz; nie oznaczajÄ…, Å¼e nie jesteÅ› dobrym programistÄ…! DoÅ›wiadczeni
Rustaceanie nadal otrzymujÄ… bÅ‚Ä™dy kompilatora.</p>
<p>OtrzymaÅ‚eÅ› komunikat o bÅ‚Ä™dzie <code>cannot assign twice to immutable variable `x`</code>
(nie moÅ¼na przypisaÄ‡ dwa razy do niezmiennej zmiennej <code>x</code>), poniewaÅ¼ prÃ³bowaÅ‚eÅ›
przypisaÄ‡ drugÄ… wartoÅ›Ä‡ do niezmiennej zmiennej <code>x</code>.</p>
<p>WaÅ¼ne jest, abyÅ›my otrzymywali bÅ‚Ä™dy kompilacji, gdy prÃ³bujemy zmieniÄ‡ wartoÅ›Ä‡,
ktÃ³ra zostaÅ‚a oznaczona jako niezmienna, poniewaÅ¼ ta wÅ‚aÅ›nie sytuacja moÅ¼e
prowadziÄ‡ do bÅ‚Ä™dÃ³w. JeÅ›li jedna czÄ™Å›Ä‡ naszego kodu dziaÅ‚a w oparciu o
zaÅ‚oÅ¼enie, Å¼e wartoÅ›Ä‡ nigdy siÄ™ nie zmieni, a inna czÄ™Å›Ä‡ naszego kodu zmienia
tÄ™ wartoÅ›Ä‡, moÅ¼liwe jest, Å¼e pierwsza czÄ™Å›Ä‡ kodu nie wykona tego, do czego
zostaÅ‚a zaprojektowana. PrzyczynÄ™ tego rodzaju bÅ‚Ä™du moÅ¼e byÄ‡ trudno
wyÅ›ledziÄ‡ po fakcie, zwÅ‚aszcza gdy druga czÄ™Å›Ä‡ kodu zmienia wartoÅ›Ä‡ tylko
<em>czasami</em>. Kompilator Rusta gwarantuje, Å¼e gdy zadeklarujesz, Å¼e wartoÅ›Ä‡ siÄ™
nie zmieni, to naprawdÄ™ siÄ™ nie zmieni, wiÄ™c nie musisz sam tego Å›ledziÄ‡.
TwÃ³j kod jest dziÄ™ki temu Å‚atwiejszy do przemyÅ›lenia.</p>
<p>Ale mutowalnoÅ›Ä‡ moÅ¼e byÄ‡ bardzo przydatna i moÅ¼e sprawiÄ‡, Å¼e kod bÄ™dzie
wygodniejszy w pisaniu. ChociaÅ¼ zmienne sÄ… domyÅ›lnie niezmienne, moÅ¼esz
uczyniÄ‡ je mutowalnymi, dodajÄ…c <code>mut</code> przed nazwÄ… zmiennej, tak jak to
zrobiÅ‚eÅ› w <a href="#storing-values-with-variables">Rozdziale 2</a><!-- ignore -->.
Dodanie <code>mut</code> rÃ³wnieÅ¼ przekazuje intencjÄ™ przyszÅ‚ym czytelnikom kodu,
wskazujÄ…c, Å¼e inne czÄ™Å›ci kodu bÄ™dÄ… zmieniaÄ‡ wartoÅ›Ä‡ tej zmiennej.</p>
<p>Na przykÅ‚ad, zmieÅ„my <em>src/main.rs</em> na nastÄ™pujÄ…cy kod:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut x = 5;
    println!("WartoÅ›Ä‡ x to: {x}");
    x = 6;
    println!("WartoÅ›Ä‡ x to: {x}");
}</code></pre>
<p>Kiedy uruchomimy program teraz, otrzymamy:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
WartoÅ›Ä‡ x to: 5
WartoÅ›Ä‡ x to: 6
</code></pre>
<p>MoÅ¼emy zmieniÄ‡ wartoÅ›Ä‡ przypisanÄ… do <code>x</code> z <code>5</code> na <code>6</code>, gdy uÅ¼yto <code>mut</code>.
Ostatecznie, decyzja o uÅ¼yciu mutowalnoÅ›ci zaleÅ¼y od Ciebie i od tego, co
uwaÅ¼asz za najbardziej przejrzyste w danej sytuacji.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="constants"></a></p>
<h3 id="deklarowanie-staÅ‚ych"><a class="header" href="#deklarowanie-staÅ‚ych">Deklarowanie staÅ‚ych</a></h3>
<p>Podobnie jak niezmienne zmienne, <em>staÅ‚e</em> to wartoÅ›ci, ktÃ³re sÄ… powiÄ…zane z
nazwÄ… i nie mogÄ… byÄ‡ zmieniane, ale istniejÄ… pewne rÃ³Å¼nice miÄ™dzy staÅ‚ymi a
zmiennymi.</p>
<p>Po pierwsze, nie wolno uÅ¼ywaÄ‡ <code>mut</code> ze staÅ‚ymi. StaÅ‚e sÄ… nie tylko domyÅ›lnie
niezmienne â€” sÄ… zawsze niezmienne. StaÅ‚e deklaruje siÄ™ za pomocÄ… sÅ‚owa
kluczowego <code>const</code> zamiast sÅ‚owa kluczowego <code>let</code>, a typ wartoÅ›ci <em>musi</em> byÄ‡
annotowany. Typy i adnotacje typÃ³w omÃ³wimy w nastÄ™pnej sekcji, <a href="#data-types">â€Typy
danychâ€</a><!-- ignore -->, wiÄ™c na razie nie martw siÄ™ szczegÃ³Å‚ami.
Wystarczy wiedzieÄ‡, Å¼e zawsze musisz podawaÄ‡ typ.</p>
<p>StaÅ‚e mogÄ… byÄ‡ deklarowane w dowolnym zasiÄ™gu, w tym w zasiÄ™gu globalnym, co
czyni je uÅ¼ytecznymi dla wartoÅ›ci, o ktÃ³rych wiele czÄ™Å›ci kodu musi wiedzieÄ‡.</p>
<p>Ostatnia rÃ³Å¼nica polega na tym, Å¼e staÅ‚e mogÄ… byÄ‡ ustawiane tylko na wyraÅ¼enie
staÅ‚e, a nie na wynik wartoÅ›ci, ktÃ³ra mogÅ‚aby byÄ‡ obliczona tylko w czasie
uruchamiania.</p>
<p>Oto przykÅ‚ad deklaracji staÅ‚ej:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
<span class="boring">}</span></code></pre>
<p>Nazwa staÅ‚ej to <code>THREE_HOURS_IN_SECONDS</code>, a jej wartoÅ›Ä‡ jest ustawiona na
wynik pomnoÅ¼enia 60 (liczby sekund w minucie) przez 60 (liczby minut w
godzinie) przez 3 (liczby godzin, ktÃ³re chcemy policzyÄ‡ w tym programie).
KonwencjÄ… nazewniczÄ… Rusta dla staÅ‚ych jest uÅ¼ywanie samych duÅ¼ych liter z
podkreÅ›leniami miÄ™dzy sÅ‚owami. Kompilator jest w stanie oceniÄ‡ ograniczony
zestaw operacji w czasie kompilacji, co pozwala nam zapisaÄ‡ tÄ™ wartoÅ›Ä‡ w sposÃ³b
Å‚atwiejszy do zrozumienia i weryfikacji, zamiast ustawiaÄ‡ tÄ™ staÅ‚Ä… na wartoÅ›Ä‡
10 800. WiÄ™cej informacji na temat operacji, ktÃ³re moÅ¼na stosowaÄ‡ przy
deklarowaniu staÅ‚ych, znajdziesz w <a href="../reference/const_eval.html">sekcji Rust Reference dotyczÄ…cej
ewaluacji staÅ‚ych</a>.</p>
<p>StaÅ‚e sÄ… waÅ¼ne przez caÅ‚y czas dziaÅ‚ania programu, w zasiÄ™gu, w ktÃ³rym zostaÅ‚y
zadeklarowane. Ta wÅ‚aÅ›ciwoÅ›Ä‡ sprawia, Å¼e staÅ‚e sÄ… przydatne dla wartoÅ›ci w
domenie aplikacji, o ktÃ³rych wiele czÄ™Å›ci programu moÅ¼e potrzebowaÄ‡ wiedzieÄ‡,
takich jak maksymalna liczba punktÃ³w, jakÄ… kaÅ¼dy gracz moÅ¼e zdobyÄ‡, lub
prÄ™dkoÅ›Ä‡ Å›wiatÅ‚a.</p>
<p>Nazywanie zakodowanych wartoÅ›ci uÅ¼ywanych w caÅ‚ym programie jako staÅ‚ych jest
przydatne w przekazywaniu znaczenia tej wartoÅ›ci przyszÅ‚ym utrzymujÄ…cym kod.
Pomaga rÃ³wnieÅ¼ mieÄ‡ tylko jedno miejsce w kodzie, ktÃ³re trzeba by zmieniÄ‡,
gdyby zakodowana wartoÅ›Ä‡ wymagaÅ‚a aktualizacji w przyszÅ‚oÅ›ci.</p>
<h3 id="przesÅ‚anianie"><a class="header" href="#przesÅ‚anianie">PrzesÅ‚anianie</a></h3>
<p>Jak widziaÅ‚eÅ› w samouczku gry w zgadywanie w <a href="#comparing-the-guess-to-the-secret-number">Rozdziale
2</a><!-- ignore -->, moÅ¼esz
zadeklarowaÄ‡ nowÄ… zmiennÄ… o tej samej nazwie co poprzednia zmienna. Rustaceanie
mÃ³wiÄ…, Å¼e pierwsza zmienna jest <em>przesÅ‚oniÄ™ta</em> przez drugÄ…, co oznacza, Å¼e druga
zmienna jest tym, co kompilator bÄ™dzie widziaÅ‚, gdy uÅ¼yjesz nazwy zmiennej.
W efekcie druga zmienna przysÅ‚ania pierwszÄ…, przejmujÄ…c wszelkie uÅ¼ycia nazwy
zmiennej na siebie, dopÃ³ki sama nie zostanie przesÅ‚oniÄ™ta lub zasiÄ™g siÄ™ nie
zakoÅ„czy. MoÅ¼emy przesÅ‚oniÄ‡ zmiennÄ…, uÅ¼ywajÄ…c tej samej nazwy zmiennej i
powtarzajÄ…c uÅ¼ycie sÅ‚owa kluczowego <code>let</code> w nastÄ™pujÄ…cy sposÃ³b:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("WartoÅ›Ä‡ x w wewnÄ™trznym zasiÄ™gu to: {x}");
    }

    println!("WartoÅ›Ä‡ x to: {x}");
}</code></pre>
<p>Ten program najpierw wiÄ…Å¼e <code>x</code> z wartoÅ›ciÄ… <code>5</code>. NastÄ™pnie tworzy nowÄ… zmiennÄ…
<code>x</code>, powtarzajÄ…c <code>let x =</code>, biorÄ…c oryginalnÄ… wartoÅ›Ä‡ i dodajÄ…c <code>1</code> tak, aby
wartoÅ›Ä‡ <code>x</code> wynosiÅ‚a <code>6</code>. NastÄ™pnie, wewnÄ…trz wewnÄ™trznego zasiÄ™gu
utworzonego za pomocÄ… nawiasÃ³w klamrowych, trzecia instrukcja <code>let</code> rÃ³wnieÅ¼
przesÅ‚ania <code>x</code> i tworzy nowÄ… zmiennÄ…, mnoÅ¼Ä…c poprzedniÄ… wartoÅ›Ä‡ przez <code>2</code>, aby
nadaÄ‡ <code>x</code> wartoÅ›Ä‡ <code>12</code>. Gdy ten zasiÄ™g siÄ™ koÅ„czy, wewnÄ™trzne przesÅ‚anianie
zakoÅ„czy siÄ™, a <code>x</code> powrÃ³ci do <code>6</code>. Kiedy uruchomimy ten program, wyÅ›wietli
siÄ™ nastÄ™pujÄ…cy wynik:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
WartoÅ›Ä‡ x w wewnÄ™trznym zasiÄ™gu to: 12
WartoÅ›Ä‡ x to: 6
</code></pre>
<p>PrzesÅ‚anianie rÃ³Å¼ni siÄ™ od oznaczania zmiennej jako <code>mut</code>, poniewaÅ¼
otrzymamy bÅ‚Ä…d kompilacji, jeÅ›li przypadkowo sprÃ³bujemy przypisaÄ‡ nowÄ… wartoÅ›Ä‡
do tej zmiennej bez uÅ¼ycia sÅ‚owa kluczowego <code>let</code>. UÅ¼ywajÄ…c <code>let</code>,
moÅ¼emy wykonaÄ‡ kilka transformacji na wartoÅ›ci, ale po tych transformacjach
zmienna pozostanie niezmienna.</p>
<p>Inna rÃ³Å¼nica miÄ™dzy <code>mut</code> a przesÅ‚anianiem polega na tym, Å¼e poniewaÅ¼
efektywnie tworzymy nowÄ… zmiennÄ…, gdy ponownie uÅ¼ywamy sÅ‚owa kluczowego <code>let</code>,
moÅ¼emy zmieniÄ‡ typ wartoÅ›ci, ale ponownie uÅ¼yÄ‡ tej samej nazwy. Na przykÅ‚ad,
powiedzmy, Å¼e nasz program prosi uÅ¼ytkownika o podanie liczby spacji,
jakie chce miÄ™dzy tekstem, wprowadzajÄ…c spacje, a nastÄ™pnie chcemy
przechowywaÄ‡ te dane wejÅ›ciowe jako liczbÄ™:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let spaces = "   ";
    let spaces = spaces.len();
<span class="boring">}</span></code></pre>
<p>Pierwsza zmienna <code>spaces</code> jest typu string, a druga zmienna <code>spaces</code> jest
typu liczbowego. PrzesÅ‚anianie pozwala nam uniknÄ…Ä‡ wymyÅ›lania rÃ³Å¼nych nazw,
takich jak <code>spaces_str</code> i <code>spaces_num</code>; zamiast tego moÅ¼emy ponownie uÅ¼yÄ‡
prostszej nazwy <code>spaces</code>. JednakÅ¼e, jeÅ›li sprÃ³bujemy uÅ¼yÄ‡ <code>mut</code> w tym
przypadku, jak pokazano tutaj, otrzymamy bÅ‚Ä…d kompilacji:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut spaces = "   ";
    spaces = spaces.len();
<span class="boring">}</span></code></pre>
<p>BÅ‚Ä…d mÃ³wi, Å¼e nie wolno nam mutowaÄ‡ typu zmiennej:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
2 |     let mut spaces = "   ";
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` (bin "variables") due to 1 previous error
</code></pre>
<p>Teraz, gdy zbadaliÅ›my, jak dziaÅ‚ajÄ… zmienne, przyjrzyjmy siÄ™ innym typom
danych, ktÃ³re mogÄ… mieÄ‡.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="typy-danych-1"><a href="#typy-danych-1" class="header">Typy danych</a></h1>
<h2 id="typy-danych"><a class="header" href="#typy-danych">Typy danych</a></h2>
<p>KaÅ¼da wartoÅ›Ä‡ w RuÅ›cie ma okreÅ›lony <em>typ danych</em>, ktÃ³ry informuje Rusta, jaki
rodzaj danych jest okreÅ›lany, aby wiedziaÅ‚, jak z nimi pracowaÄ‡. Przyjrzymy siÄ™
dwÃ³m podzbiorom typÃ³w danych: skalarnym i zÅ‚oÅ¼onym.</p>
<p>PamiÄ™taj, Å¼e Rust jest jÄ™zykiem <em>statycznie typowanym</em>, co oznacza, Å¼e musi
znaÄ‡ typy wszystkich zmiennych w czasie kompilacji. Kompilator zazwyczaj moÅ¼e
wywnioskowaÄ‡, jakiego typu chcemy uÅ¼yÄ‡, na podstawie wartoÅ›ci i sposobu jej
uÅ¼ycia. W przypadkach, gdy moÅ¼liwych jest wiele typÃ³w, np. gdy konwertowaliÅ›my
<code>String</code> na typ numeryczny za pomocÄ… <code>parse</code> w sekcji <a href="#comparing-the-guess-to-the-secret-number">â€PorÃ³wnywanie strzaÅ‚u z
tajnÄ… liczbÄ…â€</a><!-- ignore -->
w Rozdziale 2, musimy dodaÄ‡ adnotacjÄ™ typu, takÄ… jak ta:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = "42".parse().expect("Not a number!");
<span class="boring">}</span></code></pre>
<p>JeÅ›li nie dodamy adnotacji typu <code>: u32</code> pokazanej w poprzednim kodzie, Rust
wyÅ›wietli nastÄ™pujÄ…cy bÅ‚Ä…d, co oznacza, Å¼e kompilator potrzebuje od nas wiÄ™cej
informacji, aby wiedzieÄ‡, jakiego typu chcemy uÅ¼yÄ‡:</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0284]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^        ----- type must be known at this point
  |
  = note: cannot satisfy `&lt;_ as FromStr&gt;::Err == _`
help: consider giving `guess` an explicit type
  |
2 |     let guess: /* Type */ = "42".parse().expect("Not a number!");
  |              ++++++++++++

For more information about this error, try `rustc --explain E0284`.
error: could not compile `no_type_annotations` (bin "no_type_annotations") due to 1 previous error
</code></pre>
<p>Zobaczysz rÃ³Å¼ne adnotacje typÃ³w dla innych typÃ³w danych.</p>
<h3 id="typy-skalarne"><a class="header" href="#typy-skalarne">Typy skalarne</a></h3>
<p>Typ <em>skalarny</em> reprezentuje pojedynczÄ… wartoÅ›Ä‡. Rust ma cztery gÅ‚Ã³wne typy
skalarne: liczby caÅ‚kowite, liczby zmiennoprzecinkowe, wartoÅ›ci boolowskie i
znaki. MoÅ¼esz je rozpoznaÄ‡ z innych jÄ™zykÃ³w programowania. PrzejdÅºmy do tego,
jak dziaÅ‚ajÄ… w Rust.</p>
<h4 id="typy-caÅ‚kowite"><a class="header" href="#typy-caÅ‚kowite">Typy caÅ‚kowite</a></h4>
<p><em>Liczba caÅ‚kowita</em> to liczba bez czÄ™Å›ci uÅ‚amkowej. UÅ¼yliÅ›my jednego typu
caÅ‚kowitego w Rozdziale 2, typu <code>u32</code>. Ta deklaracja typu wskazuje, Å¼e wartoÅ›Ä‡,
z ktÃ³rÄ… jest skojarzona, powinna byÄ‡ niepodpisanÄ… liczbÄ… caÅ‚kowitÄ… (typy
caÅ‚kowite ze znakiem zaczynajÄ… siÄ™ od <code>i</code> zamiast <code>u</code>), ktÃ³ra zajmuje 32 bity
pamiÄ™ci. Tabela 3-1 pokazuje wbudowane typy caÅ‚kowite w Rust. MoÅ¼emy uÅ¼yÄ‡
dowolnego z tych wariantÃ³w do zadeklarowania typu wartoÅ›ci caÅ‚kowitej.</p>
<p><span class="caption">Tabela 3-1: Typy caÅ‚kowite w Rust</span></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>DÅ‚ugoÅ›Ä‡</th><th>Ze znakiem</th><th>Bez znaku</th></tr>
</thead>
<tbody>
<tr><td>8-bitÃ³w</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-bitÃ³w</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-bitÃ³w</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-bitÃ³w</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-bitÃ³w</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>ZaleÅ¼ne od architektury</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody>
</table>
</div>
<p>KaÅ¼dy wariant moÅ¼e byÄ‡ ze znakiem lub bez znaku i ma wyraÅºny rozmiar.
<em>Ze znakiem</em> i <em>bez znaku</em> odnoszÄ… siÄ™ do tego, czy liczba moÅ¼e byÄ‡ ujemna â€“
inaczej mÃ³wiÄ…c, czy liczba musi mieÄ‡ znak (ze znakiem), czy zawsze bÄ™dzie
dodatnia i dlatego moÅ¼e byÄ‡ reprezentowana bez znaku (bez znaku). To jak
pisanie liczb na papierze: gdy znak ma znaczenie, liczba jest pokazywana ze
znakiem plus lub minus; jednak, gdy moÅ¼na bezpiecznie zaÅ‚oÅ¼yÄ‡, Å¼e liczba jest
dodatnia, jest pokazywana bez znaku. Liczby ze znakiem sÄ… przechowywane za
pomocÄ… reprezentacji <a href="https://en.wikipedia.org/wiki/Two%27s_complement">dopeÅ‚nienia do dwÃ³ch</a><!-- ignore -->.</p>
<p>KaÅ¼dy wariant ze znakiem moÅ¼e przechowywaÄ‡ liczby od âˆ’(2<sup>n âˆ’ 1</sup>) do
2<sup>n âˆ’ 1</sup> âˆ’ 1 wÅ‚Ä…cznie, gdzie <em>n</em> to liczba bitÃ³w, ktÃ³re uÅ¼ywa ten wariant.
Tak wiÄ™c <code>i8</code> moÅ¼e przechowywaÄ‡ liczby od âˆ’(2<sup>7</sup>) do 2<sup>7</sup> âˆ’ 1,
co rÃ³wna siÄ™ âˆ’128 do 127. Warianty bez znaku mogÄ… przechowywaÄ‡ liczby od 0 do
2<sup>n</sup> âˆ’ 1, wiÄ™c <code>u8</code> moÅ¼e przechowywaÄ‡ liczby od 0 do 2<sup>8</sup> âˆ’ 1,
co rÃ³wna siÄ™ 0 do 255.</p>
<p>Dodatkowo, typy <code>isize</code> i <code>usize</code> zaleÅ¼Ä… od architektury komputera, na ktÃ³rym
dziaÅ‚a TwÃ³j program: 64 bity, jeÅ›li jesteÅ› na architekturze 64-bitowej, i 32
bity, jeÅ›li jesteÅ› na architekturze 32-bitowej.</p>
<p>LiteraÅ‚y caÅ‚kowite moÅ¼na zapisywaÄ‡ w dowolnej z form pokazanych w tabeli 3-2.
ZauwaÅ¼, Å¼e literaÅ‚y liczbowe, ktÃ³re mogÄ… byÄ‡ wieloma typami numerycznymi,
dopuszczajÄ… sufiks typu, taki jak <code>57u8</code>, do okreÅ›lenia typu. LiteraÅ‚y
liczbowe mogÄ… rÃ³wnieÅ¼ uÅ¼ywaÄ‡ <code>_</code> jako wizualnego separatora, aby uÅ‚atwiÄ‡
odczytanie liczby, np. <code>1_000</code>, ktÃ³ra bÄ™dzie miaÅ‚a takÄ… samÄ… wartoÅ›Ä‡, jakbyÅ›
okreÅ›liÅ‚ <code>1000</code>.</p>
<p><span class="caption">Tabela 3-2: LiteraÅ‚y caÅ‚kowite w Rust</span></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>LiteraÅ‚y liczbowe</th><th>PrzykÅ‚ad</th></tr>
</thead>
<tbody>
<tr><td>DziesiÄ™tne</td><td><code>98_222</code></td></tr>
<tr><td>Szesnastkowe</td><td><code>0xff</code></td></tr>
<tr><td>Ã“semkowe</td><td><code>0o77</code></td></tr>
<tr><td>Binarne</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Bajtowe (tylko <code>u8</code>)</td><td><code>b'A'</code></td></tr>
</tbody>
</table>
</div>
<p>WiÄ™c skÄ…d wiesz, jakiego typu liczby caÅ‚kowitej uÅ¼yÄ‡? JeÅ›li nie jesteÅ› pewien,
domyÅ›lne ustawienia Rusta sÄ… zazwyczaj dobrym punktem wyjÅ›cia: typy caÅ‚kowite
domyÅ›lnie przyjmujÄ… <code>i32</code>. GÅ‚Ã³wna sytuacja, w ktÃ³rej uÅ¼yÅ‚byÅ› <code>isize</code> lub
<code>usize</code>, to indeksowanie jakiegoÅ› rodzaju kolekcji.</p>
<section class="note" aria-role="note">
<h5 id="przepeÅ‚nienie-liczby-caÅ‚kowitej"><a class="header" href="#przepeÅ‚nienie-liczby-caÅ‚kowitej">PrzepeÅ‚nienie liczby caÅ‚kowitej</a></h5>
<p>ZaÅ‚Ã³Å¼my, Å¼e masz zmiennÄ… typu <code>u8</code>, ktÃ³ra moÅ¼e przechowywaÄ‡ wartoÅ›ci od 0 do
255. JeÅ›li sprÃ³bujesz zmieniÄ‡ zmiennÄ… na wartoÅ›Ä‡ spoza tego zakresu, takÄ… jak
256, nastÄ…pi <em>przepeÅ‚nienie liczby caÅ‚kowitej</em>, co moÅ¼e skutkowaÄ‡ jednym z
dwÃ³ch zachowaÅ„. Podczas kompilacji w trybie debugowania Rust zawiera
sprawdzenia przepeÅ‚nienia liczby caÅ‚kowitej, ktÃ³re powodujÄ…, Å¼e program
<em>panikuje</em> w czasie wykonywania, jeÅ›li wystÄ…pi takie zachowanie. Rust uÅ¼ywa
terminu <em>panicking</em>, gdy program koÅ„czy dziaÅ‚anie z bÅ‚Ä™dem; omÃ³wimy paniki
bardziej szczegÃ³Å‚owo w sekcji <a href="#nieodwracalne-bÅ‚Ä™dy-z-panic-1">â€BÅ‚Ä™dy nie do odzyskania za pomocÄ…
<code>panic!</code>â€</a><!-- ignore --> w Rozdziale 9.</p>
<p>Podczas kompilacji w trybie wydania z flagÄ… <code>--release</code>, Rust <em>nie</em> zawiera
sprawdzeÅ„ przepeÅ‚nienia liczby caÅ‚kowitej, ktÃ³re powodujÄ… paniki. Zamiast
tego, jeÅ›li wystÄ…pi przepeÅ‚nienie, Rust wykonuje <em>zawijanie dopeÅ‚nienia do
dwÃ³ch</em>. KrÃ³tko mÃ³wiÄ…c, wartoÅ›ci wiÄ™ksze niÅ¼ maksymalna wartoÅ›Ä‡, jakÄ… moÅ¼e
przechowywaÄ‡ typ, â€zawijajÄ… siÄ™â€ do minimalnej wartoÅ›ci, jakÄ… moÅ¼e przechowywaÄ‡
typ. W przypadku <code>u8</code>, wartoÅ›Ä‡ 256 staje siÄ™ 0, wartoÅ›Ä‡ 257 staje siÄ™ 1 i tak
dalej. Program nie bÄ™dzie panikowaÅ‚, ale zmienna bÄ™dzie miaÅ‚a wartoÅ›Ä‡, ktÃ³ra
prawdopodobnie nie jest tym, czego siÄ™ spodziewaÅ‚eÅ›. Opieranie siÄ™ na zachowaniu
zawijania przepeÅ‚nienia liczby caÅ‚kowitej jest uwaÅ¼ane za bÅ‚Ä…d.</p>
<p>Aby jawnie obsÅ‚uÅ¼yÄ‡ moÅ¼liwoÅ›Ä‡ przepeÅ‚nienia, moÅ¼esz uÅ¼yÄ‡ tych rodzin metod
dostarczanych przez standardowÄ… bibliotekÄ™ dla prymitywnych typÃ³w liczbowych:</p>
<ul>
<li>Zawijaj we wszystkich trybach za pomocÄ… metod <code>wrapping_*</code>, takich jak
<code>wrapping_add</code>.</li>
<li>Zwracaj wartoÅ›Ä‡ <code>None</code>, jeÅ›li wystÄ…pi przepeÅ‚nienie, za pomocÄ… metod
<code>checked_*</code>.</li>
<li>Zwracaj wartoÅ›Ä‡ i wartoÅ›Ä‡ boolowskÄ… wskazujÄ…cÄ…, czy wystÄ…piÅ‚o
przepeÅ‚nienie, za pomocÄ… metod <code>overflowing_*</code>.</li>
<li>Saturuj przy minimalnych lub maksymalnych wartoÅ›ciach typu za pomocÄ… metod
<code>saturating_*</code>.</li>
</ul>
</section>
<h4 id="typy-zmiennoprzecinkowe"><a class="header" href="#typy-zmiennoprzecinkowe">Typy zmiennoprzecinkowe</a></h4>
<p>Rust ma rÃ³wnieÅ¼ dwa prymitywne typy dla <em>liczb zmiennoprzecinkowych</em>, ktÃ³re sÄ…
liczbami z punktami dziesiÄ™tnymi. Typy zmiennoprzecinkowe Rusta to <code>f32</code> i <code>f64</code>,
ktÃ³re majÄ… odpowiednio 32 i 64 bity. DomyÅ›lnym typem jest <code>f64</code>, poniewaÅ¼ na
nowoczesnych procesorach ma on w przybliÅ¼eniu takÄ… samÄ… prÄ™dkoÅ›Ä‡ jak <code>f32</code>,
ale jest w stanie zapewniÄ‡ wiÄ™kszÄ… precyzjÄ™. Wszystkie typy zmiennoprzecinkowe
sÄ… ze znakiem.</p>
<p>Oto przykÅ‚ad, ktÃ³ry pokazuje liczby zmiennoprzecinkowe w akcji:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}</code></pre>
<p>Liczby zmiennoprzecinkowe sÄ… reprezentowane zgodnie ze standardem IEEE-754.</p>
<h4 id="operacje-numeryczne"><a class="header" href="#operacje-numeryczne">Operacje numeryczne</a></h4>
<p>Rust obsÅ‚uguje podstawowe operacje matematyczne, ktÃ³rych moÅ¼na oczekiwaÄ‡ dla
wszystkich typÃ³w liczbowych: dodawanie, odejmowanie, mnoÅ¼enie, dzielenie i
reszta z dzielenia. Dzielenie caÅ‚kowite obcina w kierunku zera do
najbliÅ¼szej liczby caÅ‚kowitej. PoniÅ¼szy kod pokazuje, jak uÅ¼yÄ‡ kaÅ¼dej operacji
numerycznej w instrukcji <code>let</code>:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    // dodawanie
    let sum = 5 + 10;

    // odejmowanie
    let difference = 95.5 - 4.3;

    // mnoÅ¼enie
    let product = 4 * 30;

    // dzielenie
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // Wynosi -1

    // reszta z dzielenia
    let remainder = 43 % 5;
}</code></pre>
<p>KaÅ¼de wyraÅ¼enie w tych instrukcjach uÅ¼ywa operatora matematycznego i ocenia
siÄ™ do pojedynczej wartoÅ›ci, ktÃ³ra nastÄ™pnie jest wiÄ…zana ze zmiennÄ…. <a href="#b---operatory-i-symbole">Dodatek
B</a><!-- ignore --> zawiera listÄ™ wszystkich operatorÃ³w,
dostarczanych przez Rusta.</p>
<h4 id="typ-boolowski"><a class="header" href="#typ-boolowski">Typ boolowski</a></h4>
<p>Podobnie jak w wiÄ™kszoÅ›ci innych jÄ™zykÃ³w programowania, typ boolowski w Rust
ma dwie moÅ¼liwe wartoÅ›ci: <code>true</code> i <code>false</code>. WartoÅ›ci boolowskie majÄ… rozmiar
jednego bajta. Typ boolowski w Rust jest okreÅ›lany za pomocÄ… <code>bool</code>. Na
przykÅ‚ad:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let t = true;

    let f: bool = false; // z jawnÄ… adnotacjÄ… typu
}</code></pre>
<p>GÅ‚Ã³wnym sposobem uÅ¼ywania wartoÅ›ci boolowskich jest poprzez warunki, takie jak
wyraÅ¼enie <code>if</code>. OmÃ³wimy, jak dziaÅ‚ajÄ… wyraÅ¼enia <code>if</code> w Rust w sekcji <a href="#control-flow">â€Sterowanie
przepÅ‚ywemâ€</a><!-- ignore -->.</p>
<h4 id="typ-znakowy"><a class="header" href="#typ-znakowy">Typ znakowy</a></h4>
<p>Typ <code>char</code> w Rust jest najbardziej prymitywnym typem alfabetycznym jÄ™zyka.
Oto kilka przykÅ‚adÃ³w deklarowania wartoÅ›ci <code>char</code>:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let c = 'z';
    let z: char = 'â„¤'; // z jawnÄ… adnotacjÄ… typu
    let heart_eyed_cat = 'ğŸ˜»';
}</code></pre>
<p>ZwrÃ³Ä‡ uwagÄ™, Å¼e literaÅ‚y <code>char</code> okreÅ›lamy pojedynczymi cudzysÅ‚owami, w
przeciwieÅ„stwie do literaÅ‚Ã³w stringowych, ktÃ³re uÅ¼ywajÄ… podwÃ³jnych cudzysÅ‚owÃ³w.
Typ <code>char</code> w Rust ma rozmiar 4 bajtÃ³w i reprezentuje skalarnÄ… wartoÅ›Ä‡ Unicode,
co oznacza, Å¼e moÅ¼e reprezentowaÄ‡ znacznie wiÄ™cej niÅ¼ tylko ASCII. Litery
akcentowane; znaki chiÅ„skie, japoÅ„skie i koreaÅ„skie; emotikony; oraz spacje o
zerowej szerokoÅ›ci sÄ… w RuÅ›cie prawidÅ‚owymi wartoÅ›ciami <code>char</code>. Skalarne
wartoÅ›ci Unicode mieszczÄ… siÄ™ w zakresie od <code>U+0000</code> do <code>U+D7FF</code> oraz od <code>U+E000</code>
do <code>U+10FFFF</code> wÅ‚Ä…cznie. Jednak â€znakâ€ nie jest tak naprawdÄ™ koncepcjÄ… w Unicode,
wiÄ™c Twoja ludzka intuicja co do tego, czym jest â€znakâ€, moÅ¼e nie pasowaÄ‡ do
tego, czym jest <code>char</code> w Rust. OmÃ³wimy ten temat szczegÃ³Å‚owo w sekcji
<a href="#storing-utf-8-encoded-text-with-strings">â€Przechowywanie tekstu kodowanego UTF-8 za pomocÄ… ciÄ…gÃ³w
znakÃ³wâ€</a><!-- ignore --> w Rozdziale 8.</p>
<h3 id="typy-zÅ‚oÅ¼one"><a class="header" href="#typy-zÅ‚oÅ¼one">Typy zÅ‚oÅ¼one</a></h3>
<p><em>Typy zÅ‚oÅ¼one</em> mogÄ… grupowaÄ‡ wiele wartoÅ›ci w jeden typ. Rust ma dwa
prymitywne typy zÅ‚oÅ¼one: krotki i tablice.</p>
<h4 id="typ-krotki"><a class="header" href="#typ-krotki">Typ krotki</a></h4>
<p><em>Krotka</em> to ogÃ³lny sposÃ³b grupowania wielu wartoÅ›ci o rÃ³Å¼nych typach w jeden
typ zÅ‚oÅ¼ony. Krotki majÄ… staÅ‚Ä… dÅ‚ugoÅ›Ä‡: po zadeklarowaniu nie mogÄ… rosnÄ…Ä‡ ani
kurczyÄ‡ siÄ™.</p>
<p>Tworzymy krotkÄ™, piszÄ…c listÄ™ wartoÅ›ci oddzielonych przecinkami w nawiasach.
KaÅ¼da pozycja w krotce ma typ, a typy rÃ³Å¼nych wartoÅ›ci w krotce nie muszÄ… byÄ‡
takie same. W tym przykÅ‚adzie dodaliÅ›my opcjonalne adnotacje typÃ³w:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}</code></pre>
<p>Zmienna <code>tup</code> wiÄ…Å¼e siÄ™ z caÅ‚Ä… krotkÄ…, poniewaÅ¼ krotka jest traktowana jako
pojedynczy element zÅ‚oÅ¼ony. Aby uzyskaÄ‡ poszczegÃ³lne wartoÅ›ci z krotki, moÅ¼emy
uÅ¼yÄ‡ dopasowania wzorcÃ³w do dekonstrukcji wartoÅ›ci krotki, w ten sposÃ³b:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {y}");
}</code></pre>
<p>Ten program najpierw tworzy krotkÄ™ i wiÄ…Å¼e jÄ… ze zmiennÄ… <code>tup</code>. NastÄ™pnie uÅ¼ywa
wzorca z <code>let</code>, aby wziÄ…Ä‡ <code>tup</code> i zamieniÄ‡ jÄ… w trzy oddzielne zmienne: <code>x</code>, <code>y</code>
i <code>z</code>. Nazywa siÄ™ to <em>dekonstrukcjÄ…</em>, poniewaÅ¼ rozbija pojedynczÄ… krotkÄ™ na
trzy czÄ™Å›ci. Na koniec program wypisuje wartoÅ›Ä‡ <code>y</code>, ktÃ³ra wynosi <code>6.4</code>.</p>
<p>MoÅ¼emy rÃ³wnieÅ¼ uzyskaÄ‡ dostÄ™p do elementu krotki bezpoÅ›rednio, uÅ¼ywajÄ…c kropki
(<code>.</code>) nastÄ™pujÄ…cej po indeksie wartoÅ›ci, do ktÃ³rej chcemy uzyskaÄ‡ dostÄ™p. Na
przykÅ‚ad:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}</code></pre>
<p>Ten program tworzy krotkÄ™ <code>x</code>, a nastÄ™pnie uzyskuje dostÄ™p do kaÅ¼dego elementu
krotki za pomocÄ… ich odpowiednich indeksÃ³w. Podobnie jak w wiÄ™kszoÅ›ci jÄ™zykÃ³w
programowania, pierwszy indeks w krotce to 0.</p>
<p>Krotka bez Å¼adnych wartoÅ›ci ma specjalnÄ… nazwÄ™, <em>jednostka</em>. Ta wartoÅ›Ä‡ i jej
odpowiedni typ sÄ… zapisywane jako <code>()</code> i reprezentujÄ… pustÄ… wartoÅ›Ä‡ lub pusty
typ zwracany. WyraÅ¼enia niejawnie zwracajÄ… wartoÅ›Ä‡ jednostkowÄ…, jeÅ›li nie
zwracajÄ… Å¼adnej innej wartoÅ›ci.</p>
<h4 id="typ-tablicowy"><a class="header" href="#typ-tablicowy">Typ tablicowy</a></h4>
<p>Innym sposobem posiadania kolekcji wielu wartoÅ›ci jest <em>tablica</em>. W przeciwieÅ„stwie
do krotki, kaÅ¼dy element tablicy musi mieÄ‡ ten sam typ. W przeciwieÅ„stwie do
tablic w niektÃ³rych innych jÄ™zykach, tablice w Rust majÄ… staÅ‚Ä… dÅ‚ugoÅ›Ä‡.</p>
<p>WartoÅ›ci w tablicy zapisujemy jako listÄ™ oddzielonÄ… przecinkami w nawiasach
kwadratowych:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let a = [1, 2, 3, 4, 5];
}</code></pre>
<p>Tablice sÄ… przydatne, gdy chcesz, aby dane byÅ‚y alokowane na stosie, tak jak
inne typy, ktÃ³re widzieliÅ›my do tej pory, a nie na stercie (omÃ³wimy stos i
sterÄ™ dokÅ‚adniej w <a href="#the-stack-and-the-heap">Rozdziale 4</a><!-- ignore -->) lub gdy
chcesz zapewniÄ‡, Å¼e zawsze bÄ™dziesz mieÄ‡ staÅ‚Ä… liczbÄ™ elementÃ³w. Tablica nie
jest jednak tak elastyczna jak typ wektora. Wektor to podobny typ kolekcji
dostarczany przez standardowÄ… bibliotekÄ™, ktÃ³ry <em>moÅ¼e</em> rosnÄ…Ä‡ lub kurczyÄ‡ siÄ™
w rozmiarze, poniewaÅ¼ jego zawartoÅ›Ä‡ znajduje siÄ™ na stercie. JeÅ›li nie masz
pewnoÅ›ci, czy uÅ¼yÄ‡ tablicy, czy wektora, prawdopodobnie powinieneÅ› uÅ¼yÄ‡ wektora.
<a href="#przechowywanie-list-wartoÅ›ci-za-pomocÄ…-wektorÃ³w-1">RozdziaÅ‚ 8</a><!-- ignore --> omawia wektory bardziej szczegÃ³Å‚owo.</p>
<p>Jednak tablice sÄ… bardziej przydatne, gdy wiesz, Å¼e liczba elementÃ³w nie bÄ™dzie
musiaÅ‚a siÄ™ zmieniaÄ‡. Na przykÅ‚ad, jeÅ›li uÅ¼ywaÅ‚byÅ› nazw miesiÄ™cy w programie,
prawdopodobnie uÅ¼yÅ‚byÅ› tablicy, a nie wektora, poniewaÅ¼ wiesz, Å¼e zawsze bÄ™dzie
zawieraÄ‡ 12 elementÃ³w:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = ["StyczeÅ„", "Luty", "Marzec", "KwiecieÅ„", "Maj", "Czerwiec", "Lipiec",
              "SierpieÅ„", "WrzesieÅ„", "PaÅºdziernik", "Listopad", "GrudzieÅ„"];
<span class="boring">}</span></code></pre>
<p>Typ tablicy zapisujesz, uÅ¼ywajÄ…c nawiasÃ³w kwadratowych z typem kaÅ¼dego
elementu, Å›rednika, a nastÄ™pnie liczby elementÃ³w w tablicy, w ten sposÃ³b:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre>
<p>Tutaj <code>i32</code> jest typem kaÅ¼dego elementu. Po Å›redniku liczba <code>5</code> wskazuje, Å¼e
tablica zawiera piÄ™Ä‡ elementÃ³w.</p>
<p>MoÅ¼esz rÃ³wnieÅ¼ zainicjalizowaÄ‡ tablicÄ™ tak, aby zawieraÅ‚a tÄ™ samÄ… wartoÅ›Ä‡ dla
kaÅ¼dego elementu, okreÅ›lajÄ…c wartoÅ›Ä‡ poczÄ…tkowÄ…, po ktÃ³rej nastÄ™puje Å›rednik,
a nastÄ™pnie dÅ‚ugoÅ›Ä‡ tablicy w nawiasach kwadratowych, jak pokazano tutaj:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}</span></code></pre>
<p>Tablica o nazwie <code>a</code> bÄ™dzie zawieraÅ‚a <code>5</code> elementÃ³w, z ktÃ³rych wszystkie
poczÄ…tkowo zostanÄ… ustawione na wartoÅ›Ä‡ <code>3</code>. Jest to to samo, co napisanie
<code>let a = [3, 3, 3, 3, 3];</code>, ale w bardziej zwiÄ™zÅ‚y sposÃ³b.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="accessing-array-elements"></a></p>
<h4 id="dostÄ™p-do-elementÃ³w-tablicy"><a class="header" href="#dostÄ™p-do-elementÃ³w-tablicy">DostÄ™p do elementÃ³w tablicy</a></h4>
<p>Tablica to pojedynczy blok pamiÄ™ci o znanej, staÅ‚ej wielkoÅ›ci, ktÃ³ry moÅ¼e byÄ‡
alokowany na stosie. MoÅ¼esz uzyskaÄ‡ dostÄ™p do elementÃ³w tablicy za pomocÄ…
indeksowania, w ten sposÃ³b:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}</code></pre>
<p>W tym przykÅ‚adzie zmienna o nazwie <code>first</code> otrzyma wartoÅ›Ä‡ <code>1</code>, poniewaÅ¼ jest
to wartoÅ›Ä‡ pod indeksem <code>[0]</code> w tablicy. Zmienna o nazwie <code>second</code> otrzyma
wartoÅ›Ä‡ <code>2</code> z indeksu <code>[1]</code> w tablicy.</p>
<h4 id="nieprawidÅ‚owy-dostÄ™p-do-elementÃ³w-tablicy"><a class="header" href="#nieprawidÅ‚owy-dostÄ™p-do-elementÃ³w-tablicy">NieprawidÅ‚owy dostÄ™p do elementÃ³w tablicy</a></h4>
<p>Zobaczmy, co siÄ™ stanie, jeÅ›li sprÃ³bujesz uzyskaÄ‡ dostÄ™p do elementu tablicy,
ktÃ³ry wykracza poza jej koniec. Powiedzmy, Å¼e uruchamiasz ten kod, podobny do
gry w zgadywanie z RozdziaÅ‚u 2, aby uzyskaÄ‡ indeks tablicy od uÅ¼ytkownika:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre><code class="language-rust ignore panics">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&amp;mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!("The value of the element at index {index} is: {element}");
}</code></pre>
<p>Ten kod kompiluje siÄ™ pomyÅ›lnie. JeÅ›li uruchomisz ten kod za pomocÄ…
<code>cargo run</code> i wprowadzisz <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code> lub <code>4</code>, program wyÅ›wietli
odpowiedniÄ… wartoÅ›Ä‡ pod tym indeksem w tablicy. JeÅ›li zamiast tego wprowadzisz
liczbÄ™ wykraczajÄ…cÄ… poza koniec tablicy, takÄ… jak <code>10</code>, zobaczysz dane wyjÅ›ciowe
podobne do tego:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->
<pre><code class="language-console">thread 'main' panicked at src/main.rs:19:19:
index out of bounds: the len is 5 but the index is 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Program spowodowaÅ‚ bÅ‚Ä…d wykonawczy w momencie uÅ¼ycia nieprawidÅ‚owej wartoÅ›ci w
operacji indeksowania. Program zakoÅ„czyÅ‚ dziaÅ‚anie z komunikatem o bÅ‚Ä™dzie i
nie wykonaÅ‚ koÅ„cowej instrukcji <code>println!</code>. Kiedy prÃ³bujesz uzyskaÄ‡ dostÄ™p do
elementu za pomocÄ… indeksowania, Rust sprawdzi, czy podany indeks jest mniejszy
niÅ¼ dÅ‚ugoÅ›Ä‡ tablicy. JeÅ›li indeks jest wiÄ™kszy lub rÃ³wny dÅ‚ugoÅ›ci, Rust
spanikuje. To sprawdzenie musi nastÄ…piÄ‡ w czasie wykonania, szczegÃ³lnie w tym
przypadku, poniewaÅ¼ kompilator nie jest w stanie wiedzieÄ‡, jakÄ… wartoÅ›Ä‡
uÅ¼ytkownik wprowadzi, gdy uruchomi kod pÃ³Åºniej.</p>
<p>Jest to przykÅ‚ad dziaÅ‚ania zasad bezpieczeÅ„stwa pamiÄ™ci Rusta. W wielu
niskopoziomowych jÄ™zykach ten rodzaj sprawdzenia nie jest wykonywany, a gdy
podasz nieprawidÅ‚owy indeks, moÅ¼na uzyskaÄ‡ dostÄ™p do nieprawidÅ‚owej pamiÄ™ci.
Rust chroni CiÄ™ przed tego rodzaju bÅ‚Ä™dami, natychmiast koÅ„czÄ…c dziaÅ‚anie,
zamiast pozwalaÄ‡ na dostÄ™p do pamiÄ™ci i kontynuowaÄ‡. RozdziaÅ‚ 9 omawia wiÄ™cej
o obsÅ‚udze bÅ‚Ä™dÃ³w w Rust i o tym, jak pisaÄ‡ czytelny, bezpieczny kod, ktÃ³ry ani
nie panikuje, ani nie pozwala na dostÄ™p do nieprawidÅ‚owej pamiÄ™ci.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="funkcje-1"><a href="#funkcje-1" class="header">Funkcje</a></h1>
<h2 id="funkcje"><a class="header" href="#funkcje">Funkcje</a></h2>
<p>Funkcje sÄ… powszechne w kodzie Rusta. WidziaÅ‚eÅ› juÅ¼ jednÄ… z
najwaÅ¼niejszych funkcji w jÄ™zyku: funkcjÄ™ <code>main</code>, ktÃ³ra jest punktem wejÅ›cia
wielu programÃ³w. WidziaÅ‚eÅ› rÃ³wnieÅ¼ sÅ‚owo kluczowe <code>fn</code>, ktÃ³re pozwala
deklarowaÄ‡ nowe funkcje.</p>
<p>Kod Rusta uÅ¼ywa <em>snake case</em> jako konwencjonalnego stylu dla nazw funkcji i
zmiennych, w ktÃ³rym wszystkie litery sÄ… maÅ‚e, a podkreÅ›lenia oddzielajÄ… sÅ‚owa.
Oto program, ktÃ³ry zawiera przykÅ‚adowÄ… definicjÄ™ funkcji:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Inna funkcja.");
}</code></pre>
<p>Definiujemy funkcjÄ™ w RuÅ›cie, wpisujÄ…c <code>fn</code> po ktÃ³rej nastÄ™puje nazwa funkcji i
zestaw nawiasÃ³w. Nawiasy klamrowe informujÄ… kompilator, gdzie zaczyna siÄ™ i
koÅ„czy ciaÅ‚o funkcji.</p>
<p>MoÅ¼emy wywoÅ‚aÄ‡ dowolnÄ… zdefiniowanÄ… przez nas funkcjÄ™, wpisujÄ…c jej nazwÄ™,
a nastÄ™pnie zestaw nawiasÃ³w. PoniewaÅ¼ <code>another_function</code> jest zdefiniowana w
programie, moÅ¼e byÄ‡ wywoÅ‚ana z wewnÄ…trz funkcji <code>main</code>. ZauwaÅ¼, Å¼e zdefiniowaliÅ›my
<code>another_function</code> <em>po</em> funkcji <code>main</code> w kodzie ÅºrÃ³dÅ‚owym; mogliÅ›my jÄ… rÃ³wnieÅ¼
zdefiniowaÄ‡ wczeÅ›niej. Rust nie dba o to, gdzie definiujesz swoje funkcje,
a jedynie o to, czy sÄ… zdefiniowane w zasiÄ™gu, ktÃ³ry moÅ¼e byÄ‡ widoczny dla
wywoÅ‚ujÄ…cego.</p>
<p>UtwÃ³rzmy nowy projekt binarny o nazwie <em>functions</em>, aby dokÅ‚adniej zbadaÄ‡
funkcje. UmieÅ›Ä‡ przykÅ‚ad <code>another_function</code> w <em>src/main.rs</em> i uruchom go.
Ppowinien pojawiÄ‡ siÄ™ nastÄ™pujÄ…cy wynik:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
Inna funkcja.
</code></pre>
<p>Wiersze wykonujÄ… siÄ™ w kolejnoÅ›ci, w jakiej pojawiajÄ… siÄ™ w funkcji <code>main</code>.
Najpierw wypisuje siÄ™ komunikat â€Witaj, Å›wiecie!â€, a nastÄ™pnie wywoÅ‚ywana jest
<code>another_function</code> i wypisuje siÄ™ jej komunikat.</p>
<h3 id="parametry"><a class="header" href="#parametry">Parametry</a></h3>
<p>MoÅ¼emy definiowaÄ‡ funkcje tak, aby miaÅ‚y <em>parametry</em>, ktÃ³re sÄ… specjalnymi
zmiennymi bÄ™dÄ…cymi czÄ™Å›ciÄ… sygnatury funkcji. Gdy funkcja ma parametry, moÅ¼na
podaÄ‡ jej konkretne wartoÅ›ci dla tych parametrÃ³w. Technicznie, konkretne
wartoÅ›ci nazywane sÄ… <em>argumentami</em>, ale w potocznej rozmowie ludzie majÄ…
skÅ‚onnoÅ›Ä‡ do uÅ¼ywania sÅ‚Ã³w <em>parametr</em> i <em>argument</em> zamiennie dla zmiennych w
definicji funkcji lub konkretnych wartoÅ›ci przekazywanych podczas wywoÅ‚ywania
funkcji.</p>
<p>W tej wersji <code>another_function</code> dodajemy parametr:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("WartoÅ›Ä‡ x to: {x}");
}</code></pre>
<p>SprÃ³buj uruchomiÄ‡ ten program; powinieneÅ› uzyskaÄ‡ nastÄ™pujÄ…cy wynik:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
WartoÅ›Ä‡ x to: 5
</code></pre>
<p>Deklaracja <code>another_function</code> ma jeden parametr o nazwie <code>x</code>. Typ <code>x</code> jest
okreÅ›lony jako <code>i32</code>. Kiedy przekazujemy <code>5</code> do <code>another_function</code>, makro
<code>println!</code> umieszcza <code>5</code> tam, gdzie w ciÄ…gu formatujÄ…cym znajdowaÅ‚y siÄ™ nawiasy
klemrowe zawierajÄ…ce <code>x</code>.</p>
<p>W sygnaturach funkcji <em>musisz</em> zadeklarowaÄ‡ typ kaÅ¼dego parametru. Jest to
Å›wiadoma decyzja w projekcie Rusta: Wymaganie adnotacji typÃ³w w definicjach
funkcji oznacza, Å¼e kompilator prawie nigdy nie potrzebuje, abyÅ› uÅ¼ywaÅ‚ ich
w innym miejscu w kodzie, aby zrozumieÄ‡, jaki typ masz na myÅ›li. Kompilator
jest rÃ³wnieÅ¼ w stanie dostarczyÄ‡ bardziej pomocne komunikaty o bÅ‚Ä™dach, jeÅ›li
wie, jakich typÃ³w oczekuje funkcja.</p>
<p>Podczas definiowania wielu parametrÃ³w, oddziel deklaracje parametrÃ³w przecinkami,
w ten sposÃ³b:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("Pomiar to: {value}{unit_label}");
}</code></pre>
<p>Ten przykÅ‚ad tworzy funkcjÄ™ o nazwie <code>print_labeled_measurement</code> z dwoma
parametrami. Pierwszy parametr ma nazwÄ™ <code>value</code> i jest typu <code>i32</code>. Drugi ma
nazwÄ™ <code>unit_label</code> i jest typu <code>char</code>. Funkcja nastÄ™pnie wypisuje tekst
zawierajÄ…cy zarÃ³wno <code>value</code>, jak i <code>unit_label</code>.</p>
<p>SprÃ³buj uruchomiÄ‡ ten kod. ZastÄ…p program znajdujÄ…cy siÄ™ obecnie w pliku
<em>src/main.rs</em> projektu <em>functions</em> poprzednim przykÅ‚adem i uruchom go za
pomocÄ… <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
Pomiar to: 5h
</code></pre>
<p>PoniewaÅ¼ wywoÅ‚aliÅ›my funkcjÄ™ z <code>5</code> jako wartoÅ›ciÄ… dla <code>value</code> i <code>'h'</code> jako
wartoÅ›ciÄ… dla <code>unit_label</code>, wyjÅ›cie programu zawiera te wartoÅ›ci.</p>
<h3 id="instrukcje-i-wyraÅ¼enia"><a class="header" href="#instrukcje-i-wyraÅ¼enia">Instrukcje i wyraÅ¼enia</a></h3>
<p>CiaÅ‚a funkcji skÅ‚adajÄ… siÄ™ z serii instrukcji, opcjonalnie zakoÅ„czonych
wyraÅ¼eniem. Do tej pory omÃ³wione przez nas funkcje nie zawieraÅ‚y koÅ„cowego
wyraÅ¼enia, ale widziaÅ‚eÅ› wyraÅ¼enie jako czÄ™Å›Ä‡ instrukcji. PoniewaÅ¼ Rust jest
jÄ™zykiem opartym na wyraÅ¼eniach, jest to waÅ¼ne rozrÃ³Å¼nienie do zrozumienia.
Inne jÄ™zyki nie majÄ… tych samych rozrÃ³Å¼nieÅ„, wiÄ™c przyjrzyjmy siÄ™, czym sÄ…
instrukcje i wyraÅ¼enia oraz jak ich rÃ³Å¼nice wpÅ‚ywajÄ… na ciaÅ‚a funkcji.</p>
<ul>
<li><em>Instrukcje</em> to polecenia, ktÃ³re wykonujÄ… jakÄ…Å› akcjÄ™ i nie zwracajÄ…
wartoÅ›ci.</li>
<li><em>WyraÅ¼enia</em> obliczajÄ… siÄ™ do wartoÅ›ci wynikowej.</li>
</ul>
<p>Przyjrzyjmy siÄ™ kilku przykÅ‚adom.</p>
<p>W rzeczywistoÅ›ci juÅ¼ uÅ¼ywaliÅ›my instrukcji i wyraÅ¼eÅ„. Tworzenie zmiennej i
przypisywanie jej wartoÅ›ci za pomocÄ… sÅ‚owa kluczowego <code>let</code> jest instrukcjÄ….
W Listingu 3-1, <code>let y = 6;</code> to instrukcja.</p>
<listing number="3-1" file-name="src/main.rs" caption="Deklaracja funkcji `main` zawierajÄ…ca jednÄ… instrukcjÄ™">
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let y = 6;
}</code></pre>
</listing>
<p>Definicje funkcji to rÃ³wnieÅ¼ instrukcje; caÅ‚y poprzedni przykÅ‚ad sam w sobie
jest instrukcjÄ…. (Jak wkrÃ³tce zobaczymy, wywoÅ‚ywanie funkcji nie jest
instrukcjÄ….)</p>
<p>Instrukcje nie zwracajÄ… wartoÅ›ci. Dlatego nie moÅ¼esz przypisaÄ‡ instrukcji
<code>let</code> do innej zmiennej, tak jak prÃ³buje to zrobiÄ‡ poniÅ¼szy kod; otrzymasz bÅ‚Ä…d:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = (let y = 6);
}</code></pre>
<p>Po uruchomieniu tego programu otrzymasz nastÄ™pujÄ…cy bÅ‚Ä…d:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found `let` statement
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

warning: unnecessary parentheses around assigned value
 --&gt; src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^         ^
  |
  = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
  |
2 -     let x = (let y = 6);
2 +     let x = let y = 6;
  |

warning: `functions` (bin "functions") generated 1 warning
error: could not compile `functions` (bin "functions") due to 1 previous error; 1 warning emitted
</code></pre>
<p>Instrukcja <code>let y = 6</code> nie zwraca wartoÅ›ci, wiÄ™c nie ma nic, do czego <code>x</code>
mogÅ‚oby siÄ™ zwiÄ…zaÄ‡. RÃ³Å¼ni siÄ™ to od tego, co dzieje siÄ™ w innych jÄ™zykach,
takich jak C i Ruby, gdzie przypisanie zwraca wartoÅ›Ä‡ przypisania. W tych
jÄ™zykach moÅ¼na napisaÄ‡ <code>x = y = 6</code> i sprawiÄ‡, Å¼e zarÃ³wno <code>x</code>, jak i <code>y</code> bÄ™dÄ…
miaÅ‚y wartoÅ›Ä‡ <code>6</code>; tak nie jest w RuÅ›cie.</p>
<p>WyraÅ¼enia obliczajÄ… siÄ™ do wartoÅ›ci i stanowiÄ… wiÄ™kszoÅ›Ä‡ pozostaÅ‚ego kodu,
ktÃ³ry bÄ™dziesz pisaÄ‡ w RuÅ›cie. RozwaÅ¼ operacjÄ™ matematycznÄ…, takÄ… jak <code>5 + 6</code>,
ktÃ³ra jest wyraÅ¼eniem, ktÃ³re oblicza siÄ™ do wartoÅ›ci <code>11</code>. WyraÅ¼enia mogÄ… byÄ‡
czÄ™Å›ciÄ… instrukcji: W Listingu 3-1, <code>6</code> w instrukcji <code>let y = 6;</code> jest
wyraÅ¼eniem, ktÃ³re oblicza siÄ™ do wartoÅ›ci <code>6</code>. WywoÅ‚ywanie funkcji jest
wyraÅ¼eniem. WywoÅ‚ywanie makra jest wyraÅ¼eniem. Nowy blok zasiÄ™gu utworzony za
pomocÄ… nawiasÃ³w klamrowych jest wyraÅ¼eniem, na przykÅ‚ad:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("WartoÅ›Ä‡ y to: {y}");
}</code></pre>
<p>To wyraÅ¼enie:</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}</code></pre>
<p>jest blokiem, ktÃ³ry w tym przypadku oblicza siÄ™ do <code>4</code>. Ta wartoÅ›Ä‡ zostaje
zwiÄ…zana z <code>y</code> jako czÄ™Å›Ä‡ instrukcji <code>let</code>. ZauwaÅ¼ wiersz <code>x + 1</code> bez Å›rednika
na koÅ„cu, co rÃ³Å¼ni siÄ™ od wiÄ™kszoÅ›ci dotychczas widzianych wierszy. WyraÅ¼enia
nie zawierajÄ… koÅ„cowych Å›rednikÃ³w. JeÅ›li dodasz Å›rednik na koÅ„cu wyraÅ¼enia,
zmienisz je w instrukcjÄ™, a wtedy nie zwrÃ³ci ono wartoÅ›ci. Miej to na uwadze,
gdy bÄ™dziesz dalej poznawaÄ‡ wartoÅ›ci zwracane przez funkcje i wyraÅ¼enia.</p>
<h3 id="funkcje-zwracajÄ…ce-wartoÅ›ci"><a class="header" href="#funkcje-zwracajÄ…ce-wartoÅ›ci">Funkcje zwracajÄ…ce wartoÅ›ci</a></h3>
<p>Funkcje mogÄ… zwracaÄ‡ wartoÅ›ci do wywoÅ‚ujÄ…cego je kodu. Nie nazywamy wartoÅ›ci
zwracanych, ale musimy zadeklarowaÄ‡ ich typ po strzaÅ‚ce (<code>-&gt;</code>). W RuÅ›cie,
wartoÅ›Ä‡ zwracana przez funkcjÄ™ jest synonimem wartoÅ›ci ostatniego wyraÅ¼enia w
bloku ciaÅ‚a funkcji. MoÅ¼esz zwrÃ³ciÄ‡ wartoÅ›Ä‡ wczeÅ›niej z funkcji, uÅ¼ywajÄ…c
sÅ‚owa kluczowego <code>return</code> i okreÅ›lajÄ…c wartoÅ›Ä‡, ale wiÄ™kszoÅ›Ä‡ funkcji zwraca
ostatnie wyraÅ¼enie niejawnie. Oto przykÅ‚ad funkcji, ktÃ³ra zwraca wartoÅ›Ä‡:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!("WartoÅ›Ä‡ x to: {x}");
}</code></pre>
<p>Nie ma wywoÅ‚aÅ„ funkcji, makr, ani nawet instrukcji <code>let</code> w funkcji <code>five</code> â€”
tylko sama liczba <code>5</code>. To jest caÅ‚kowicie poprawna funkcja w RuÅ›cie.
ZauwaÅ¼, Å¼e typ zwracany funkcji jest rÃ³wnieÅ¼ okreÅ›lony jako <code>-&gt; i32</code>.
SprÃ³buj uruchomiÄ‡ ten kod; wyjÅ›cie powinno wyglÄ…daÄ‡ tak:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
WartoÅ›Ä‡ x to: 5
</code></pre>
<p><code>5</code> w <code>five</code> jest wartoÅ›ciÄ… zwracanÄ… przez funkcjÄ™, dlatego typ zwracany to
<code>i32</code>. Zbadajmy to bardziej szczegÃ³Å‚owo. SÄ… tu dwa waÅ¼ne aspekty:
Po pierwsze, wiersz <code>let x = five();</code> pokazuje, Å¼e uÅ¼ywamy wartoÅ›ci
zwracanej przez funkcjÄ™ do inicjalizacji zmiennej. PoniewaÅ¼ funkcja <code>five</code>
zwraca <code>5</code>, ten wiersz jest rÃ³wnowaÅ¼ny z nastÄ™pujÄ…cym:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre>
<p>Po drugie, funkcja <code>five</code> nie ma parametrÃ³w i definiuje typ wartoÅ›ci
zwracanej, ale ciaÅ‚o funkcji to samotne <code>5</code> bez Å›rednika, poniewaÅ¼ jest to
wyraÅ¼enie, ktÃ³rego wartoÅ›Ä‡ chcemy zwrÃ³ciÄ‡.</p>
<p>Przyjrzyjmy siÄ™ innemu przykÅ‚adowi:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = plus_one(5);

    println!("WartoÅ›Ä‡ x to: {x}");
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<p>Uruchomienie tego kodu wypisze <code>WartoÅ›Ä‡ x to: 6</code>. Ale co siÄ™ stanie, jeÅ›li
umieÅ›cimy Å›rednik na koÅ„cu wiersza zawierajÄ…cego <code>x + 1</code>, zmieniajÄ…c go z
wyraÅ¼enia w instrukcjÄ™?</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = plus_one(5);

    println!("WartoÅ›Ä‡ x to: {x}");
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}</code></pre>
<p>Skompilowanie tego kodu spowoduje bÅ‚Ä…d, jak nastÄ™puje:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: remove this semicolon to return this value

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` (bin "functions") due to 1 previous error
</code></pre>
<p>GÅ‚Ã³wny komunikat o bÅ‚Ä™dzie, <code>mismatched types</code> (niezgodne typy), ujawnia
sedno problemu z tym kodem. Definicja funkcji <code>plus_one</code> mÃ³wi, Å¼e zwrÃ³ci <code>i32</code>,
ale instrukcje nie obliczajÄ… siÄ™ do wartoÅ›ci, co jest wyraÅ¼one przez <code>()</code>,
typ jednostkowy. Dlatego nic nie jest zwracane, co jest sprzeczne z definicjÄ…
funkcji i skutkuje bÅ‚Ä™dem. W tym wyjÅ›ciu Rust dostarcza komunikat, ktÃ³ry byÄ‡
moÅ¼e pomoÅ¼e rozwiÄ…zaÄ‡ ten problem: sugeruje usuniÄ™cie Å›rednika, co naprawiÅ‚oby
bÅ‚Ä…d.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="komentarze-1"><a href="#komentarze-1" class="header">Komentarze</a></h1>
<h2 id="komentarze"><a class="header" href="#komentarze">Komentarze</a></h2>
<p>Wszyscy programiÅ›ci dÄ…Å¼Ä… do tego, aby ich kod byÅ‚ Å‚atwy do zrozumienia, ale
czasami wymagane jest dodatkowe wyjaÅ›nienie. W takich przypadkach programiÅ›ci
pozostawiajÄ… <em>komentarze</em> w swoim kodzie ÅºrÃ³dÅ‚owym, ktÃ³re kompilator zignoruje,
ale ktÃ³re osoby czytajÄ…ce kod ÅºrÃ³dÅ‚owy mogÄ… uznaÄ‡ za przydatne.</p>
<p>Oto prosty komentarz:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// witaj, Å›wiecie
<span class="boring">}</span></code></pre>
<p>W RuÅ›cie idiomatyczny styl komentarzy rozpoczyna komentarz dwoma ukoÅ›nikami,
a komentarz trwa do koÅ„ca linii. W przypadku komentarzy, ktÃ³re rozciÄ…gajÄ… siÄ™
poza jednÄ… liniÄ™, naleÅ¼y umieÅ›ciÄ‡ <code>//</code> na kaÅ¼dej linii, w ten sposÃ³b:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WiÄ™c robimy tutaj coÅ› skomplikowanego, na tyle dÅ‚ugiego, Å¼e potrzebujemy
// wielu linii komentarzy, Å¼eby to zrobiÄ‡! Uff! Mamy nadziejÄ™, Å¼e ten komentarz
// wyjaÅ›ni, co siÄ™ dzieje.
<span class="boring">}</span></code></pre>
<p>Komentarze mogÄ… byÄ‡ rÃ³wnieÅ¼ umieszczane na koÅ„cu wierszy zawierajÄ…cych kod:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let lucky_number = 7; // CzujÄ™ siÄ™ dzisiaj szczÄ™Å›ciarzem
}</code></pre>
<p>Ale czÄ™Å›ciej zobaczysz je uÅ¼ywane w tym formacie, z komentarzem w osobnej linii
powyÅ¼ej kodu, ktÃ³ry opisuje:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    // CzujÄ™ siÄ™ dzisiaj szczÄ™Å›ciarzem
    let lucky_number = 7;
}</code></pre>
<p>Rust ma rÃ³wnieÅ¼ inny rodzaj komentarzy, komentarze dokumentacyjne, ktÃ³re omÃ³wimy
w <a href="#publikowanie-pakietu-na-cratesio-1">sekcji â€Publikowanie skrzynki na Crates.ioâ€</a><!-- ignore -->
w Rozdziale 14.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="przepÅ‚yw-sterowania-1"><a href="#przepÅ‚yw-sterowania-1" class="header">PrzepÅ‚yw sterowania</a></h1>
<h2 id="przepÅ‚yw-sterowania"><a class="header" href="#przepÅ‚yw-sterowania">PrzepÅ‚yw sterowania</a></h2>
<p>MoÅ¼liwoÅ›Ä‡ uruchomienia czÄ™Å›ci kodu w zaleÅ¼noÅ›ci od tego, czy warunek jest
<code>true</code>, oraz moÅ¼liwoÅ›Ä‡ wielokrotnego uruchamiania czÄ™Å›ci kodu, dopÃ³ki warunek
jest <code>true</code>, to podstawowe bloki konstrukcyjne w wiÄ™kszoÅ›ci jÄ™zykÃ³w
programowania. NajczÄ™stsze konstrukcje, ktÃ³re pozwalajÄ… kontrolowaÄ‡ przepÅ‚yw
wykonania kodu Rusta, to wyraÅ¼enia <code>if</code> i pÄ™tle.</p>
<h3 id="wyraÅ¼enia-if"><a class="header" href="#wyraÅ¼enia-if">WyraÅ¼enia <code>if</code></a></h3>
<p>WyraÅ¼enie <code>if</code> pozwala rozgaÅ‚Ä™ziaÄ‡ kod w zaleÅ¼noÅ›ci od warunkÃ³w. Podajesz
warunek, a nastÄ™pnie stwierdzasz: â€JeÅ›li ten warunek jest speÅ‚niony, uruchom
ten blok kodu. JeÅ›li warunek nie jest speÅ‚niony, nie uruchamiaj tego bloku
kodu.â€</p>
<p>UtwÃ³rz nowy projekt o nazwie <em>branches</em> w katalogu <em>projects</em>, aby zbadaÄ‡
wyraÅ¼enie <code>if</code>. W pliku <em>src/main.rs</em> wprowadÅº nastÄ™pujÄ…cy kod:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!("warunek byÅ‚ prawdziwy");
    } else {
        println!("warunek byÅ‚ faÅ‚szywy");
    }
}</code></pre>
<p>Wszystkie wyraÅ¼enia <code>if</code> zaczynajÄ… siÄ™ od sÅ‚owa kluczowego <code>if</code>, po ktÃ³rym
nastÄ™puje warunek. W tym przypadku warunek sprawdza, czy zmienna <code>number</code> ma
wartoÅ›Ä‡ mniejszÄ… niÅ¼ 5. Blok kodu do wykonania, jeÅ›li warunek jest <code>true</code>,
umieszczamy bezpoÅ›rednio po warunku w nawiasach klamrowych. Bloki kodu
powiÄ…zane z warunkami w wyraÅ¼eniach <code>if</code> sÄ… czasami nazywane <em>ramionami</em>,
podobnie jak ramiona w wyraÅ¼eniach <code>match</code>, ktÃ³re omÃ³wiliÅ›my w sekcji
<a href="#comparing-the-guess-to-the-secret-number">â€PorÃ³wnywanie zgadywanej liczby z tajnÄ…
liczbÄ…â€</a><!-- ignore --> w
Rozdziale 2.</p>
<p>Opcjonalnie moÅ¼emy rÃ³wnieÅ¼ doÅ‚Ä…czyÄ‡ wyraÅ¼enie <code>else</code>, co tutaj zrobiliÅ›my, aby
podaÄ‡ programowi alternatywny blok kodu do wykonania, jeÅ›li warunek oceni siÄ™
na <code>false</code>. JeÅ›li nie podasz wyraÅ¼enia <code>else</code>, a warunek jest <code>false</code>,
program po prostu pominie blok <code>if</code> i przejdzie do nastÄ™pnej czÄ™Å›ci kodu.</p>
<p>SprÃ³buj uruchomiÄ‡ ten kod; powinieneÅ› zobaczyÄ‡ nastÄ™pujÄ…cy wynik:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
warunek byÅ‚ prawdziwy
</code></pre>
<p>SprÃ³bujmy zmieniÄ‡ wartoÅ›Ä‡ <code>number</code> na takÄ…, ktÃ³ra sprawi, Å¼e warunek bÄ™dzie
<code>false</code>, aby zobaczyÄ‡, co siÄ™ stanie:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let number = 7;
<span class="boring">
</span><span class="boring">    if number &lt; 5 {
</span><span class="boring">        println!("condition was true");
</span><span class="boring">    } else {
</span><span class="boring">        println!("condition was false");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Uruchom program ponownie i spÃ³jrz na wynik:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
warunek byÅ‚ faÅ‚szywy
</code></pre>
<p>Warto rÃ³wnieÅ¼ zauwaÅ¼yÄ‡, Å¼e warunek w tym kodzie <em>musi</em> byÄ‡ typu <code>bool</code>.
JeÅ›li warunek nie jest typu <code>bool</code>, otrzymamy bÅ‚Ä…d. Na przykÅ‚ad, sprÃ³buj
uruchomiÄ‡ nastÄ™pujÄ…cy kod:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}</code></pre>
<p>Warunek <code>if</code> tym razem oblicza siÄ™ do wartoÅ›ci <code>3</code>, a Rust zwraca bÅ‚Ä…d:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
</code></pre>
<p>BÅ‚Ä…d wskazuje, Å¼e Rust oczekiwaÅ‚ <code>bool</code>, ale otrzymaÅ‚ liczbÄ™ caÅ‚kowitÄ….
W przeciwieÅ„stwie do jÄ™zykÃ³w takich jak Ruby i JavaScript, Rust nie bÄ™dzie
automatycznie prÃ³bowaÅ‚ konwertowaÄ‡ typÃ³w niebÄ™dÄ…cych <code>bool</code> na <code>bool</code>.
Musisz byÄ‡ jawny i zawsze dostarczaÄ‡ <code>if</code> z wartoÅ›ciÄ… <code>bool</code> jako warunkiem.
JeÅ›li chcemy, aby blok kodu <code>if</code> byÅ‚ uruchamiany tylko wtedy, gdy liczba nie
jest rÃ³wna <code>0</code>, na przykÅ‚ad, moÅ¼emy zmieniÄ‡ wyraÅ¼enie <code>if</code> na nastÄ™pujÄ…ce:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let number = 3;

    if number != 0 {
        println!("number byÅ‚o czymÅ› innym niÅ¼ zero");
    }
}</code></pre>
<p>Uruchomienie tego kodu wypisze <code>number byÅ‚o czymÅ› innym niÅ¼ zero</code>.</p>
<h4 id="obsÅ‚uga-wielu-warunkÃ³w-za-pomocÄ…-else-if"><a class="header" href="#obsÅ‚uga-wielu-warunkÃ³w-za-pomocÄ…-else-if">ObsÅ‚uga wielu warunkÃ³w za pomocÄ… <code>else if</code></a></h4>
<p>MoÅ¼esz uÅ¼yÄ‡ wielu warunkÃ³w, Å‚Ä…czÄ…c <code>if</code> i <code>else</code> w wyraÅ¼eniu <code>else if</code>.
Na przykÅ‚ad:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("liczba jest podzielna przez 4");
    } else if number % 3 == 0 {
        println!("liczba jest podzielna przez 3");
    } else if number % 2 == 0 {
        println!("liczba jest podzielna przez 2");
    } else {
        println!("liczba nie jest podzielna przez 4, 3 ani 2");
    }
}</code></pre>
<p>Ten program moÅ¼e podÄ…Å¼yÄ‡ czterema moÅ¼liwymi Å›cieÅ¼kami. Po jego uruchomieniu
powinieneÅ› zobaczyÄ‡ nastÄ™pujÄ…cy wynik:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
liczba jest podzielna przez 3
</code></pre>
<p>Kiedy ten program siÄ™ wykonuje, sprawdza kolejno kaÅ¼de wyraÅ¼enie <code>if</code> i
wykonuje pierwszy blok, dla ktÃ³rego warunek ocenia siÄ™ na <code>true</code>. ZauwaÅ¼, Å¼e
mimo Å¼e 6 jest podzielne przez 2, nie widzimy wyjÅ›cia <code>liczba jest podzielna przez 2</code>, ani tekstu <code>liczba nie jest podzielna przez 4, 3 ani 2</code> z bloku
<code>else</code>. Dzieje siÄ™ tak, poniewaÅ¼ Rust wykonuje blok tylko dla pierwszego
warunku <code>true</code>, a gdy tylko znajdzie taki, nie sprawdza juÅ¼ reszty.</p>
<p>Zbyt wiele wyraÅ¼eÅ„ <code>else if</code> moÅ¼e zaÅ›miecaÄ‡ kod, wiÄ™c jeÅ›li masz ich wiÄ™cej niÅ¼
jeden, moÅ¼esz chcieÄ‡ refaktoryzowaÄ‡ swÃ³j kod. RozdziaÅ‚ 6 opisuje potÄ™Å¼nÄ…
konstrukcjÄ™ rozgaÅ‚Ä™ziajÄ…cÄ… Rusta o nazwie <code>match</code> dla takich przypadkÃ³w.</p>
<h4 id="uÅ¼ywanie-if-w-instrukcji-let"><a class="header" href="#uÅ¼ywanie-if-w-instrukcji-let">UÅ¼ywanie <code>if</code> w instrukcji <code>let</code></a></h4>
<p>PoniewaÅ¼ <code>if</code> jest wyraÅ¼eniem, moÅ¼emy go uÅ¼yÄ‡ po prawej stronie instrukcji
<code>let</code>, aby przypisaÄ‡ wynik do zmiennej, jak w Listingu 3-2.</p>
<listing number="3-2" file-name="src/main.rs" caption="Przypisywanie wyniku wyraÅ¼enia `if` do zmiennej">
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("WartoÅ›Ä‡ liczby to: {number}");
}</code></pre>
</listing>
<p>Zmienna <code>number</code> zostanie zwiÄ…zana z wartoÅ›ciÄ… na podstawie wyniku wyraÅ¼enia
<code>if</code>. Uruchom ten kod, aby zobaczyÄ‡, co siÄ™ stanie:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
WartoÅ›Ä‡ liczby to: 5
</code></pre>
<p>PamiÄ™taj, Å¼e bloki kodu oceniajÄ… siÄ™ do ostatniego w nich wyraÅ¼enia, a same
liczby sÄ… rÃ³wnieÅ¼ wyraÅ¼eniami. W tym przypadku wartoÅ›Ä‡ caÅ‚ego wyraÅ¼enia <code>if</code>
zaleÅ¼y od tego, ktÃ³ry blok kodu zostanie wykonany. Oznacza to, Å¼e wartoÅ›ci,
ktÃ³re potencjalnie mogÄ… byÄ‡ wynikami z kaÅ¼dego ramienia <code>if</code>, muszÄ… byÄ‡ tego
samego typu; w Listingu 3-2 wyniki zarÃ³wno ramienia <code>if</code>, jak i ramienia
<code>else</code> byÅ‚y liczbami caÅ‚kowitymi <code>i32</code>. JeÅ›li typy nie pasujÄ… do siebie, jak w
nastÄ™pujÄ…cym przykÅ‚adzie, otrzymamy bÅ‚Ä…d:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let number = if condition { 5 } else { "szeÅ›Ä‡" };

    println!("WartoÅ›Ä‡ liczby to: {number}");
}</code></pre>
<p>Kiedy sprÃ³bujemy skompilowaÄ‡ ten kod, otrzymamy bÅ‚Ä…d. Ramiona <code>if</code> i <code>else</code>
majÄ… niezgodne typy wartoÅ›ci, a Rust dokÅ‚adnie wskazuje, gdzie znaleÅºÄ‡ problem
w programie:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { "six" };
  |                                 -          ^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
</code></pre>
<p>WyraÅ¼enie w bloku <code>if</code> oblicza siÄ™ do liczby caÅ‚kowitej, a wyraÅ¼enie w bloku
<code>else</code> oblicza siÄ™ do ciÄ…gu znakÃ³w. To nie zadziaÅ‚a, poniewaÅ¼ zmienne muszÄ…
mieÄ‡ pojedynczy typ, a Rust musi wiedzieÄ‡ jednoznacznie w czasie kompilacji,
jakiego typu jest zmienna <code>number</code>. ZnajomoÅ›Ä‡ typu <code>number</code> pozwala
kompilatorowi sprawdziÄ‡, czy typ jest prawidÅ‚owy wszÄ™dzie tam, gdzie uÅ¼ywamy
<code>number</code>. Rust nie byÅ‚by w stanie tego zrobiÄ‡, gdyby typ <code>number</code> byÅ‚
okreÅ›lany tylko w czasie dziaÅ‚ania; kompilator byÅ‚by bardziej zÅ‚oÅ¼ony i dawaÅ‚by
mniej gwarancji co do kodu, gdyby musiaÅ‚ Å›ledziÄ‡ wiele hipotetycznych typÃ³w
dla dowolnej zmiennej.</p>
<h3 id="powtarzanie-z-pÄ™tlami"><a class="header" href="#powtarzanie-z-pÄ™tlami">Powtarzanie z pÄ™tlami</a></h3>
<p>CzÄ™sto przydatne jest wielokrotne wykonanie bloku kodu. Do tego zadania Rust
udostÄ™pnia kilka <em>pÄ™tli</em>, ktÃ³re bÄ™dÄ… wykonywaÄ‡ kod wewnÄ…trz ciaÅ‚a pÄ™tli do
koÅ„ca, a nastÄ™pnie natychmiast wrÃ³cÄ… na poczÄ…tek. Aby poeksperymentowaÄ‡ z
pÄ™tlami, utwÃ³rzmy nowy projekt o nazwie <em>loops</em>.</p>
<p>Rust ma trzy rodzaje pÄ™tli: <code>loop</code>, <code>while</code> i <code>for</code>. SprÃ³bujmy kaÅ¼dej z nich.</p>
<h4 id="powtarzanie-kodu-za-pomocÄ…-loop"><a class="header" href="#powtarzanie-kodu-za-pomocÄ…-loop">Powtarzanie kodu za pomocÄ… <code>loop</code></a></h4>
<p>SÅ‚owo kluczowe <code>loop</code> mÃ³wi Rustowi, aby wykonywaÅ‚ blok kodu w kÃ³Å‚ko, albo w
nieskoÅ„czonoÅ›Ä‡, albo dopÃ³ki jawnie nie powiesz mu, aby siÄ™ zatrzymaÅ‚.</p>
<p>Jako przykÅ‚ad, zmieÅ„ plik <em>src/main.rs</em> w katalogu <em>loops</em> tak, aby wyglÄ…daÅ‚
tak:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!("znowu!");
    }
}</code></pre>
<p>Kiedy uruchomimy ten program, bÄ™dziemy widzieÄ‡ <code>znowu!</code> wypisywane w kÃ³Å‚ko
nieprzerwanie, dopÃ³ki nie zatrzymamy programu rÄ™cznie. WiÄ™kszoÅ›Ä‡ terminali
obsÅ‚uguje skrÃ³t klawiaturowy <kbd>ctrl</kbd>-<kbd>C</kbd> do przerwania
programu, ktÃ³ry utknÄ…Å‚ w nieustannej pÄ™tli. SprÃ³buj:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/loops`
znowu!
znowu!
znowu!
znowu!
^Cznowu!
</code></pre>
<p>Symbol <code>^C</code> reprezentuje miejsce, w ktÃ³rym naciÅ›nÄ…Å‚eÅ› <kbd>ctrl</kbd>-<kbd>C</kbd>.</p>
<p>MoÅ¼esz, ale nie musisz, zobaczyÄ‡ sÅ‚owo <code>znowu!</code> wypisane po <code>^C</code>, w zaleÅ¼noÅ›ci
od tego, w ktÃ³rym miejscu pÄ™tli znajdowaÅ‚ siÄ™ kod, gdy otrzymaÅ‚ sygnaÅ‚
przerwania.</p>
<p>Na szczÄ™Å›cie Rust udostÄ™pnia rÃ³wnieÅ¼ sposÃ³b na wyjÅ›cie z pÄ™tli za pomocÄ… kodu.
MoÅ¼esz umieÅ›ciÄ‡ sÅ‚owo kluczowe <code>break</code> w pÄ™tli, aby powiedzieÄ‡ programowi,
kiedy ma zakoÅ„czyÄ‡ wykonywanie pÄ™tli. Przypomnij sobie, Å¼e zrobiliÅ›my to w
grze w zgadywanie w <a href="#quitting-after-a-correct-guess">sekcji â€ZakoÅ„czenie po poprawnym
odgadniÄ™ciuâ€</a><!-- ignore --> w Rozdziale 2,
aby zakoÅ„czyÄ‡ program, gdy uÅ¼ytkownik wygraÅ‚ grÄ™, zgadujÄ…c poprawnÄ… liczbÄ™.</p>
<p>UÅ¼ywaliÅ›my rÃ³wnieÅ¼ <code>continue</code> w grze w zgadywanie, co w pÄ™tli mÃ³wi programowi,
aby pominÄ…Å‚ pozostaÅ‚y kod w tej iteracji pÄ™tli i przeszedÅ‚ do nastÄ™pnej
iteracji.</p>
<h4 id="zwracanie-wartoÅ›ci-z-pÄ™tli"><a class="header" href="#zwracanie-wartoÅ›ci-z-pÄ™tli">Zwracanie wartoÅ›ci z pÄ™tli</a></h4>
<p>Jednym z zastosowaÅ„ pÄ™tli <code>loop</code> jest ponowne wykonanie operacji, o ktÃ³rej wiesz,
Å¼e moÅ¼e siÄ™ nie powieÅ›Ä‡, na przykÅ‚ad sprawdzenie, czy wÄ…tek zakoÅ„czyÅ‚ swoje
zadanie. MoÅ¼e byÄ‡ rÃ³wnieÅ¼ konieczne przekazanie wyniku tej operacji poza pÄ™tlÄ™
do reszty kodu. Aby to zrobiÄ‡, moÅ¼esz dodaÄ‡ wartoÅ›Ä‡, ktÃ³rÄ… chcesz zwrÃ³ciÄ‡, po
wyraÅ¼eniu <code>break</code>, ktÃ³rego uÅ¼ywasz do zatrzymania pÄ™tli; ta wartoÅ›Ä‡ zostanie
zwrÃ³cona z pÄ™tli, abyÅ› mÃ³gÅ‚ jej uÅ¼yÄ‡, jak pokazano tutaj:</p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("Wynik to {result}");
}</code></pre>
<p>Przed pÄ™tlÄ… deklarujemy zmiennÄ… <code>counter</code> i inicjalizujemy jÄ… na <code>0</code>.
NastÄ™pnie deklarujemy zmiennÄ… <code>result</code>, aby przechowywaÅ‚a wartoÅ›Ä‡ zwrÃ³conÄ… z
pÄ™tli. W kaÅ¼dej iteracji pÄ™tli dodajemy <code>1</code> do zmiennej <code>counter</code>, a nastÄ™pnie
sprawdzamy, czy <code>counter</code> jest rÃ³wne <code>10</code>. Gdy tak jest, uÅ¼ywamy sÅ‚owa
kluczowego <code>break</code> z wartoÅ›ciÄ… <code>counter * 2</code>. Po pÄ™tli uÅ¼ywamy Å›rednika,
aby zakoÅ„czyÄ‡ instrukcjÄ™, ktÃ³ra przypisuje wartoÅ›Ä‡ do <code>result</code>. Na koniec
wypisujemy wartoÅ›Ä‡ w <code>result</code>, ktÃ³ra w tym przypadku wynosi <code>20</code>.</p>
<p>MoÅ¼esz rÃ³wnieÅ¼ <code>return</code> z wnÄ™trza pÄ™tli. Podczas gdy <code>break</code> tylko wychodzi z
bieÅ¼Ä…cej pÄ™tli, <code>return</code> zawsze wychodzi z bieÅ¼Ä…cej funkcji.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="loop-labels-to-disambiguate-between-multiple-loops"></a></p>
<h4 id="rozrÃ³Å¼nianie-wielu-pÄ™tli-za-pomocÄ…-etykiet-pÄ™tli"><a class="header" href="#rozrÃ³Å¼nianie-wielu-pÄ™tli-za-pomocÄ…-etykiet-pÄ™tli">RozrÃ³Å¼nianie wielu pÄ™tli za pomocÄ… etykiet pÄ™tli</a></h4>
<p>JeÅ›li masz pÄ™tle zagnieÅ¼dÅ¼one w innych pÄ™tlach, <code>break</code> i <code>continue</code> dotyczÄ…
aktualnie najbardziej wewnÄ™trznej pÄ™tli. MoÅ¼esz opcjonalnie okreÅ›liÄ‡ <em>etykietÄ™
pÄ™tli</em> dla pÄ™tli, ktÃ³rÄ… nastÄ™pnie moÅ¼esz uÅ¼yÄ‡ z <code>break</code> lub <code>continue</code>, aby
okreÅ›liÄ‡, Å¼e te sÅ‚owa kluczowe dotyczÄ… oznaczonej pÄ™tli, a nie najbardziej
wewnÄ™trznej. Etykiety pÄ™tli muszÄ… zaczynaÄ‡ siÄ™ od pojedynczego cudzysÅ‚owu.
Oto przykÅ‚ad z dwoma zagnieÅ¼dÅ¼onymi pÄ™tlami:</p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("licznik = {count}");
        let mut remaining = 10;

        loop {
            println!("pozostaÅ‚o = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("KoÅ„cowy licznik = {count}");
}</code></pre>
<p>ZewnÄ™trzna pÄ™tla ma etykietÄ™ <code>'counting_up</code> i bÄ™dzie liczyÄ‡ od 0 do 2.
WewnÄ™trzna pÄ™tla bez etykiety liczy od 10 do 9. Pierwszy <code>break</code>, ktÃ³ry nie
okreÅ›la etykiety, zakoÅ„czy tylko wewnÄ™trznÄ… pÄ™tlÄ™. Instrukcja <code>break 'counting_up;</code> zakoÅ„czy zewnÄ™trznÄ… pÄ™tlÄ™. Ten kod wypisuje:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
licznik = 0
pozostaÅ‚o = 10
pozostaÅ‚o = 9
licznik = 1
pozostaÅ‚o = 10
pozostaÅ‚o = 9
licznik = 2
pozostaÅ‚o = 10
KoÅ„cowy licznik = 2
</code></pre>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="conditional-loops-with-while"></a></p>
<h4 id="upraszczanie-pÄ™tli-warunkowych-za-pomocÄ…-while"><a class="header" href="#upraszczanie-pÄ™tli-warunkowych-za-pomocÄ…-while">Upraszczanie pÄ™tli warunkowych za pomocÄ… <code>while</code></a></h4>
<p>Program czÄ™sto musi oceniaÄ‡ warunek wewnÄ…trz pÄ™tli. DopÃ³ki warunek jest <code>true</code>,
pÄ™tla dziaÅ‚a. Gdy warunek przestaje byÄ‡ <code>true</code>, program wywoÅ‚uje <code>break</code>,
zatrzymujÄ…c pÄ™tlÄ™. MoÅ¼liwe jest zaimplementowanie takiego zachowania za pomocÄ…
poÅ‚Ä…czenia <code>loop</code>, <code>if</code>, <code>else</code> i <code>break</code>; moÅ¼esz sprÃ³bowaÄ‡ tego teraz w
programie, jeÅ›li chcesz. Jednak ten wzorzec jest tak powszechny, Å¼e Rust ma
wbudowanÄ… konstrukcjÄ™ jÄ™zykowÄ… dla niego, zwanÄ… pÄ™tlÄ… <code>while</code>. W Listingu 3-3
uÅ¼ywamy <code>while</code>, aby zapÄ™tliÄ‡ program trzy razy, odliczajÄ…c za kaÅ¼dym razem,
a nastÄ™pnie, po pÄ™tli, wypisaÄ‡ wiadomoÅ›Ä‡ i zakoÅ„czyÄ‡ dziaÅ‚anie.</p>
<listing number="3-3" file-name="src/main.rs" caption="UÅ¼ywanie pÄ™tli `while` do uruchamiania kodu, dopÃ³ki warunek ocenia siÄ™ na `true`">
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("START!!!");
}</code></pre>
</listing>
<p>Ta konstrukcja eliminuje wiele zagnieÅ¼dÅ¼eÅ„, ktÃ³re byÅ‚yby konieczne, gdybyÅ›
uÅ¼ywaÅ‚ <code>loop</code>, <code>if</code>, <code>else</code> i <code>break</code>, i jest bardziej przejrzysta.
DopÃ³ki warunek ocenia siÄ™ na <code>true</code>, kod dziaÅ‚a; w przeciwnym razie wychodzi
z pÄ™tli.</p>
<h4 id="przeglÄ…danie-kolekcji-za-pomocÄ…-for"><a class="header" href="#przeglÄ…danie-kolekcji-za-pomocÄ…-for">PrzeglÄ…danie kolekcji za pomocÄ… <code>for</code></a></h4>
<p>MoÅ¼esz uÅ¼yÄ‡ konstrukcji <code>while</code> do iteracji po elementach kolekcji, takiej jak
tablica. Na przykÅ‚ad, pÄ™tla w Listingu 3-4 wypisuje kaÅ¼dy element w tablicy <code>a</code>.</p>
<listing number="3-4" file-name="src/main.rs" caption="Iterowanie po kaÅ¼dym elemencie kolekcji za pomocÄ… pÄ™tli `while`">
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!("wartoÅ›Ä‡ to: {}", a[index]);

        index += 1;
    }
}</code></pre>
</listing>
<p>Tutaj kod liczy elementy w tablicy. Zaczyna od indeksu <code>0</code>, a nastÄ™pnie zapÄ™tla
siÄ™, aÅ¼ osiÄ…gnie ostatni indeks w tablicy (czyli, gdy <code>index &lt; 5</code> przestaje byÄ‡
<code>true</code>). Uruchomienie tego kodu wypisze kaÅ¼dy element w tablicy:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
wartoÅ›Ä‡ to: 10
wartoÅ›Ä‡ to: 20
wartoÅ›Ä‡ to: 30
wartoÅ›Ä‡ to: 40
wartoÅ›Ä‡ to: 50
</code></pre>
<p>Wszystkie piÄ™Ä‡ wartoÅ›ci tablicy pojawia siÄ™ w terminalu, zgodnie z oczekiwaniami.
Mimo Å¼e <code>index</code> osiÄ…gnie wartoÅ›Ä‡ <code>5</code> w pewnym momencie, pÄ™tla przestaje siÄ™
wykonywaÄ‡ przed prÃ³bÄ… pobrania szÃ³stej wartoÅ›ci z tablicy.</p>
<p>Jednak to podejÅ›cie jest podatne na bÅ‚Ä™dy; moglibyÅ›my spowodowaÄ‡ panikÄ™
programu, jeÅ›li wartoÅ›Ä‡ indeksu lub warunek testowy sÄ… niepoprawne. Na
przykÅ‚ad, jeÅ›li zmieniÅ‚eÅ› definicjÄ™ tablicy <code>a</code> na cztery elementy, ale
zapomniaÅ‚eÅ› zaktualizowaÄ‡ warunek na <code>while index &lt; 4</code>, kod ulegÅ‚by panice.
Jest to rÃ³wnieÅ¼ wolne, poniewaÅ¼ kompilator dodaje kod wykonawczy do
wykonywania kontroli warunkowej, czy indeks znajduje siÄ™ w granicach tablicy w
kaÅ¼dej iteracji pÄ™tli.</p>
<p>Jako bardziej zwiÄ™zÅ‚Ä… alternatywÄ™, moÅ¼esz uÅ¼yÄ‡ pÄ™tli <code>for</code> i wykonaÄ‡ kod dla
kaÅ¼dego elementu w kolekcji. PÄ™tla <code>for</code> wyglÄ…da jak kod w Listingu 3-5.</p>
<listing number="3-5" file-name="src/main.rs" caption="Iterowanie po kaÅ¼dym elemencie kolekcji za pomocÄ… pÄ™tli `for`">
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("wartoÅ›Ä‡ to: {element}");
    }
}</code></pre>
</listing>
<p>Kiedy uruchomimy ten kod, zobaczymy ten sam wynik co w Listingu 3-4. Co
waÅ¼niejsze, zwiÄ™kszyliÅ›my teraz bezpieczeÅ„stwo kodu i wyeliminowaliÅ›my
moÅ¼liwoÅ›Ä‡ bÅ‚Ä™dÃ³w, ktÃ³re mogÅ‚yby wyniknÄ…Ä‡ z wyjÅ›cia poza koniec tablicy lub
niewystarczajÄ…cego przeszukania i pominiÄ™cia niektÃ³rych elementÃ³w. Kod
maszynowy generowany z pÄ™tli <code>for</code> moÅ¼e byÄ‡ rÃ³wnieÅ¼ bardziej wydajny,
poniewaÅ¼ indeks nie musi byÄ‡ porÃ³wnywany z dÅ‚ugoÅ›ciÄ… tablicy w kaÅ¼dej
iteracji.</p>
<p>UÅ¼ywajÄ…c pÄ™tli <code>for</code>, nie musiaÅ‚byÅ› pamiÄ™taÄ‡ o zmienianiu Å¼adnego innego kodu,
gdybyÅ› zmieniÅ‚ liczbÄ™ wartoÅ›ci w tablicy, tak jak to miaÅ‚o miejsce w metodzie
uÅ¼ytej w Listingu 3-4.</p>
<p>BezpieczeÅ„stwo i zwiÄ™zÅ‚oÅ›Ä‡ pÄ™tli <code>for</code> sprawiajÄ…, Å¼e sÄ… one najczÄ™Å›ciej
uÅ¼ywanÄ… konstrukcjÄ… pÄ™tli w RuÅ›cie. Nawet w sytuacjach, gdy chcesz uruchomiÄ‡
jakiÅ› kod okreÅ›lonÄ… liczbÄ™ razy, jak w przykÅ‚adzie odliczania, ktÃ³ry uÅ¼ywaÅ‚
pÄ™tli <code>while</code> w Listingu 3-3, wiÄ™kszoÅ›Ä‡ RustaceanÃ³w uÅ¼yÅ‚aby pÄ™tli <code>for</code>. SposÃ³b
na to polegaÅ‚by na uÅ¼yciu <code>Range</code>, dostarczanego przez bibliotekÄ™ standardowÄ…,
ktÃ³ry generuje wszystkie liczby w sekwencji, zaczynajÄ…c od jednej liczby i
koÅ„czÄ…c przed innÄ… liczbÄ….</p>
<p>Oto jak wyglÄ…daÅ‚oby odliczanie za pomocÄ… pÄ™tli <code>for</code> i innej metody, o ktÃ³rej
jeszcze nie mÃ³wiliÅ›my, <code>rev</code>, do odwracania zakresu:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("START!!!");
}</code></pre>
<p>Ten kod jest trochÄ™ Å‚adniejszy, prawda?</p>
<h2 id="podsumowanie-2"><a class="header" href="#podsumowanie-2">Podsumowanie</a></h2>
<p>UdaÅ‚o siÄ™! DotarÅ‚eÅ› do koÅ„ca obszernego rozdziaÅ‚u: nauczyÅ‚eÅ› siÄ™ o zmiennych,
skalarnych i zÅ‚oÅ¼onych typach danych, funkcjach, komentarzach, wyraÅ¼eniach
<code>if</code> i pÄ™tlach! Aby poÄ‡wiczyÄ‡ koncepcje omÃ³wione w tym rozdziale, sprÃ³buj
zbudowaÄ‡ programy, aby wykonaÄ‡ nastÄ™pujÄ…ce zadania:</p>
<ul>
<li>Konwertowanie temperatur miÄ™dzy stopniami Fahrenheita i Celsjusza.</li>
<li>Generowanie <em>n</em>-tej liczby Fibonacciego.</li>
<li>Wypisywanie tekstu kolÄ™dy â€The Twelve Days of Christmasâ€, wykorzystujÄ…c
powtÃ³rzenia w piosence.</li>
</ul>
<p>Kiedy bÄ™dziesz gotowy, przejdziemy do koncepcji w RuÅ›cie, ktÃ³ra <em>nie</em> wystÄ™puje
powszechnie w innych jÄ™zykach programowania: wÅ‚asnoÅ›ci.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="zrozumienie-wÅ‚asnoÅ›ci"><a class="header" href="#zrozumienie-wÅ‚asnoÅ›ci">Zrozumienie wÅ‚asnoÅ›ci</a></h1>
<p>WÅ‚asnoÅ›Ä‡ to najbardziej unikalna cecha Rusta i ma gÅ‚Ä™bokie implikacje dla
pozostaÅ‚ej czÄ™Å›ci jÄ™zyka. UmoÅ¼liwia Rustowi gwarantowanie bezpieczeÅ„stwa
pamiÄ™ci bez potrzeby zbierania Å›mieci, dlatego waÅ¼ne jest zrozumienie, jak
dziaÅ‚a wÅ‚asnoÅ›Ä‡. W tym rozdziale omÃ³wimy wÅ‚asnoÅ›Ä‡, a takÅ¼e kilka
powiÄ…zanych funkcji: poÅ¼yczanie, wycinki i sposÃ³b, w jaki Rust rozmieszcza dane
w pamiÄ™ci.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="czym-jest-wÅ‚asnoÅ›Ä‡-1"><a href="#czym-jest-wÅ‚asnoÅ›Ä‡-1" class="header">Czym jest WÅ‚asnoÅ›Ä‡?</a></h1>
<h2 id="czym-jest-wÅ‚asnoÅ›Ä‡"><a class="header" href="#czym-jest-wÅ‚asnoÅ›Ä‡">Czym jest WÅ‚asnoÅ›Ä‡?</a></h2>
<p><em>WÅ‚asnoÅ›Ä‡</em> to zbiÃ³r zasad, ktÃ³re okreÅ›lajÄ…, w jaki sposÃ³b program w Rust zarzÄ…dza pamiÄ™ciÄ….Wszystkie programy muszÄ… zarzÄ…dzaÄ‡ sposobem, w jaki wykorzystujÄ… pamiÄ™Ä‡ komputera podczas dziaÅ‚ania.NiektÃ³re jÄ™zyki majÄ… zbieranie Å›mieci, ktÃ³re regularnie szuka nieuÅ¼ywanej juÅ¼ pamiÄ™cipamiÄ™ci podczas dziaÅ‚ania programu; w innych jÄ™zykach programista musi jawnieprzydzieliÄ‡ i zwolniÄ‡ pamiÄ™Ä‡. Rust uÅ¼ywa trzeciego podejÅ›cia: PamiÄ™Ä‡ jest zarzÄ…dzanaprzez system wÅ‚asnoÅ›ci z zestawem zasad, ktÃ³re kompilator sprawdza. JeÅ›liktÃ³rakolwiek z zasad zostanie naruszona, program siÄ™ nie skompiluje. Å»adna z funkcjiwÅ‚asnoÅ›ci nie spowolni programu podczas jego dziaÅ‚ania.</p>
<p>PoniewaÅ¼ wÅ‚asnoÅ›Ä‡ jest nowÄ… koncepcjÄ… dla wielu programistÃ³w, przyzwyczajenie siÄ™ do niej zajmuje trochÄ™ czasu.DobrÄ… wiadomoÅ›ciÄ… jest to, Å¼e im bardziej doÅ›wiadczony bÄ™dziesz w Rusti zasadach systemu wÅ‚asnoÅ›ci, tym Å‚atwiej bÄ™dzie ci naturalnierozwinÄ…Ä‡ kod, ktÃ³ry jest bezpieczny i wydajny. Trzymaj tak dalej!</p>
<p>Kiedy zrozumiesz wÅ‚asnoÅ›Ä‡, bÄ™dziesz mieÄ‡ solidne podstawy do zrozumieniafunkcji, ktÃ³re sprawiajÄ…, Å¼e Rust jest unikalny. W tym rozdziale poznasz wÅ‚asnoÅ›Ä‡,pracujÄ…c nad przykÅ‚adami, ktÃ³re koncentrujÄ… siÄ™ na bardzo popularnej strukturze danych:ciÄ…gach znakÃ³w.</p>
<blockquote>
<h3 id="stos-i-sterta"><a class="header" href="#stos-i-sterta">Stos i sterta</a></h3>
<p>Wiele jÄ™zykÃ³w programowania nie wymaga od ciebie zbyt czÄ™stego myÅ›lenia o stosie i stercie.Ale w jÄ™zyku programowania systemowego, takim jak Rust, to, czy wartoÅ›Ä‡ znajduje siÄ™ na stosie, czy na stercie,wpÅ‚ywa na zachowanie jÄ™zyka i na to, dlaczego musisz podejmowaÄ‡ pewne decyzje.CzÄ™Å›ci wÅ‚asnoÅ›ci zostanÄ… opisane w odniesieniu do stosu i stertyw dalszej czÄ™Å›ci tego rozdziaÅ‚u, wiÄ™c oto krÃ³tkie wyjaÅ›nienie w przygotowaniu.</p>
<p>ZarÃ³wno stos, jak i sterta sÄ… czÄ™Å›ciami pamiÄ™ci dostÄ™pnymi dla twojego kodu do uÅ¼yciaw czasie wykonywania, ale sÄ… one strukturalizowane w rÃ³Å¼ny sposÃ³b. Stos przechowuje wartoÅ›ciw kolejnoÅ›ci, w jakiej je otrzymuje, i usuwa wartoÅ›ci w odwrotnej kolejnoÅ›ci.Jest to okreÅ›lane jako <em>ostatnie weszÅ‚o, pierwsze wyszÅ‚o (LIFO)</em>. PomyÅ›l o stosietalerzy: Kiedy dodajesz wiÄ™cej talerzy, kÅ‚adziesz je na wierzchu stosu, a kiedypotrzebujesz talerza, bierzesz jeden z gÃ³ry. Dodawanie lub usuwanie talerzy ze Å›rodka lub z doÅ‚u nie dziaÅ‚aÅ‚oby tak dobrze!Dodawanie danych nazywa siÄ™ <em>wkÅ‚adaniem na stos</em>, a usuwanie danych nazywa siÄ™ <em>zdejmowaniem ze stosu</em>.Wszystkie dane przechowywane na stosie muszÄ… mieÄ‡ znanÄ…, staÅ‚Ä… wielkoÅ›Ä‡.Dane o nieznanym rozmiarze w czasie kompilacji lub rozmiarze, ktÃ³ry moÅ¼e siÄ™ zmieniÄ‡, muszÄ… byÄ‡ przechowywanena stercie.</p>
<p>Sterta jest mniej zorganizowana: Kiedy umieszczasz dane na stercie, Å¼Ä…daszwielkoÅ›ci miejsca. Alokator pamiÄ™ci znajduje wolne miejsce na stercie,ktÃ³re jest wystarczajÄ…co duÅ¼e, oznacza je jako zajÄ™te i zwraca <em>wskaÅºnik</em>,ktÃ³ry jest adresem tej lokalizacji. Ten proces nazywa siÄ™ _alokacjÄ… na stercie_i jest czasami skracany do samego <em>alokowania</em> (wkÅ‚adanie wartoÅ›ci na stos nie jest uwaÅ¼ane za alokacjÄ™).PoniewaÅ¼ wskaÅºnik do sterty ma znanÄ…, staÅ‚Ä… wielkoÅ›Ä‡, moÅ¼esz przechowywaÄ‡ wskaÅºnik na stosie,ale kiedy chcesz uzyskaÄ‡ rzeczywiste dane, musisz podÄ…Å¼aÄ‡ za wskaÅºnikiem.PomyÅ›l o tym, jakbyÅ› siedziaÅ‚ w restauracji. Kiedy wchodzisz, podajesz liczbÄ™osÃ³b w twojej grupie, a host znajduje pusty stÃ³Å‚, ktÃ³ry pasuje do wszystkich,i prowadzi ciÄ™ tam. JeÅ›li ktoÅ› z twojej grupy spÃ³Åºni siÄ™, moÅ¼e zapytaÄ‡,gdzie zostaÅ‚eÅ› usadzony, aby ciÄ™ znaleÅºÄ‡.</p>
<p>WkÅ‚adanie na stos jest szybsze niÅ¼ alokowanie na stercie, poniewaÅ¼ alokator nigdy nie musi szukaÄ‡miejsca do przechowywania nowych danych; ta lokalizacja zawsze znajduje siÄ™ na szczycie stosu.W porÃ³wnaniu, alokacja miejsca na stercie wymaga wiÄ™cej pracy, poniewaÅ¼ alokator musinajpierw znaleÅºÄ‡ wystarczajÄ…co duÅ¼o miejsca, aby pomieÅ›ciÄ‡ dane, a nastÄ™pnie wykonaÄ‡ ksiÄ™gowoÅ›Ä‡,aby przygotowaÄ‡ siÄ™ do nastÄ™pnej alokacji.</p>
<p>DostÄ™p do danych na stercie jest zazwyczaj wolniejszy niÅ¼ dostÄ™p do danych na stosie,poniewaÅ¼ musisz podÄ…Å¼aÄ‡ za wskaÅºnikiem, aby tam dotrzeÄ‡. WspÃ³Å‚czesne procesorysÄ… szybsze, jeÅ›li mniej skaczÄ… po pamiÄ™ci. KontynuujÄ…c analogiÄ™,rozwaÅ¼ kelnera w restauracji przyjmujÄ…cego zamÃ³wienia od wielu stolikÃ³w.Najbardziej efektywne jest zebranie wszystkich zamÃ³wieÅ„ przy jednym stole, zanim przejdzie siÄ™ do nastÄ™pnego.Przyjmowanie zamÃ³wienia ze stoÅ‚u A, nastÄ™pnie zamÃ³wienia ze stoÅ‚u B,nastÄ™pnie ponownie z A, a nastÄ™pnie ponownie z B, byÅ‚oby znacznie wolniejszym procesem.W ten sam sposÃ³b procesor zazwyczaj lepiej wykonuje swojÄ… pracÄ™, jeÅ›lidziaÅ‚a na danych, ktÃ³re sÄ… blisko innych danych (jak na stosie),a nie dalej (jak moÅ¼e byÄ‡ na stercie).</p>
<p>Kiedy twÃ³j kod wywoÅ‚uje funkcjÄ™, wartoÅ›ci przekazane do funkcji(w tym, potencjalnie, wskaÅºniki do danych na stercie) i zmienne lokalne funkcji sÄ…wkÅ‚adane na stos. Kiedy funkcja siÄ™ koÅ„czy, te wartoÅ›ci sÄ… usuwane ze stosu.</p>
<p>Åšledzenie, ktÃ³re czÄ™Å›ci kodu uÅ¼ywajÄ… jakich danych na stercie,minimalizowanie iloÅ›ci zduplikowanych danych na stercie i czyszczenie nieuÅ¼ywanychdanych na stercie, aby nie zabrakÅ‚o miejsca, to problemyczne kwestie,ktÃ³re adresuje system wÅ‚asnoÅ›ci. Kiedy zrozumiesz wÅ‚asnoÅ›Ä‡,nie bÄ™dziesz musiaÅ‚ czÄ™sto myÅ›leÄ‡ o stosie i stercie.Ale wiedzÄ…c, Å¼e gÅ‚Ã³wnym celem wÅ‚asnoÅ›ci jest zarzÄ…dzanie danymi na stercie,moÅ¼e to pomÃ³c wyjaÅ›niÄ‡, dlaczego dziaÅ‚a to tak, jak dziaÅ‚a.</p>
</blockquote>
<h3 id="zasady-wÅ‚asnoÅ›ci"><a class="header" href="#zasady-wÅ‚asnoÅ›ci">Zasady WÅ‚asnoÅ›ci</a></h3>
<p>Najpierw przyjrzyjmy siÄ™ zasadom wÅ‚asnoÅ›ci. PamiÄ™taj o nich,gdy bÄ™dziemy przechodziÄ‡ przez przykÅ‚ady, ktÃ³re je ilustrujÄ…:</p>
<ul>
<li>KaÅ¼da wartoÅ›Ä‡ w Rust ma <em>wÅ‚aÅ›ciciela</em>.</li>
<li>W danym momencie moÅ¼e byÄ‡ tylko jeden wÅ‚aÅ›ciciel.</li>
<li>Gdy wÅ‚aÅ›ciciel wyjdzie poza zasiÄ™g, wartoÅ›Ä‡ zostanie usuniÄ™ta (<em>dropped</em>).</li>
</ul>
<h3 id="zasiÄ™g-zmiennych"><a class="header" href="#zasiÄ™g-zmiennych">ZasiÄ™g zmiennych</a></h3>
<p>Teraz, gdy podstawowa skÅ‚adnia Rust jest juÅ¼ za nami, nie bÄ™dziemy zawieraÄ‡ caÅ‚ego kodu <code>fn main() {</code> w przykÅ‚adach, wiÄ™c jeÅ›li Å›ledzisz, upewnij siÄ™, Å¼e umieÅ›ciÅ‚eÅ› poniÅ¼sze przykÅ‚ady rÄ™cznie w funkcji <code>main</code>. W rezultacie nasze przykÅ‚ady bÄ™dÄ… nieco bardziej zwiÄ™zÅ‚e, pozwalajÄ…c nam skupiÄ‡ siÄ™ na rzeczywistych szczegÃ³Å‚ach, a nie na kodzie szablonowym.</p>
<p>Jako pierwszy przykÅ‚ad wÅ‚asnoÅ›ci, przyjrzymy siÄ™ zasiÄ™gowi niektÃ³rych zmiennych. <em>ZasiÄ™g</em> to zakres w programie, w ktÃ³rym element jest waÅ¼ny. WeÅºmy nastÄ™pujÄ…cÄ… zmiennÄ…:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "hello";
<span class="boring">}</span></code></pre>
<p>Zmienna <code>s</code> odnosi siÄ™ do literaÅ‚u ciÄ…gu znakÃ³w, gdzie wartoÅ›Ä‡ ciÄ…gu jest zakodowana bezpoÅ›rednio w tekÅ›cie naszego programu. Zmienna jest waÅ¼na od momentu jej zadeklarowania do koÅ„ca bieÅ¼Ä…cego zasiÄ™gu. Listing 4-1 przedstawia program z komentarzami oznaczajÄ…cymi, gdzie zmienna <code>s</code> byÅ‚aby waÅ¼na.</p>
<listing number="4-1" caption="Zmienna i zasiÄ™g, w ktÃ³rym jest waÅ¼na">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    {                      // s jest tutaj niewaÅ¼ne, poniewaÅ¼ nie zostaÅ‚o jeszcze zadeklarowane
        let s = "hello";   // s jest waÅ¼ne od tego momentu

        // rÃ³b coÅ› z s
    }                      // ten zasiÄ™g siÄ™ skoÅ„czyÅ‚, a s jest juÅ¼ niewaÅ¼ne
<span class="boring">}</span></code></pre>
</listing>
<p>Innymi sÅ‚owy, sÄ… tutaj dwa waÅ¼ne momenty w czasie:</p>
<ul>
<li>Kiedy <code>s</code> wchodzi <em>w</em> zasiÄ™g, jest waÅ¼ne.</li>
<li>Pozostaje waÅ¼ne, dopÃ³ki nie wyjdzie <em>z</em> zasiÄ™gu.</li>
</ul>
<p>Na tym etapie, zwiÄ…zek miÄ™dzy zasiÄ™gami a waÅ¼noÅ›ciÄ… zmiennych jest podobny jak w innych jÄ™zykach programowania. Teraz bÄ™dziemy budowaÄ‡ na tym zrozumieniu, wprowadzajÄ…c typ <code>String</code>.</p>
<h3 id="typ-string"><a class="header" href="#typ-string">Typ <code>String</code></a></h3>
<p>Aby zilustrowaÄ‡ zasady wÅ‚asnoÅ›ci, potrzebujemy typu danych, ktÃ³ry jest bardziej zÅ‚oÅ¼ony niÅ¼ te, ktÃ³re omÃ³wiliÅ›my w sekcji <a href="#data-types">â€Typy danychâ€</a><!-- ignore --> w Rozdziale 3. WczeÅ›niej omÃ³wione typy majÄ… znany rozmiar, mogÄ… byÄ‡ przechowywane na stosie i zdejmowane ze stosu po zakoÅ„czeniu ich zasiÄ™gu, oraz mogÄ… byÄ‡ szybko i trywialnie kopiowane, aby utworzyÄ‡ nowÄ…, niezaleÅ¼nÄ… instancjÄ™, jeÅ›li inna czÄ™Å›Ä‡ kodu musi uÅ¼yÄ‡ tej samej wartoÅ›ci w innym zasiÄ™gu. Chcemy jednak przyjrzeÄ‡ siÄ™ danym przechowywanym na stercie i zbadaÄ‡, w jaki sposÃ³b Rust wie, kiedy te dane posprzÄ…taÄ‡, a typ <code>String</code> jest doskonaÅ‚ym przykÅ‚adem.</p>
<p>Skoncentrujemy siÄ™ na czÄ™Å›ciach <code>String</code>, ktÃ³re odnoszÄ… siÄ™ do wÅ‚asnoÅ›ci. Te aspekty dotyczÄ… rÃ³wnieÅ¼ innych zÅ‚oÅ¼onych typÃ³w danych, niezaleÅ¼nie od tego, czy sÄ… dostarczane przez bibliotekÄ™ standardowÄ…, czy stworzone przez ciebie. Aspekty <code>String</code> niezwiÄ…zane z wÅ‚asnoÅ›ciÄ… omÃ³wimy w <a href="#przechowywanie-tekstu-zakodowanego-w-utf-8-za-pomocÄ…-ciÄ…gÃ³w-znakÃ³w-1">Rozdziale 8</a><!-- ignore -->.</p>
<p>WidzieliÅ›my juÅ¼ literaÅ‚y ciÄ…gÃ³w znakÃ³w, gdzie wartoÅ›Ä‡ ciÄ…gu jest zakodowana na staÅ‚e w naszym programie. LiteraÅ‚y ciÄ…gÃ³w znakÃ³w sÄ… wygodne, ale nie nadajÄ… siÄ™ do kaÅ¼dej sytuacji, w ktÃ³rej moÅ¼emy chcieÄ‡ uÅ¼yÄ‡ tekstu. Jednym z powodÃ³w jest to, Å¼e sÄ… one niezmienne. InnÄ… przyczynÄ… jest to, Å¼e nie kaÅ¼da wartoÅ›Ä‡ ciÄ…gu moÅ¼e byÄ‡ znana, gdy piszemy nasz kod: na przykÅ‚ad, co jeÅ›li chcemy pobraÄ‡ dane od uÅ¼ytkownika i je zapisaÄ‡? WÅ‚aÅ›nie dla takich sytuacji Rust ma typ <code>String</code>. Ten typ zarzÄ…dza danymi alokowanymi na stercie i jako taki jest w stanie przechowywaÄ‡ iloÅ›Ä‡ tekstu, ktÃ³ra jest nam nieznana w czasie kompilacji. MoÅ¼esz utworzyÄ‡ <code>String</code> z literaÅ‚u ciÄ…gu znakÃ³w za pomocÄ… funkcji <code>from</code>, w ten sposÃ³b:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");
<span class="boring">}</span></code></pre>
<p>Operator podwÃ³jnego dwukropka <code>::</code> pozwala nam na umieszczenie funkcji <code>from</code> w przestrzeni nazw typu <code>String</code>, zamiast uÅ¼ywaÄ‡ nazwy takiej jak <code>string_from</code>. WiÄ™cej o tej skÅ‚adni omÃ³wimy w sekcji <a href="#methods">â€Metodyâ€</a><!-- ignore --> w Rozdziale 5, oraz gdy bÄ™dziemy mÃ³wiÄ‡ o przestrzeniach nazw z moduÅ‚ami w sekcji <a href="#Å›cieÅ¼ki-do-odwoÅ‚ywania-siÄ™-do-elementu-w-drzewie-moduÅ‚Ã³w-1">â€ÅšcieÅ¼ki do odwoÅ‚ywania siÄ™ do elementu w drzewie moduÅ‚Ã³wâ€</a><!-- ignore --> w Rozdziale 7.</p>
<p>Tego rodzaju ciÄ…g <em>moÅ¼e</em> byÄ‡ mutowalny:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() dodaje literaÅ‚ do String

    println!("{s}"); // to wyÅ›wietli `hello, world!`
<span class="boring">}</span></code></pre>
<p>WiÄ™c, jaka jest tutaj rÃ³Å¼nica? Dlaczego <code>String</code> moÅ¼e byÄ‡ mutowalny, a literaÅ‚y nie? RÃ³Å¼nica tkwi w sposobie, w jaki te dwa typy obsÅ‚ugujÄ… pamiÄ™Ä‡.</p>
<h3 id="pamiÄ™Ä‡-i-alokacja"><a class="header" href="#pamiÄ™Ä‡-i-alokacja">PamiÄ™Ä‡ i Alokacja</a></h3>
<p>W przypadku literaÅ‚u ciÄ…gu znakÃ³w, znamy jego zawartoÅ›Ä‡ w czasie kompilacji, wiÄ™c tekst jest zakodowany bezpoÅ›rednio w finalnym pliku wykonywalnym. Dlatego literaÅ‚y ciÄ…gÃ³w znakÃ³w sÄ… szybkie i wydajne. Ale te wÅ‚aÅ›ciwoÅ›ci wynikajÄ… tylko z niezmiennoÅ›ci literaÅ‚u ciÄ…gu znakÃ³w. Niestety, nie moÅ¼emy umieÅ›ciÄ‡ bloku pamiÄ™ci w pliku binarnym dla kaÅ¼dego fragmentu tekstu, ktÃ³rego rozmiar jest nieznany w czasie kompilacji i ktÃ³rego rozmiar moÅ¼e zmieniaÄ‡ siÄ™ podczas dziaÅ‚ania programu.</p>
<p>Z typem <code>String</code>, aby obsÅ‚ugiwaÄ‡ zmienny, rozszerzalny fragment tekstu, musimy zaalokowaÄ‡ na stercie iloÅ›Ä‡ pamiÄ™ci, nieznanÄ… w czasie kompilacji, aby pomieÅ›ciÄ‡ zawartoÅ›Ä‡. Oznacza to:</p>
<ul>
<li>PamiÄ™Ä‡ musi byÄ‡ Å¼Ä…dana od alokatora pamiÄ™ci w czasie wykonywania.</li>
<li>Potrzebujemy sposobu na zwrÃ³cenie tej pamiÄ™ci alokatorowi, gdy skoÅ„czymy z naszym <code>String</code>.</li>
</ul>
<p>Ta pierwsza czÄ™Å›Ä‡ jest wykonywana przez nas: Kiedy wywoÅ‚ujemy <code>String::from</code>, jego implementacja Å¼Ä…da potrzebnej pamiÄ™ci. Jest to doÅ›Ä‡ powszechne w jÄ™zykach programowania.</p>
<p>Jednak druga czÄ™Å›Ä‡ jest inna. W jÄ™zykach z <em>garbage collector (GC)</em>, GC Å›ledzi i usuwa pamiÄ™Ä‡, ktÃ³ra nie jest juÅ¼ uÅ¼ywana, i nie musimy o tym myÅ›leÄ‡. W wiÄ™kszoÅ›ci jÄ™zykÃ³w bez GC, to nasza odpowiedzialnoÅ›Ä‡, aby zidentyfikowaÄ‡, kiedy pamiÄ™Ä‡ nie jest juÅ¼ uÅ¼ywana i wywoÅ‚aÄ‡ kod, aby jawnie jÄ… zwolniÄ‡, tak jak robiliÅ›my to, aby jÄ… zaÅ¼Ä…daÄ‡. Robienie tego poprawnie byÅ‚o historycznie trudnym problemem programistycznym. JeÅ›li zapomnimy, zmarnujemy pamiÄ™Ä‡. JeÅ›li zrobimy to zbyt wczeÅ›nie, bÄ™dziemy mieÄ‡ nieprawidÅ‚owÄ… zmiennÄ…. JeÅ›li zrobimy to dwukrotnie, to teÅ¼ jest bÅ‚Ä…d. Musimy sparowaÄ‡ dokÅ‚adnie jednÄ… <code>allocate</code> z dokÅ‚adnie jednÄ… <code>free</code>.</p>
<p>Rust obiera innÄ… Å›cieÅ¼kÄ™: PamiÄ™Ä‡ jest automatycznie zwracana, gdy zmienna, ktÃ³ra jÄ… posiada, wyjdzie poza zasiÄ™g. Oto wersja naszego przykÅ‚adu zasiÄ™gu z Listingu 4-1, uÅ¼ywajÄ…ca <code>String</code> zamiast literaÅ‚u ciÄ…gu znakÃ³w:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    {
        let s = String::from("hello"); // s jest waÅ¼ne od tego momentu

        // rÃ³b coÅ› z s
    }                                  // ten zasiÄ™g siÄ™ skoÅ„czyÅ‚, a s jest juÅ¼
                                       // niewaÅ¼ne
<span class="boring">}</span></code></pre>
<p>Istnieje naturalny moment, w ktÃ³rym moÅ¼emy zwrÃ³ciÄ‡ pamiÄ™Ä‡ potrzebnÄ… naszej <code>String</code> alokatorowi: kiedy <code>s</code> wyjdzie poza zasiÄ™g. Kiedy zmienna wychodzi poza zasiÄ™g, Rust wywoÅ‚uje dla nas specjalnÄ… funkcjÄ™. Funkcja ta nazywa siÄ™ <a href="../std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a><!-- ignore --> i to w niej autor <code>String</code> moÅ¼e umieÅ›ciÄ‡ kod do zwracania pamiÄ™ci. Rust automatycznie wywoÅ‚uje <code>drop</code> przy zamykajÄ…cym nawiasie klamrowym.</p>
<blockquote>
<p>Uwaga: W C++ ten wzorzec dealokowania zasobÃ³w na koÅ„cu Å¼ycia elementu jest czasami nazywany <em>Resource Acquisition Is Initialization (RAII)</em>. Funkcja <code>drop</code> w Rust bÄ™dzie ci znana, jeÅ›li uÅ¼ywaÅ‚eÅ› wzorcÃ³w RAII.</p>
</blockquote>
<p>Ten wzorzec ma gÅ‚Ä™boki wpÅ‚yw na sposÃ³b pisania kodu w Rust. MoÅ¼e wydawaÄ‡ siÄ™ prosty teraz, ale zachowanie kodu moÅ¼e byÄ‡ nieoczekiwane w bardziej skomplikowanych sytuacjach, gdy chcemy, aby wiele zmiennych uÅ¼ywaÅ‚o danych, ktÃ³re zaalokowaliÅ›my na stercie. Przyjrzyjmy siÄ™ teraz kilku z tych sytuacji.</p>
<p><a id="ways-variables-and-data-interact-move"></a></p>
<h4 id="zmienne-i-dane-w-interakcji-przez-przeniesienie-move"><a class="header" href="#zmienne-i-dane-w-interakcji-przez-przeniesienie-move">Zmienne i Dane w Interakcji przez Przeniesienie (Move)</a></h4>
<p>W Rust wiele zmiennych moÅ¼e wchodziÄ‡ w interakcjÄ™ z tymi samymi danymi na rÃ³Å¼ne sposoby. Listing 4-2 przedstawia przykÅ‚ad uÅ¼ycia liczby caÅ‚kowitej.</p>
<listing number="4-2" caption="Przypisanie wartoÅ›ci caÅ‚kowitej zmiennej `x` do `y`">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}</span></code></pre>
</listing>
<p>Prawdopodobnie moÅ¼emy zgadnÄ…Ä‡, co to robi: â€Przypisz wartoÅ›Ä‡ <code>5</code> do <code>x</code>; nastÄ™pnie, utwÃ³rz kopiÄ™ wartoÅ›ci z <code>x</code> i przypisz jÄ… do <code>y</code>.â€ Mamy teraz dwie zmienne, <code>x</code> i <code>y</code>, i obie sÄ… rÃ³wne <code>5</code>. Tak wÅ‚aÅ›nie siÄ™ dzieje, poniewaÅ¼ liczby caÅ‚kowite sÄ… prostymi wartoÅ›ciami o znanym, staÅ‚ym rozmiarze, a te dwie wartoÅ›ci <code>5</code> sÄ… umieszczane na stosie.</p>
<p>Teraz przyjrzyjmy siÄ™ wersji <code>String</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1;
<span class="boring">}</span></code></pre>
<p>WyglÄ…da to bardzo podobnie, wiÄ™c moglibyÅ›my zaÅ‚oÅ¼yÄ‡, Å¼e dziaÅ‚aÅ‚oby tak samo: to znaczy, Å¼e druga linia utworzyÅ‚aby kopiÄ™ wartoÅ›ci z <code>s1</code> i przypisaÅ‚a jÄ… do <code>s2</code>. Ale tak siÄ™ nie dzieje.</p>
<p>Przyjrzyj siÄ™ Rysunkowi 4-1, aby zobaczyÄ‡, co dzieje siÄ™ z <code>String</code> pod maskÄ…. <code>String</code> skÅ‚ada siÄ™ z trzech czÄ™Å›ci, pokazanych po lewej stronie: wskaÅºnika do pamiÄ™ci, ktÃ³ra przechowuje zawartoÅ›Ä‡ ciÄ…gu, dÅ‚ugoÅ›ci i pojemnoÅ›ci. Ta grupa danych jest przechowywana na stosie. Po prawej stronie znajduje siÄ™ pamiÄ™Ä‡ na stercie, ktÃ³ra przechowuje zawartoÅ›Ä‡.</p>
<img alt="Dwie tabele: pierwsza tabela zawiera reprezentacjÄ™ s1 na stosie, skÅ‚adajÄ…cÄ… siÄ™ z jej dÅ‚ugoÅ›ci (5), pojemnoÅ›ci (5) i wskaÅºnika do pierwszej wartoÅ›ci w drugiej tabeli. Druga tabela zawiera reprezentacjÄ™ danych ciÄ…gu znakÃ³w na stercie, bajt po bajcie." src="img/trpl04-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Rysunek 4-1: Reprezentacja w pamiÄ™ci <code>String</code> zawierajÄ…cego wartoÅ›Ä‡ <code>"hello"</code> przypisanÄ… do <code>s1</code></span></p>
<p>DÅ‚ugoÅ›Ä‡ to iloÅ›Ä‡ pamiÄ™ci, w bajtach, ktÃ³rÄ… aktualnie wykorzystuje zawartoÅ›Ä‡ <code>String</code>. PojemnoÅ›Ä‡ to caÅ‚kowita iloÅ›Ä‡ pamiÄ™ci, w bajtach, ktÃ³rÄ… <code>String</code> otrzymaÅ‚ od alokatora. RÃ³Å¼nica miÄ™dzy dÅ‚ugoÅ›ciÄ… a pojemnoÅ›ciÄ… ma znaczenie, ale nie w tym kontekÅ›cie, wiÄ™c na razie moÅ¼na jÄ… zignorowaÄ‡.</p>
<p>Kiedy przypisujemy <code>s1</code> do <code>s2</code>, dane <code>String</code> sÄ… kopiowane, co oznacza, Å¼e kopiujemy wskaÅºnik, dÅ‚ugoÅ›Ä‡ i pojemnoÅ›Ä‡, ktÃ³re znajdujÄ… siÄ™ na stosie. Nie kopiujemy danych na stercie, do ktÃ³rych odwoÅ‚uje siÄ™ wskaÅºnik. Innymi sÅ‚owy, reprezentacja danych w pamiÄ™ci wyglÄ…da jak na Rysunku 4-2.</p>
<img alt="Trzy tabele: tabele s1 i s2 reprezentujÄ…ce te ciÄ…gi na stosie, odpowiednio, i obie wskazujÄ…ce na te same dane ciÄ…gu na stercie." src="img/trpl04-02.svg" class="center" style="width: 50%;" />
<p><span class="caption">Rysunek 4-2: Reprezentacja w pamiÄ™ci zmiennej <code>s2</code>, ktÃ³ra zawiera kopiÄ™ wskaÅºnika, dÅ‚ugoÅ›ci i pojemnoÅ›ci <code>s1</code></span></p>
<p>Reprezentacja <em>nie</em> wyglÄ…da jak na Rysunku 4-3, ktÃ³ry przedstawiaÅ‚by pamiÄ™Ä‡, gdyby Rust zamiast tego skopiowaÅ‚ rÃ³wnieÅ¼ dane na stercie. Gdyby Rust tak zrobiÅ‚, operacja <code>s2 = s1</code> mogÅ‚aby byÄ‡ bardzo kosztowna pod wzglÄ™dem wydajnoÅ›ci, gdyby dane na stercie byÅ‚y duÅ¼e.</p>
<img alt="Cztery tabele: dwie tabele reprezentujÄ…ce dane stosu dla s1 i s2, a kaÅ¼da wskazuje na wÅ‚asnÄ… kopiÄ™ danych ciÄ…gu na stercie." src="img/trpl04-03.svg" class="center" style="width: 50%;" />
<p><span class="caption">Rysunek 4-3: Inna moÅ¼liwoÅ›Ä‡ tego, co <code>s2 = s1</code> mÃ³gÅ‚by zrobiÄ‡, gdyby Rust skopiowaÅ‚ rÃ³wnieÅ¼ dane ze sterty</span></p>
<p>WczeÅ›niej powiedzieliÅ›my, Å¼e gdy zmienna wychodzi poza zasiÄ™g, Rust automatycznie wywoÅ‚uje funkcjÄ™ <code>drop</code> i zwalnia pamiÄ™Ä‡ sterty dla tej zmiennej. Ale Rysunek 4-2 pokazuje, Å¼e oba wskaÅºniki danych wskazujÄ… na tÄ™ samÄ… lokalizacjÄ™. To jest problem: kiedy <code>s2</code> i <code>s1</code> wyjdÄ… poza zasiÄ™g, oba bÄ™dÄ… prÃ³bowaÅ‚y zwolniÄ‡ tÄ™ samÄ… pamiÄ™Ä‡. Jest to znane jako bÅ‚Ä…d <em>podwÃ³jnego zwolnienia</em> (<em>double free</em>) i jest jednym z bÅ‚Ä™dÃ³w bezpieczeÅ„stwa pamiÄ™ci, o ktÃ³rych wspomnieliÅ›my wczeÅ›niej. Dwukrotne zwolnienie pamiÄ™ci moÅ¼e prowadziÄ‡ do uszkodzenia pamiÄ™ci, co potencjalnie moÅ¼e prowadziÄ‡ do luk w zabezpieczeniach.</p>
<p>Aby zapewniÄ‡ bezpieczeÅ„stwo pamiÄ™ci, po linii <code>let s2 = s1;</code>, Rust uwaÅ¼a <code>s1</code> za juÅ¼ nieprawidÅ‚owe. Dlatego Rust nie musi zwalniaÄ‡ niczego, gdy <code>s1</code> wychodzi poza zasiÄ™g. SprawdÅº, co siÄ™ stanie, gdy sprÃ³bujesz uÅ¼yÄ‡ <code>s1</code> po utworzeniu <code>s2</code>; to nie zadziaÅ‚a:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1;

    println!("{s1}, world!");
<span class="boring">}</span></code></pre>
<p>Otrzymasz bÅ‚Ä…d podobny do tego, poniewaÅ¼ Rust uniemoÅ¼liwia uÅ¼ycie uniewaÅ¼nionej referencji:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:16
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{s1}, world!");
  |                ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s1.clone();
  |                ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>JeÅ›li sÅ‚yszaÅ‚eÅ› o pojÄ™ciach <em>pÅ‚ytka kopia</em> i <em>gÅ‚Ä™boka kopia</em> pracujÄ…c z innymi jÄ™zykami, koncepcja kopiowania wskaÅºnika, dÅ‚ugoÅ›ci i pojemnoÅ›ci bez kopiowania danych prawdopodobnie brzmi jak tworzenie pÅ‚ytkiej kopii. Ale poniewaÅ¼ Rust rÃ³wnieÅ¼ uniewaÅ¼nia pierwszÄ… zmiennÄ…, zamiast nazywaÄ‡ to pÅ‚ytkÄ… kopiÄ…, nazywa siÄ™ to <em>przeniesieniem</em>. W tym przykÅ‚adzie powiedzielibyÅ›my, Å¼e <code>s1</code> zostaÅ‚o <em>przeniesione</em> do <code>s2</code>. Zatem to, co faktycznie siÄ™ dzieje, pokazano na Rysunku 4-4.</p>
<img alt="Trzy tabele: tabele s1 i s2 reprezentujÄ…ce te ciÄ…gi na stosie, odpowiednio, i obie wskazujÄ…ce na te same dane ciÄ…gu na stercie. Tabela s1 jest wyszarzona, poniewaÅ¼ s1 nie jest juÅ¼ waÅ¼ne; tylko s2 moÅ¼e byÄ‡ uÅ¼ywane do dostÄ™pu do danych na stercie." src="img/trpl04-04.svg" class="center" style="width: 50%;" />
<p><span class="caption">Rysunek 4-4: Reprezentacja w pamiÄ™ci po uniewaÅ¼nieniu <code>s1</code></span></p>
<p>To rozwiÄ…zuje nasz problem! Gdy tylko <code>s2</code> jest waÅ¼ne, gdy wyjdzie ono poza zasiÄ™g, samo zwolni pamiÄ™Ä‡, i gotowe.</p>
<p>Dodatkowo, istnieje wynikajÄ…ca z tego decyzja projektowa: Rust nigdy nie stworzy automatycznie â€gÅ‚Ä™bokichâ€ kopii twoich danych. Dlatego wszelkie <em>automatyczne</em> kopiowanie moÅ¼na uznaÄ‡ za tanie pod wzglÄ™dem wydajnoÅ›ci czasu wykonania.</p>
<h4 id="zasiÄ™g-i-przypisanie"><a class="header" href="#zasiÄ™g-i-przypisanie">ZasiÄ™g i przypisanie</a></h4>
<p>OdwrotnoÅ›Ä‡ tego jest rÃ³wnieÅ¼ prawdziwa dla zwiÄ…zku miÄ™dzy zasiÄ™giem, wÅ‚asnoÅ›ciÄ… i zwalnianiem pamiÄ™ci za pomocÄ… funkcji <code>drop</code>. Kiedy przypisujesz caÅ‚kowicie nowÄ… wartoÅ›Ä‡ do istniejÄ…cej zmiennej, Rust natychmiast wywoÅ‚a <code>drop</code> i zwolni pamiÄ™Ä‡ oryginalnej wartoÅ›ci. RozwaÅ¼my na przykÅ‚ad ten kod:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");
    s = String::from("ahoy");

    println!("{s}, world!");
<span class="boring">}</span></code></pre>
<p>PoczÄ…tkowo deklarujemy zmiennÄ… <code>s</code> i wiÄ…Å¼emy jÄ… z <code>String</code> o wartoÅ›ci <code>"hello"</code>. NastÄ™pnie, natychmiast tworzymy nowy <code>String</code> o wartoÅ›ci <code>"ahoy"</code> i przypisujemy go do <code>s</code>. W tym momencie nic nie odnosi siÄ™ do oryginalnej wartoÅ›ci na stercie. Rysunek 4-5 ilustruje teraz dane stosu i sterty:</p>
<img alt="Jedna tabela reprezentujÄ…ca wartoÅ›Ä‡ ciÄ…gu na stosie, wskazujÄ…ca na drugÄ… czÄ™Å›Ä‡ danych ciÄ…gu (ahoy) na stercie, z oryginalnymi danymi ciÄ…gu (hello) wyszarzonymi, poniewaÅ¼ nie moÅ¼na juÅ¼ do nich uzyskaÄ‡ dostÄ™pu." src="img/trpl04-05.svg" class="center" style="width: 50%;" />
<p><span class="caption">Rysunek 4-5: Reprezentacja w pamiÄ™ci po caÅ‚kowitym zastÄ…pieniu wartoÅ›ci poczÄ…tkowej</span></p>
<p>Oryginalny ciÄ…g znakÃ³w natychmiast wychodzi wiÄ™c poza zasiÄ™g. Rust uruchomi na nim funkcjÄ™ <code>drop</code> i jego pamiÄ™Ä‡ zostanie natychmiast zwolniona. Kiedy na koÅ„cu wydrukujemy wartoÅ›Ä‡, bÄ™dzie ona wynosiÄ‡ <code>â€ahoy, world!â€</code>.</p>
<p><a id="ways-variables-and-data-interact-clone"></a></p>
<h4 id="zmienne-i-dane-w-interakcji-przez-klonowanie-clone"><a class="header" href="#zmienne-i-dane-w-interakcji-przez-klonowanie-clone">Zmienne i Dane w Interakcji przez Klonowanie (Clone)</a></h4>
<p>JeÅ›li <em>chcemy</em> gÅ‚Ä™boko skopiowaÄ‡ dane <code>String</code> ze sterty, a nie tylko dane ze stosu, moÅ¼emy uÅ¼yÄ‡ wspÃ³lnej metody <code>clone</code>. SkÅ‚adniÄ™ metod omÃ³wimy w Rozdziale 5, ale poniewaÅ¼ metody sÄ… wspÃ³lnÄ… cechÄ… wielu jÄ™zykÃ³w programowania, prawdopodobnie widziaÅ‚eÅ› je juÅ¼ wczeÅ›niej.</p>
<p>Oto przykÅ‚ad metody <code>clone</code> w dziaÅ‚aniu:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {s1}, s2 = {s2}");
<span class="boring">}</span></code></pre>
<p>To dziaÅ‚a bez problemÃ³w i wyraÅºnie tworzy zachowanie pokazane na Rysunku 4-3, gdzie dane na stercie <em>sÄ…</em> kopiowane.</p>
<p>Kiedy widzisz wywoÅ‚anie <code>clone</code>, wiesz, Å¼e wykonywany jest jakiÅ› dowolny kod i Å¼e ten kod moÅ¼e byÄ‡ kosztowny. To wizualny wskaÅºnik, Å¼e dzieje siÄ™ coÅ› innego.</p>
<h4 id="dane-tylko-na-stosie-kopia"><a class="header" href="#dane-tylko-na-stosie-kopia">Dane tylko na stosie: Kopia</a></h4>
<p>Jest jeszcze jedna kwestia, o ktÃ³rej jeszcze nie mÃ³wiliÅ›my. Ten kod uÅ¼ywajÄ…cy liczb caÅ‚kowitych â€” czÄ™Å›Ä‡ z nich pokazana w Listingu 4-2 â€” dziaÅ‚a i jest prawidÅ‚owy:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!("x = {x}, y = {y}");
<span class="boring">}</span></code></pre>
<p>Ale ten kod wydaje siÄ™ zaprzeczaÄ‡ temu, czego siÄ™ wÅ‚aÅ›nie nauczyliÅ›my: Nie mamy wywoÅ‚ania <code>clone</code>, ale <code>x</code> jest nadal waÅ¼ne i nie zostaÅ‚o przeniesione do <code>y</code>.</p>
<p>Powodem jest to, Å¼e typy takie jak liczby caÅ‚kowite, ktÃ³re majÄ… znany rozmiar w czasie kompilacji, sÄ… przechowywane w caÅ‚oÅ›ci na stosie, wiÄ™c kopie rzeczywistych wartoÅ›ci sÄ… szybkie do wykonania. Oznacza to, Å¼e nie ma powodu, dla ktÃ³rego chcielibyÅ›my uniemoÅ¼liwiÄ‡ <code>x</code> bycie waÅ¼nym po utworzeniu zmiennej <code>y</code>. Innymi sÅ‚owy, nie ma tutaj rÃ³Å¼nicy miÄ™dzy kopiowaniem gÅ‚Ä™bokim a pÅ‚ytkim, wiÄ™c wywoÅ‚anie <code>clone</code> nie zrobiÅ‚oby nic innego niÅ¼ zwykÅ‚e kopiowanie pÅ‚ytkie, i moÅ¼emy to pominÄ…Ä‡.</p>
<p>Rust posiada specjalnÄ… adnotacjÄ™ zwanÄ… cechÄ… <code>Copy</code>, ktÃ³rÄ… moÅ¼emy umieszczaÄ‡ na typach przechowywanych na stosie, tak jak to jest w przypadku liczb caÅ‚kowitych (wiÄ™cej o cechach omÃ³wimy w <a href="#definiowanie-wspÃ³lnego-zachowania-za-pomocÄ…-cech-1">Rozdziale 10</a><!-- ignore -->). JeÅ›li typ implementuje cechÄ™ <code>Copy</code>, zmienne, ktÃ³re jej uÅ¼ywajÄ…, nie sÄ… przenoszone, lecz sÄ… trywialnie kopiowane, co sprawia, Å¼e pozostajÄ… waÅ¼ne po przypisaniu do innej zmiennej.</p>
<p>Rust nie pozwoli nam zaadnotowaÄ‡ typu jako <code>Copy</code>, jeÅ›li typ, lub ktÃ³rakolwiek z jego czÄ™Å›ci, zaimplementowaÅ‚ cechÄ™ <code>Drop</code>. JeÅ›li typ potrzebuje, aby coÅ› specjalnego siÄ™ staÅ‚o, gdy wartoÅ›Ä‡ wyjdzie poza zasiÄ™g, a my dodamy adnotacjÄ™ <code>Copy</code> do tego typu, otrzymamy bÅ‚Ä…d kompilacji. Aby dowiedzieÄ‡ siÄ™, jak dodaÄ‡ adnotacjÄ™ <code>Copy</code> do swojego typu w celu zaimplementowania cechy, zobacz <a href="#c---cechy-dziedziczne">â€Cechy pochodneâ€</a><!-- ignore --> w Dodatku C.</p>
<p>WiÄ™c, jakie typy implementujÄ… cechÄ™ <code>Copy</code>? Aby byÄ‡ pewnym, moÅ¼esz sprawdziÄ‡ dokumentacjÄ™ dla danego typu, ale ogÃ³lnie rzecz biorÄ…c, kaÅ¼da grupa prostych wartoÅ›ci skalarnych moÅ¼e implementowaÄ‡ <code>Copy</code>, a nic, co wymaga alokacji lub jest jakÄ…Å› formÄ… zasobu, nie moÅ¼e implementowaÄ‡ <code>Copy</code>. Oto niektÃ³re typy, ktÃ³re implementujÄ… <code>Copy</code>:</p>
<ul>
<li>Wszystkie typy caÅ‚kowite, takie jak <code>u32</code>.</li>
<li>Typ boolowski, <code>bool</code>, z wartoÅ›ciami <code>true</code> i <code>false</code>.</li>
<li>Wszystkie typy zmiennoprzecinkowe, takie jak <code>f64</code>.</li>
<li>Typ znakowy, <code>char</code>.</li>
<li>Krotki, jeÅ›li zawierajÄ… tylko typy, ktÃ³re rÃ³wnieÅ¼ implementujÄ… <code>Copy</code>. Na przykÅ‚ad <code>(i32, i32)</code> implementuje <code>Copy</code>, ale <code>(i32, String)</code> nie.</li>
</ul>
<h3 id="wÅ‚asnoÅ›Ä‡-i-funkcje"><a class="header" href="#wÅ‚asnoÅ›Ä‡-i-funkcje">WÅ‚asnoÅ›Ä‡ i Funkcje</a></h3>
<p>Mechanizmy przekazywania wartoÅ›ci do funkcji sÄ… podobne do tych, ktÃ³re wystÄ™pujÄ… przy przypisywaniu wartoÅ›ci do zmiennej. Przekazanie zmiennej do funkcji spowoduje przeniesienie lub skopiowanie, tak jak przypisanie. Listing 4-3 zawiera przykÅ‚ad z adnotacjami pokazujÄ…cymi, gdzie zmienne wchodzÄ… w zasiÄ™g i wychodzÄ… z niego.</p>
<listing number="4-3" file-name="src/main.rs" caption="Funkcje z adnotacjami wÅ‚asnoÅ›ci i zasiÄ™gu">
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let s = String::from("hello");  // s wchodzi w zasiÄ™g

    takes_ownership(s);             // wartoÅ›Ä‡ s przenosi siÄ™ do funkcji...
                                    // ... i dlatego jest tutaj niewaÅ¼na

    let x = 5;                      // x wchodzi w zasiÄ™g

    makes_copy(x);                  // PoniewaÅ¼ i32 implementuje cechÄ™ Copy,
                                    // x NIE przenosi siÄ™ do funkcji,
                                    // wiÄ™c moÅ¼na uÅ¼ywaÄ‡ x pÃ³Åºniej.

} // Tutaj x wychodzi z zasiÄ™gu, potem s. JednakÅ¼e, poniewaÅ¼ wartoÅ›Ä‡ s zostaÅ‚a przeniesiona,
  // nic specjalnego siÄ™ nie dzieje.

fn takes_ownership(some_string: String) { // some_string wchodzi w zasiÄ™g
    println!("{some_string}");
} // Tutaj some_string wychodzi z zasiÄ™gu i wywoÅ‚ywane jest `drop`. PamiÄ™Ä‡ bazowa
  // jest zwalniana.

fn makes_copy(some_integer: i32) { // some_integer wchodzi w zasiÄ™g
    println!("{some_integer}");
} // Tutaj some_integer wychodzi z zasiÄ™gu. Nic specjalnego siÄ™ nie dzieje.</code></pre>
</listing>
<p>JeÅ›li sprÃ³bowalibyÅ›my uÅ¼yÄ‡ <code>s</code> po wywoÅ‚aniu <code>takes_ownership</code>, Rust wyrzuciÅ‚by bÅ‚Ä…d kompilacji. Te statyczne sprawdzenia chroniÄ… nas przed bÅ‚Ä™dami. SprÃ³buj dodaÄ‡ kod do <code>main</code>, ktÃ³ry uÅ¼ywa <code>s</code> i <code>x</code>, aby zobaczyÄ‡, gdzie moÅ¼na ich uÅ¼ywaÄ‡, a gdzie zasady wÅ‚asnoÅ›ci uniemoÅ¼liwiajÄ… to.</p>
<h3 id="wartoÅ›ci-zwracane-i-zasiÄ™g"><a class="header" href="#wartoÅ›ci-zwracane-i-zasiÄ™g">WartoÅ›ci zwracane i zasiÄ™g</a></h3>
<p>Zwracanie wartoÅ›ci moÅ¼e rÃ³wnieÅ¼ przenosiÄ‡ wÅ‚asnoÅ›Ä‡. Listing 4-4 przedstawia przykÅ‚ad funkcji, ktÃ³ra zwraca pewnÄ… wartoÅ›Ä‡, z podobnymi adnotacjami jak te z Listingu 4-3.</p>
<listing number="4-4" file-name="src/main.rs" caption="Przenoszenie wÅ‚asnoÅ›ci wartoÅ›ci zwracanych">
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let s1 = gives_ownership();        // gives_ownership przenosi swojÄ… wartoÅ›Ä‡
                                       // zwracanÄ… do s1

    let s2 = String::from("hello");    // s2 wchodzi w zasiÄ™g

    let s3 = takes_and_gives_back(s2); // s2 jest przenoszone do
                                       // takes_and_gives_back, ktÃ³re rÃ³wnieÅ¼
                                       // przenosi swojÄ… wartoÅ›Ä‡ zwracanÄ… do s3
} // Tutaj s3 wychodzi z zasiÄ™gu i jest usuwane. s2 zostaÅ‚o przeniesione, wiÄ™c nic
  // siÄ™ nie dzieje. s1 wychodzi z zasiÄ™gu i jest usuwane.

fn gives_ownership() -&gt; String {       // gives_ownership przeniesie swojÄ…
                                       // wartoÅ›Ä‡ zwracanÄ… do funkcji,
                                       // ktÃ³ra jÄ… wywoÅ‚a

    let some_string = String::from("yours"); // some_string wchodzi w zasiÄ™g

    some_string                        // some_string jest zwracane i
                                       // przenosi siÄ™ do funkcji
                                       // wywoÅ‚ujÄ…cej
}

// Ta funkcja przyjmuje String i zwraca String.
fn takes_and_gives_back(a_string: String) -&gt; String {
    // a_string wchodzi w
    // zasiÄ™g

    a_string  // a_string jest zwracane i przenosi siÄ™ do funkcji wywoÅ‚ujÄ…cej
}</code></pre>
</listing>
<p>WÅ‚asnoÅ›Ä‡ zmiennej zawsze podlega temu samemu wzorcowi: przypisanie wartoÅ›ci do innej zmiennej powoduje jej przeniesienie. Gdy zmienna zawierajÄ…ca dane na stercie wyjdzie poza zasiÄ™g, wartoÅ›Ä‡ zostanie posprzÄ…tana przez <code>drop</code>, chyba Å¼e wÅ‚asnoÅ›Ä‡ danych zostaÅ‚a przeniesiona do innej zmiennej.</p>
<p>ChociaÅ¼ to dziaÅ‚a, przejmowanie wÅ‚asnoÅ›ci, a nastÄ™pnie zwracanie wÅ‚asnoÅ›ci przy kaÅ¼dej funkcji jest trochÄ™ mÄ™czÄ…ce. Co, jeÅ›li chcemy pozwoliÄ‡ funkcji uÅ¼yÄ‡ wartoÅ›ci, ale nie przejmowaÄ‡ wÅ‚asnoÅ›ci? Jest to doÅ›Ä‡ denerwujÄ…ce, Å¼e wszystko, co przekazujemy, musi byÄ‡ rÃ³wnieÅ¼ zwrÃ³cone, jeÅ›li chcemy uÅ¼yÄ‡ tego ponownie, oprÃ³cz wszelkich danych wynikajÄ…cych z treÅ›ci funkcji, ktÃ³re rÃ³wnieÅ¼ moÅ¼emy chcieÄ‡ zwrÃ³ciÄ‡.</p>
<p>Rust pozwala nam zwracaÄ‡ wiele wartoÅ›ci za pomocÄ… krotki, jak pokazano w Listingu 4-5.</p>
<listing number="4-5" file-name="src/main.rs" caption="Zwracanie wÅ‚asnoÅ›ci parametrÃ³w">
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("DÅ‚ugoÅ›Ä‡ '{s2}' wynosi {len}.");
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() zwraca dÅ‚ugoÅ›Ä‡ String

    (s, length)
}</code></pre>
</listing>
<p>Ale to zbyt wiele ceremonii i duÅ¼o pracy dla koncepcji, ktÃ³ra powinna byÄ‡ powszechna. Na szczÄ™Å›cie Rust ma funkcjÄ™ do uÅ¼ywania wartoÅ›ci bez przenoszenia wÅ‚asnoÅ›ci: referencje.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="referencje-i-poÅ¼yczanie-1"><a href="#referencje-i-poÅ¼yczanie-1" class="header">Referencje i PoÅ¼yczanie</a></h1>
<h2 id="referencje-i-poÅ¼yczanie"><a class="header" href="#referencje-i-poÅ¼yczanie">Referencje i PoÅ¼yczanie</a></h2>
<p>Problem z kodem krotki w Listingu 4-5 polega na tym, Å¼e musimy zwrÃ³ciÄ‡ <code>String</code> do funkcji wywoÅ‚ujÄ…cej, abyÅ›my mogli nadal uÅ¼ywaÄ‡ <code>String</code> po wywoÅ‚aniu <code>calculate_length</code>, poniewaÅ¼ <code>String</code> zostaÅ‚o przeniesione do <code>calculate_length</code>. Zamiast tego moÅ¼emy dostarczyÄ‡ referencjÄ™ do wartoÅ›ci <code>String</code>. Referencja jest jak wskaÅºnik w tym sensie, Å¼e jest to adres, za ktÃ³rym moÅ¼emy podÄ…Å¼aÄ‡, aby uzyskaÄ‡ dostÄ™p do danych przechowywanych pod tym adresem; te dane sÄ… wÅ‚asnoÅ›ciÄ… innej zmiennej. W przeciwieÅ„stwie do wskaÅºnika, referencja gwarantuje, Å¼e wskazuje na waÅ¼nÄ… wartoÅ›Ä‡ okreÅ›lonego typu przez caÅ‚y okres Å¼ycia tej referencji.</p>
<p>Oto jak zdefiniowaÄ‡ i uÅ¼yÄ‡ funkcji <code>calculate_length</code>, ktÃ³ra jako parametr przyjmuje referencjÄ™ do obiektu zamiast przejmowaÄ‡ wÅ‚asnoÅ›Ä‡ wartoÅ›ci:</p>
<listing file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);

    println!("DÅ‚ugoÅ›Ä‡ '{s1}' wynosi {len}.");
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}</code></pre>
</listing>
<p>Po pierwsze, zauwaÅ¼, Å¼e caÅ‚y kod krotki w deklaracji zmiennej i wartoÅ›ci zwracanej funkcji zniknÄ…Å‚. Po drugie, zauwaÅ¼, Å¼e przekazujemy <code>&amp;s1</code> do <code>calculate_length</code> i, w jej definicji, przyjmujemy <code>&amp;String</code> zamiast <code>String</code>. Te ampersandy reprezentujÄ… referencje i pozwalajÄ… odwoÅ‚ywaÄ‡ siÄ™ do pewnej wartoÅ›ci bez przejmowania jej wÅ‚asnoÅ›ci. Rysunek 4-6 przedstawia tÄ™ koncepcjÄ™.</p>
<img alt="Trzy tabele: tabela dla s zawiera tylko wskaÅºnik do tabeli dla s1. Tabela dla s1 zawiera dane stosu dla s1 i wskazuje na dane ciÄ…gu na stercie." src="img/trpl04-06.svg" class="center" />
<p><span class="caption">Rysunek 4-6: Diagram <code>&amp;String</code> <code>s</code> wskazujÄ…cego na <code>String</code> <code>s1</code></span></p>
<blockquote>
<p>Uwaga: PrzeciwieÅ„stwem referencji za pomocÄ… <code>&amp;</code> jest <em>dereferencjowanie</em>, ktÃ³re jest realizowane za pomocÄ… operatora dereferencji, <code>*</code>. Zobaczymy kilka zastosowaÅ„ operatora dereferencji w Rozdziale 8 i omÃ³wimy szczegÃ³Å‚y dereferencji w Rozdziale 15.</p>
</blockquote>
<p>Przyjrzyjmy siÄ™ bliÅ¼ej wywoÅ‚aniu funkcji:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);
<span class="boring">
</span><span class="boring">    println!("DÅ‚ugoÅ›Ä‡ '{s1}' wynosi {len}.");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calculate_length(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}</span></code></pre>
<p>SkÅ‚adnia <code>&amp;s1</code> pozwala nam utworzyÄ‡ referencjÄ™, ktÃ³ra <em>odnosi siÄ™</em> do wartoÅ›ci <code>s1</code>, ale jej nie posiada. PoniewaÅ¼ referencja nie jest jej wÅ‚aÅ›cicielem, wartoÅ›Ä‡, na ktÃ³rÄ… wskazuje, nie zostanie usuniÄ™ta, gdy referencja przestanie byÄ‡ uÅ¼ywana.</p>
<p>Podobnie, sygnatura funkcji uÅ¼ywa <code>&amp;</code> do wskazania, Å¼e typ parametru <code>s</code> jest referencjÄ…. Dodajmy kilka wyjaÅ›niajÄ…cych adnotacji:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from("hello");
</span><span class="boring">
</span><span class="boring">    let len = calculate_length(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!("DÅ‚ugoÅ›Ä‡ '{s1}' wynosi {len}.");
</span><span class="boring">}
</span><span class="boring">
</span>fn calculate_length(s: &amp;String) -&gt; usize { // s jest referencjÄ… do String
    s.len()
} // Tutaj s wychodzi z zasiÄ™gu. Ale poniewaÅ¼ s nie posiada wÅ‚asnoÅ›ci tego,
  // do czego siÄ™ odnosi, String nie jest usuwane.</code></pre>
<p>ZasiÄ™g, w ktÃ³rym zmienna <code>s</code> jest waÅ¼na, jest taki sam jak zasiÄ™g kaÅ¼dego parametru funkcji, ale wartoÅ›Ä‡ wskazywana przez referencjÄ™ nie jest usuwana, gdy <code>s</code> przestaje byÄ‡ uÅ¼ywane, poniewaÅ¼ <code>s</code> nie posiada wÅ‚asnoÅ›ci. Gdy funkcje majÄ… referencje jako parametry zamiast rzeczywistych wartoÅ›ci, nie bÄ™dziemy musieli zwracaÄ‡ wartoÅ›ci, aby oddaÄ‡ wÅ‚asnoÅ›Ä‡, poniewaÅ¼ nigdy jej nie posiadaliÅ›my.</p>
<p>Nazywamy czynnoÅ›Ä‡ tworzenia referencji <em>poÅ¼yczaniem</em>. Jak w prawdziwym Å¼yciu, jeÅ›li ktoÅ› posiada coÅ›, moÅ¼esz to od niego poÅ¼yczyÄ‡. Kiedy skoÅ„czysz, musisz to zwrÃ³ciÄ‡. Nie jesteÅ› jego wÅ‚aÅ›cicielem.</p>
<p>WiÄ™c co siÄ™ stanie, jeÅ›li sprÃ³bujemy zmodyfikowaÄ‡ coÅ›, co poÅ¼yczamy? WyprÃ³buj kod z Listingu 4-6. Uwaga, spoiler: To nie dziaÅ‚a!</p>
<listing number="4-6" file-name="src/main.rs" caption="PrÃ³ba modyfikacji poÅ¼yczonej wartoÅ›ci">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from("hello");

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(", world");
}</code></pre>
</listing>
<p>Oto bÅ‚Ä…d:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
  |
help: consider changing this to be a mutable reference
  |
7 | fn change(some_string: &amp;mut String) {
  |                         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Tak jak zmienne sÄ… domyÅ›lnie niezmienne, tak samo referencje. Nie wolno nam modyfikowaÄ‡ czegoÅ›, do czego mamy referencjÄ™.</p>
<h3 id="mutowalne-referencje"><a class="header" href="#mutowalne-referencje">Mutowalne referencje</a></h3>
<p>MoÅ¼emy naprawiÄ‡ kod z Listingu 4-6, aby umoÅ¼liwiÄ‡ modyfikacjÄ™ poÅ¼yczonej wartoÅ›ci za pomocÄ… kilku drobnych zmian, ktÃ³re zamiast tego uÅ¼ywajÄ… <em>mutowalnej referencji</em>:</p>
<listing file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut s = String::from("hello");

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(", world");
}</code></pre>
</listing>
<p>Najpierw zmieniamy <code>s</code> na <code>mut</code>. NastÄ™pnie tworzymy mutowalnÄ… referencjÄ™ za pomocÄ… <code>&amp;mut s</code> w miejscu wywoÅ‚ania funkcji <code>change</code> i aktualizujemy sygnaturÄ™ funkcji, aby akceptowaÅ‚a mutowalnÄ… referencjÄ™ za pomocÄ… <code>some_string: &amp;mut String</code>. DziÄ™ki temu bardzo jasno wynika, Å¼e funkcja <code>change</code> bÄ™dzie mutowaÄ‡ poÅ¼yczonÄ… wartoÅ›Ä‡.</p>
<p>Mutowalne referencje majÄ… jedno duÅ¼e ograniczenie: jeÅ›li masz mutowalnÄ… referencjÄ™ do wartoÅ›ci, nie moÅ¼esz mieÄ‡ Å¼adnych innych referencji do tej wartoÅ›ci. Ten kod, ktÃ³ry prÃ³buje utworzyÄ‡ dwie mutowalne referencje do <code>s</code>, zakoÅ„czy siÄ™ niepowodzeniem:</p>
<listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!("{r1}, {r2}");
<span class="boring">}</span></code></pre>
</listing>
<p>Oto bÅ‚Ä…d:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!("{r1}, {r2}");
  |                -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Ten bÅ‚Ä…d mÃ³wi, Å¼e ten kod jest nieprawidÅ‚owy, poniewaÅ¼ nie moÅ¼emy poÅ¼yczyÄ‡ <code>s</code> jako mutowalne wiÄ™cej niÅ¼ raz w tym samym czasie. Pierwsze mutowalne poÅ¼yczenie nastÄ™puje w <code>r1</code> i musi trwaÄ‡, dopÃ³ki nie zostanie uÅ¼yte w <code>println!</code>, ale miÄ™dzy utworzeniem tej mutowalnej referencji a jej uÅ¼yciem prÃ³bowaliÅ›my utworzyÄ‡ kolejnÄ… mutowalnÄ… referencjÄ™ w <code>r2</code>, ktÃ³ra poÅ¼ycza te same dane co <code>r1</code>.</p>
<p>Ograniczenie zapobiegajÄ…ce rÃ³wnoczesnemu posiadaniu wielu mutowalnych referencji do tych samych danych pozwala na mutacjÄ™, ale w bardzo kontrolowany sposÃ³b. Jest to coÅ›, z czym borykajÄ… siÄ™ nowi Rustaceanowie, poniewaÅ¼ wiÄ™kszoÅ›Ä‡ jÄ™zykÃ³w pozwala mutowaÄ‡, kiedy tylko chcesz. KorzyÅ›ciÄ… z tego ograniczenia jest to, Å¼e Rust moÅ¼e zapobiegaÄ‡ wyÅ›cigom danych w czasie kompilacji. <em>WyÅ›cig danych</em> jest podobny do warunku wyÅ›cigu i wystÄ™puje, gdy zachodzÄ… te trzy zachowania:</p>
<ul>
<li>Dwa lub wiÄ™cej wskaÅºnikÃ³w uzyskuje dostÄ™p do tych samych danych w tym samym czasie.</li>
<li>Co najmniej jeden ze wskaÅºnikÃ³w jest uÅ¼ywany do zapisu danych.</li>
<li>Nie ma mechanizmu synchronizujÄ…cego dostÄ™p do danych.</li>
</ul>
<p>WyÅ›cigi danych powodujÄ… niezdefiniowane zachowanie i mogÄ… byÄ‡ trudne do zdiagnozowania i naprawienia, gdy prÃ³bujesz je Å›ledziÄ‡ w czasie wykonania; Rust zapobiega temu problemowi, odmawiajÄ…c kompilacji kodu z wyÅ›cigami danych!</p>
<p>Jak zawsze, moÅ¼emy uÅ¼yÄ‡ nawiasÃ³w klamrowych do stworzenia nowego zasiÄ™gu, co pozwala na wiele mutowalnych referencji, ale nie <em>jednoczesnych</em>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    {
        let r1 = &amp;mut s;
    } // r1 wychodzi z zasiÄ™gu tutaj, wiÄ™c moÅ¼emy stworzyÄ‡ nowÄ… referencjÄ™ bez problemÃ³w.

    let r2 = &amp;mut s;
<span class="boring">}</span></code></pre>
<p>Rust narzuca podobnÄ… zasadÄ™ dla Å‚Ä…czenia mutowalnych i niemutowalnych referencji. Ten kod powoduje bÅ‚Ä…d:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;s; // bez problemu
    let r2 = &amp;s; // bez problemu
    let r3 = &amp;mut s; // DUÅ»Y PROBLEM

    println!("{r1}, {r2}, and {r3}");
<span class="boring">}</span></code></pre>
<p>Oto bÅ‚Ä…d:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // no problem
6 |     let r3 = &amp;mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{r1}, {r2}, and {r3}");
  |                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Uff! <em>Nie</em> moÅ¼emy rÃ³wnieÅ¼ mieÄ‡ mutowalnej referencji, gdy mamy niezmiennÄ… referencjÄ™ do tej samej wartoÅ›ci.</p>
<p>UÅ¼ytkownicy referencji niezmiennej nie spodziewajÄ… siÄ™, Å¼e wartoÅ›Ä‡ nagle siÄ™ zmieni! JednakÅ¼e, wiele referencji niezmiennych jest dozwolonych, poniewaÅ¼ nikt, kto tylko odczytuje dane, nie ma moÅ¼liwoÅ›ci wpÅ‚ywania na odczytywanie danych przez nikogo innego.</p>
<p>ZauwaÅ¼, Å¼e zasiÄ™g referencji rozpoczyna siÄ™ w miejscu jej wprowadzenia i trwa do ostatniego uÅ¼ycia tej referencji. Na przykÅ‚ad, ten kod skompiluje siÄ™, poniewaÅ¼ ostatnie uÅ¼ycie referencji niezmiennych jest w <code>println!</code>, zanim zostanie wprowadzona referencja mutowalna:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;s; // bez problemu
    let r2 = &amp;s; // bez problemu
    println!("{r1} i {r2}");
    // Zmienne r1 i r2 nie bÄ™dÄ… uÅ¼ywane po tym punkcie.

    let r3 = &amp;mut s; // bez problemu
    println!("{r3}");
<span class="boring">}</span></code></pre>
<p>ZasiÄ™gi niezmiennych referencji <code>r1</code> i <code>r2</code> koÅ„czÄ… siÄ™ po <code>println!</code>, gdzie sÄ… ostatnio uÅ¼ywane, co nastÄ™puje przed utworzeniem mutowalnej referencji <code>r3</code>. Te zasiÄ™gi nie nakÅ‚adajÄ… siÄ™, wiÄ™c ten kod jest dozwolony: kompilator moÅ¼e stwierdziÄ‡, Å¼e referencja nie jest juÅ¼ uÅ¼ywana w punkcie przed koÅ„cem zasiÄ™gu.</p>
<p>ChociaÅ¼ bÅ‚Ä™dy poÅ¼yczania mogÄ… czasem frustrowaÄ‡, pamiÄ™taj, Å¼e to kompilator Rust wskazuje potencjalny bÅ‚Ä…d wczeÅ›nie (w czasie kompilacji, a nie w czasie wykonania) i pokazuje dokÅ‚adnie, gdzie leÅ¼y problem. Wtedy nie musisz szukaÄ‡ przyczyny, dla ktÃ³rej twoje dane nie sÄ… tym, czego siÄ™ spodziewaÅ‚eÅ›.</p>
<h3 id="zwisajÄ…ce-referencje"><a class="header" href="#zwisajÄ…ce-referencje">ZwisajÄ…ce referencje</a></h3>
<p>W jÄ™zykach ze wskaÅºnikami Å‚atwo jest bÅ‚Ä™dnie utworzyÄ‡ <em>zwisajÄ…cy wskaÅºnik</em> â€” wskaÅºnik, ktÃ³ry odwoÅ‚uje siÄ™ do miejsca w pamiÄ™ci, ktÃ³re mogÅ‚o zostaÄ‡ przekazane komuÅ› innemu â€” zwalniajÄ…c czÄ™Å›Ä‡ pamiÄ™ci, jednoczeÅ›nie zachowujÄ…c wskaÅºnik do tej pamiÄ™ci. W Rust, natomiast, kompilator gwarantuje, Å¼e referencje nigdy nie bÄ™dÄ… zwisajÄ…cymi referencjami: jeÅ›li masz referencjÄ™ do jakichÅ› danych, kompilator zapewni, Å¼e dane te nie wyjdÄ… poza zasiÄ™g przed referencjÄ… do nich.</p>
<p>SprÃ³bujmy utworzyÄ‡ zwisajÄ…cÄ… referencjÄ™, aby zobaczyÄ‡, jak Rust im zapobiega, sygnalizujÄ…c bÅ‚Ä…d kompilacji:</p>
<listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from("hello");

    &amp;s
}</code></pre>
</listing>
<p>Oto bÅ‚Ä…d:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime, but this is uncommon unless you're returning a borrowed value from a `const` or a `static`
  |
5 | fn dangle() -&gt; &amp;'static String {
  |                 +++++++
help: instead, you are more likely to want to return an owned value
  |
5 - fn dangle() -&gt; &amp;String {
5 + fn dangle() -&gt; String {
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Ten komunikat o bÅ‚Ä™dzie odnosi siÄ™ do funkcji, ktÃ³rej jeszcze nie omÃ³wiliÅ›my: czasÃ³w Å¼ycia. SzczegÃ³Å‚owo omÃ³wimy czasy Å¼ycia w Rozdziale 10. Ale jeÅ›li zignorujesz czÄ™Å›ci dotyczÄ…ce czasÃ³w Å¼ycia, komunikat zawiera klucz do tego, dlaczego ten kod jest problemem:</p>
<pre><code class="language-text">typ zwracany przez tÄ™ funkcjÄ™ zawiera wartoÅ›Ä‡ poÅ¼yczonÄ…, ale nie ma wartoÅ›ci,
z ktÃ³rej moÅ¼na jÄ… poÅ¼yczyÄ‡
</code></pre>
<p>Przyjrzyjmy siÄ™ bliÅ¼ej, co dokÅ‚adnie dzieje siÄ™ na kaÅ¼dym etapie naszego kodu <code>dangle</code>:</p>
<listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let reference_to_nothing = dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn dangle() -&gt; &amp;String { // dangle zwraca referencjÄ™ do String

    let s = String::from("hello"); // s to nowy String

    &amp;s // zwracamy referencjÄ™ do String, s
} // Tutaj s wychodzi z zasiÄ™gu i jest usuwane, wiÄ™c jego pamiÄ™Ä‡ znika.
  // NiebezpieczeÅ„stwo!</code></pre>
</listing>
<p>PoniewaÅ¼ <code>s</code> jest tworzone wewnÄ…trz <code>dangle</code>, kiedy kod <code>dangle</code> siÄ™ zakoÅ„czy, <code>s</code> zostanie dealokowane. Ale prÃ³bowaliÅ›my zwrÃ³ciÄ‡ do niego referencjÄ™. Oznacza to, Å¼e ta referencja wskazywaÅ‚aby na nieprawidÅ‚owy <code>String</code>. To niedobrze! Rust nam na to nie pozwoli.</p>
<p>RozwiÄ…zaniem jest bezpoÅ›rednie zwrÃ³cenie <code>String</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let string = no_dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn no_dangle() -&gt; String {
    let s = String::from("hello");

    s
}</code></pre>
<p>To dziaÅ‚a bez problemÃ³w. WÅ‚asnoÅ›Ä‡ zostaje przeniesiona, a nic nie jest dealokowane.</p>
<h3 id="zasady-referencji"><a class="header" href="#zasady-referencji">Zasady referencji</a></h3>
<p>Podsumujmy, co omÃ³wiliÅ›my na temat referencji:</p>
<ul>
<li>W dowolnym momencie moÅ¼esz mieÄ‡ <em>albo</em> jednÄ… mutowalnÄ… referencjÄ™ <em>albo</em> dowolnÄ… liczbÄ™ niemutowalnych referencji.</li>
<li>Referencje muszÄ… byÄ‡ zawsze waÅ¼ne.</li>
</ul>
<p>NastÄ™pnie przyjrzymy siÄ™ innemu rodzajowi referencji: wycinkom (slices).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="typ-wycinak-slice-1"><a href="#typ-wycinak-slice-1" class="header">Typ Wycinak (Slice)</a></h1>
<h2 id="typ-wycinak-slice"><a class="header" href="#typ-wycinak-slice">Typ Wycinak (Slice)</a></h2>
<p><em>Wycinki (Slices)</em> pozwalajÄ… odwoÅ‚ywaÄ‡ siÄ™ do ciÄ…gÅ‚ej sekwencji elementÃ³w w <a href="#wspÃ³lne-kolekcje">kolekcji</a><!-- ignore -->. Wycinek jest rodzajem referencji, wiÄ™c nie posiada wÅ‚asnoÅ›ci.</p>
<p>Oto maÅ‚y problem programistyczny: Napisz funkcjÄ™, ktÃ³ra przyjmuje ciÄ…g sÅ‚Ã³w oddzielonych spacjami i zwraca pierwsze sÅ‚owo, ktÃ³re znajdzie w tym ciÄ…gu. JeÅ›li funkcja nie znajdzie spacji w ciÄ…gu, caÅ‚y ciÄ…g musi byÄ‡ jednym sÅ‚owem, wiÄ™c powinien zostaÄ‡ zwrÃ³cony caÅ‚y ciÄ…g.</p>
<blockquote>
<p>Uwaga: Dla celÃ³w wprowadzenia wycinkÃ³w, w tej sekcji zakÅ‚adamy tylko ASCII; bardziej szczegÃ³Å‚owe omÃ³wienie obsÅ‚ugi UTF-8 znajduje siÄ™ w sekcji <a href="#storing-utf-8-encoded-text-with-strings">â€Przechowywanie tekstu kodowanego w UTF-8 za pomocÄ… ciÄ…gÃ³w znakÃ³wâ€</a><!-- ignore --> w Rozdziale 8.</p>
</blockquote>
<p>Przyjrzyjmy siÄ™, jak napisalibyÅ›my sygnaturÄ™ tej funkcji bez uÅ¼ycia wycinkÃ³w, aby zrozumieÄ‡ problem, ktÃ³ry wycinki rozwiÄ…Å¼Ä…:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?</code></pre>
<p>Funkcja <code>first_word</code> ma parametr typu <code>&amp;String</code>. Nie potrzebujemy wÅ‚asnoÅ›ci, wiÄ™c to jest w porzÄ…dku. (W idiomatycznym Rust, funkcje nie przejmujÄ… wÅ‚asnoÅ›ci swoich argumentÃ³w, chyba Å¼e jest to konieczne, a powody tego stanÄ… siÄ™ jasne, gdy bÄ™dziemy kontynuowaÄ‡.) Ale co powinniÅ›my zwrÃ³ciÄ‡? Nie mamy tak naprawdÄ™ sposobu, aby mÃ³wiÄ‡ o <em>czÄ™Å›ci</em> ciÄ…gu. Jednak moglibyÅ›my zwrÃ³ciÄ‡ indeks koÅ„ca sÅ‚owa, wskazany przez spacjÄ™. SprÃ³bujmy tego, jak pokazano w Listingu 4-7.</p>
<listing number="4-7" file-name="src/main.rs" caption="Funkcja `first_word`, ktÃ³ra zwraca wartoÅ›Ä‡ indeksu bajtowego do parametru `String`">
<pre class="playground"><code class="language-rust edition2024">fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
</listing>
<p>PoniewaÅ¼ musimy przejÅ›Ä‡ przez <code>String</code> element po elemencie i sprawdziÄ‡, czy wartoÅ›Ä‡ jest spacjÄ…, przeksztaÅ‚cimy nasz <code>String</code> w tablicÄ™ bajtÃ³w za pomocÄ… metody <code>as_bytes</code>.</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span>    let bytes = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>NastÄ™pnie, tworzymy iterator po tablicy bajtÃ³w uÅ¼ywajÄ…c metody <code>iter</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>Iteratory omÃ³wimy bardziej szczegÃ³Å‚owo w <a href="#przetwarzanie-serii-elementÃ³w-za-pomocÄ…-iteratorÃ³w-1">Rozdziale 13</a><!-- ignore -->. Na razie wystarczy wiedzieÄ‡, Å¼e <code>iter</code> to metoda, ktÃ³ra zwraca kaÅ¼dy element w kolekcji, a <code>enumerate</code> opakowuje wynik <code>iter</code> i zwraca kaÅ¼dy element jako czÄ™Å›Ä‡ krotki. Pierwszy element krotki zwrÃ³conej z <code>enumerate</code> to indeks, a drugi element to referencja do elementu. Jest to nieco wygodniejsze niÅ¼ samodzielne obliczanie indeksu.</p>
<p>PoniewaÅ¼ metoda <code>enumerate</code> zwraca krotkÄ™, moÅ¼emy uÅ¼yÄ‡ wzorcÃ³w do dekonstrukcji tej krotki. WiÄ™cej o wzorcach omÃ³wimy w <a href="#patterns-that-bind-to-values">Rozdziale 6</a><!-- ignore -->. W pÄ™tli <code>for</code> okreÅ›lamy wzorzec, ktÃ³ry ma <code>i</code> dla indeksu w krotce i <code>&amp;item</code> dla pojedynczego bajtu w krotce. PoniewaÅ¼ otrzymujemy referencjÄ™ do elementu z <code>.iter().enumerate()</code>, uÅ¼ywamy <code>&amp;</code> we wzorcu.</p>
<p>WewnÄ…trz pÄ™tli <code>for</code> szukamy bajtu reprezentujÄ…cego spacjÄ™, uÅ¼ywajÄ…c skÅ‚adni literaÅ‚u bajtowego. JeÅ›li znajdziemy spacjÄ™, zwracamy pozycjÄ™. W przeciwnym razie zwracamy dÅ‚ugoÅ›Ä‡ ciÄ…gu, uÅ¼ywajÄ…c <code>s.len()</code>.</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>Mamy teraz sposÃ³b na znalezienie indeksu koÅ„ca pierwszego sÅ‚owa w ciÄ…gu, ale jest problem. Zwracamy samo <code>usize</code>, ale jest to znaczÄ…ca liczba tylko w kontekÅ›cie <code>&amp;String</code>. Innymi sÅ‚owy, poniewaÅ¼ jest to oddzielna wartoÅ›Ä‡ od <code>String</code>, nie ma gwarancji, Å¼e bÄ™dzie ona nadal waÅ¼na w przyszÅ‚oÅ›ci. RozwaÅ¼ program z Listingu 4-8, ktÃ³ry uÅ¼ywa funkcji <code>first_word</code> z Listingu 4-7.</p>
<listing number="4-8" file-name="src/main.rs" caption="Przechowywanie wyniku wywoÅ‚ania funkcji `first_word`, a nastÄ™pnie zmiana zawartoÅ›ci `String`">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s); // word otrzyma wartoÅ›Ä‡ 5

    s.clear(); // to oprÃ³Å¼nia String, sprawiajÄ…c, Å¼e staje siÄ™ rÃ³wny ""

    // word nadal ma wartoÅ›Ä‡ 5 tutaj, ale s nie ma juÅ¼ Å¼adnej zawartoÅ›ci, ktÃ³rej moglibyÅ›my
    // sensownie uÅ¼yÄ‡ z wartoÅ›ciÄ… 5, wiÄ™c word jest teraz caÅ‚kowicie niewaÅ¼ne!
}</code></pre>
</listing>
<p>Ten program kompiluje siÄ™ bez Å¼adnych bÅ‚Ä™dÃ³w i skompilowaÅ‚by siÄ™ rÃ³wnieÅ¼, gdybyÅ›my uÅ¼yli <code>word</code> po wywoÅ‚aniu <code>s.clear()</code>. PoniewaÅ¼ <code>word</code> w Å¼aden sposÃ³b nie jest powiÄ…zane ze stanem <code>s</code>, <code>word</code> nadal zawiera wartoÅ›Ä‡ <code>5</code>. MoglibyÅ›my uÅ¼yÄ‡ tej wartoÅ›ci <code>5</code> ze zmiennÄ… <code>s</code>, aby sprÃ³bowaÄ‡ wyodrÄ™bniÄ‡ pierwsze sÅ‚owo, ale byÅ‚by to bÅ‚Ä…d, poniewaÅ¼ zawartoÅ›Ä‡ <code>s</code> zmieniÅ‚a siÄ™, odkÄ…d zapisaliÅ›my <code>5</code> w <code>word</code>.</p>
<p>Martwienie siÄ™ o to, Å¼e indeks w <code>word</code> przestaje byÄ‡ zsynchronizowany z danymi w <code>s</code>, jest uciÄ…Å¼liwe i podatne na bÅ‚Ä™dy! ZarzÄ…dzanie tymi indeksami jest jeszcze bardziej kruche, jeÅ›li napiszemy funkcjÄ™ <code>second_word</code>. Jej sygnatura musiaÅ‚aby wyglÄ…daÄ‡ tak:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {</code></pre>
<p>Teraz Å›ledzimy indeks poczÄ…tkowy <em>i</em> koÅ„cowy, i mamy jeszcze wiÄ™cej wartoÅ›ci, ktÃ³re zostaÅ‚y obliczone na podstawie danych w okreÅ›lonym stanie, ale w ogÃ³le nie sÄ… z tym stanem powiÄ…zane. Mamy trzy niepowiÄ…zane zmienne, ktÃ³re muszÄ… byÄ‡ zsynchronizowane.</p>
<p>Na szczÄ™Å›cie Rust ma rozwiÄ…zanie tego problemu: wycinki ciÄ…gÃ³w znakÃ³w (string slices).</p>
<h3 id="wycinki-ciÄ…gÃ³w-znakÃ³w-string-slices"><a class="header" href="#wycinki-ciÄ…gÃ³w-znakÃ³w-string-slices">Wycinki ciÄ…gÃ³w znakÃ³w (String Slices)</a></h3>
<p><em>Wycinek ciÄ…gu znakÃ³w</em> to referencja do ciÄ…gÅ‚ej sekwencji elementÃ³w <code>String</code> i wyglÄ…da tak:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s = String::from("hello world");

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
<span class="boring">}</span></code></pre>
<p>Zamiast referencji do caÅ‚ego <code>String</code>, <code>hello</code> jest referencjÄ… do fragmentu <code>String</code>, okreÅ›lonego dodatkowym fragmentem <code>[0..5]</code>. Wycinki tworzymy za pomocÄ… zakresu w nawiasach kwadratowych, okreÅ›lajÄ…c <code>[indeks_poczÄ…tkowy..indeks_koÅ„cowy]</code>, gdzie <em><code>indeks_poczÄ…tkowy</code></em> to pierwsza pozycja w wycinku, a <em><code>indeks_koÅ„cowy</code></em> to jeden wiÄ™cej niÅ¼ ostatnia pozycja w wycinku. WewnÄ™trznie struktura danych wycinka przechowuje pozycjÄ™ poczÄ…tkowÄ… i dÅ‚ugoÅ›Ä‡ wycinka, co odpowiada <em><code>indeks_koÅ„cowy</code></em> minus <em><code>indeks_poczÄ…tkowy</code></em>. Zatem w przypadku <code>let world = &amp;s[6..11];</code>, <code>world</code> byÅ‚by wycinkiem, ktÃ³ry zawiera wskaÅºnik do bajtu o indeksie 6 w <code>s</code> z wartoÅ›ciÄ… dÅ‚ugoÅ›ci <code>5</code>.</p>
<p>Rysunek 4-7 przedstawia to na diagramie.</p>
<img alt="Trzy tabele: tabela reprezentujÄ…ca dane stosu s, ktÃ³ra wskazuje na bajt o indeksie 0 w tabeli danych ciÄ…gu &quot;hello world&quot; na stercie. Trzecia tabela reprezentuje dane stosu wycinka world, ktÃ³ra ma wartoÅ›Ä‡ dÅ‚ugoÅ›ci 5 i wskazuje na bajt 6 tabeli danych sterty." src="img/trpl04-07.svg" class="center" style="width: 50%;" />
<p><span class="caption">Rysunek 4-7: Wycinek ciÄ…gu znakÃ³w odnoszÄ…cy siÄ™ do czÄ™Å›ci <code>String</code></span></p>
<p>DziÄ™ki skÅ‚adni zakresu <code>..</code> w Rust, jeÅ›li chcesz zaczÄ…Ä‡ od indeksu 0, moÅ¼esz pominÄ…Ä‡ wartoÅ›Ä‡ przed dwoma kropkami. Innymi sÅ‚owy, te sÄ… rÃ³wnowaÅ¼ne:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}</span></code></pre>
<p>Analogicznie, jeÅ›li twÃ³j wycinek zawiera ostatni bajt <code>String</code>, moÅ¼esz pominÄ…Ä‡ koÅ„cowÄ… liczbÄ™. Oznacza to, Å¼e te sÄ… rÃ³wnowaÅ¼ne:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}</span></code></pre>
<p>MoÅ¼esz rÃ³wnieÅ¼ pominÄ…Ä‡ obie wartoÅ›ci, aby utworzyÄ‡ wycinek caÅ‚ego ciÄ…gu. W ten sposÃ³b te sÄ… rÃ³wnowaÅ¼ne:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}</span></code></pre>
<blockquote>
<p>Uwaga: Indeksy zakresu wycinka ciÄ…gu muszÄ… wystÄ™powaÄ‡ na prawidÅ‚owych granicach znakÃ³w UTF-8. JeÅ›li sprÃ³bujesz utworzyÄ‡ wycinek ciÄ…gu w Å›rodku znaku wielobajtowego, program zakoÅ„czy siÄ™ bÅ‚Ä™dem.</p>
</blockquote>
<p>MajÄ…c na uwadze wszystkie te informacje, przepiszmy <code>first_word</code>, aby zwracaÅ‚o wycinek. Typ, ktÃ³ry oznacza â€wycinek ciÄ…gu znakÃ³wâ€, jest zapisywany jako <code>&amp;str</code>:</p>
<listing file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
</listing>
<p>Indeks koÅ„ca sÅ‚owa uzyskujemy w ten sam sposÃ³b, jak w Listingu 4-7, szukajÄ…c pierwszego wystÄ…pienia spacji. Gdy znajdziemy spacjÄ™, zwracamy wycinek ciÄ…gu, uÅ¼ywajÄ…c poczÄ…tku ciÄ…gu i indeksu spacji jako indeksÃ³w poczÄ…tkowego i koÅ„cowego.</p>
<p>Teraz, gdy wywoÅ‚ujemy <code>first_word</code>, otrzymujemy jednÄ… wartoÅ›Ä‡, ktÃ³ra jest powiÄ…zana z danymi podstawowymi. WartoÅ›Ä‡ ta skÅ‚ada siÄ™ z referencji do punktu poczÄ…tkowego wycinka i liczby elementÃ³w w wycinku.</p>
<p>Zwracanie wycinka dziaÅ‚aÅ‚oby rÃ³wnieÅ¼ dla funkcji <code>second_word</code>:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>Mamy teraz prosty interfejs API, ktÃ³ry jest znacznie trudniejszy do popsucia, poniewaÅ¼ kompilator zapewni, Å¼e referencje do <code>String</code> pozostanÄ… waÅ¼ne. PamiÄ™tasz bÅ‚Ä…d w programie z Listingu 4-8, kiedy uzyskaliÅ›my indeks koÅ„ca pierwszego sÅ‚owa, ale potem wyczyÅ›ciliÅ›my ciÄ…g, wiÄ™c nasz indeks byÅ‚ nieprawidÅ‚owy? Ten kod byÅ‚ logicznie niepoprawny, ale nie wykazywaÅ‚ Å¼adnych natychmiastowych bÅ‚Ä™dÃ³w. Problemy pojawiÅ‚yby siÄ™ pÃ³Åºniej, gdybyÅ›my nadal prÃ³bowali uÅ¼ywaÄ‡ indeksu pierwszego sÅ‚owa z oprÃ³Å¼nionym ciÄ…giem. Wycinki uniemoÅ¼liwiajÄ… ten bÅ‚Ä…d i pozwalajÄ… nam znacznie wczeÅ›niej dowiedzieÄ‡ siÄ™, Å¼e mamy problem z naszym kodem. UÅ¼ycie wersji <code>first_word</code> z wycinkiem spowoduje bÅ‚Ä…d kompilacji:</p>
<listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn first_word(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s);

    s.clear(); // bÅ‚Ä…d!

    println!("pierwsze sÅ‚owo to: {word}");
}</code></pre>
</listing>
<p>Oto bÅ‚Ä…d kompilatora:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {word}");
   |                                   ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Przypomnij sobie z zasad poÅ¼yczania, Å¼e jeÅ›li mamy niezmiennÄ… referencjÄ™ do czegoÅ›, nie moÅ¼emy rÃ³wnieÅ¼ wziÄ…Ä‡ mutowalnej referencji. PoniewaÅ¼ <code>clear</code> musi skrÃ³ciÄ‡ <code>String</code>, potrzebuje mutowalnej referencji. <code>println!</code> po wywoÅ‚aniu <code>clear</code> uÅ¼ywa referencji w <code>word</code>, wiÄ™c referencja niezmienna musi byÄ‡ nadal aktywna w tym punkcie. Rust zabrania istnienia mutowalnej referencji w <code>clear</code> i niezmiennej referencji w <code>word</code> w tym samym czasie, a kompilacja koÅ„czy siÄ™ niepowodzeniem. Rust nie tylko uÅ‚atwiÅ‚ nam korzystanie z API, ale takÅ¼e wyeliminowaÅ‚ caÅ‚Ä… klasÄ™ bÅ‚Ä™dÃ³w w czasie kompilacji!</p>
<p><a id="string-literals-are-slices"></a></p>
<h4 id="literaÅ‚y-ciÄ…gÃ³w-znakÃ³w-jako-wycinki"><a class="header" href="#literaÅ‚y-ciÄ…gÃ³w-znakÃ³w-jako-wycinki">LiteraÅ‚y ciÄ…gÃ³w znakÃ³w jako wycinki</a></h4>
<p>Przypomnijmy, Å¼e mÃ³wiliÅ›my o literaÅ‚ach ciÄ…gÃ³w znakÃ³w przechowywanych wewnÄ…trz pliku binarnego. Teraz, gdy wiemy o wycinkach, moÅ¼emy wÅ‚aÅ›ciwie zrozumieÄ‡ literaÅ‚y ciÄ…gÃ³w znakÃ³w:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "Hello, world!";
<span class="boring">}</span></code></pre>
<p>Typ <code>s</code> to <code>&amp;str</code>: jest to wycinek wskazujÄ…cy na ten konkretny punkt w pliku binarnym. Jest to rÃ³wnieÅ¼ powÃ³d, dla ktÃ³rego literaÅ‚y ciÄ…gÃ³w znakÃ³w sÄ… niezmienne; <code>&amp;str</code> to niezmienna referencja.</p>
<h4 id="wycinki-ciÄ…gÃ³w-znakÃ³w-jako-parametry"><a class="header" href="#wycinki-ciÄ…gÃ³w-znakÃ³w-jako-parametry">Wycinki ciÄ…gÃ³w znakÃ³w jako parametry</a></h4>
<p>Wiedza o tym, Å¼e moÅ¼na tworzyÄ‡ wycinki z literaÅ‚Ã³w i wartoÅ›ci <code>String</code>, prowadzi nas do jeszcze jednego ulepszenia funkcji <code>first_word</code>, a mianowicie jej sygnatury:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>Bardziej doÅ›wiadczony Rustacean napisaÅ‚by sygnaturÄ™ pokazanÄ… w Listingu 4-9 zamiast niej, poniewaÅ¼ pozwala to nam uÅ¼ywaÄ‡ tej samej funkcji zarÃ³wno dla wartoÅ›ci <code>&amp;String</code>, jak i dla wartoÅ›ci <code>&amp;str</code>.</p>
<listing number="4-9" caption="Ulepszanie funkcji `first_word` poprzez uÅ¼ycie wycinka ciÄ…gu znakÃ³w dla typu parametru `s`">
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from("hello world");
</span><span class="boring">
</span><span class="boring">    // `first_word` dziaÅ‚a na wycinkach `String`Ã³w, czÄ™Å›ciowych lub caÅ‚ych.
</span><span class="boring">    let word = first_word(&amp;my_string[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">    // `first_word` dziaÅ‚a rÃ³wnieÅ¼ na referencjach do `String`Ã³w, ktÃ³re sÄ… rÃ³wnowaÅ¼ne
</span><span class="boring">    // z caÅ‚ymi wycinkami `String`Ã³w.
</span><span class="boring">    let word = first_word(&amp;my_string);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = "hello world";
</span><span class="boring">
</span><span class="boring">    // `first_word` dziaÅ‚a na wycinkach literaÅ‚Ã³w ciÄ…gu znakÃ³w, czÄ™Å›ciowych lub
</span><span class="boring">    // caÅ‚ych.
</span><span class="boring">    let word = first_word(&amp;my_string_literal[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // PoniewaÅ¼ literaÅ‚y ciÄ…gu znakÃ³w *sÄ…* juÅ¼ wycinkami ciÄ…gu znakÃ³w,
</span><span class="boring">    // to rÃ³wnieÅ¼ dziaÅ‚a, bez skÅ‚adni wycinkÃ³w!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre>
</listing>
<p>JeÅ›li mamy wycinek ciÄ…gu znakÃ³w, moÅ¼emy go przekazaÄ‡ bezpoÅ›rednio. JeÅ›li mamy <code>String</code>, moÅ¼emy przekazaÄ‡ wycinek <code>String</code> lub referencjÄ™ do <code>String</code>. Ta elastycznoÅ›Ä‡ wykorzystuje konwersje dereferencji, cechÄ™, ktÃ³rÄ… omÃ³wimy w sekcji <a href="#using-deref-coercions-in-functions-and-methods">â€UÅ¼ywanie konwersji dereferencji w funkcjach i metodachâ€</a><!-- ignore --> w Rozdziale 15.</p>
<p>Definiowanie funkcji, ktÃ³ra przyjmuje wycinek ciÄ…gu znakÃ³w zamiast referencji do <code>String</code>, sprawia, Å¼e nasze API jest bardziej ogÃ³lne i uÅ¼yteczne bez utraty Å¼adnej funkcjonalnoÅ›ci:</p>
<listing file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let my_string = String::from("hello world");

    // `first_word` dziaÅ‚a na wycinkach `String`Ã³w, czÄ™Å›ciowych lub caÅ‚ych.
    let word = first_word(&amp;my_string[0..6]);
    let word = first_word(&amp;my_string[..]);
    // `first_word` dziaÅ‚a rÃ³wnieÅ¼ na referencjach do `String`Ã³w, ktÃ³re sÄ… rÃ³wnowaÅ¼ne
    // z caÅ‚ymi wycinkami `String`Ã³w.
    let word = first_word(&amp;my_string);

    let my_string_literal = "hello world";

    // `first_word` dziaÅ‚a na wycinkach literaÅ‚Ã³w ciÄ…gu znakÃ³w, czÄ™Å›ciowych lub
    // caÅ‚ych.
    let word = first_word(&amp;my_string_literal[0..6]);
    let word = first_word(&amp;my_string_literal[..]);

    // PoniewaÅ¼ literaÅ‚y ciÄ…gu znakÃ³w *sÄ…* juÅ¼ wycinkami ciÄ…gu znakÃ³w,
    // to rÃ³wnieÅ¼ dziaÅ‚a, bez skÅ‚adni wycinkÃ³w!
    let word = first_word(my_string_literal);
}</code></pre>
</listing>
<h3 id="inne-wycinki"><a class="header" href="#inne-wycinki">Inne wycinki</a></h3>
<p>Wycinki ciÄ…gÃ³w znakÃ³w, jak moÅ¼na sobie wyobraziÄ‡, sÄ… specyficzne dla ciÄ…gÃ³w. Ale istnieje rÃ³wnieÅ¼ bardziej ogÃ³lny typ wycinka. RozwaÅ¼my tÄ™ tablicÄ™:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre>
<p>Tak samo jak moÅ¼emy chcieÄ‡ odwoÅ‚aÄ‡ siÄ™ do czÄ™Å›ci ciÄ…gu, moÅ¼emy chcieÄ‡ odwoÅ‚aÄ‡ siÄ™ do czÄ™Å›ci tablicy. ZrobilibyÅ›my to w ten sposÃ³b:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}</span></code></pre>
<p>Ten wycinek ma typ <code>&amp;[i32]</code>. DziaÅ‚a tak samo jak wycinki ciÄ…gÃ³w, przechowujÄ…c referencjÄ™ do pierwszego elementu i dÅ‚ugoÅ›Ä‡. BÄ™dziesz uÅ¼ywaÄ‡ tego rodzaju wycinkÃ³w dla wszelkiego rodzaju innych kolekcji. Te kolekcje omÃ³wimy szczegÃ³Å‚owo, gdy bÄ™dziemy mÃ³wiÄ‡ o wektorach w Rozdziale 8.</p>
<h2 id="podsumowanie-3"><a class="header" href="#podsumowanie-3">Podsumowanie</a></h2>
<p>Koncepcje wÅ‚asnoÅ›ci, poÅ¼yczania i wycinkÃ³w zapewniajÄ… bezpieczeÅ„stwo pamiÄ™ci w programach Rust w czasie kompilacji. JÄ™zyk Rust daje kontrolÄ™ nad wykorzystaniem pamiÄ™ci w taki sam sposÃ³b, jak inne jÄ™zyki programowania systemowego. Ale to, Å¼e wÅ‚aÅ›ciciel danych automatycznie czyÅ›ci te dane, gdy wÅ‚aÅ›ciciel wychodzi poza zasiÄ™g, oznacza, Å¼e nie musisz pisaÄ‡ i debugowaÄ‡ dodatkowego kodu, aby uzyskaÄ‡ tÄ™ kontrolÄ™.</p>
<p>WÅ‚asnoÅ›Ä‡ wpÅ‚ywa na dziaÅ‚anie wielu innych czÄ™Å›ci Rust, wiÄ™c bÄ™dziemy rozmawiaÄ‡ o tych koncepcjach w dalszej czÄ™Å›ci ksiÄ…Å¼ki. PrzejdÅºmy do RozdziaÅ‚u 5 i przyjrzyjmy siÄ™ grupowaniu fragmentÃ³w danych w <code>struct</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="uÅ¼ycie-struktur-do-organizacji-powiÄ…zanych-danych"><a class="header" href="#uÅ¼ycie-struktur-do-organizacji-powiÄ…zanych-danych">UÅ¼ycie struktur do organizacji powiÄ…zanych danych</a></h1>
<p><em>Struktura</em> to niestandardowy typ danych, ktÃ³ry pozwala na grupowanie i nazywanie wielu powiÄ…zanych wartoÅ›ci, tworzÄ…cych spÃ³jnÄ… grupÄ™. JeÅ›li znasz jÄ™zyki obiektowe, struktura jest jak atrybuty danych obiektu. W tym rozdziale porÃ³wnamy krotki ze strukturami, aby rozbudowaÄ‡ twojÄ… wiedzÄ™ i pokazaÄ‡, kiedy struktury sÄ… lepszym sposobem na grupowanie danych.</p>
<p>OmÃ³wimy, jak definiowaÄ‡ i tworzyÄ‡ instancje struktur. Dowiemy siÄ™, jak definiowaÄ‡ funkcje skojarzone, zwÅ‚aszcza <em>metody</em>, aby okreÅ›laÄ‡ zachowanie zwiÄ…zane z typem struktury. Struktury i typy wyliczeniowe (enum, omÃ³wione w Rozdziale 6) to elementy skÅ‚adowe do tworzenia nowych typÃ³w w domenie twojego programu, aby w peÅ‚ni wykorzystaÄ‡ sprawdzanie typÃ³w w czasie kompilacji w Rust.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="definiowanie-i-tworzenie-instancji-struktur-1"><a href="#definiowanie-i-tworzenie-instancji-struktur-1" class="header">Definiowanie i tworzenie instancji struktur</a></h1>
<h2 id="definiowanie-i-tworzenie-instancji-struktur"><a class="header" href="#definiowanie-i-tworzenie-instancji-struktur">Definiowanie i tworzenie instancji struktur</a></h2>
<p>Struktury sÄ… podobne do krotek, omÃ³wionych w sekcji <a href="#the-tuple-type">â€Typ krotkiâ€</a><!-- ignore -->, w tym, Å¼e obie przechowujÄ… wiele powiÄ…zanych wartoÅ›ci. Podobnie jak krotki, elementy struktury mogÄ… byÄ‡ rÃ³Å¼nych typÃ³w. W przeciwieÅ„stwie do krotek, w strukturze nazwiesz kaÅ¼dy element danych, tak aby byÅ‚o jasne, co oznaczajÄ… wartoÅ›ci. Dodanie tych nazw sprawia, Å¼e struktury sÄ… bardziej elastyczne niÅ¼ krotki: nie musisz polegaÄ‡ na kolejnoÅ›ci danych, aby okreÅ›liÄ‡ lub uzyskaÄ‡ dostÄ™p do wartoÅ›ci instancji.</p>
<p>Aby zdefiniowaÄ‡ strukturÄ™, wpisujemy sÅ‚owo kluczowe <code>struct</code> i nadajemy nazwÄ™ caÅ‚ej strukturze. Nazwa struktury powinna opisywaÄ‡ znaczenie grupowanych danych. NastÄ™pnie, w nawiasach klamrowych, definiujemy nazwy i typy elementÃ³w danych, ktÃ³re nazywamy <em>polami</em>. Na przykÅ‚ad, Listing 5-1 przedstawia strukturÄ™, ktÃ³ra przechowuje informacje o koncie uÅ¼ytkownika.</p>
<listing number="5-1" file-name="src/main.rs" caption="Definicja struktury `User`">
<pre class="playground"><code class="language-rust edition2024">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
</listing>
<p>Aby uÅ¼yÄ‡ struktury po jej zdefiniowaniu, tworzymy <em>instancjÄ™</em> tej struktury, okreÅ›lajÄ…c konkretne wartoÅ›ci dla kaÅ¼dego z pÃ³l. Tworzymy instancjÄ™, podajÄ…c nazwÄ™ struktury, a nastÄ™pnie dodajemy nawiasy klamrowe zawierajÄ…ce pary <em><code>klucz: wartoÅ›Ä‡</code></em>, gdzie klucze to nazwy pÃ³l, a wartoÅ›ci to dane, ktÃ³re chcemy przechowywaÄ‡ w tych polach. Nie musimy okreÅ›laÄ‡ pÃ³l w tej samej kolejnoÅ›ci, w jakiej zadeklarowaliÅ›my je w strukturze. Innymi sÅ‚owy, definicja struktury jest jak ogÃ³lny szablon dla typu, a instancje wypeÅ‚niajÄ… ten szablon konkretnymi danymi, aby utworzyÄ‡ wartoÅ›ci tego typu. Na przykÅ‚ad, moÅ¼emy zadeklarowaÄ‡ konkretnego uÅ¼ytkownika, jak pokazano w Listingu 5-2.</p>
<listing number="5-2" file-name="src/main.rs" caption="Tworzenie instancji struktury `User`">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}</code></pre>
</listing>
<p>Aby uzyskaÄ‡ konkretnÄ… wartoÅ›Ä‡ ze struktury, uÅ¼ywamy notacji kropkowej. Na przykÅ‚ad, aby uzyskaÄ‡ dostÄ™p do adresu e-mail tego uÅ¼ytkownika, uÅ¼ywamy <code>user1.email</code>. JeÅ›li instancja jest mutowalna, moÅ¼emy zmieniÄ‡ wartoÅ›Ä‡, uÅ¼ywajÄ…c notacji kropkowej i przypisujÄ…c jÄ… do konkretnego pola. Listing 5-3 pokazuje, jak zmieniÄ‡ wartoÅ›Ä‡ w polu <code>email</code> mutowalnej instancji <code>User</code>.</p>
<listing number="5-3" file-name="src/main.rs" caption="Zmiana wartoÅ›ci w polu `email` instancji `User`">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}</code></pre>
</listing>
<p>ZauwaÅ¼, Å¼e caÅ‚a instancja musi byÄ‡ mutowalna; Rust nie pozwala nam oznaczaÄ‡ tylko niektÃ³rych pÃ³l jako mutowalne. Podobnie jak w przypadku kaÅ¼dego wyraÅ¼enia, moÅ¼emy skonstruowaÄ‡ nowÄ… instancjÄ™ struktury jako ostatnie wyraÅ¼enie w treÅ›ci funkcji, aby niejawnie zwrÃ³ciÄ‡ tÄ™ nowÄ… instancjÄ™.</p>
<p>Listing 5-4 przedstawia funkcjÄ™ <code>build_user</code>, ktÃ³ra zwraca instancjÄ™ <code>User</code> z podanym adresem e-mail i nazwÄ… uÅ¼ytkownika. Pole <code>active</code> otrzymuje wartoÅ›Ä‡ <code>true</code>, a <code>sign_in_count</code> wartoÅ›Ä‡ <code>1</code>.</p>
<listing number="5-4" file-name="src/main.rs" caption="Funkcja `build_user`, ktÃ³ra przyjmuje adres e-mail i nazwÄ™ uÅ¼ytkownika oraz zwraca instancjÄ™ `User`">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("someone@example.com"),
</span><span class="boring">        String::from("someusername123"),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre>
</listing>
<p>Logiczne jest nazwanie parametrÃ³w funkcji tak samo jak pÃ³l struktury, ale powtarzanie nazw pÃ³l <code>email</code> i <code>username</code> oraz zmiennych jest trochÄ™ uciÄ…Å¼liwe. Gdyby struktura miaÅ‚a wiÄ™cej pÃ³l, powtarzanie kaÅ¼dej nazwy staÅ‚oby siÄ™ jeszcze bardziej irytujÄ…ce. Na szczÄ™Å›cie istnieje wygodna skrÃ³cona forma!</p>
<p><a id="using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name"></a></p>
<h3 id="uÅ¼ywanie-skrÃ³conej-skÅ‚adni-inicjalizacji-pola"><a class="header" href="#uÅ¼ywanie-skrÃ³conej-skÅ‚adni-inicjalizacji-pola">UÅ¼ywanie skrÃ³conej skÅ‚adni inicjalizacji pola</a></h3>
<p>PoniewaÅ¼ nazwy parametrÃ³w i nazwy pÃ³l struktury sÄ… dokÅ‚adnie takie same w Listingu 5-4, moÅ¼emy uÅ¼yÄ‡ skÅ‚adni <em>skrÃ³conej inicjalizacji pola</em> do przepisania <code>build_user</code> tak, aby zachowywaÅ‚a siÄ™ dokÅ‚adnie tak samo, ale nie powtarzaÅ‚a <code>username</code> i <code>email</code>, jak pokazano w Listingu 5-5.</p>
<listing number="5-5" file-name="src/main.rs" caption="Funkcja `build_user`, ktÃ³ra uÅ¼ywa skrÃ³conej inicjalizacji pola, poniewaÅ¼ parametry `username` i `email` majÄ… takie same nazwy jak pola struktury">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("someone@example.com"),
</span><span class="boring">        String::from("someusername123"),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre>
</listing>
<p>Tutaj tworzymy nowÄ… instancjÄ™ struktury <code>User</code>, ktÃ³ra ma pole o nazwie <code>email</code>. Chcemy ustawiÄ‡ wartoÅ›Ä‡ pola <code>email</code> na wartoÅ›Ä‡ z parametru <code>email</code> funkcji <code>build_user</code>. PoniewaÅ¼ pole <code>email</code> i parametr <code>email</code> majÄ… tÄ™ samÄ… nazwÄ™, wystarczy napisaÄ‡ <code>email</code> zamiast <code>email: email</code>.</p>
<p><a id="creating-instances-from-other-instances-with-struct-update-syntax"></a></p>
<h3 id="tworzenie-instancji-za-pomocÄ…-skÅ‚adni-aktualizacji-struktury"><a class="header" href="#tworzenie-instancji-za-pomocÄ…-skÅ‚adni-aktualizacji-struktury">Tworzenie instancji za pomocÄ… skÅ‚adni aktualizacji struktury</a></h3>
<p>CzÄ™sto przydaje siÄ™ tworzenie nowej instancji struktury, ktÃ³ra zawiera wiÄ™kszoÅ›Ä‡ wartoÅ›ci z innej instancji tego samego typu, ale zmienia niektÃ³re z nich. MoÅ¼esz to zrobiÄ‡ za pomocÄ… skÅ‚adni aktualizacji struktury.</p>
<p>Najpierw, w Listingu 5-6, pokazujemy, jak utworzyÄ‡ nowÄ… instancjÄ™ <code>User</code> w <code>user2</code> w zwykÅ‚y sposÃ³b, bez skÅ‚adni aktualizacji. Ustawiamy nowÄ… wartoÅ›Ä‡ dla <code>email</code>, ale poza tym uÅ¼ywamy tych samych wartoÅ›ci z <code>user1</code>, ktÃ³re utworzyliÅ›my w Listingu 5-2.</p>
<listing number="5-6" file-name="src/main.rs" caption="Tworzenie nowej instancji `User` z uÅ¼yciem wszystkich wartoÅ›ci z `user1` oprÃ³cz jednej">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("someone@example.com"),
</span><span class="boring">        username: String::from("someusername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}</code></pre>
</listing>
<p>UÅ¼ywajÄ…c skÅ‚adni aktualizacji struktury, moÅ¼emy osiÄ…gnÄ…Ä‡ ten sam efekt za pomocÄ… mniejszej iloÅ›ci kodu, jak pokazano w Listingu 5-7. SkÅ‚adnia <code>..</code> okreÅ›la, Å¼e pozostaÅ‚e pola, ktÃ³re nie zostaÅ‚y jawnie ustawione, powinny mieÄ‡ takÄ… samÄ… wartoÅ›Ä‡ jak pola w danej instancji.</p>
<listing number="5-7" file-name="src/main.rs" caption="UÅ¼ywanie skÅ‚adni aktualizacji struktury do ustawienia nowej wartoÅ›ci `email` dla instancji `User`, ale uÅ¼ycie reszty wartoÅ›ci z `user1`">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --snip--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("someone@example.com"),
</span><span class="boring">        username: String::from("someusername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
}</code></pre>
</listing>
<p>Kod w Listingu 5-7 rÃ³wnieÅ¼ tworzy instancjÄ™ <code>user2</code>, ktÃ³ra ma innÄ… wartoÅ›Ä‡ dla <code>email</code>, ale ma te same wartoÅ›ci dla pÃ³l <code>username</code>, <code>active</code> i <code>sign_in_count</code> co <code>user1</code>. Instrukcja <code>..user1</code> musi znajdowaÄ‡ siÄ™ na koÅ„cu, aby okreÅ›liÄ‡, Å¼e wszelkie pozostaÅ‚e pola powinny otrzymaÄ‡ swoje wartoÅ›ci z odpowiednich pÃ³l w <code>user1</code>, ale moÅ¼emy wybraÄ‡, aby okreÅ›liÄ‡ wartoÅ›ci dla dowolnej liczby pÃ³l w dowolnej kolejnoÅ›ci, niezaleÅ¼nie od kolejnoÅ›ci pÃ³l w definicji struktury.</p>
<p>ZauwaÅ¼, Å¼e skÅ‚adnia aktualizacji struktury uÅ¼ywa <code>=</code> jak przypisania; dzieje siÄ™ tak dlatego, Å¼e przenosi ona dane, tak jak widzieliÅ›my to w sekcji <a href="#variables-and-data-interact-with-move">â€Zmienne i dane w interakcji przez przeniesienieâ€</a><!-- ignore -->. W tym przykÅ‚adzie nie moÅ¼emy juÅ¼ uÅ¼ywaÄ‡ <code>user1</code> po utworzeniu <code>user2</code>, poniewaÅ¼ <code>String</code> z pola <code>username</code> w <code>user1</code> zostaÅ‚o przeniesione do <code>user2</code>. GdybyÅ›my podali <code>user2</code> nowe wartoÅ›ci <code>String</code> dla <code>email</code> i <code>username</code>, a wiÄ™c uÅ¼yli tylko wartoÅ›ci <code>active</code> i <code>sign_in_count</code> z <code>user1</code>, wÃ³wczas <code>user1</code> byÅ‚oby nadal waÅ¼ne po utworzeniu <code>user2</code>. ZarÃ³wno <code>active</code>, jak i <code>sign_in_count</code> to typy implementujÄ…ce cechÄ™ <code>Copy</code>, wiÄ™c zastosowaÅ‚oby siÄ™ zachowanie, o ktÃ³rym mÃ³wiliÅ›my w sekcji <a href="#stack-only-data-copy">â€Dane tylko na stosie: Kopiaâ€</a><!-- ignore -->. W tym przykÅ‚adzie nadal moÅ¼emy uÅ¼ywaÄ‡ <code>user1.email</code>, poniewaÅ¼ jego wartoÅ›Ä‡ nie zostaÅ‚a przeniesiona z <code>user1</code>.</p>
<p><a id="using-tuple-structs-without-named-fields-to-create-different-types"></a></p>
<h3 id="tworzenie-rÃ³Å¼nych-typÃ³w-za-pomocÄ…-struktur-krotkowych"><a class="header" href="#tworzenie-rÃ³Å¼nych-typÃ³w-za-pomocÄ…-struktur-krotkowych">Tworzenie rÃ³Å¼nych typÃ³w za pomocÄ… struktur krotkowych</a></h3>
<p>Rust obsÅ‚uguje rÃ³wnieÅ¼ struktury, ktÃ³re wyglÄ…dajÄ… podobnie do krotek, nazywane <em>strukturami krotkowymi</em>. Struktury krotkowe posiadajÄ… dodatkowe znaczenie, ktÃ³re nadaje im nazwa struktury, ale nie majÄ… nazw powiÄ…zanych z ich polami; zamiast tego majÄ… tylko typy pÃ³l. Struktury krotkowe sÄ… uÅ¼yteczne, gdy chcesz nadaÄ‡ caÅ‚ej krotce nazwÄ™ i uczyniÄ‡ jÄ… innym typem niÅ¼ inne krotki, oraz gdy nazwanie kaÅ¼dego pola, jak w zwykÅ‚ej strukturze, byÅ‚oby zbyt rozwlekÅ‚e lub redundantne.</p>
<p>Aby zdefiniowaÄ‡ strukturÄ™ krotkowÄ…, zacznij od sÅ‚owa kluczowego <code>struct</code> i nazwy struktury, a nastÄ™pnie podaj typy w krotce. Na przykÅ‚ad, tutaj definiujemy i uÅ¼ywamy dwÃ³ch struktur krotkowych o nazwach <code>Color</code> i <code>Point</code>:</p>
<listing file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}</code></pre>
</listing>
<p>ZauwaÅ¼, Å¼e wartoÅ›ci <code>black</code> i <code>origin</code> sÄ… rÃ³Å¼nych typÃ³w, poniewaÅ¼ sÄ… instancjami rÃ³Å¼nych struktur krotek. KaÅ¼da zdefiniowana przez ciebie struktura jest swoim wÅ‚asnym typem, mimo Å¼e pola w strukturze mogÄ… mieÄ‡ te same typy. Na przykÅ‚ad, funkcja, ktÃ³ra przyjmuje parametr typu <code>Color</code>, nie moÅ¼e przyjÄ…Ä‡ <code>Point</code> jako argumentu, mimo Å¼e oba typy skÅ‚adajÄ… siÄ™ z trzech wartoÅ›ci <code>i32</code>. W przeciwnym razie, instancje struktur krotek sÄ… podobne do krotek w tym sensie, Å¼e moÅ¼na je dekomponowaÄ‡ na pojedyncze elementy i moÅ¼na uÅ¼yÄ‡ <code>.</code> po ktÃ³rym nastÄ™puje indeks, aby uzyskaÄ‡ dostÄ™p do pojedynczej wartoÅ›ci. W przeciwieÅ„stwie do krotek, struktury krotki wymagajÄ… podania nazwy typu struktury podczas dekompozycji. Na przykÅ‚ad, napisalibyÅ›my <code>let Point(x, y, z) = origin;</code>, aby dekomponowaÄ‡ wartoÅ›ci punktu <code>origin</code> na zmienne o nazwach <code>x</code>, <code>y</code> i <code>z</code>.</p>
<p><a id="unit-like-structs-without-any-fields"></a></p>
<h3 id="definiowanie-struktur-podobnych-do-jednostek"><a class="header" href="#definiowanie-struktur-podobnych-do-jednostek">Definiowanie struktur podobnych do jednostek</a></h3>
<p>MoÅ¼na rÃ³wnieÅ¼ definiowaÄ‡ struktury, ktÃ³re nie majÄ… Å¼adnych pÃ³l! Nazywa siÄ™ je <em>strukturami podobnymi do jednostek</em>, poniewaÅ¼ zachowujÄ… siÄ™ podobnie do <code>()</code>, typu jednostkowego, o ktÃ³rym wspominaliÅ›my w sekcji <a href="#the-tuple-type">â€Typ krotkiâ€</a><!-- ignore -->. Struktury podobne do jednostek mogÄ… byÄ‡ uÅ¼yteczne, gdy trzeba zaimplementowaÄ‡ cechÄ™ dla jakiegoÅ› typu, ale nie ma siÄ™ Å¼adnych danych do przechowywania w samym typie. O cechach omÃ³wimy w Rozdziale 10. Oto przykÅ‚ad deklaracji i tworzenia instancji struktury jednostkowej o nazwie <code>AlwaysEqual</code>:</p>
<listing file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}</code></pre>
</listing>
<p>Aby zdefiniowaÄ‡ <code>AlwaysEqual</code>, uÅ¼ywamy sÅ‚owa kluczowego <code>struct</code>, wybranej nazwy, a nastÄ™pnie Å›rednika. Nie ma potrzeby uÅ¼ywania nawiasÃ³w klamrowych ani okrÄ…gÅ‚ych! NastÄ™pnie moÅ¼emy uzyskaÄ‡ instancjÄ™ <code>AlwaysEqual</code> w zmiennej <code>subject</code> w podobny sposÃ³b: uÅ¼ywajÄ…c zdefiniowanej nazwy, bez nawiasÃ³w klamrowych ani okrÄ…gÅ‚ych. WyobraÅº sobie, Å¼e pÃ³Åºniej zaimplementujemy zachowanie dla tego typu, tak aby kaÅ¼da instancja <code>AlwaysEqual</code> zawsze byÅ‚a rÃ³wna kaÅ¼dej instancji dowolnego innego typu, byÄ‡ moÅ¼e w celach testowych. Nie potrzebowalibyÅ›my Å¼adnych danych, aby zaimplementowaÄ‡ to zachowanie! W Rozdziale 10 dowiesz siÄ™, jak definiowaÄ‡ cechy i implementowaÄ‡ je na dowolnym typie, w tym na strukturach podobnych do jednostek.</p>
<blockquote>
<h3 id="wÅ‚asnoÅ›Ä‡-danych-struktury"><a class="header" href="#wÅ‚asnoÅ›Ä‡-danych-struktury">WÅ‚asnoÅ›Ä‡ Danych Struktury</a></h3>
<p>W definicji struktury <code>User</code> z Listingu 5-1 uÅ¼yliÅ›my wÅ‚asnego typu <code>String</code> zamiast typu wycinka ciÄ…gu <code>&amp;str</code>. Jest to celowy wybÃ³r, poniewaÅ¼ chcemy, aby kaÅ¼da instancja tej struktury posiadaÅ‚a wszystkie swoje dane, a dane te byÅ‚y waÅ¼ne tak dÅ‚ugo, jak waÅ¼na jest caÅ‚a struktura.</p>
<p>MoÅ¼liwe jest rÃ³wnieÅ¼, aby struktury przechowywaÅ‚y referencje do danych naleÅ¼Ä…cych do czegoÅ› innego, ale do tego wymagane jest uÅ¼ycie <em>czasÃ³w Å¼ycia</em> â€“ funkcji Rust, ktÃ³rÄ… omÃ³wimy w Rozdziale 10. Czasy Å¼ycia zapewniajÄ…, Å¼e dane, do ktÃ³rych odnosi siÄ™ struktura, sÄ… waÅ¼ne tak dÅ‚ugo, jak waÅ¼na jest struktura. Powiedzmy, Å¼e sprÃ³bujesz przechowywaÄ‡ referencjÄ™ w strukturze bez okreÅ›lania czasÃ³w Å¼ycia, tak jak poniÅ¼ej w <em>src/main.rs</em>; to nie zadziaÅ‚a:</p>
<listing file-name="src/main.rs">
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore does_not_compile">struct User {
    active: bool,
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: "someusername123",
        email: "someone@example.2com",
        sign_in_count: 1,
    };
}</code></pre>
</listing>
<p>Kompilator bÄ™dzie narzekaÅ‚, Å¼e potrzebuje specyfikatorÃ³w czasu Å¼ycia:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:15
  |
3 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 ~     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:12
  |
4 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 |     username: &amp;str,
4 ~     email: &amp;'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs` (bin "structs") due to 2 previous errors
</code></pre>
<p>W Rozdziale 10 omÃ³wimy, jak naprawiÄ‡ te bÅ‚Ä™dy, aby moÅ¼na byÅ‚o przechowywaÄ‡ referencje w strukturach, ale na razie bÄ™dziemy naprawiaÄ‡ takie bÅ‚Ä™dy, uÅ¼ywajÄ…c typÃ³w posiadanych, takich jak <code>String</code>, zamiast referencji, takich jak <code>&amp;str</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="przykÅ‚adowy-program-uÅ¼ywajÄ…cy-struktur-1"><a href="#przykÅ‚adowy-program-uÅ¼ywajÄ…cy-struktur-1" class="header">PrzykÅ‚adowy program uÅ¼ywajÄ…cy struktur</a></h1>
<h2 id="przykÅ‚adowy-program-uÅ¼ywajÄ…cy-struktur"><a class="header" href="#przykÅ‚adowy-program-uÅ¼ywajÄ…cy-struktur">PrzykÅ‚adowy program uÅ¼ywajÄ…cy struktur</a></h2>
<p>Aby zrozumieÄ‡, kiedy warto uÅ¼ywaÄ‡ struktur, napiszmy program, ktÃ³ry oblicza pole prostokÄ…ta. Zaczniemy od uÅ¼ycia pojedynczych zmiennych, a nastÄ™pnie zrefaktoryzujemy program, aÅ¼ bÄ™dziemy uÅ¼ywaÄ‡ struktur.</p>
<p>StwÃ³rzmy nowy projekt binarny za pomocÄ… Cargo o nazwie <em>rectangles</em>, ktÃ³ry bÄ™dzie przyjmowaÅ‚ szerokoÅ›Ä‡ i wysokoÅ›Ä‡ prostokÄ…ta podane w pikselach i obliczaÅ‚ pole prostokÄ…ta. Listing 5-8 przedstawia krÃ³tki program z jednym sposobem na zrobienie tego w pliku <em>src/main.rs</em> naszego projektu.</p>
<listing number="5-8" file-name="src/main.rs" caption="Obliczanie pola prostokÄ…ta okreÅ›lonego przez oddzielne zmienne szerokoÅ›ci i wysokoÅ›ci">
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        "Pole prostokÄ…ta wynosi {} pikseli kwadratowych.",
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}</code></pre>
</listing>
<p>Teraz uruchom ten program za pomocÄ… <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/rectangles`
The area of the rectangle is 1500 square pixels.
</code></pre>
<p>Ten kod z powodzeniem oblicza pole prostokÄ…ta, wywoÅ‚ujÄ…c funkcjÄ™ <code>area</code> z kaÅ¼dym wymiarem, ale moÅ¼emy zrobiÄ‡ wiÄ™cej, aby uczyniÄ‡ ten kod bardziej przejrzystym i czytelnym.</p>
<p>Problem z tym kodem jest widoczny w sygnaturze <code>area</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    let width1 = 30;
</span><span class="boring">    let height1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        "Pole prostokÄ…ta wynosi {} pikseli kwadratowych.",
</span><span class="boring">        area(width1, height1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn area(width: u32, height: u32) -&gt; u32 {
<span class="boring">    width * height
</span><span class="boring">}</span></code></pre>
<p>Funkcja <code>area</code> ma za zadanie obliczyÄ‡ pole jednego prostokÄ…ta, ale napisana przez nas funkcja ma dwa parametry i nigdzie w naszym programie nie jest jasne, Å¼e te parametry sÄ… ze sobÄ… powiÄ…zane. ByÅ‚oby bardziej czytelne i Å‚atwiejsze w zarzÄ…dzaniu, gdybyÅ›my zgrupowali szerokoÅ›Ä‡ i wysokoÅ›Ä‡. OmÃ³wiliÅ›my juÅ¼ jeden sposÃ³b, w jaki moglibyÅ›my to zrobiÄ‡ w sekcji <a href="#the-tuple-type">â€Typ krotkiâ€</a><!-- ignore --> w Rozdziale 3: uÅ¼ywajÄ…c krotek.</p>
<h3 id="refaktoryzacja-za-pomocÄ…-krotek"><a class="header" href="#refaktoryzacja-za-pomocÄ…-krotek">Refaktoryzacja za pomocÄ… krotek</a></h3>
<p>Listing 5-9 przedstawia innÄ… wersjÄ™ naszego programu, ktÃ³ra uÅ¼ywa krotek.</p>
<listing number="5-9" file-name="src/main.rs" caption="OkreÅ›lanie szerokoÅ›ci i wysokoÅ›ci prostokÄ…ta za pomocÄ… krotki">
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let rect1 = (30, 50);

    println!(
        "Pole prostokÄ…ta wynosi {} pikseli kwadratowych.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}</code></pre>
</listing>
<p>Pod pewnym wzglÄ™dem ten program jest lepszy. Krotki pozwalajÄ… nam dodaÄ‡ trochÄ™ struktury, a teraz przekazujemy tylko jeden argument. Ale pod innym wzglÄ™dem ta wersja jest mniej przejrzysta: krotki nie nazywajÄ… swoich elementÃ³w, wiÄ™c musimy indeksowaÄ‡ czÄ™Å›ci krotki, co sprawia, Å¼e nasze obliczenia sÄ… mniej oczywiste.</p>
<p>Pomylenie szerokoÅ›ci i wysokoÅ›ci nie miaÅ‚oby znaczenia dla obliczania powierzchni, ale gdybyÅ›my chcieli narysowaÄ‡ prostokÄ…t na ekranie, miaÅ‚oby to znaczenie! MusielibyÅ›my pamiÄ™taÄ‡, Å¼e <code>width</code> to indeks krotki <code>0</code>, a <code>height</code> to indeks krotki <code>1</code>. ByÅ‚oby to jeszcze trudniejsze do zrozumienia i zapamiÄ™tania dla kogoÅ› innego, kto uÅ¼ywaÅ‚by naszego kodu. PoniewaÅ¼ nie przekazaliÅ›my znaczenia naszych danych w naszym kodzie, Å‚atwiej jest teraz wprowadziÄ‡ bÅ‚Ä™dy.</p>
<p><a id="refactoring-with-structs-adding-more-meaning"></a></p>
<h3 id="refaktoryzacja-za-pomocÄ…-struktur"><a class="header" href="#refaktoryzacja-za-pomocÄ…-struktur">Refaktoryzacja za pomocÄ… struktur</a></h3>
<p>UÅ¼ywamy struktur, aby dodaÄ‡ znaczenie poprzez etykietowanie danych. MoÅ¼emy przeksztaÅ‚ciÄ‡ krotkÄ™, ktÃ³rej uÅ¼ywamy, w strukturÄ™ z nazwÄ… dla caÅ‚oÅ›ci, a takÅ¼e nazwami dla czÄ™Å›ci, jak pokazano w Listingu 5-10.</p>
<listing number="5-10" file-name="src/main.rs" caption="Definiowanie struktury `Rectangle`">
<pre class="playground"><code class="language-rust edition2024">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "Pole prostokÄ…ta wynosi {} pikseli kwadratowych.",
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}</code></pre>
</listing>
<p>Tutaj zdefiniowaliÅ›my strukturÄ™ i nazwaliÅ›my jÄ… <code>Rectangle</code>. W nawiasach klamrowych zdefiniowaliÅ›my pola jako <code>width</code> i <code>height</code>, z ktÃ³rych oba majÄ… typ <code>u32</code>. NastÄ™pnie, w <code>main</code>, utworzyliÅ›my konkretnÄ… instancjÄ™ <code>Rectangle</code> o szerokoÅ›ci <code>30</code> i wysokoÅ›ci <code>50</code>.</p>
<p>Nasza funkcja <code>area</code> jest teraz zdefiniowana z jednym parametrem, ktÃ³ry nazwaliÅ›my <code>rectangle</code>, ktÃ³rego typem jest niezmienne poÅ¼yczenie instancji struktury <code>Rectangle</code>. Jak wspomniano w Rozdziale 4, chcemy poÅ¼yczyÄ‡ strukturÄ™, a nie przejmowaÄ‡ jej wÅ‚asnoÅ›ci. W ten sposÃ³b <code>main</code> zachowuje wÅ‚asnoÅ›Ä‡ i moÅ¼e nadal uÅ¼ywaÄ‡ <code>rect1</code>, co jest powodem, dla ktÃ³rego uÅ¼ywamy <code>&amp;</code> w sygnaturze funkcji i tam, gdzie wywoÅ‚ujemy funkcjÄ™.</p>
<p>Funkcja <code>area</code> uzyskuje dostÄ™p do pÃ³l <code>width</code> i <code>height</code> instancji <code>Rectangle</code> (zauwaÅ¼, Å¼e dostÄ™p do pÃ³l poÅ¼yczonej instancji struktury nie przenosi wartoÅ›ci pÃ³l, dlatego czÄ™sto spotyka siÄ™ poÅ¼yczanie struktur). Nasza sygnatura funkcji <code>area</code> mÃ³wi teraz dokÅ‚adnie, co mamy na myÅ›li: Oblicz pole <code>Rectangle</code>, uÅ¼ywajÄ…c jego pÃ³l <code>width</code> i <code>height</code>. Przekazuje to, Å¼e szerokoÅ›Ä‡ i wysokoÅ›Ä‡ sÄ… ze sobÄ… powiÄ…zane, i nadaje wartoÅ›ciom opisowe nazwy, zamiast uÅ¼ywaÄ‡ wartoÅ›ci indeksu krotki <code>0</code> i <code>1</code>. Jest to korzyÅ›Ä‡ dla przejrzystoÅ›ci.</p>
<p><a id="adding-useful-functionality-with-derived-traits"></a></p>
<h3 id="dodawanie-funkcjonalnoÅ›ci-za-pomocÄ…-wyprowadzonych-cech-derived-traits"><a class="header" href="#dodawanie-funkcjonalnoÅ›ci-za-pomocÄ…-wyprowadzonych-cech-derived-traits">Dodawanie funkcjonalnoÅ›ci za pomocÄ… wyprowadzonych cech (derived traits)</a></h3>
<p>PrzydaÅ‚oby siÄ™ mÃ³c wyÅ›wietliÄ‡ instancjÄ™ <code>Rectangle</code> podczas debugowania programu i zobaczyÄ‡ wartoÅ›ci wszystkich jej pÃ³l. Listing 5-11 prÃ³buje uÅ¼yÄ‡ makra <a href="../std/macro.println.html"><code>println!</code></a><!-- ignore -->, tak jak uÅ¼ywaliÅ›my w poprzednich rozdziaÅ‚ach. Jednak to nie zadziaÅ‚a.</p>
<listing number="5-11" file-name="src/main.rs" caption="PrÃ³ba wydrukowania instancji `Rectangle`">
<pre><code class="language-rust ignore does_not_compile">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 to {rect1}");
}</code></pre>
</listing>
<p>Kiedy skompilujemy ten kod, otrzymamy bÅ‚Ä…d z nastÄ™pujÄ…cym gÅ‚Ã³wnym komunikatem:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<p>Makro <code>println!</code> potrafi wiele rodzajÃ³w formatowania, a domyÅ›lnie nawiasy klamrowe mÃ³wiÄ… <code>println!</code>, aby uÅ¼yÄ‡ formatowania znanego jako <code>Display</code>: wyjÅ›cie przeznaczone do bezpoÅ›redniego uÅ¼ytku przez uÅ¼ytkownika koÅ„cowego. Prymitywne typy, ktÃ³re widzieliÅ›my do tej pory, domyÅ›lnie implementujÄ… <code>Display</code>, poniewaÅ¼ istnieje tylko jeden sposÃ³b, w jaki chciaÅ‚byÅ› pokazaÄ‡ <code>1</code> lub inny typ prymitywny uÅ¼ytkownikowi. Ale w przypadku struktur sposÃ³b, w jaki <code>println!</code> powinien sformatowaÄ‡ wyjÅ›cie, jest mniej jasny, poniewaÅ¼ istnieje wiÄ™cej moÅ¼liwoÅ›ci wyÅ›wietlania: Czy chcesz przecinkÃ³w, czy nie? Czy chcesz drukowaÄ‡ nawiasy klamrowe? Czy wszystkie pola powinny byÄ‡ wyÅ›wietlane? Z powodu tej niejednoznacznoÅ›ci Rust nie prÃ³buje zgadywaÄ‡, czego chcemy, a struktury nie majÄ… dostarczonej implementacji <code>Display</code> do uÅ¼ycia z <code>println!</code> i symbolem zastÄ™pczym <code>{}</code>.</p>
<p>JeÅ›li bÄ™dziemy dalej czytaÄ‡ bÅ‚Ä™dy, znajdziemy tÄ™ pomocnÄ… notatkÄ™:</p>
<pre><code class="language-text">   |                        |`Rectangle` nie moÅ¼e byÄ‡ sformatowany za pomocÄ… domyÅ›lnego formatatora
   |                        wymaganego przez ten parametr formatowania
</code></pre>
<p>SprÃ³bujmy! WywoÅ‚anie makra <code>println!</code> bÄ™dzie teraz wyglÄ…daÄ‡ tak: <code>println!("rect1 to {rect1:?}");</code>. Umieszczenie specyfikatora <code>:?</code> w nawiasach klamrowych mÃ³wi <code>println!</code>, Å¼e chcemy uÅ¼yÄ‡ formatu wyjÅ›ciowego o nazwie <code>Debug</code>. Cecha <code>Debug</code> umoÅ¼liwia nam wyÅ›wietlanie naszej struktury w sposÃ³b uÅ¼yteczny dla programistÃ³w, dziÄ™ki czemu moÅ¼emy zobaczyÄ‡ jej wartoÅ›Ä‡ podczas debugowania kodu.</p>
<p>Skompiluj kod z tÄ… zmianÄ…. Cholera! Nadal otrzymujemy bÅ‚Ä…d:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` nie implementuje `Debug`
</code></pre>
<p>Ale znowu, kompilator daje nam pomocnÄ… notatkÄ™:</p>
<pre><code class="language-text">   |                        wymagany przez ten parametr formatowania
   |
</code></pre>
<p>Rust <em>zawiera</em> funkcjonalnoÅ›Ä‡ do wyÅ›wietlania informacji debugujÄ…cych, ale musimy jawnie jÄ… wÅ‚Ä…czyÄ‡, aby ta funkcjonalnoÅ›Ä‡ byÅ‚a dostÄ™pna dla naszej struktury. Aby to zrobiÄ‡, dodajemy zewnÄ™trzny atrybut <code>#[derive(Debug)]</code> tuÅ¼ przed definicjÄ… struktury, jak pokazano w Listingu 5-12.</p>
<listing number="5-12" file-name="src/main.rs" caption="Dodawanie atrybutu do wyprowadzania cechy `Debug` i drukowanie instancji `Rectangle` za pomocÄ… formatowania debugowania">
<pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 to {rect1:?}");
}</code></pre>
</listing>
<p>Teraz, gdy uruchomimy program, nie otrzymamy Å¼adnych bÅ‚Ä™dÃ³w i zobaczymy nastÄ™pujÄ…ce wyjÅ›cie:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle { width: 30, height: 50 }
</code></pre>
<p>PiÄ™knie! To nie jest najÅ‚adniejsze wyjÅ›cie, ale pokazuje wartoÅ›ci wszystkich pÃ³l dla tej instancji, co z pewnoÅ›ciÄ… pomogÅ‚oby podczas debugowania. Kiedy mamy wiÄ™ksze struktury, przydatne jest, aby wyjÅ›cie byÅ‚o nieco Å‚atwiejsze do odczytania; w takich przypadkach moÅ¼emy uÅ¼yÄ‡ <code>{:#?}</code> zamiast <code>{:?}</code> w ciÄ…gu <code>println!</code>. W tym przykÅ‚adzie uÅ¼ycie stylu <code>{:#?}</code> spowoduje wyÅ›wietlenie nastÄ™pujÄ…cego komunikatu:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle {
    width: 30,
    height: 50,
}
</code></pre>
<p>Innym sposobem wydrukowania wartoÅ›ci za pomocÄ… formatu <code>Debug</code> jest uÅ¼ycie makra <a href="../std/macro.dbg.html"><code>dbg!</code></a><!-- ignore -->, ktÃ³re przejmuje wÅ‚asnoÅ›Ä‡ wyraÅ¼enia (w przeciwieÅ„stwie do <code>println!</code>, ktÃ³re przyjmuje referencjÄ™), drukuje plik i numer linii, w ktÃ³rej wystÄ™puje wywoÅ‚anie makra <code>dbg!</code> wraz z wynikowÄ… wartoÅ›ciÄ… tego wyraÅ¼enia i zwraca wÅ‚asnoÅ›Ä‡ wartoÅ›ci.</p>
<blockquote>
<p>Uwaga: WywoÅ‚anie makra <code>dbg!</code> drukuje do standardowego strumienia bÅ‚Ä™dÃ³w konsoli (<code>stderr</code>), w przeciwieÅ„stwie do <code>println!</code>, ktÃ³re drukuje do standardowego strumienia wyjÅ›ciowego konsoli (<code>stdout</code>). WiÄ™cej o <code>stderr</code> i <code>stdout</code> omÃ³wimy w sekcji <a href="#przekierowywanie-bÅ‚Ä™dÃ³w-do-standardowego-strumienia-bÅ‚Ä™dÃ³w-1">â€Przekierowywanie bÅ‚Ä™dÃ³w do standardowego strumienia bÅ‚Ä™dÃ³wâ€ w Rozdziale 12</a><!-- ignore -->.</p>
</blockquote>
<p>Oto przykÅ‚ad, w ktÃ³rym interesuje nas wartoÅ›Ä‡ przypisana do pola <code>width</code>, a takÅ¼e wartoÅ›Ä‡ caÅ‚ej struktury w <code>rect1</code>:</p>
<pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&amp;rect1);
}</code></pre>
<p>MoÅ¼emy umieÅ›ciÄ‡ <code>dbg!</code> wokÃ³Å‚ wyraÅ¼enia <code>30 * scale</code> i, poniewaÅ¼ <code>dbg!</code> zwraca wÅ‚asnoÅ›Ä‡ wartoÅ›ci wyraÅ¼enia, pole <code>width</code> otrzyma tÄ™ samÄ… wartoÅ›Ä‡, jakbyÅ›my nie mieli tam wywoÅ‚ania <code>dbg!</code>. Nie chcemy, aby <code>dbg!</code> przejmowaÅ‚o wÅ‚asnoÅ›Ä‡ <code>rect1</code>, wiÄ™c w nastÄ™pnym wywoÅ‚aniu uÅ¼ywamy referencji do <code>rect1</code>. Oto jak wyglÄ…da wyjÅ›cie z tego przykÅ‚adu:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10:16] 30 * scale = 60
[src/main.rs:14:5] &amp;rect1 = Rectangle {
    width: 60,
    height: 50,
}
</code></pre>
<p>Widzimy, Å¼e pierwsza czÄ™Å›Ä‡ wyjÅ›cia pochodzi z pliku <em>src/main.rs</em> w linii 10, gdzie debugujemy wyraÅ¼enie <code>30 * scale</code>, a jego wynikowa wartoÅ›Ä‡ to <code>60</code> (formatowanie <code>Debug</code> zaimplementowane dla liczb caÅ‚kowitych polega na wydrukowaniu tylko ich wartoÅ›ci). WywoÅ‚anie <code>dbg!</code> w linii 14 pliku <em>src/main.rs</em> wyprowadza wartoÅ›Ä‡ <code>&amp;rect1</code>, czyli struktury <code>Rectangle</code>. To wyjÅ›cie wykorzystuje Å‚adne formatowanie <code>Debug</code> typu <code>Rectangle</code>. Makro <code>dbg!</code> moÅ¼e byÄ‡ naprawdÄ™ pomocne, gdy prÃ³bujesz dowiedzieÄ‡ siÄ™, co robi twÃ³j kod!</p>
<p>OprÃ³cz cechy <code>Debug</code>, Rust dostarczyÅ‚ szereg cech, ktÃ³rych moÅ¼emy uÅ¼ywaÄ‡ z atrybutem <code>derive</code>, ktÃ³re mogÄ… dodawaÄ‡ uÅ¼yteczne zachowanie do naszych niestandardowych typÃ³w. Te cechy i ich zachowania sÄ… wymienione w <a href="#c---cechy-dziedziczne">Dodatku C</a><!-- ignore -->. OmÃ³wimy, jak zaimplementowaÄ‡ te cechy z niestandardowym zachowaniem, a takÅ¼e jak tworzyÄ‡ wÅ‚asne cechy w Rozdziale 10. Istnieje rÃ³wnieÅ¼ wiele innych atrybutÃ³w niÅ¼ <code>derive</code>; wiÄ™cej informacji moÅ¼na znaleÅºÄ‡ w sekcji <a href="../reference/attributes.html">â€Atrybutyâ€ w dokumentacji Rust Reference</a>.</p>
<p>Nasza funkcja <code>area</code> jest bardzo specyficzna: oblicza tylko pole prostokÄ…tÃ³w. Pomocne byÅ‚oby powiÄ…zanie tego zachowania bliÅ¼ej z naszÄ… strukturÄ… <code>Rectangle</code>, poniewaÅ¼ nie bÄ™dzie ono dziaÅ‚aÄ‡ z Å¼adnym innym typem. Przyjrzyjmy siÄ™, jak moÅ¼emy kontynuowaÄ‡ refaktoryzacjÄ™ tego kodu, zamieniajÄ…c funkcjÄ™ <code>area</code> w metodÄ™ <code>area</code> zdefiniowanÄ… dla naszego typu <code>Rectangle</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="metody-1"><a href="#metody-1" class="header">Metody</a></h1>
<h2 id="metody"><a class="header" href="#metody">Metody</a></h2>
<p>Metody sÄ… podobne do funkcji: deklarujemy je sÅ‚owem kluczowym <code>fn</code> i nazwÄ…, mogÄ… mieÄ‡ parametry i zwracaÄ‡ wartoÅ›Ä‡, oraz zawierajÄ… kod, ktÃ³ry jest uruchamiany po wywoÅ‚aniu metody z innego miejsca. W przeciwieÅ„stwie do funkcji, metody sÄ… definiowane w kontekÅ›cie struktury (lub typu wyliczeniowego albo obiektu cechy, ktÃ³re omÃ³wimy odpowiednio w <a href="#typy-wyliczeniowe-enum-i-dopasowywanie-wzorcÃ³w">Rozdziale 6</a><!-- ignore --> i <a href="#uÅ¼ywanie-obiektÃ³w-trait-do-abstrakcji-nad-wspÃ³lnym-zachowaniem-1">Rozdziale 18</a><!-- ignore -->), a ich pierwszym parametrem jest zawsze <code>self</code>, ktÃ³re reprezentuje instancjÄ™ struktury, na ktÃ³rej wywoÅ‚ywana jest metoda.</p>
<p><a id="defining-methods"></a></p>
<h3 id="skÅ‚adnia-metody"><a class="header" href="#skÅ‚adnia-metody">SkÅ‚adnia metody</a></h3>
<p>ZmieÅ„my funkcjÄ™ <code>area</code>, ktÃ³ra ma instancjÄ™ <code>Rectangle</code> jako parametr, i zamiast tego stwÃ³rzmy metodÄ™ <code>area</code> zdefiniowanÄ… w strukturze <code>Rectangle</code>, jak pokazano w Listingu 5-13.</p>
<listing number="5-13" file-name="src/main.rs" caption="Definiowanie metody `area` w strukturze `Rectangle`">
<pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "Pole prostokÄ…ta wynosi {} pikseli kwadratowych.",
        rect1.area()
    );
}</code></pre>
</listing>
<p>Aby zdefiniowaÄ‡ funkcjÄ™ w kontekÅ›cie <code>Rectangle</code>, rozpoczynamy blok <code>impl</code> (implementacji) dla <code>Rectangle</code>. Wszystko w tym bloku <code>impl</code> bÄ™dzie powiÄ…zane z typem <code>Rectangle</code>. NastÄ™pnie przenosimy funkcjÄ™ <code>area</code> do nawiasÃ³w klamrowych <code>impl</code> i zmieniamy pierwszy (a w tym przypadku jedyny) parametr na <code>self</code> w sygnaturze i wszÄ™dzie w treÅ›ci. W <code>main</code>, gdzie wywoÅ‚aliÅ›my funkcjÄ™ <code>area</code> i przekazaliÅ›my <code>rect1</code> jako argument, moÅ¼emy zamiast tego uÅ¼yÄ‡ <em>skÅ‚adni metody</em> do wywoÅ‚ania metody <code>area</code> na naszej instancji <code>Rectangle</code>. SkÅ‚adnia metody wystÄ™puje po instancji: dodajemy kropkÄ™, po ktÃ³rej nastÄ™puje nazwa metody, nawiasy i wszelkie argumenty.</p>
<p>W sygnaturze <code>area</code> uÅ¼ywamy <code>&amp;self</code> zamiast <code>rectangle: &amp;Rectangle</code>. <code>&amp;self</code> to w rzeczywistoÅ›ci skrÃ³t od <code>self: &amp;Self</code>. W bloku <code>impl</code> typ <code>Self</code> jest aliasem dla typu, dla ktÃ³rego jest blok <code>impl</code>. Metody muszÄ… mieÄ‡ parametr o nazwie <code>self</code> typu <code>Self</code> jako swÃ³j pierwszy parametr, wiÄ™c Rust pozwala na skrÃ³cenie tego do samej nazwy <code>self</code> w miejscu pierwszego parametru. ZauwaÅ¼, Å¼e nadal musimy uÅ¼ywaÄ‡ <code>&amp;</code> przed skrÃ³tem <code>self</code>, aby wskazaÄ‡, Å¼e ta metoda poÅ¼ycza instancjÄ™ <code>Self</code>, tak jak zrobiliÅ›my to w <code>rectangle: &amp;Rectangle</code>. Metody mogÄ… przejmowaÄ‡ wÅ‚asnoÅ›Ä‡ <code>self</code>, poÅ¼yczaÄ‡ <code>self</code> niezmiennie, jak to zrobiliÅ›my tutaj, lub poÅ¼yczaÄ‡ <code>self</code> mutowalnie, tak jak kaÅ¼dy inny parametr.</p>
<p>WybraliÅ›my <code>&amp;self</code> z tego samego powodu, dla ktÃ³rego uÅ¼yliÅ›my <code>&amp;Rectangle</code> w wersji funkcyjnej: nie chcemy przejmowaÄ‡ wÅ‚asnoÅ›ci i chcemy tylko odczytywaÄ‡ dane ze struktury, a nie do niej zapisywaÄ‡. GdybyÅ›my chcieli zmieniÄ‡ instancjÄ™, na ktÃ³rej wywoÅ‚aliÅ›my metodÄ™, w ramach dziaÅ‚ania metody, uÅ¼ylibyÅ›my <code>&amp;mut self</code> jako pierwszego parametru. Posiadanie metody, ktÃ³ra przejmuje wÅ‚asnoÅ›Ä‡ instancji, uÅ¼ywajÄ…c tylko <code>self</code> jako pierwszego parametru, jest rzadkie; ta technika jest zazwyczaj uÅ¼ywana, gdy metoda przeksztaÅ‚ca <code>self</code> w coÅ› innego i chcemy uniemoÅ¼liwiÄ‡ wywoÅ‚ujÄ…cemu uÅ¼ywanie oryginalnej instancji po transformacji.</p>
<p>GÅ‚Ã³wnym powodem uÅ¼ywania metod zamiast funkcji, oprÃ³cz zapewnienia skÅ‚adni metody i braku koniecznoÅ›ci powtarzania typu <code>self</code> w sygnaturze kaÅ¼dej metody, jest organizacja. UmieÅ›ciliÅ›my wszystkie rzeczy, ktÃ³re moÅ¼emy zrobiÄ‡ z instancjÄ… typu, w jednym bloku <code>impl</code>, zamiast zmuszaÄ‡ przyszÅ‚ych uÅ¼ytkownikÃ³w naszego kodu do szukania moÅ¼liwoÅ›ci <code>Rectangle</code> w rÃ³Å¼nych miejscach dostarczanej przez nas biblioteki.</p>
<p>ZauwaÅ¼, Å¼e moÅ¼emy nadaÄ‡ metodzie takÄ… samÄ… nazwÄ™ jak jednemu z pÃ³l struktury. Na przykÅ‚ad, moÅ¼emy zdefiniowaÄ‡ metodÄ™ w <code>Rectangle</code>, ktÃ³ra rÃ³wnieÅ¼ nazywa siÄ™ <code>width</code>:</p>
<listing file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!("ProstokÄ…t ma szerokoÅ›Ä‡ rÃ³Å¼nÄ… od zera; wynosi {}", rect1.width);
    }
}</code></pre>
</listing>
<p>Tutaj, decydujemy, aby metoda <code>width</code> zwracaÅ‚a <code>true</code>, jeÅ›li wartoÅ›Ä‡ w polu <code>width</code> instancji jest wiÄ™ksza niÅ¼ <code>0</code>, a <code>false</code>, jeÅ›li wartoÅ›Ä‡ jest <code>0</code>: moÅ¼emy uÅ¼yÄ‡ pola o tej samej nazwie w metodzie do dowolnego celu. W <code>main</code>, gdy po <code>rect1.width</code> umieÅ›cimy nawiasy, Rust wie, Å¼e chodzi nam o metodÄ™ <code>width</code>. Gdy nie uÅ¼ywamy nawiasÃ³w, Rust wie, Å¼e chodzi nam o pole <code>width</code>.</p>
<p>CzÄ™sto, choÄ‡ nie zawsze, gdy nadajemy metodzie takÄ… samÄ… nazwÄ™ jak polu, chcemy, aby zwracaÅ‚a tylko wartoÅ›Ä‡ z pola i nic wiÄ™cej. Takie metody nazywane sÄ… <em>getterami</em>, a Rust nie implementuje ich automatycznie dla pÃ³l struktur, tak jak robiÄ… to niektÃ³re inne jÄ™zyki. Gettery sÄ… uÅ¼yteczne, poniewaÅ¼ moÅ¼na uczyniÄ‡ pole prywatnym, ale metodÄ™ publicznÄ…, a tym samym umoÅ¼liwiÄ‡ dostÄ™p tylko do odczytu do tego pola jako czÄ™Å›ci publicznego API typu. OmÃ³wimy, czym sÄ… publiczne i prywatne, oraz jak oznaczyÄ‡ pole lub metodÄ™ jako publicznÄ… lub prywatnÄ… w <a href="#exposing-paths-with-the-pub-keyword">Rozdziale 7</a><!-- ignore -->.</p>
<blockquote>
<h3 id="gdzie-jest-operator--"><a class="header" href="#gdzie-jest-operator--">Gdzie jest operator <code>-&gt;</code>?</a></h3>
<p>W C i C++ do wywoÅ‚ywania metod uÅ¼ywa siÄ™ dwÃ³ch rÃ³Å¼nych operatorÃ³w: <code>.</code> jeÅ›li wywoÅ‚uje siÄ™ metodÄ™ bezpoÅ›rednio na obiekcie, oraz <code>-&gt;</code> jeÅ›li wywoÅ‚uje siÄ™ metodÄ™ na wskaÅºniku do obiektu i trzeba najpierw dereferencjowaÄ‡ wskaÅºnik. Innymi sÅ‚owy, jeÅ›li <code>object</code> jest wskaÅºnikiem, <code>object-&gt;something()</code> jest podobne do <code>(*object).something()</code>.</p>
<p>Rust nie ma odpowiednika operatora <code>-&gt;</code>; zamiast tego, Rust ma funkcjÄ™ zwanÄ… <em>automatycznym referencjowaniem i dereferencjowaniem</em>. WywoÅ‚ywanie metod jest jednym z niewielu miejsc w Rust z takim zachowaniem.</p>
<p>DziaÅ‚a to w nastÄ™pujÄ…cy sposÃ³b: Kiedy wywoÅ‚ujesz metodÄ™ <code>object.something()</code>, Rust automatycznie dodaje <code>&amp;</code>, <code>&amp;mut</code> lub <code>*</code>, tak aby <code>object</code> pasowaÅ‚ do sygnatury metody. Innymi sÅ‚owy, poniÅ¼sze sÄ… takie same:</p>
<!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}</span></code></pre>
<p>Pierwsza z nich wyglÄ…da znacznie czyÅ›ciej. To automatyczne zachowanie referencjonowania dziaÅ‚a, poniewaÅ¼ metody majÄ… wyraÅºny odbiornik â€” typ <code>self</code>. BiorÄ…c pod uwagÄ™ odbiornik i nazwÄ™ metody, Rust moÅ¼e jednoznacznie okreÅ›liÄ‡, czy metoda odczytuje (<code>&amp;self</code>), mutuje (<code>&amp;mut self</code>), czy zuÅ¼ywa (<code>self</code>). Fakt, Å¼e Rust sprawia, Å¼e poÅ¼yczanie jest niejawne dla odbiornikÃ³w metod, jest duÅ¼Ä… czÄ™Å›ciÄ… sprawiania, Å¼e wÅ‚asnoÅ›Ä‡ jest ergonomiczna w praktyce.</p>
</blockquote>
<h3 id="metody-z-wiÄ™kszÄ…-liczbÄ…-parametrÃ³w"><a class="header" href="#metody-z-wiÄ™kszÄ…-liczbÄ…-parametrÃ³w">Metody z wiÄ™kszÄ… liczbÄ… parametrÃ³w</a></h3>
<p>PoÄ‡wiczmy uÅ¼ywanie metod, implementujÄ…c drugÄ… metodÄ™ w strukturze <code>Rectangle</code>. Tym razem chcemy, aby instancja <code>Rectangle</code> przyjmowaÅ‚a innÄ… instancjÄ™ <code>Rectangle</code> i zwracaÅ‚a <code>true</code>, jeÅ›li drugi <code>Rectangle</code> moÅ¼e caÅ‚kowicie zmieÅ›ciÄ‡ siÄ™ w <code>self</code> (pierwszym <code>Rectangle</code>); w przeciwnym razie powinna zwrÃ³ciÄ‡ <code>false</code>. Oznacza to, Å¼e po zdefiniowaniu metody <code>can_hold</code>, chcemy mÃ³c napisaÄ‡ program pokazany w Listingu 5-14.</p>
<listing number="5-14" file-name="src/main.rs" caption="UÅ¼ycie jeszcze nie napisanej metody `can_hold`">
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Czy rect1 moÅ¼e pomieÅ›ciÄ‡ rect2? {}", rect1.can_hold(&amp;rect2));
    println!("Czy rect1 moÅ¼e pomieÅ›ciÄ‡ rect3? {}", rect1.can_hold(&amp;rect3));
}</code></pre>
</listing>
<p>Oczekiwane wyjÅ›cie wyglÄ…daÅ‚oby nastÄ™pujÄ…co, poniewaÅ¼ oba wymiary <code>rect2</code> sÄ… mniejsze niÅ¼ wymiary <code>rect1</code>, ale <code>rect3</code> jest szerszy niÅ¼ <code>rect1</code>:</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<p>Wiemy, Å¼e chcemy zdefiniowaÄ‡ metodÄ™, wiÄ™c bÄ™dzie ona w bloku <code>impl Rectangle</code>. Nazwa metody bÄ™dzie <code>can_hold</code>, i przyjmie niezmienne poÅ¼yczenie innego <code>Rectangle</code> jako parametr. MoÅ¼emy stwierdziÄ‡, jaki bÄ™dzie typ parametru, patrzÄ…c na kod, ktÃ³ry wywoÅ‚uje metodÄ™: <code>rect1.can_hold(&amp;rect2)</code> przekazuje <code>&amp;rect2</code>, co jest niezmiennym poÅ¼yczeniem <code>rect2</code>, instancji <code>Rectangle</code>. Ma to sens, poniewaÅ¼ musimy tylko odczytywaÄ‡ <code>rect2</code> (zamiast zapisywaÄ‡, co oznaczaÅ‚oby, Å¼e potrzebowalibyÅ›my mutowalnego poÅ¼yczenia), i chcemy, aby <code>main</code> zachowaÅ‚o wÅ‚asnoÅ›Ä‡ <code>rect2</code>, abyÅ›my mogli go ponownie uÅ¼yÄ‡ po wywoÅ‚aniu metody <code>can_hold</code>. WartoÅ›ciÄ… zwracanÄ… <code>can_hold</code> bÄ™dzie Boolean, a implementacja sprawdzi, czy szerokoÅ›Ä‡ i wysokoÅ›Ä‡ <code>self</code> sÄ… wiÄ™ksze niÅ¼ szerokoÅ›Ä‡ i wysokoÅ›Ä‡ drugiego <code>Rectangle</code>, odpowiednio. Dodajmy nowÄ… metodÄ™ <code>can_hold</code> do bloku <code>impl</code> z Listingu 5-13, pokazanej w Listingu 5-15.</p>
<listing number="5-15" file-name="src/main.rs" caption="Implementacja metody `can_hold` w `Rectangle`, ktÃ³ra przyjmuje innÄ… instancjÄ™ `Rectangle` jako parametr">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("Czy rect1 moÅ¼e pomieÅ›ciÄ‡ rect2? {}", rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!("Czy rect1 moÅ¼e pomieÅ›ciÄ‡ rect3? {}", rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre>
</listing>
<p>Po uruchomieniu tego kodu z funkcjÄ… <code>main</code> z Listingu 5-14, otrzymamy poÅ¼Ä…dane wyjÅ›cie. Metody mogÄ… przyjmowaÄ‡ wiele parametrÃ³w, ktÃ³re dodajemy do sygnatury po parametrze <code>self</code>, a te parametry dziaÅ‚ajÄ… tak samo jak parametry w funkcjach.</p>
<h3 id="funkcje-skojarzone"><a class="header" href="#funkcje-skojarzone">Funkcje skojarzone</a></h3>
<p>Wszystkie funkcje zdefiniowane w bloku <code>impl</code> nazywane sÄ… <em>funkcjami skojarzonymi</em>, poniewaÅ¼ sÄ… powiÄ…zane z typem nazwanym po <code>impl</code>. MoÅ¼emy definiowaÄ‡ funkcje skojarzone, ktÃ³re nie majÄ… <code>self</code> jako swojego pierwszego parametru (i dlatego nie sÄ… metodami), poniewaÅ¼ nie potrzebujÄ… instancji typu do dziaÅ‚ania. UÅ¼yliÅ›my juÅ¼ jednej takiej funkcji: funkcji <code>String::from</code> zdefiniowanej dla typu <code>String</code>.</p>
<p>Funkcje skojarzone, ktÃ³re nie sÄ… metodami, sÄ… czÄ™sto uÅ¼ywane jako konstruktory, ktÃ³re zwracajÄ… nowÄ… instancjÄ™ struktury. SÄ… one czÄ™sto nazywane <code>new</code>, ale <code>new</code> nie jest specjalnÄ… nazwÄ… i nie jest wbudowane w jÄ™zyk. Na przykÅ‚ad, moglibyÅ›my zapewniÄ‡ funkcjÄ™ skojarzonÄ… o nazwie <code>square</code>, ktÃ³ra miaÅ‚aby jeden parametr wymiaru i uÅ¼ywaÅ‚aby go zarÃ³wno jako szerokoÅ›ci, jak i wysokoÅ›ci, uÅ‚atwiajÄ…c w ten sposÃ³b tworzenie kwadratowego <code>Rectangle</code> zamiast koniecznoÅ›ci dwukrotnego okreÅ›lania tej samej wartoÅ›ci:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Self {
        Self {
            width: size,
            height: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let sq = Rectangle::square(3);
</span><span class="boring">}</span></code></pre>
<p>SÅ‚owa kluczowe <code>Self</code> w typie zwracanym i w treÅ›ci funkcji sÄ… aliasami dla typu, ktÃ³ry pojawia siÄ™ po sÅ‚owie kluczowym <code>impl</code>, czyli w tym przypadku <code>Rectangle</code>.</p>
<p>Aby wywoÅ‚aÄ‡ tÄ™ funkcjÄ™ skojarzonÄ…, uÅ¼ywamy skÅ‚adni <code>::</code> z nazwÄ… struktury; <code>let sq = Rectangle::square(3);</code> jest przykÅ‚adem. Ta funkcja jest umieszczona w przestrzeni nazw struktury: skÅ‚adnia <code>::</code> jest uÅ¼ywana zarÃ³wno dla funkcji skojarzonych, jak i przestrzeni nazw utworzonych przez moduÅ‚y. OmÃ³wimy moduÅ‚y w <a href="#kontrola-zasiÄ™gu-i-prywatnoÅ›ci-za-pomocÄ…-moduÅ‚Ã³w-1">Rozdziale 7</a><!-- ignore -->.</p>
<h3 id="wiele-blokÃ³w-impl"><a class="header" href="#wiele-blokÃ³w-impl">Wiele blokÃ³w <code>impl</code></a></h3>
<p>KaÅ¼da struktura moÅ¼e mieÄ‡ wiele blokÃ³w <code>impl</code>. Na przykÅ‚ad, Listing 5-15 jest rÃ³wnowaÅ¼ny z kodem pokazanym w Listingu 5-16, ktÃ³ry ma kaÅ¼dÄ… metodÄ™ w swoim wÅ‚asnym bloku <code>impl</code>.</p>
<listing number="5-16" caption="Przepisanie Listingu 5-15 z uÅ¼yciem wielu blokÃ³w `impl`">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("Czy rect1 moÅ¼e pomieÅ›ciÄ‡ rect2? {}", rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!("Czy rect1 moÅ¼e pomieÅ›ciÄ‡ rect3? {}", rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre>
</listing>
<p>Nie ma powodu, aby rozdzielaÄ‡ te metody na wiele blokÃ³w <code>impl</code> w tym przypadku, ale jest to poprawna skÅ‚adnia. Zobaczymy przypadek, w ktÃ³rym wiele blokÃ³w <code>impl</code> jest uÅ¼ytecznych w Rozdziale 10, gdzie omÃ³wimy typy generyczne i cechy.</p>
<h2 id="podsumowanie-4"><a class="header" href="#podsumowanie-4">Podsumowanie</a></h2>
<p>Struktury pozwalajÄ… tworzyÄ‡ niestandardowe typy, ktÃ³re majÄ… znaczenie dla twojej domeny. UÅ¼ywajÄ…c struktur, moÅ¼esz zachowaÄ‡ powiÄ…zane ze sobÄ… fragmenty danych i nazywaÄ‡ kaÅ¼dy z nich, aby TwÃ³j kod byÅ‚ przejrzysty. W blokach <code>impl</code> moÅ¼esz definiowaÄ‡ funkcje powiÄ…zane z Twoim typem, a metody sÄ… rodzajem funkcji powiÄ…zanych, ktÃ³re pozwalajÄ… okreÅ›laÄ‡ zachowanie instancji Twoich struktur.</p>
<p>Ale struktury to nie jedyny sposÃ³b, w jaki moÅ¼esz tworzyÄ‡ niestandardowe typy: przejdÅºmy do funkcji <code>enum</code> w Rust, aby dodaÄ‡ kolejne narzÄ™dzie do Twojego zestawu.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="typy-wyliczeniowe-enum-i-dopasowywanie-wzorcÃ³w"><a class="header" href="#typy-wyliczeniowe-enum-i-dopasowywanie-wzorcÃ³w">Typy wyliczeniowe (enum) i dopasowywanie wzorcÃ³w</a></h1>
<p>W tym rozdziale przyjrzymy siÄ™ wyliczeniom, zwanym rÃ³wnieÅ¼ <em>enumami</em>.Enumy pozwalajÄ… zdefiniowaÄ‡ typ poprzez wyliczenie jego moÅ¼liwych wariantÃ³w.Najpierw zdefiniujemy i uÅ¼yjemy enum, aby pokazaÄ‡, jak enum moÅ¼e kodowaÄ‡znaczenie wraz z danymi. NastÄ™pnie zbadamy szczegÃ³lnie uÅ¼yteczny enum,nazwany <code>Option</code>, ktÃ³ry wyraÅ¼a, Å¼e wartoÅ›Ä‡ moÅ¼e byÄ‡ albo czymÅ›, albo niczym.NastÄ™pnie przyjrzymy siÄ™, jak dopasowywanie wzorcÃ³w w wyraÅ¼eniu <code>match</code>uÅ‚atwia uruchamianie rÃ³Å¼nego kodu dla rÃ³Å¼nych wartoÅ›ci enum. Na koniecomÃ³wimy, jak konstrukcja <code>if let</code> jest kolejnym wygodnym i zwiÄ™zÅ‚ym idiomemdostÄ™pnym do obsÅ‚ugi enumÃ³w w twoim kodzie.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="definiowanie-typu-wyliczeniowego-1"><a href="#definiowanie-typu-wyliczeniowego-1" class="header">Definiowanie typu wyliczeniowego</a></h1>
<h2 id="definiowanie-typu-wyliczeniowego"><a class="header" href="#definiowanie-typu-wyliczeniowego">Definiowanie typu wyliczeniowego</a></h2>
<p>Podczas gdy struktury dajÄ… ci sposÃ³b grupowania powiÄ…zanych pÃ³l i danych, jak <code>Rectangle</code> z jego <code>width</code> i <code>height</code>, enums dajÄ… ci sposÃ³b powiedzenia, Å¼e wartoÅ›Ä‡ jest jednÄ… z moÅ¼liwych zestawÃ³w wartoÅ›ci. Na przykÅ‚ad, moÅ¼emy chcieÄ‡ powiedzieÄ‡, Å¼e <code>Rectangle</code> jest jednym z moÅ¼liwych ksztaÅ‚tÃ³w, ktÃ³re obejmujÄ… rÃ³wnieÅ¼ <code>Circle</code> i <code>Triangle</code>. Aby to zrobiÄ‡, Rust pozwala nam zakodowaÄ‡ te moÅ¼liwoÅ›ci jako enum.</p>
<p>Przyjrzyjmy siÄ™ sytuacji, ktÃ³rÄ… moÅ¼emy chcieÄ‡ wyraziÄ‡ w kodzie i zobaczmy, dlaczego enums sÄ… uÅ¼yteczne i bardziej odpowiednie niÅ¼ struktury w tym przypadku. Powiedzmy, Å¼e musimy pracowaÄ‡ z adresami IP. Obecnie uÅ¼ywane sÄ… dwa gÅ‚Ã³wne standardy dla adresÃ³w IP: wersja czwarta i wersja szÃ³sta. PoniewaÅ¼ sÄ… to jedyne moÅ¼liwoÅ›ci dla adresu IP, z ktÃ³rymi nasz program siÄ™ spotka, moÅ¼emy <em>wyliczyÄ‡</em> wszystkie moÅ¼liwe warianty, skÄ…d pochodzi nazwa â€enumerationâ€.</p>
<p>KaÅ¼dy adres IP moÅ¼e byÄ‡ adresem wersji czwartej lub wersji szÃ³stej, ale nie oboma jednoczeÅ›nie. Ta wÅ‚aÅ›ciwoÅ›Ä‡ adresÃ³w IP sprawia, Å¼e struktura danych enum jest odpowiednia, poniewaÅ¼ wartoÅ›Ä‡ enum moÅ¼e byÄ‡ tylko jednym ze swoich wariantÃ³w. ZarÃ³wno adresy wersji czwartej, jak i wersji szÃ³stej sÄ… nadal zasadniczo adresami IP, wiÄ™c powinny byÄ‡ traktowane jako ten sam typ, gdy kod obsÅ‚uguje sytuacje, ktÃ³re majÄ… zastosowanie do kaÅ¼dego rodzaju adresu IP.</p>
<p>MoÅ¼emy wyraziÄ‡ tÄ™ koncepcjÄ™ w kodzie, definiujÄ…c wyliczenie <code>IpAddrKind</code> i wymieniajÄ…c moÅ¼liwe rodzaje adresÃ³w IP, ktÃ³rymi mogÄ… byÄ‡ <code>V4</code> i <code>V6</code>. SÄ… to warianty enum:</p>
<pre class="playground"><code class="language-rust edition2024">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre>
<p><code>IpAddrKind</code> to teraz niestandardowy typ danych, ktÃ³rego moÅ¼emy uÅ¼ywaÄ‡ w innych miejscach naszego kodu.</p>
<h3 id="wartoÅ›ci-wyliczeniowe"><a class="header" href="#wartoÅ›ci-wyliczeniowe">WartoÅ›ci wyliczeniowe</a></h3>
<p>MoÅ¼emy tworzyÄ‡ instancje kaÅ¼dego z dwÃ³ch wariantÃ³w <code>IpAddrKind</code> w nastÄ™pujÄ…cy sposÃ³b:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre>
<p>ZauwaÅ¼, Å¼e warianty enum sÄ… umieszczone w przestrzeni nazw pod jego identyfikatorem, a my uÅ¼ywamy podwÃ³jnego dwukropka do rozdzielenia tych dwÃ³ch. Jest to przydatne, poniewaÅ¼ teraz obie wartoÅ›ci <code>IpAddrKind::V4</code> i <code>IpAddrKind::V6</code> sÄ… tego samego typu: <code>IpAddrKind</code>. MoÅ¼emy wtedy, na przykÅ‚ad, zdefiniowaÄ‡ funkcjÄ™, ktÃ³ra przyjmuje dowolny <code>IpAddrKind</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}</code></pre>
<p>I moÅ¼emy wywoÅ‚aÄ‡ tÄ™ funkcjÄ™ z dowolnym wariantem:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre>
<p>UÅ¼ywanie typÃ³w wyliczeniowych (enums) ma jeszcze wiÄ™cej zalet. MyÅ›lÄ…c wiÄ™cej o naszym typie adresu IP, w tej chwili nie mamy sposobu na przechowywanie rzeczywistych <em>danych</em> adresu IP; wiemy tylko, jakiego jest <em>rodzaju</em>. BiorÄ…c pod uwagÄ™, Å¼e wÅ‚aÅ›nie dowiedziaÅ‚eÅ› siÄ™ o strukturach w Rozdziale 5, moÅ¼esz byÄ‡ skÅ‚onny do rozwiÄ…zania tego problemu za pomocÄ… struktur, jak pokazano w Listingu 6-1.</p>
<listing number="6-1" caption="Przechowywanie danych i wariantu `IpAddrKind` adresu IP za pomocÄ… `struct`">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
<span class="boring">}</span></code></pre>
</listing>
<p>Tutaj zdefiniowaliÅ›my strukturÄ™ <code>IpAddr</code>, ktÃ³ra ma dwa pola: pole <code>kind</code> typu <code>IpAddrKind</code> (enum, ktÃ³re zdefiniowaliÅ›my wczeÅ›niej) i pole <code>address</code> typu <code>String</code>. Mamy dwie instancje tej struktury. Pierwsza to <code>home</code> i ma wartoÅ›Ä‡ <code>IpAddrKind::V4</code> jako swoje <code>kind</code> z powiÄ…zanymi danymi adresu <code>127.0.0.1</code>. Druga instancja to <code>loopback</code>. Ma ona inny wariant <code>IpAddrKind</code> jako swojÄ… wartoÅ›Ä‡ <code>kind</code>, <code>V6</code>, i ma powiÄ…zany z nim adres <code>::1</code>. UÅ¼yliÅ›my struktury do poÅ‚Ä…czenia wartoÅ›ci <code>kind</code> i <code>address</code>, wiÄ™c teraz wariant jest powiÄ…zany z wartoÅ›ciÄ….</p>
<p>JednakÅ¼e, reprezentowanie tej samej koncepcji uÅ¼ywajÄ…c tylko typu wyliczeniowego jest bardziej zwiÄ™zÅ‚e: zamiast typu wyliczeniowego wewnÄ…trz struktury, moÅ¼emy umieÅ›ciÄ‡ dane bezpoÅ›rednio w kaÅ¼dym wariancie typu wyliczeniowego. Ta nowa definicja typu wyliczeniowego <code>IpAddr</code> mÃ³wi, Å¼e zarÃ³wno warianty <code>V4</code>, jak i <code>V6</code> bÄ™dÄ… miaÅ‚y powiÄ…zane wartoÅ›ci <code>String</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre>
<p>Dane do kaÅ¼dego wariantu enum doÅ‚Ä…czamy bezpoÅ›rednio, wiÄ™c nie ma potrzeby uÅ¼ywania dodatkowej struktury. W tym przypadku Å‚atwiej jest rÃ³wnieÅ¼ zauwaÅ¼yÄ‡ innÄ… cechÄ™ dziaÅ‚ania enumÃ³w: nazwa kaÅ¼dego zdefiniowanego przez nas wariantu enum staje siÄ™ rÃ³wnieÅ¼ funkcjÄ…, ktÃ³ra konstruuje instancjÄ™ enum. Oznacza to, Å¼e <code>IpAddr::V4()</code> jest wywoÅ‚aniem funkcji, ktÃ³ra przyjmuje argument <code>String</code> i zwraca instancjÄ™ typu <code>IpAddr</code>. TÄ™ funkcjÄ™ konstruujÄ…cÄ… otrzymujemy automatycznie w wyniku zdefiniowania enum.</p>
<p>Istnieje jeszcze jedna zaleta uÅ¼ywania typu wyliczeniowego zamiast struktury: kaÅ¼dy wariant moÅ¼e mieÄ‡ rÃ³Å¼ne typy i iloÅ›ci powiÄ…zanych danych. Adresy IP wersji czwartej zawsze bÄ™dÄ… miaÅ‚y cztery komponenty numeryczne o wartoÅ›ciach od 0 do 255. GdybyÅ›my chcieli przechowywaÄ‡ adresy <code>V4</code> jako cztery wartoÅ›ci <code>u8</code>, ale nadal wyraÅ¼aÄ‡ adresy <code>V6</code> jako pojedynczÄ… wartoÅ›Ä‡ <code>String</code>, nie bylibyÅ›my w stanie tego zrobiÄ‡ za pomocÄ… struktury. Typy wyliczeniowe z Å‚atwoÅ›ciÄ… radzÄ… sobie z tym przypadkiem:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre>
<p>PokazaliÅ›my kilka rÃ³Å¼nych sposobÃ³w definiowania struktur danych do przechowywania adresÃ³w IP wersji czwartej i szÃ³stej. Jednak, jak siÄ™ okazuje, chÄ™Ä‡ przechowywania adresÃ³w IP i kodowania ich rodzaju jest tak powszechna, Å¼e <a href="../std/net/enum.IpAddr.html">biblioteka standardowa ma definicjÄ™, ktÃ³rej moÅ¼emy uÅ¼yÄ‡!</a><!-- ignore --> Przyjrzyjmy siÄ™, jak biblioteka standardowa definiuje <code>IpAddr</code>. Ma ona dokÅ‚adnie ten sam typ wyliczeniowy i warianty, ktÃ³re zdefiniowaliÅ›my i uÅ¼yliÅ›my, ale osadza dane adresowe w wariantach w postaci dwÃ³ch rÃ³Å¼nych struktur, ktÃ³re sÄ… definiowane inaczej dla kaÅ¼dego wariantu:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}</span></code></pre>
<p>Ten kod ilustruje, Å¼e wariant enum moÅ¼e zawieraÄ‡ dowolny rodzaj danych: ciÄ…gi znakÃ³w, typy numeryczne lub struktury, na przykÅ‚ad. MoÅ¼e nawet zawieraÄ‡ inny enum! Ponadto, typy biblioteki standardowej czÄ™sto nie sÄ… o wiele bardziej skomplikowane niÅ¼ to, co sam byÅ› wymyÅ›liÅ‚.</p>
<p>ZauwaÅ¼, Å¼e choÄ‡ biblioteka standardowa zawiera definicjÄ™ dla <code>IpAddr</code>, nadal moÅ¼emy tworzyÄ‡ i uÅ¼ywaÄ‡ wÅ‚asnej definicji bez konfliktu, poniewaÅ¼ nie wprowadziliÅ›my definicji z biblioteki standardowej do naszego zasiÄ™gu. WiÄ™cej o wprowadzaniu typÃ³w do zasiÄ™gu omÃ³wimy w Rozdziale 7.</p>
<p>Przyjrzyjmy siÄ™ innemu przykÅ‚adowi typu wyliczeniowego w Listingu 6-2: ten ma szerokÄ… gamÄ™ typÃ³w osadzonych w swoich wariantach.</p>
<listing number="6-2" caption="Typ wyliczeniowy `Message`, ktÃ³rego warianty przechowujÄ… rÃ³Å¼ne iloÅ›ci i typy wartoÅ›ci">
<pre class="playground"><code class="language-rust edition2024">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
</listing>
<p>Ten typ wyliczeniowy ma cztery warianty o rÃ³Å¼nych typach:</p>
<ul>
<li><code>Quit</code>: Nie ma z nim zwiÄ…zanych Å¼adnych danych</li>
<li><code>Move</code>: Ma nazwane pola, podobnie jak struktura</li>
<li><code>Write</code>: Zawiera pojedynczy <code>String</code></li>
<li><code>ChangeColor</code>: Zawiera trzy wartoÅ›ci <code>i32</code></li>
</ul>
<p>Definiowanie enum z wariantami takimi jak te w Listingu 6-2 jest podobne do definiowania rÃ³Å¼nych rodzajÃ³w definicji struktur, z tÄ… rÃ³Å¼nicÄ…, Å¼e enum nie uÅ¼ywa sÅ‚owa kluczowego <code>struct</code>, a wszystkie warianty sÄ… zgrupowane pod typem <code>Message</code>. NastÄ™pujÄ…ce struktury mogÅ‚yby przechowywaÄ‡ te same dane, co poprzednie warianty enum:</p>
<pre class="playground"><code class="language-rust edition2024">struct QuitMessage; // struktura jednostkowa
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // struktura krotki
struct ChangeColorMessage(i32, i32, i32); // struktura krotki
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>Ale gdybyÅ›my uÅ¼yli rÃ³Å¼nych struktur, z ktÃ³rych kaÅ¼da ma swÃ³j wÅ‚asny typ, nie moglibyÅ›my tak Å‚atwo zdefiniowaÄ‡ funkcji, ktÃ³ra przyjmowaÅ‚aby dowolny z tych rodzajÃ³w wiadomoÅ›ci, jak w przypadku typu wyliczeniowego <code>Message</code> zdefiniowanego w Listingu 6-2, ktÃ³ry jest pojedynczym typem.</p>
<p>Istnieje jeszcze jedno podobieÅ„stwo miÄ™dzy typami wyliczeniowymi a strukturami: tak jak jesteÅ›my w stanie definiowaÄ‡ metody w strukturach za pomocÄ… <code>impl</code>, tak samo jesteÅ›my w stanie definiowaÄ‡ metody w typach wyliczeniowych. Oto metoda o nazwie <code>call</code>, ktÃ³rÄ… moglibyÅ›my zdefiniowaÄ‡ w naszym typie wyliczeniowym <code>Message</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quit,
</span><span class="boring">        Move { x: i32, y: i32 },
</span><span class="boring">        Write(String),
</span><span class="boring">        ChangeColor(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn call(&amp;self) {
            // treÅ›Ä‡ metody zostaÅ‚aby zdefiniowana tutaj
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
<span class="boring">}</span></code></pre>
<p>TreÅ›Ä‡ metody uÅ¼yÅ‚aby <code>self</code>, aby uzyskaÄ‡ wartoÅ›Ä‡, na ktÃ³rej wywoÅ‚aliÅ›my metodÄ™. W tym przykÅ‚adzie utworzyliÅ›my zmiennÄ… <code>m</code>, ktÃ³ra ma wartoÅ›Ä‡ <code>Message::Write(String::from("hello"))</code>, i to wÅ‚aÅ›nie bÄ™dzie <code>self</code> w treÅ›ci metody <code>call</code>, gdy zostanie uruchomione <code>m.call()</code>.</p>
<p>Przyjrzyjmy siÄ™ innemu enumowi w bibliotece standardowej, ktÃ³ry jest bardzo powszechny i uÅ¼yteczny: <code>Option</code>.</p>
<p><a id="the-option-enum-and-its-advantages-over-null-values"></a></p>
<h3 id="typ-wyliczeniowy-option"><a class="header" href="#typ-wyliczeniowy-option">Typ wyliczeniowy <code>Option</code></a></h3>
<p>Ta sekcja bada studium przypadku <code>Option</code>, ktÃ³re jest innym typem wyliczeniowym zdefiniowanym przez bibliotekÄ™ standardowÄ…. Typ <code>Option</code> koduje bardzo powszechny scenariusz, w ktÃ³rym wartoÅ›Ä‡ moÅ¼e byÄ‡ czymÅ›, albo moÅ¼e byÄ‡ niczym.</p>
<p>Na przykÅ‚ad, jeÅ›li zaÅ¼Ä…dasz pierwszego elementu z niepustej listy, otrzymasz wartoÅ›Ä‡. JeÅ›li zaÅ¼Ä…dasz pierwszego elementu z pustej listy, otrzymasz nic. WyraÅ¼enie tej koncepcji w kategoriach systemu typÃ³w oznacza, Å¼e kompilator moÅ¼e sprawdziÄ‡, czy obsÅ‚uÅ¼yÅ‚eÅ› wszystkie przypadki, ktÃ³re powinieneÅ› obsÅ‚uÅ¼yÄ‡; ta funkcjonalnoÅ›Ä‡ moÅ¼e zapobiegaÄ‡ bÅ‚Ä™dom, ktÃ³re sÄ… niezwykle powszechne w innych jÄ™zykach programowania.</p>
<p>Projektowanie jÄ™zykÃ³w programowania czÄ™sto rozpatruje siÄ™ w kategoriach tego, jakie funkcje siÄ™ uwzglÄ™dnia, ale funkcje, ktÃ³re siÄ™ wyklucza, rÃ³wnieÅ¼ sÄ… waÅ¼ne. Rust nie posiada funkcji null, ktÃ³rÄ… ma wiele innych jÄ™zykÃ³w. <em>Null</em> to wartoÅ›Ä‡, ktÃ³ra oznacza, Å¼e nie ma tam Å¼adnej wartoÅ›ci. W jÄ™zykach z null, zmienne mogÄ… zawsze byÄ‡ w jednym z dwÃ³ch stanÃ³w: null lub nie-null.</p>
<p>W swojej prezentacji z 2009 roku â€Null References: The Billion Dollar Mistakeâ€ Tony Hoare, wynalazca wartoÅ›ci null, powiedziaÅ‚:</p>
<blockquote>
<p>Nazywam to moim miliardowym bÅ‚Ä™dem. W tamtym czasie projektowaÅ‚em pierwszy kompleksowy system typÃ³w dla referencji w jÄ™zyku obiektowym. Moim celem byÅ‚o zapewnienie, Å¼e wszelkie uÅ¼ycie referencji powinno byÄ‡ absolutnie bezpieczne, z automatycznym sprawdzaniem wykonywanym przez kompilator. Ale nie mogÅ‚em oprzeÄ‡ siÄ™ pokusie wprowadzenia referencji null, po prostu dlatego, Å¼e byÅ‚a tak Å‚atwa do zaimplementowania. DoprowadziÅ‚o to do niezliczonych bÅ‚Ä™dÃ³w, luk w zabezpieczeniach i awarii systemÃ³w, ktÃ³re prawdopodobnie spowodowaÅ‚y miliard dolarÃ³w bÃ³lu i szkÃ³d w ciÄ…gu ostatnich czterdziestu lat.</p>
</blockquote>
<p>Problem z wartoÅ›ciami null polega na tym, Å¼e jeÅ›li sprÃ³bujesz uÅ¼yÄ‡ wartoÅ›ci null jako wartoÅ›ci nie-null, otrzymasz jakiÅ› bÅ‚Ä…d. PoniewaÅ¼ ta wÅ‚aÅ›ciwoÅ›Ä‡ null lub nie-null jest wszechobecna, niezwykle Å‚atwo jest popeÅ‚niÄ‡ tego rodzaju bÅ‚Ä…d.</p>
<p>Jednak koncepcja, ktÃ³rÄ… null prÃ³buje wyraziÄ‡, jest nadal uÅ¼yteczna: null to wartoÅ›Ä‡, ktÃ³ra jest obecnie nieprawidÅ‚owa lub nieobecna z jakiegoÅ› powodu.</p>
<p>Problem nie leÅ¼y w samej koncepcji, lecz w konkretnej implementacji. W zwiÄ…zku z tym Rust nie posiada wartoÅ›ci null, ale ma enum, ktÃ³ry moÅ¼e kodowaÄ‡ koncepcjÄ™ obecnoÅ›ci lub braku wartoÅ›ci. Tym enumem jest <code>Option&lt;T&gt;</code>, i jest on <a href="../std/option/enum.Option.html">zdefiniowany przez bibliotekÄ™ standardowÄ…</a><!-- ignore --> w nastÄ™pujÄ…cy sposÃ³b:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}</span></code></pre>
<p>Typ wyliczeniowy <code>Option&lt;T&gt;</code> jest tak uÅ¼yteczny, Å¼e jest nawet wÅ‚Ä…czony do preambuly; nie musisz jawnie wprowadzaÄ‡ go do zasiÄ™gu. Jego warianty sÄ… rÃ³wnieÅ¼ wÅ‚Ä…czone do preambuly: moÅ¼esz uÅ¼ywaÄ‡ <code>Some</code> i <code>None</code> bezpoÅ›rednio bez prefiksu <code>Option::</code>. Typ wyliczeniowy <code>Option&lt;T&gt;</code> jest nadal zwykÅ‚ym typem wyliczeniowym, a <code>Some(T)</code> i <code>None</code> sÄ… nadal wariantami typu <code>Option&lt;T&gt;</code>.</p>
<p>SkÅ‚adnia <code>&lt;T&gt;</code> to cecha Rust, o ktÃ³rej jeszcze nie mÃ³wiliÅ›my. Jest to ogÃ³lny parametr typu, a o ogÃ³lnych typach szerzej omÃ³wimy w Rozdziale 10. Na razie musisz wiedzieÄ‡, Å¼e <code>&lt;T&gt;</code> oznacza, Å¼e wariant <code>Some</code> typu wyliczeniowego <code>Option</code> moÅ¼e przechowywaÄ‡ pojedynczy element danych dowolnego typu, a kaÅ¼dy konkretny typ, ktÃ³ry zostanie uÅ¼yty zamiast <code>T</code>, sprawia, Å¼e caÅ‚y typ <code>Option&lt;T&gt;</code> staje siÄ™ innym typem. Oto kilka przykÅ‚adÃ³w uÅ¼ycia wartoÅ›ci <code>Option</code> do przechowywania typÃ³w liczbowych i znakowych:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}</span></code></pre>
<p>Typ <code>some_number</code> to <code>Option&lt;i32&gt;</code>. Typ <code>some_char</code> to <code>Option&lt;char&gt;</code>, co jest innym typem. Rust moÅ¼e wywnioskowaÄ‡ te typy, poniewaÅ¼ okreÅ›liliÅ›my wartoÅ›Ä‡ w wariancie <code>Some</code>. Dla <code>absent_number</code>, Rust wymaga od nas adnotacji caÅ‚ego typu <code>Option</code>: kompilator nie moÅ¼e wywnioskowaÄ‡ typu, ktÃ³ry bÄ™dzie przechowywaÅ‚ odpowiadajÄ…cy mu wariant <code>Some</code>, patrzÄ…c tylko na wartoÅ›Ä‡ <code>None</code>. Tutaj mÃ³wimy Rustowi, Å¼e chcemy, aby <code>absent_number</code> byÅ‚ typu <code>Option&lt;i32&gt;</code>.</p>
<p>Kiedy mamy wartoÅ›Ä‡ <code>Some</code>, wiemy, Å¼e wartoÅ›Ä‡ jest obecna, a wartoÅ›Ä‡ jest przechowywana w <code>Some</code>. Kiedy mamy wartoÅ›Ä‡ <code>None</code>, w pewnym sensie oznacza to to samo co null: nie mamy waÅ¼nej wartoÅ›ci. Dlaczego wiÄ™c <code>Option&lt;T&gt;</code> jest lepsze niÅ¼ null?</p>
<p>KrÃ³tko mÃ³wiÄ…c, poniewaÅ¼ <code>Option&lt;T&gt;</code> i <code>T</code> (gdzie <code>T</code> moÅ¼e byÄ‡ dowolnym typem) sÄ… rÃ³Å¼nymi typami, kompilator nie pozwoli nam uÅ¼yÄ‡ wartoÅ›ci <code>Option&lt;T&gt;</code> tak, jakby byÅ‚a ona na pewno prawidÅ‚owÄ… wartoÅ›ciÄ…. Na przykÅ‚ad ten kod nie skompiluje siÄ™, poniewaÅ¼ prÃ³buje dodaÄ‡ <code>i8</code> do <code>Option&lt;i8&gt;</code>:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let sum = x + y;
<span class="boring">}</span></code></pre>
<p>JeÅ›li uruchomimy ten kod, otrzymamy komunikat o bÅ‚Ä™dzie podobny do tego:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` do `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ brak implementacji dla `i8 + Option&lt;i8&gt;`
  |
  = help: cecha `Add&lt;Option&lt;i8&gt;&gt;` nie jest zaimplementowana dla `i8`
  = help: nastÄ™pujÄ…ce inne typy implementujÄ… cechÄ™ `Add&lt;Rhs&gt;`:
            `&amp;i8` implementuje `Add&lt;i8&gt;`
            `&amp;i8` implementuje `Add`
            `i8` implementuje `Add&lt;&amp;i8&gt;`
            `i8` implementuje `Add`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` (bin "enums") due to 1 previous error
</code></pre>
<p>Intensywnie! W efekcie ten komunikat o bÅ‚Ä™dzie oznacza, Å¼e Rust nie rozumie, jak dodaÄ‡ <code>i8</code> i <code>Option&lt;i8&gt;</code>, poniewaÅ¼ sÄ… to rÃ³Å¼ne typy. Kiedy mamy wartoÅ›Ä‡ typu takiego jak <code>i8</code> w Rust, kompilator zapewni, Å¼e zawsze mamy prawidÅ‚owÄ… wartoÅ›Ä‡. MoÅ¼emy postÄ™powaÄ‡ pewnie, nie muszÄ…c sprawdzaÄ‡ wartoÅ›ci null przed uÅ¼yciem tej wartoÅ›ci. Tylko wtedy, gdy mamy <code>Option&lt;i8&gt;</code> (lub dowolny typ wartoÅ›ci, z ktÃ³rym pracujemy), musimy martwiÄ‡ siÄ™ o ewentualny brak wartoÅ›ci, a kompilator upewni siÄ™, Å¼e obsÅ‚uÅ¼ymy ten przypadek przed uÅ¼yciem wartoÅ›ci.</p>
<p>Innymi sÅ‚owy, musisz przekonwertowaÄ‡ <code>Option&lt;T&gt;</code> na <code>T</code>, zanim bÄ™dziesz mÃ³gÅ‚ wykonywaÄ‡ operacje <code>T</code>. OgÃ³lnie rzecz biorÄ…c, pomaga to wychwyciÄ‡ jeden z najczÄ™stszych problemÃ³w z null: zaÅ‚oÅ¼enie, Å¼e coÅ› nie jest null, gdy w rzeczywistoÅ›ci jest.</p>
<p>Eliminowanie ryzyka bÅ‚Ä™dnego zaÅ‚oÅ¼enia wartoÅ›ci nie-null pomaga ci byÄ‡ pewniejszym swojego kodu. Aby mieÄ‡ wartoÅ›Ä‡, ktÃ³ra potencjalnie moÅ¼e byÄ‡ null, musisz jawnie siÄ™ na to zgodziÄ‡, czyniÄ…c typ tej wartoÅ›ci <code>Option&lt;T&gt;</code>. NastÄ™pnie, gdy uÅ¼ywasz tej wartoÅ›ci, musisz jawnie obsÅ‚uÅ¼yÄ‡ przypadek, gdy wartoÅ›Ä‡ jest null. WszÄ™dzie tam, gdzie wartoÅ›Ä‡ ma typ, ktÃ³ry nie jest <code>Option&lt;T&gt;</code>, <em>moÅ¼esz</em> bezpiecznie zaÅ‚oÅ¼yÄ‡, Å¼e wartoÅ›Ä‡ nie jest null. ByÅ‚a to celowa decyzja projektowa dla Rust, aby ograniczyÄ‡ wszechobecnoÅ›Ä‡ wartoÅ›ci null i zwiÄ™kszyÄ‡ bezpieczeÅ„stwo kodu w Rust.</p>
<p>WiÄ™c jak wyciÄ…gnÄ…Ä‡ wartoÅ›Ä‡ <code>T</code> z wariantu <code>Some</code>, gdy masz wartoÅ›Ä‡ typu <code>Option&lt;T&gt;</code>, aby mÃ³c jej uÅ¼yÄ‡? Enum <code>Option&lt;T&gt;</code> ma wiele metod, ktÃ³re sÄ… przydatne w rÃ³Å¼nych sytuacjach; moÅ¼esz je sprawdziÄ‡ w <a href="../std/option/enum.Option.html">jej dokumentacji</a><!-- ignore -->. Zapoznanie siÄ™ z metodami w <code>Option&lt;T&gt;</code> bÄ™dzie niezwykle pomocne w Twojej podrÃ³Å¼y z Rust.</p>
<p>OgÃ³lnie rzecz biorÄ…c, aby uÅ¼yÄ‡ wartoÅ›ci <code>Option&lt;T&gt;</code>, chcesz mieÄ‡ kod, ktÃ³ry obsÅ‚uÅ¼y kaÅ¼dy wariant. Chcesz, aby pewien kod uruchamiaÅ‚ siÄ™ tylko wtedy, gdy masz wartoÅ›Ä‡ <code>Some(T)</code>, i ten kod moÅ¼e uÅ¼ywaÄ‡ wewnÄ™trznego <code>T</code>. Chcesz, aby inny kod uruchamiaÅ‚ siÄ™ tylko wtedy, gdy masz wartoÅ›Ä‡ <code>None</code>, a ten kod nie ma dostÄ™pnej wartoÅ›ci <code>T</code>. WyraÅ¼enie <code>match</code> jest konstrukcjÄ… przepÅ‚ywu sterowania, ktÃ³ra robi to wÅ‚aÅ›nie w przypadku enumÃ³w: uruchamia inny kod w zaleÅ¼noÅ›ci od wariantu enum, ktÃ³ry posiada, a ten kod moÅ¼e uÅ¼ywaÄ‡ danych zawartych w pasujÄ…cej wartoÅ›ci.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="konstrukcja-kontroli-przepÅ‚ywu-match-1"><a href="#konstrukcja-kontroli-przepÅ‚ywu-match-1" class="header">Konstrukcja kontroli przepÅ‚ywu `match`</a></h1>
<p><a id="the-match-control-flow-operator"></a></p>
<h2 id="konstrukcja-kontroli-przepÅ‚ywu-match"><a class="header" href="#konstrukcja-kontroli-przepÅ‚ywu-match">Konstrukcja kontroli przepÅ‚ywu <code>match</code></a></h2>
<p>Rust ma niezwykle potÄ™Å¼nÄ… konstrukcjÄ™ kontroli przepÅ‚ywu o nazwie <code>match</code>, ktÃ³ra pozwala porÃ³wnywaÄ‡ wartoÅ›Ä‡ z seriÄ… wzorcÃ³w, a nastÄ™pnie wykonywaÄ‡ kod na podstawie pasujÄ…cego wzorca. Wzorce mogÄ… skÅ‚adaÄ‡ siÄ™ z literaÅ‚Ã³w, nazw zmiennych, symboli wieloznacznych i wielu innych rzeczy; <a href="#wzorce-i-dopasowywanie">RozdziaÅ‚ 19</a><!-- ignore --> obejmuje wszystkie rÃ³Å¼ne rodzaje wzorcÃ³w i to, co robiÄ…. SiÅ‚a <code>match</code> pochodzi z ekspresywnoÅ›ci wzorcÃ³w i faktu, Å¼e kompilator potwierdza, Å¼e wszystkie moÅ¼liwe przypadki sÄ… obsÅ‚ugiwane.</p>
<p>PomyÅ›l o wyraÅ¼eniu <code>match</code> jak o maszynie do sortowania monet: monety zjeÅ¼dÅ¼ajÄ… po torze z otworami o rÃ³Å¼nej wielkoÅ›ci, a kaÅ¼da moneta wpada przez pierwszy otwÃ³r, do ktÃ³rego pasuje. W ten sam sposÃ³b wartoÅ›ci przechodzÄ… przez kaÅ¼dy wzorzec w <code>match</code>, a przy pierwszym wzorcu, do ktÃ³rego wartoÅ›Ä‡ â€pasujeâ€, wartoÅ›Ä‡ wpada do skojarzonego bloku kodu, aby zostaÄ‡ uÅ¼yta podczas wykonania.</p>
<p>Skoro mowa o monetach, uÅ¼yjmy ich jako przykÅ‚adu z <code>match</code>! MoÅ¼emy napisaÄ‡ funkcjÄ™, ktÃ³ra przyjmuje nieznanÄ… monetÄ™ amerykaÅ„skÄ… i, podobnie jak maszyna liczÄ…ca, okreÅ›la, jaka to moneta i zwraca jej wartoÅ›Ä‡ w centach, jak pokazano w Listingu 6-3.</p>
<listing number="6-3" caption="Typ wyliczeniowy i wyraÅ¼enie `match`, ktÃ³re ma warianty typu wyliczeniowego jako wzorce">
<pre class="playground"><code class="language-rust edition2024">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
</listing>
<p>RozÅ‚Ã³Å¼my <code>match</code> w funkcji <code>value_in_cents</code>. Najpierw wymieniamy sÅ‚owo kluczowe <code>match</code>, po ktÃ³rym nastÄ™puje wyraÅ¼enie, ktÃ³re w tym przypadku jest wartoÅ›ciÄ… <code>coin</code>. To wydaje siÄ™ bardzo podobne do wyraÅ¼enia warunkowego uÅ¼ywanego z <code>if</code>, ale jest duÅ¼a rÃ³Å¼nica: z <code>if</code> warunek musi ewaluowaÄ‡ do wartoÅ›ci boolowskiej, ale tutaj moÅ¼e to byÄ‡ dowolny typ. Typ <code>coin</code> w tym przykÅ‚adzie to enum <code>Coin</code>, ktÃ³ry zdefiniowaliÅ›my w pierwszej linii.</p>
<p>NastÄ™pne sÄ… ramiona <code>match</code>. Ramka skÅ‚ada siÄ™ z dwÃ³ch czÄ™Å›ci: wzorca i pewnego kodu. Pierwsza ramka ma wzorzec, ktÃ³rym jest wartoÅ›Ä‡ <code>Coin::Penny</code>, a nastÄ™pnie operator <code>=&gt;</code>, ktÃ³ry oddziela wzorzec od kodu do uruchomienia. Kod w tym przypadku to po prostu wartoÅ›Ä‡ <code>1</code>. KaÅ¼da ramka jest oddzielona od nastÄ™pnej przecinkiem.</p>
<p>Kiedy wyraÅ¼enie <code>match</code> jest wykonywane, porÃ³wnuje ono wynikowÄ… wartoÅ›Ä‡ z wzorcem kaÅ¼dej gaÅ‚Ä™zi, po kolei. JeÅ›li wzorzec pasuje do wartoÅ›ci, kod skojarzony z tym wzorcem jest wykonywany. JeÅ›li ten wzorzec nie pasuje do wartoÅ›ci, wykonanie przechodzi do nastÄ™pnej gaÅ‚Ä™zi, podobnie jak w maszynie do sortowania monet. MoÅ¼emy mieÄ‡ tyle gaÅ‚Ä™zi, ile potrzebujemy: w Listingu 6-3, nasz <code>match</code> ma cztery gaÅ‚Ä™zie.</p>
<p>Kod skojarzony z kaÅ¼dym ramieniem jest wyraÅ¼eniem, a wynikowa wartoÅ›Ä‡ wyraÅ¼enia w pasujÄ…cym ramieniu jest wartoÅ›ciÄ…, ktÃ³ra jest zwracana dla caÅ‚ego wyraÅ¼enia <code>match</code>.</p>
<p>Zazwyczaj nie uÅ¼ywamy nawiasÃ³w klamrowych, jeÅ›li kod gaÅ‚Ä™zi <code>match</code> jest krÃ³tki, jak w Listingu 6-3, gdzie kaÅ¼da gaÅ‚Ä…Åº po prostu zwraca wartoÅ›Ä‡. JeÅ›li chcesz uruchomiÄ‡ wiele linii kodu w gaÅ‚Ä™zi <code>match</code>, musisz uÅ¼yÄ‡ nawiasÃ³w klamrowych, a przecinek po gaÅ‚Ä™zi jest wtedy opcjonalny. Na przykÅ‚ad, poniÅ¼szy kod drukuje â€Lucky penny!â€ za kaÅ¼dym razem, gdy metoda jest wywoÅ‚ywana z <code>Coin::Penny</code>, ale nadal zwraca ostatniÄ… wartoÅ›Ä‡ bloku, <code>1</code>:</p>
<pre class="playground"><code class="language-rust edition2024">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!("SzczÄ™Å›liwy grosz!");
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<h3 id="wzorce-ktÃ³re-wiÄ…Å¼Ä…-siÄ™-z-wartoÅ›ciami"><a class="header" href="#wzorce-ktÃ³re-wiÄ…Å¼Ä…-siÄ™-z-wartoÅ›ciami">Wzorce, ktÃ³re wiÄ…Å¼Ä… siÄ™ z wartoÅ›ciami</a></h3>
<p>InnÄ… przydatnÄ… cechÄ… ramion <code>match</code> jest to, Å¼e mogÄ… one wiÄ…zaÄ‡ siÄ™ z czÄ™Å›ciami wartoÅ›ci, ktÃ³re pasujÄ… do wzorca. W ten sposÃ³b moÅ¼emy wyodrÄ™bniaÄ‡ wartoÅ›ci z wariantÃ³w enum.</p>
<p>Na przykÅ‚ad, zmieÅ„my jeden z naszych wariantÃ³w enum, aby przechowywaÅ‚ w sobie dane. Od 1999 do 2008 roku Stany Zjednoczone biÅ‚y Ä‡wierÄ‡dolarÃ³wki z rÃ³Å¼nymi wzorami dla kaÅ¼dego z 50 stanÃ³w po jednej stronie. Å»adne inne monety nie otrzymaÅ‚y wzorÃ³w stanÃ³w, wiÄ™c tylko Ä‡wierÄ‡dolarÃ³wki majÄ… tÄ™ dodatkowÄ… wartoÅ›Ä‡. MoÅ¼emy dodaÄ‡ tÄ™ informacjÄ™ do naszego <code>enum</code>, zmieniajÄ…c wariant <code>Quarter</code> tak, aby zawieraÅ‚ wartoÅ›Ä‡ <code>UsState</code> przechowywanÄ… w Å›rodku, co zrobiliÅ›my w Listingu 6-4.</p>
<listing number="6-4" caption="Enum `Coin`, w ktÃ³rym wariant `Quarter` zawiera rÃ³wnieÅ¼ wartoÅ›Ä‡ `UsState`">
<pre class="playground"><code class="language-rust edition2024">#[derive(Debug)] // abyÅ›my mogli za chwilÄ™ sprawdziÄ‡ stan
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
</listing>
<p>WyobraÅºmy sobie, Å¼e przyjaciel prÃ³buje zebraÄ‡ wszystkie 50 monet stanowych. Podczas gdy my sortujemy naszÄ… drobnÄ… monetÄ™ wedÅ‚ug typu monety, bÄ™dziemy rÃ³wnieÅ¼ wywoÅ‚ywaÄ‡ nazwÄ™ stanu zwiÄ…zanego z kaÅ¼dÄ… monetÄ…, tak aby jeÅ›li jest to moneta, ktÃ³rej nasz przyjaciel nie ma, mÃ³gÅ‚ jÄ… dodaÄ‡ do swojej kolekcji.</p>
<p>W wyraÅ¼eniu <code>match</code> dla tego kodu dodajemy zmiennÄ… o nazwie <code>state</code> do wzorca, ktÃ³ry pasuje do wartoÅ›ci wariantu <code>Coin::Quarter</code>. Gdy pasuje <code>Coin::Quarter</code>, zmienna <code>state</code> zostanie powiÄ…zana z wartoÅ›ciÄ… stanu tej Ä‡wiartki. NastÄ™pnie moÅ¼emy uÅ¼yÄ‡ <code>state</code> w kodzie dla tego ramienia, w ten sposÃ³b:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!("Moneta stanowa z {state:?}!");
            25
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    value_in_cents(Coin::Quarter(UsState::Alaska));
</span><span class="boring">}</span></code></pre>
<p>GdybyÅ›my wywoÅ‚ali <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>, <code>coin</code> byÅ‚by <code>Coin::Quarter(UsState::Alaska)</code>. Kiedy porÃ³wnamy tÄ™ wartoÅ›Ä‡ z kaÅ¼dym z ramion <code>match</code>, Å¼adne z nich nie pasuje, dopÃ³ki nie dotrzemy do <code>Coin::Quarter(state)</code>. W tym momencie wiÄ…zanie dla <code>state</code> bÄ™dzie wartoÅ›ciÄ… <code>UsState::Alaska</code>. MoÅ¼emy nastÄ™pnie uÅ¼yÄ‡ tego wiÄ…zania w wyraÅ¼eniu <code>println!</code>, uzyskujÄ…c w ten sposÃ³b wewnÄ™trznÄ… wartoÅ›Ä‡ stanu z wariantu enum <code>Coin</code> dla <code>Quarter</code>.</p>
<p><a id="matching-with-optiont"></a></p>
<h3 id="wzorzec-optiont-match"><a class="header" href="#wzorzec-optiont-match">Wzorzec <code>Option&lt;T&gt;</code> <code>match</code></a></h3>
<p>W poprzedniej sekcji chcieliÅ›my wydobyÄ‡ wewnÄ™trznÄ… wartoÅ›Ä‡ <code>T</code> z przypadku <code>Some</code> podczas uÅ¼ywania <code>Option&lt;T&gt;</code>; moÅ¼emy rÃ³wnieÅ¼ obsÅ‚ugiwaÄ‡ <code>Option&lt;T&gt;</code> za pomocÄ… <code>match</code>, tak jak zrobiliÅ›my to z enumem <code>Coin</code>! Zamiast porÃ³wnywaÄ‡ monety, bÄ™dziemy porÃ³wnywaÄ‡ warianty <code>Option&lt;T&gt;</code>, ale sposÃ³b dziaÅ‚ania wyraÅ¼enia <code>match</code> pozostaje taki sam.</p>
<p>Powiedzmy, Å¼e chcemy napisaÄ‡ funkcjÄ™, ktÃ³ra przyjmuje <code>Option&lt;i32&gt;</code> i, jeÅ›li w Å›rodku jest wartoÅ›Ä‡, dodaje do niej 1. JeÅ›li w Å›rodku nie ma wartoÅ›ci, funkcja powinna zwrÃ³ciÄ‡ wartoÅ›Ä‡ <code>None</code> i nie prÃ³bowaÄ‡ wykonywaÄ‡ Å¼adnych operacji.</p>
<p>TÄ™ funkcjÄ™ bardzo Å‚atwo napisaÄ‡, dziÄ™ki <code>match</code>, i bÄ™dzie ona wyglÄ…daÄ‡ jak Listing 6-5.</p>
<listing number="6-5" caption="Funkcja, ktÃ³ra uÅ¼ywa wyraÅ¼enia `match` w `Option&lt;i32&gt;`">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
<span class="boring">}</span></code></pre>
</listing>
<p>Przyjrzyjmy siÄ™ dokÅ‚adniej pierwszemu wykonaniu <code>plus_one</code>. Kiedy wywoÅ‚ujemy <code>plus_one(five)</code>, zmienna <code>x</code> w ciele <code>plus_one</code> bÄ™dzie miaÅ‚a wartoÅ›Ä‡ <code>Some(5)</code>. NastÄ™pnie porÃ³wnujemy jÄ… z kaÅ¼dym ramieniem <code>match</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>WartoÅ›Ä‡ <code>Some(5)</code> nie pasuje do wzorca <code>None</code>, wiÄ™c przechodzimy do nastÄ™pnego ramienia:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span><span class="boring">            None =&gt; None,
</span>            Some(i) =&gt; Some(i + 1),
<span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>Czy <code>Some(5)</code> pasuje do <code>Some(i)</code>? Tak! Mamy ten sam wariant. <code>i</code> wiÄ…Å¼e siÄ™ z wartoÅ›ciÄ… zawartÄ… w <code>Some</code>, wiÄ™c <code>i</code> przyjmuje wartoÅ›Ä‡ <code>5</code>. NastÄ™pnie kod w ramieniu <code>match</code> jest wykonywany, wiÄ™c dodajemy 1 do wartoÅ›ci <code>i</code> i tworzymy nowÄ… wartoÅ›Ä‡ <code>Some</code> z naszym Å‚Ä…cznym <code>6</code> w Å›rodku.</p>
<p>RozwaÅ¼my teraz drugie wywoÅ‚anie <code>plus_one</code> w Listingu 6-5, gdzie <code>x</code> jest <code>None</code>. Wchodzimy do <code>match</code> i porÃ³wnujemy z pierwszym ramieniem:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>Pasuje! Nie ma wartoÅ›ci do dodania, wiÄ™c program zatrzymuje siÄ™ i zwraca wartoÅ›Ä‡ <code>None</code> po prawej stronie <code>=&gt;</code>. PoniewaÅ¼ pierwsze ramiÄ™ pasowaÅ‚o, Å¼adne inne ramiona nie sÄ… porÃ³wnywane.</p>
<p>ÅÄ…czenie <code>match</code> i enumÃ³w jest przydatne w wielu sytuacjach. BÄ™dziesz czÄ™sto widziaÅ‚ ten wzorzec w kodzie Rust: <code>match</code> z enumem, powiÄ…zanie zmiennej z danymi wewnÄ…trz, a nastÄ™pnie wykonanie kodu na tej podstawie. Na poczÄ…tku jest to trochÄ™ trudne, ale gdy siÄ™ do tego przyzwyczaisz, bÄ™dziesz Å¼aÅ‚owaÅ‚, Å¼e nie miaÅ‚eÅ› tego we wszystkich jÄ™zykach. Jest to konsekwentnie ulubiona funkcja uÅ¼ytkownikÃ³w.</p>
<h3 id="dopasowania-sÄ…-wyczerpujÄ…ce"><a class="header" href="#dopasowania-sÄ…-wyczerpujÄ…ce">Dopasowania sÄ… wyczerpujÄ…ce</a></h3>
<p>Jest jeszcze jeden aspekt <code>match</code>, ktÃ³ry musimy omÃ³wiÄ‡: wzorce ramion muszÄ… obejmowaÄ‡ wszystkie moÅ¼liwoÅ›ci. RozwaÅ¼my tÄ™ wersjÄ™ naszej funkcji <code>plus_one</code>, ktÃ³ra zawiera bÅ‚Ä…d i nie skompiluje siÄ™:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }
<span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>Nie obsÅ‚uÅ¼yliÅ›my przypadku <code>None</code>, wiÄ™c ten kod spowoduje bÅ‚Ä…d. Na szczÄ™Å›cie jest to bÅ‚Ä…d, ktÃ³ry Rust potrafi wyÅ‚apaÄ‡. JeÅ›li sprÃ³bujemy skompilowaÄ‡ ten kod, otrzymamy taki bÅ‚Ä…d:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` nie pokryto
 --&gt; src/main.rs:3:15
  |
3 |         match x {
  |               ^ wzorzec `None` nie pokryto
  |
note: `Option&lt;i32&gt;` zdefiniowano tutaj
 --&gt; /rustc/1159e78c4747b02ef996e55082b704c09b970588/library/core/src/option.rs:593:1
 ::: /rustc/1159e78c4747b02ef996e55082b704c09b970588/library/core/src/option.rs:597:5
  |
  = note: nie pokryto
  = note: dopasowana wartoÅ›Ä‡ jest typu `Option&lt;i32&gt;`
help: upewnij siÄ™, Å¼e wszystkie moÅ¼liwe przypadki sÄ… obsÅ‚ugiwane, dodajÄ…c ramiÄ™ dopasowania z wzorcem wieloznacznym lub jawnym wzorcem, jak pokazano
  |
4 ~             Some(i) =&gt; Some(i + 1),
5 ~             None =&gt; todo!(),
  |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` (bin "enums") due to 1 previous error
</code></pre>
<p>Rust wie, Å¼e nie objÄ™liÅ›my kaÅ¼dego moÅ¼liwego przypadku i nawet wie, ktÃ³ry wzorzec pominÄ™liÅ›my! Dopasowania w Rust sÄ… <em>wyczerpujÄ…ce</em>: Musimy wyczerpaÄ‡ kaÅ¼dÄ… ostatniÄ… moÅ¼liwoÅ›Ä‡, aby kod byÅ‚ poprawny. ZwÅ‚aszcza w przypadku <code>Option&lt;T&gt;</code>, gdy Rust uniemoÅ¼liwia nam zapomnienie o jawnej obsÅ‚udze przypadku <code>None</code>, chroni nas przed zakÅ‚adaniem, Å¼e mamy wartoÅ›Ä‡, gdy moÅ¼emy mieÄ‡ null, co uniemoÅ¼liwia popeÅ‚nienie bÅ‚Ä™du miliarda dolarÃ³w, o ktÃ³rym mÃ³wiliÅ›my wczeÅ›niej.</p>
<h3 id="wzorce-ogÃ³lne-catch-all-i-symbol-zastÄ™pczy-_"><a class="header" href="#wzorce-ogÃ³lne-catch-all-i-symbol-zastÄ™pczy-_">Wzorce ogÃ³lne (Catch-All) i symbol zastÄ™pczy <code>_</code></a></h3>
<p>UÅ¼ywajÄ…c typÃ³w wyliczeniowych, moÅ¼emy rÃ³wnieÅ¼ podejmowaÄ‡ specjalne dziaÅ‚ania dla kilku konkretnych wartoÅ›ci, ale dla wszystkich innych wartoÅ›ci podjÄ…Ä‡ jedno domyÅ›lne dziaÅ‚anie. WyobraÅºmy sobie, Å¼e implementujemy grÄ™, w ktÃ³rej, jeÅ›li na rzucie kostkÄ… wypadnie 3, gracz nie rusza siÄ™, ale zamiast tego dostaje fantazyjny nowy kapelusz. JeÅ›li wypadnie 7, gracz traci fantazyjny kapelusz. Dla wszystkich innych wartoÅ›ci, gracz przesuwa siÄ™ o tÄ™ liczbÄ™ pÃ³l na planszy. Oto <code>match</code>, ktÃ³ry implementuje tÄ™ logikÄ™, z wynikiem rzutu kostkÄ… zakodowanym na staÅ‚e, a nie wartoÅ›ciÄ… losowÄ…, a caÅ‚a inna logika jest reprezentowana przez funkcje bez ciaÅ‚, poniewaÅ¼ ich faktyczne zaimplementowanie wykracza poza zakres tego przykÅ‚adu:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        other =&gt; move_player(other),
    }

    fn add_fancy_hat() {}
    fn fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
<span class="boring">}</span></code></pre>
<p>Dla pierwszych dwÃ³ch gaÅ‚Ä™zi wzorcami sÄ… literaÅ‚y <code>3</code> i <code>7</code>. Dla ostatniej gaÅ‚Ä™zi, ktÃ³ra obejmuje wszystkie inne moÅ¼liwe wartoÅ›ci, wzorcem jest zmienna, ktÃ³rÄ… nazwaliÅ›my <code>other</code>. Kod uruchamiany dla gaÅ‚Ä™zi <code>other</code> uÅ¼ywa zmiennej, przekazujÄ…c jÄ… do funkcji <code>move_player</code>.</p>
<p>Ten kod kompiluje siÄ™, chociaÅ¼ nie wymieniliÅ›my wszystkich moÅ¼liwych wartoÅ›ci, jakie moÅ¼e mieÄ‡ <code>u8</code>, poniewaÅ¼ ostatni wzorzec bÄ™dzie pasowaÅ‚ do wszystkich wartoÅ›ci, ktÃ³re nie zostaÅ‚y specjalnie wymienione. Ten wzorzec typu catch-all speÅ‚nia wymÃ³g, Å¼e <code>match</code> musi byÄ‡ wyczerpujÄ…ce. ZauwaÅ¼, Å¼e musimy umieÅ›ciÄ‡ ramiÄ™ typu catch-all na koÅ„cu, poniewaÅ¼ wzorce sÄ… oceniane po kolei. GdybyÅ›my umieÅ›cili ramiÄ™ typu catch-all wczeÅ›niej, inne ramiona nigdy by siÄ™ nie uruchomiÅ‚y, wiÄ™c Rust ostrzeÅ¼e nas, jeÅ›li dodamy ramiona po catch-all!</p>
<p>Rust posiada rÃ³wnieÅ¼ wzorzec, ktÃ³rego moÅ¼emy uÅ¼yÄ‡, gdy chcemy zastosowaÄ‡ wzorzec ogÃ³lny, ale nie chcemy <em>uÅ¼ywaÄ‡</em> wartoÅ›ci w tym wzorcu: <code>_</code> to specjalny wzorzec, ktÃ³ry pasuje do dowolnej wartoÅ›ci i nie wiÄ…Å¼e siÄ™ z tÄ… wartoÅ›ciÄ…. To mÃ³wi Rustowi, Å¼e nie bÄ™dziemy uÅ¼ywaÄ‡ tej wartoÅ›ci, wiÄ™c Rust nie ostrzeÅ¼e nas o nieuÅ¼ywanej zmiennej.</p>
<p>ZmieÅ„my zasady gry: teraz, jeÅ›li wyrzucisz coÅ› innego niÅ¼ 3 lub 7, musisz rzuciÄ‡ ponownie. Nie potrzebujemy juÅ¼ uÅ¼ywaÄ‡ wartoÅ›ci typu catch-all, wiÄ™c moÅ¼emy zmieniÄ‡ nasz kod, aby uÅ¼ywaÅ‚ <code>_</code> zamiast zmiennej o nazwie <code>other</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
<span class="boring">}</span></code></pre>
<p>Ten przykÅ‚ad rÃ³wnieÅ¼ speÅ‚nia wymÃ³g wyczerpujÄ…cego dopasowania, poniewaÅ¼ jawnie ignorujemy wszystkie inne wartoÅ›ci w ostatnim ramieniu; niczego nie pominÄ™liÅ›my.</p>
<p>Na koniec zmienimy zasady gry jeszcze raz, tak aby nic innego nie dziaÅ‚o siÄ™ w Twojej turze, jeÅ›li wyrzucisz coÅ› innego niÅ¼ 3 lub 7. MoÅ¼emy to wyraziÄ‡, uÅ¼ywajÄ…c wartoÅ›ci jednostkowej (typu pustej krotki, o ktÃ³rej wspominaliÅ›my w sekcji <a href="#the-tuple-type">â€Typ krotkiâ€</a><!-- ignore -->) jako kodu, ktÃ³ry towarzyszy ramieniu <code>_</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
<span class="boring">}</span></code></pre>
<p>Tutaj jawnie mÃ³wimy Rustowi, Å¼e nie zamierzamy uÅ¼ywaÄ‡ Å¼adnej innej wartoÅ›ci, ktÃ³ra nie pasuje do wzorca w poprzednim ramieniu, i nie chcemy uruchamiaÄ‡ Å¼adnego kodu w tym przypadku.</p>
<p>WiÄ™cej o wzorcach i dopasowywaniu omÃ³wimy w <a href="#wzorce-i-dopasowywanie">Rozdziale 19</a><!-- ignore -->. Na razie przejdziemy do skÅ‚adni <code>if let</code>, ktÃ³ra moÅ¼e byÄ‡ uÅ¼yteczna w sytuacjach, gdy wyraÅ¼enie <code>match</code> jest nieco rozwlekÅ‚e.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="zwiÄ™zÅ‚a-kontrola-przepÅ‚ywu-z-if-let-i-letelse-1"><a href="#zwiÄ™zÅ‚a-kontrola-przepÅ‚ywu-z-if-let-i-letelse-1" class="header">ZwiÄ™zÅ‚a kontrola przepÅ‚ywu z `if let` i `let...else`</a></h1>
<h2 id="zwiÄ™zÅ‚a-kontrola-przepÅ‚ywu-z-if-let-i-letelse"><a class="header" href="#zwiÄ™zÅ‚a-kontrola-przepÅ‚ywu-z-if-let-i-letelse">ZwiÄ™zÅ‚a kontrola przepÅ‚ywu z <code>if let</code> i <code>let...else</code></a></h2>
<p>SkÅ‚adnia <code>if let</code> pozwala poÅ‚Ä…czyÄ‡ <code>if</code> i <code>let</code> w mniej rozwlekÅ‚y sposÃ³b obsÅ‚ugi wartoÅ›ci pasujÄ…cych do jednego wzorca, ignorujÄ…c pozostaÅ‚e. RozwaÅ¼ program z Listingu 6-6, ktÃ³ry dopasowuje wartoÅ›Ä‡ <code>Option&lt;u8&gt;</code> w zmiennej <code>config_max</code>, ale chce wykonaÄ‡ kod tylko wtedy, gdy wartoÅ›Ä‡ jest wariantem <code>Some</code>.</p>
<listing number="6-6" caption="`match`, ktÃ³ry dba tylko o wykonanie kodu, gdy wartoÅ›Ä‡ jest `Some`">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    match config_max {
        Some(max) =&gt; println!("Maksymalna wartoÅ›Ä‡ skonfigurowana to {max}"),
        _ =&gt; (),
    }
<span class="boring">}</span></code></pre>
</listing>
<p>JeÅ›li wartoÅ›Ä‡ jest <code>Some</code>, drukujemy wartoÅ›Ä‡ z wariantu <code>Some</code>, wiÄ…Å¼Ä…c jÄ… ze zmiennÄ… <code>max</code> we wzorcu. Nie chcemy nic robiÄ‡ z wartoÅ›ciÄ… <code>None</code>. Aby speÅ‚niÄ‡ wyraÅ¼enie <code>match</code>, musimy dodaÄ‡ <code>_ =&gt; ()</code> po przetworzeniu tylko jednego wariantu, co jest irytujÄ…cym, powtarzalnym kodem do dodania.</p>
<p>Zamiast tego, moglibyÅ›my to napisaÄ‡ w krÃ³tszy sposÃ³b za pomocÄ… <code>if let</code>. PoniÅ¼szy kod zachowuje siÄ™ tak samo jak <code>match</code> w Listingu 6-6:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!("Maksymalna wartoÅ›Ä‡ skonfigurowana to {max}");
    }
<span class="boring">}</span></code></pre>
<p>SkÅ‚adnia <code>if let</code> przyjmuje wzorzec i wyraÅ¼enie oddzielone znakiem rÃ³wnoÅ›ci. DziaÅ‚a tak samo jak <code>match</code>, gdzie wyraÅ¼enie jest przekazywane do <code>match</code>, a wzorzec jest jego pierwszym ramieniem. W tym przypadku wzorzec to <code>Some(max)</code>, a <code>max</code> wiÄ…Å¼e siÄ™ z wartoÅ›ciÄ… wewnÄ…trz <code>Some</code>. MoÅ¼emy nastÄ™pnie uÅ¼yÄ‡ <code>max</code> w ciele bloku <code>if let</code> w ten sam sposÃ³b, w jaki uÅ¼yliÅ›my <code>max</code> w odpowiadajÄ…cym ramieniu <code>match</code>. Kod w bloku <code>if let</code> jest wykonywany tylko wtedy, gdy wartoÅ›Ä‡ pasuje do wzorca.</p>
<p>UÅ¼ywanie <code>if let</code> oznacza mniej pisania, mniej wciÄ™Ä‡ i mniej kodu szablonowego. Tracisz jednak wyczerpujÄ…ce sprawdzanie, ktÃ³re wymusza <code>match</code>, a ktÃ³re gwarantuje, Å¼e nie zapomnisz obsÅ‚uÅ¼yÄ‡ Å¼adnych przypadkÃ³w. WybÃ³r miÄ™dzy <code>match</code> a <code>if let</code> zaleÅ¼y od tego, co robisz w konkretnej sytuacji i czy zyskanie zwiÄ™zÅ‚oÅ›ci jest odpowiednim kompromisem za utratÄ™ wyczerpujÄ…cego sprawdzania.</p>
<p>Innymi sÅ‚owy, <code>if let</code> moÅ¼na traktowaÄ‡ jako skÅ‚adniÄ™ cukrowÄ… dla <code>match</code>, ktÃ³ra uruchamia kod, gdy wartoÅ›Ä‡ pasuje do jednego wzorca, a nastÄ™pnie ignoruje wszystkie inne wartoÅ›ci.</p>
<p>MoÅ¼emy doÅ‚Ä…czyÄ‡ <code>else</code> do <code>if let</code>. Blok kodu, ktÃ³ry towarzyszy <code>else</code>, jest taki sam jak blok kodu, ktÃ³ry towarzyszyÅ‚by przypadkowi <code>_</code> w wyraÅ¼eniu <code>match</code> rÃ³wnowaÅ¼nym <code>if let</code> i <code>else</code>. Przypomnij sobie definicjÄ™ enum <code>Coin</code> w Listingu 6-4, gdzie wariant <code>Quarter</code> zawieraÅ‚ rÃ³wnieÅ¼ wartoÅ›Ä‡ <code>UsState</code>. GdybyÅ›my chcieli zliczaÄ‡ wszystkie monety inne niÅ¼ Ä‡wierÄ‡dolarÃ³wki, jednoczeÅ›nie ogÅ‚aszajÄ…c stan Ä‡wierÄ‡dolarÃ³wek, moglibyÅ›my to zrobiÄ‡ za pomocÄ… wyraÅ¼enia <code>match</code>, tak jak to:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    match coin {
        Coin::Quarter(state) =&gt; println!("Moneta stanowa z {state:?}!"),
        _ =&gt; count += 1,
    }
<span class="boring">}</span></code></pre>
<p>Albo moglibyÅ›my uÅ¼yÄ‡ wyraÅ¼enia <code>if let</code> i <code>else</code>, w ten sposÃ³b:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!("Moneta stanowa z {state:?}!");
    } else {
        count += 1;
    }
<span class="boring">}</span></code></pre>
<h2 id="pozostawanie-na-szczÄ™Å›liwej-Å›cieÅ¼ce-z-letelse"><a class="header" href="#pozostawanie-na-szczÄ™Å›liwej-Å›cieÅ¼ce-z-letelse">Pozostawanie na â€szczÄ™Å›liwej Å›cieÅ¼ceâ€ z <code>let...else</code></a></h2>
<p>CzÄ™stym wzorcem jest wykonanie pewnego obliczenia, gdy wartoÅ›Ä‡ jest obecna, a w przeciwnym razie zwrÃ³cenie wartoÅ›ci domyÅ›lnej. KontynuujÄ…c nasz przykÅ‚ad monet z wartoÅ›ciÄ… <code>UsState</code>, gdybyÅ›my chcieli powiedzieÄ‡ coÅ› zabawnego w zaleÅ¼noÅ›ci od wieku stanu na monecie, moglibyÅ›my wprowadziÄ‡ metodÄ™ w <code>UsState</code> do sprawdzania wieku stanu, w ten sposÃ³b:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)] // abyÅ›my mogli za chwilÄ™ sprawdziÄ‡ stan
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span>impl UsState {
    fn existed_in(&amp;self, year: u16) -&gt; bool {
        match self {
            UsState::Alabama =&gt; year &gt;= 1819,
            UsState::Alaska =&gt; year &gt;= 1959,
            // -- snip --
        }
    }
}
<span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
</span><span class="boring">    if let Coin::Quarter(state) = coin {
</span><span class="boring">        if state.existed_in(1900) {
</span><span class="boring">            Some(format!("{state:?} jest doÅ›Ä‡ stare, jak na AmerykÄ™!"))
</span><span class="boring">        } else {
</span><span class="boring">            Some(format!("{state:?} jest stosunkowo nowe."))
</span><span class="boring">        }
</span><span class="boring">    } else {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>NastÄ™pnie, moglibyÅ›my uÅ¼yÄ‡ <code>if let</code>, aby dopasowaÄ‡ typ monety, wprowadzajÄ…c zmiennÄ… <code>state</code> w treÅ›ci warunku, jak w Listingu 6-7.</p>
<listing number="6-7" caption="Sprawdzanie, czy stan istniaÅ‚ w 1900 roku za pomocÄ… warunkÃ³w zagnieÅ¼dÅ¼onych w `if let`">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)] // abyÅ›my mogli za chwilÄ™ sprawdziÄ‡ stan
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UsState {
</span><span class="boring">    fn existed_in(&amp;self, year: u16) -&gt; bool {
</span><span class="boring">        match self {
</span><span class="boring">            UsState::Alabama =&gt; year &gt;= 1819,
</span><span class="boring">            UsState::Alaska =&gt; year &gt;= 1959,
</span><span class="boring">            // -- snip --
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
    if let Coin::Quarter(state) = coin {
        if state.existed_in(1900) {
            Some(format!("{state:?} jest doÅ›Ä‡ stare, jak na AmerykÄ™!"))
        } else {
            Some(format!("{state:?} jest stosunkowo nowe."))
        }
    } else {
        None
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</listing>
<p>To zaÅ‚atwia sprawÄ™, ale przenosi pracÄ™ do ciaÅ‚a instrukcji <code>if let</code>, a jeÅ›li praca do wykonania jest bardziej skomplikowana, trudno moÅ¼e byÄ‡ dokÅ‚adnie Å›ledziÄ‡, jak gaÅ‚Ä™zie najwyÅ¼szego poziomu siÄ™ ze sobÄ… Å‚Ä…czÄ…. MoglibyÅ›my rÃ³wnieÅ¼ wykorzystaÄ‡ fakt, Å¼e wyraÅ¼enia produkujÄ… wartoÅ›Ä‡, aby albo wyprodukowaÄ‡ <code>state</code> z <code>if let</code>, albo zwrÃ³ciÄ‡ wczeÅ›nie, jak w Listingu 6-8. (PodobnÄ… rzecz moÅ¼na by zrobiÄ‡ z <code>match</code>.)</p>
<listing number="6-8" caption="UÅ¼ywanie `if let` do produkcji wartoÅ›ci lub wczesnego powrotu">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)] // abyÅ›my mogli za chwilÄ™ sprawdziÄ‡ stan
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UsState {
</span><span class="boring">    fn existed_in(&amp;self, year: u16) -&gt; bool {
</span><span class="boring">        match self {
</span><span class="boring">            UsState::Alabama =&gt; year &gt;= 1819,
</span><span class="boring">            UsState::Alaska =&gt; year &gt;= 1959,
</span><span class="boring">            // -- snip --
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
    let state = if let Coin::Quarter(state) = coin {
        state
    } else {
        return None;
    };

    if state.existed_in(1900) {
        Some(format!("{state:?} jest doÅ›Ä‡ stare, jak na AmerykÄ™!"))
    } else {
        Some(format!("{state:?} jest stosunkowo nowe."))
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</listing>
<p>To jest w pewnym sensie trochÄ™ irytujÄ…ce! Jedna gaÅ‚Ä…Åº <code>if let</code> produkuje wartoÅ›Ä‡, a druga caÅ‚kowicie zwraca z funkcji.</p>
<p>Aby ten powszechny wzorzec byÅ‚ Å‚atwiejszy do wyraÅ¼enia, Rust posiada <code>let...else</code>. SkÅ‚adnia <code>let...else</code> przyjmuje wzorzec po lewej stronie i wyraÅ¼enie po prawej, bardzo podobnie do <code>if let</code>, ale nie ma gaÅ‚Ä™zi <code>if</code>, tylko gaÅ‚Ä…Åº <code>else</code>. JeÅ›li wzorzec pasuje, to wiÄ…Å¼e wartoÅ›Ä‡ ze wzorca w zewnÄ™trznym zasiÄ™gu. JeÅ›li wzorzec <em>nie</em> pasuje, program przechodzi do gaÅ‚Ä™zi <code>else</code>, ktÃ³ra musi zwrÃ³ciÄ‡ wartoÅ›Ä‡ z funkcji.</p>
<p>W Listingu 6-9 moÅ¼esz zobaczyÄ‡, jak wyglÄ…da Listing 6-8, gdy uÅ¼ywamy <code>let...else</code> zamiast <code>if let</code>.</p>
<listing number="6-9" caption="UÅ¼ywanie `let...else` do wyjaÅ›nienia przepÅ‚ywu przez funkcjÄ™">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)] // abyÅ›my mogli za chwilÄ™ sprawdziÄ‡ stan
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UsState {
</span><span class="boring">    fn existed_in(&amp;self, year: u16) -&gt; bool {
</span><span class="boring">        match self {
</span><span class="boring">            UsState::Alabama =&gt; year &gt;= 1819,
</span><span class="boring">            UsState::Alaska =&gt; year &gt;= 1959,
</span><span class="boring">            // -- snip --
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
    let Coin::Quarter(state) = coin else {
        return None;
    };

    if state.existed_in(1900) {
        Some(format!("{state:?} jest doÅ›Ä‡ stare, jak na AmerykÄ™!"))
    } else {
        Some(format!("{state:?} jest stosunkowo nowe."))
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</listing>
<p>ZauwaÅ¼, Å¼e w ten sposÃ³b pozostaje ona na â€szczÄ™Å›liwej Å›cieÅ¼ceâ€ w gÅ‚Ã³wnym ciele funkcji, bez znaczÄ…co rÃ³Å¼niÄ…cego siÄ™ przepÅ‚ywu sterowania dla dwÃ³ch gaÅ‚Ä™zi, tak jak to byÅ‚o w przypadku <code>if let</code>.</p>
<p>JeÅ›li znajdziesz siÄ™ w sytuacji, w ktÃ³rej logika Twojego programu jest zbyt rozwlekÅ‚a, aby wyraziÄ‡ jÄ… za pomocÄ… <code>match</code>, pamiÄ™taj, Å¼e <code>if let</code> i <code>let...else</code> rÃ³wnieÅ¼ sÄ… w Twojej skrzynce narzÄ™dziowej Rust.</p>
<h2 id="podsumowanie-5"><a class="header" href="#podsumowanie-5">Podsumowanie</a></h2>
<p>OmÃ³wiliÅ›my, jak uÅ¼ywaÄ‡ typÃ³w wyliczeniowych do tworzenia niestandardowych typÃ³w, ktÃ³re mogÄ… byÄ‡ jednym z zestawu wyliczonych wartoÅ›ci. PokazaliÅ›my, jak typ <code>Option&lt;T&gt;</code> z biblioteki standardowej pomaga uÅ¼ywaÄ‡ systemu typÃ³w do zapobiegania bÅ‚Ä™dom. Gdy wartoÅ›ci wyliczeniowe zawierajÄ… dane, moÅ¼esz uÅ¼yÄ‡ <code>match</code> lub <code>if let</code> do wyodrÄ™bnienia i uÅ¼ycia tych wartoÅ›ci, w zaleÅ¼noÅ›ci od liczby przypadkÃ³w, ktÃ³re musisz obsÅ‚uÅ¼yÄ‡.</p>
<p>Twoje programy w Rust mogÄ… teraz wyraÅ¼aÄ‡ koncepcje w Twojej dziedzinie za pomocÄ… struktur i typÃ³w wyliczeniowych. Tworzenie niestandardowych typÃ³w do uÅ¼ycia w Twoim API zapewnia bezpieczeÅ„stwo typÃ³w: kompilator upewni siÄ™, Å¼e Twoje funkcje otrzymujÄ… tylko wartoÅ›ci typu, ktÃ³rego oczekuje kaÅ¼da funkcja.</p>
<p>Aby zapewniÄ‡ uÅ¼ytkownikom dobrze zorganizowane API, ktÃ³re jest proste w uÅ¼yciu i eksponuje dokÅ‚adnie to, czego bÄ™dÄ… potrzebowaÄ‡, przejdÅºmy teraz do moduÅ‚Ã³w Rust.</p>
<div style="break-before: page; page-break-before: always;"></div>
<p><a id="managing-growing-projects-with-packages-crates-and-modules"></a></p>
<h1 id="pakiety-kapsuÅ‚y-crate-i-moduÅ‚y"><a class="header" href="#pakiety-kapsuÅ‚y-crate-i-moduÅ‚y">Pakiety, KapsuÅ‚y (Crate) i ModuÅ‚y</a></h1>
<p>W miarÄ™ pisania duÅ¼ych programÃ³w organizacja kodu staje siÄ™ coraz waÅ¼niejsza.GrupujÄ…c powiÄ…zane funkcjonalnoÅ›ci i oddzielajÄ…c kod o rÃ³Å¼nych cechach,wyjaÅ›nisz, gdzie znaleÅºÄ‡ kod implementujÄ…cy okreÅ›lonÄ… funkcjÄ™ i gdzieudaÄ‡ siÄ™, aby zmieniÄ‡ sposÃ³b dziaÅ‚ania funkcji.</p>
<p>Napisane do tej pory programy znajdowaÅ‚y siÄ™ w jednym module w jednym pliku. W miarÄ™ rozrastania siÄ™ projektu, kod powinien byÄ‡ dzielony na wiele moduÅ‚Ã³w, a nastÄ™pnie na wiele plikÃ³w. Pakiet moÅ¼e zawieraÄ‡ wiele kapsuÅ‚ binarnych i opcjonalnie jednÄ… kapsuÅ‚Ä™ bibliotecznÄ…. W miarÄ™ rozrastania siÄ™ pakietu, moÅ¼na wyodrÄ™bniÄ‡ jego czÄ™Å›ci do osobnych kapsuÅ‚, ktÃ³re stajÄ… siÄ™ zewnÄ™trznymi zaleÅ¼noÅ›ciami. Ten rozdziaÅ‚ obejmuje wszystkie te techniki. Dla bardzo duÅ¼ych projektÃ³w skÅ‚adajÄ…cych siÄ™ z zestawu powiÄ…zanych ze sobÄ… pakietÃ³w, ktÃ³re ewoluujÄ… razem, Cargo oferuje obszary robocze, ktÃ³re omÃ³wimy w sekcji <a href="#obszary-robocze-cargo-1">â€Obszary robocze Cargoâ€</a><!-- ignore --> w Rozdziale 14.</p>
<p>OmÃ³wimy rÃ³wnieÅ¼ hermetyzacjÄ™ szczegÃ³Å‚Ã³w implementacji, co pozwala na ponowne wykorzystanie kodu na wyÅ¼szym poziomie: po zaimplementowaniu operacji, inny kod moÅ¼e wywoÅ‚aÄ‡ twÃ³j kod za poÅ›rednictwem jego publicznego interfejsu, bez koniecznoÅ›ci znajomoÅ›ci dziaÅ‚ania implementacji. SposÃ³b, w jaki piszesz kod, okreÅ›la, ktÃ³re czÄ™Å›ci sÄ… publiczne do uÅ¼ytku przez inny kod, a ktÃ³re sÄ… prywatnymi szczegÃ³Å‚ami implementacji, ktÃ³re zastrzegasz sobie prawo do zmiany. Jest to kolejny sposÃ³b na ograniczenie iloÅ›ci szczegÃ³Å‚Ã³w, ktÃ³re musisz mieÄ‡ w gÅ‚owie.</p>
<p>PowiÄ…zanÄ… koncepcjÄ… jest zasiÄ™g: zagnieÅ¼dÅ¼ony kontekst, w ktÃ³rym pisany jest kod, ma zestaw nazw, ktÃ³re sÄ… zdefiniowane jako â€w zasiÄ™guâ€. Podczas czytania, pisania i kompilowania kodu, programiÅ›ci i kompilatory muszÄ… wiedzieÄ‡, czy dana nazwa w danym miejscu odnosi siÄ™ do zmiennej, funkcji, struktury, typu wyliczeniowego, moduÅ‚u, staÅ‚ej lub innego elementu i co ten element oznacza. MoÅ¼esz tworzyÄ‡ zasiÄ™gi i zmieniaÄ‡, ktÃ³re nazwy sÄ… w zasiÄ™gu lub poza nim. Nie moÅ¼esz mieÄ‡ dwÃ³ch elementÃ³w o tej samej nazwie w tym samym zasiÄ™gu; dostÄ™pne sÄ… narzÄ™dzia do rozwiÄ…zywania konfliktÃ³w nazw.</p>
<p>Rust ma szereg funkcji, ktÃ³re pozwalajÄ… zarzÄ…dzaÄ‡ organizacjÄ… kodu, w tym to, ktÃ³re szczegÃ³Å‚y sÄ… ujawniane, ktÃ³re sÄ… prywatne i jakie nazwy znajdujÄ… siÄ™ w kaÅ¼dym zasiÄ™gu w twoich programach. Te funkcje, czasami zbiorczo nazywane <em>systemem moduÅ‚Ã³w</em>, obejmujÄ…:</p>
<ul>
<li><strong>Pakiety</strong>: Funkcja Cargo, ktÃ³ra umoÅ¼liwia budowanie, testowanie i udostÄ™pnianie kapsuÅ‚ (crates)</li>
<li><strong>KapsuÅ‚y (Crates)</strong>: Drzewo moduÅ‚Ã³w, ktÃ³re produkuje bibliotekÄ™ lub plik wykonywalny</li>
<li><strong>ModuÅ‚y i <code>use</code></strong>: PozwalajÄ… kontrolowaÄ‡ organizacjÄ™, zasiÄ™g i prywatnoÅ›Ä‡ Å›cieÅ¼ek</li>
<li><strong>ÅšcieÅ¼ki</strong>: SposÃ³b nazywania elementu, takiego jak struktura, funkcja lub moduÅ‚</li>
</ul>
<p>W tym rozdziale omÃ³wimy wszystkie te funkcje, dowiemy siÄ™, jak ze sobÄ… wspÃ³Å‚dziaÅ‚ajÄ… i wyjaÅ›nimy, jak uÅ¼ywaÄ‡ ich do zarzÄ…dzania zasiÄ™giem. Na koniec powinieneÅ› mieÄ‡ solidne zrozumienie systemu moduÅ‚Ã³w i byÄ‡ w stanie pracowaÄ‡ z zasiÄ™gami jak profesjonalista!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pakiety-i-kapsuÅ‚y-crate-1"><a href="#pakiety-i-kapsuÅ‚y-crate-1" class="header">Pakiety i KapsuÅ‚y (Crate)</a></h1>
<h2 id="pakiety-i-kapsuÅ‚y-crate"><a class="header" href="#pakiety-i-kapsuÅ‚y-crate">Pakiety i KapsuÅ‚y (Crate)</a></h2>
<p>Pierwsze czÄ™Å›ci systemu moduÅ‚Ã³w, ktÃ³re omÃ³wimy, to pakiety i kapsuÅ‚y.</p>
<p><em>KapsuÅ‚a (crate)</em> to najmniejsza iloÅ›Ä‡ kodu, jakÄ… kompilator Rust rozwaÅ¼a w danym momencie. Nawet jeÅ›li uruchomisz <code>rustc</code> zamiast <code>cargo</code> i przekaÅ¼esz pojedynczy plik ÅºrÃ³dÅ‚owy (tak jak zrobiliÅ›my to w sekcji <a href="#rust-program-basics">â€Podstawy programu w Rustâ€</a><!-- ignore --> w Rozdziale 1), kompilator traktuje ten plik jako kapsuÅ‚Ä™. KapsuÅ‚y mogÄ… zawieraÄ‡ moduÅ‚y, a moduÅ‚y mogÄ… byÄ‡ zdefiniowane w innych plikach, ktÃ³re sÄ… kompilowane razem z kapsuÅ‚Ä…, jak zobaczymy w kolejnych sekcjach.</p>
<p>KapsuÅ‚a moÅ¼e wystÄ™powaÄ‡ w jednej z dwÃ³ch form: kapsuÅ‚a binarna lub kapsuÅ‚a biblioteczna. <em>KapsuÅ‚y binarne</em> to programy, ktÃ³re moÅ¼na skompilowaÄ‡ do pliku wykonywalnego, ktÃ³ry moÅ¼na uruchomiÄ‡, na przykÅ‚ad program wiersza poleceÅ„ lub serwer. KaÅ¼da z nich musi mieÄ‡ funkcjÄ™ o nazwie <code>main</code>, ktÃ³ra definiuje, co dzieje siÄ™, gdy plik wykonywalny jest uruchamiany. Wszystkie kapsuÅ‚y, ktÃ³re do tej pory utworzyliÅ›my, byÅ‚y kapsuÅ‚ami binarnymi.</p>
<p><em>KapsuÅ‚y biblioteczne</em> nie majÄ… funkcji <code>main</code> i nie kompilujÄ… siÄ™ do pliku wykonywalnego. Zamiast tego definiujÄ… funkcjonalnoÅ›Ä‡ przeznaczonÄ… do wspÃ³Å‚dzielenia z wieloma projektami. Na przykÅ‚ad, kapsuÅ‚a <code>rand</code>, ktÃ³rej uÅ¼yliÅ›my w <a href="#generating-a-random-number">Rozdziale 2</a><!-- ignore -->, zapewnia funkcjonalnoÅ›Ä‡ generowania liczb losowych. Przez wiÄ™kszoÅ›Ä‡ czasu, gdy Rustaceans mÃ³wiÄ… â€kapsuÅ‚aâ€, majÄ… na myÅ›li kapsuÅ‚Ä™ bibliotecznÄ…, i uÅ¼ywajÄ… â€kapsuÅ‚yâ€ zamiennie z ogÃ³lnÄ… koncepcjÄ… programistycznÄ… â€bibliotekaâ€.</p>
<p><em>Katalog gÅ‚Ã³wny kapsuÅ‚y (crate root)</em> to plik ÅºrÃ³dÅ‚owy, od ktÃ³rego kompilator Rust zaczyna i ktÃ³ry stanowi moduÅ‚ gÅ‚Ã³wny twojej kapsuÅ‚y (szczegÃ³Å‚owo wyjaÅ›nimy moduÅ‚y w sekcji <a href="#kontrola-zasiÄ™gu-i-prywatnoÅ›ci-za-pomocÄ…-moduÅ‚Ã³w-1">â€Kontrola zasiÄ™gu i prywatnoÅ›ci za pomocÄ… moduÅ‚Ã³wâ€</a><!-- ignore -->).</p>
<p><em>Pakiet</em> to zbiÃ³r jednej lub wiÄ™cej kapsuÅ‚ (crates), ktÃ³re zapewniajÄ… zestaw funkcjonalnoÅ›ci. Pakiet zawiera plik <em>Cargo.toml</em>, ktÃ³ry opisuje, jak zbudowaÄ‡ te kapsuÅ‚y. Cargo jest faktycznie pakietem, ktÃ³ry zawiera kapsuÅ‚Ä™ binarnÄ… dla narzÄ™dzia wiersza poleceÅ„, ktÃ³rego uÅ¼ywaÅ‚eÅ› do budowania swojego kodu. Pakiet Cargo zawiera rÃ³wnieÅ¼ kapsuÅ‚Ä™ bibliotecznÄ…, od ktÃ³rej zaleÅ¼y kapsuÅ‚a binarna. Inne projekty mogÄ… zaleÅ¼eÄ‡ od kapsuÅ‚y bibliotecznej Cargo, aby uÅ¼ywaÄ‡ tej samej logiki, ktÃ³rej uÅ¼ywa narzÄ™dzie wiersza poleceÅ„ Cargo.</p>
<p>Pakiet moÅ¼e zawieraÄ‡ dowolnÄ… liczbÄ™ kapsuÅ‚ binarnych, ale co najwyÅ¼ej jednÄ… kapsuÅ‚Ä™ bibliotecznÄ…. Pakiet musi zawieraÄ‡ co najmniej jednÄ… kapsuÅ‚Ä™, niezaleÅ¼nie od tego, czy jest to kapsuÅ‚a biblioteczna, czy binarna.</p>
<p>Przeanalizujmy, co dzieje siÄ™, gdy tworzymy pakiet. Najpierw wpisujemy polecenie <code>cargo new my-project</code>:</p>
<pre><code class="language-console">$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
<p>Po uruchomieniu <code>cargo new my-project</code> uÅ¼ywamy <code>ls</code>, aby zobaczyÄ‡, co Cargo tworzy. W katalogu <em>my-project</em> znajduje siÄ™ plik <em>Cargo.toml</em>, dajÄ…c nam pakiet. Jest teÅ¼ katalog <em>src</em>, ktÃ³ry zawiera <em>main.rs</em>. OtwÃ³rz <em>Cargo.toml</em> w swoim edytorze tekstu i zauwaÅ¼, Å¼e nie ma tam wzmianki o <em>src/main.rs</em>. Cargo przestrzega konwencji, Å¼e <em>src/main.rs</em> jest katalogiem gÅ‚Ã³wnym kapsuÅ‚y binarnej o tej samej nazwie co pakiet. Podobnie, Cargo wie, Å¼e jeÅ›li katalog pakietu zawiera <em>src/lib.rs</em>, pakiet zawiera kapsuÅ‚Ä™ bibliotecznÄ… o tej samej nazwie co pakiet, a <em>src/lib.rs</em> jest jej katalogiem gÅ‚Ã³wnym. Cargo przekazuje pliki katalogu gÅ‚Ã³wnego kapsuÅ‚y do <code>rustc</code> w celu zbudowania biblioteki lub pliku binarnego.</p>
<p>Tutaj mamy pakiet, ktÃ³ry zawiera tylko <em>src/main.rs</em>, co oznacza, Å¼e zawiera tylko kapsuÅ‚Ä™ binarnÄ… o nazwie <code>my-project</code>. JeÅ›li pakiet zawiera <em>src/main.rs</em> i <em>src/lib.rs</em>, ma dwie kapsuÅ‚y: binarnÄ… i bibliotecznÄ…, obie o tej samej nazwie co pakiet. Pakiet moÅ¼e mieÄ‡ wiele kapsuÅ‚ binarnych, umieszczajÄ…c pliki w katalogu <em>src/bin</em>: kaÅ¼dy plik bÄ™dzie osobnÄ… kapsuÅ‚Ä… binarnÄ….</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="kontrola-zasiÄ™gu-i-prywatnoÅ›ci-za-pomocÄ…-moduÅ‚Ã³w-1"><a href="#kontrola-zasiÄ™gu-i-prywatnoÅ›ci-za-pomocÄ…-moduÅ‚Ã³w-1" class="header">Kontrola zasiÄ™gu i prywatnoÅ›ci za pomocÄ… moduÅ‚Ã³w</a></h1>
<p><a id="defining-modules-to-control-scope-and-privacy"></a></p>
<h2 id="kontrola-zasiÄ™gu-i-prywatnoÅ›ci-za-pomocÄ…-moduÅ‚Ã³w"><a class="header" href="#kontrola-zasiÄ™gu-i-prywatnoÅ›ci-za-pomocÄ…-moduÅ‚Ã³w">Kontrola zasiÄ™gu i prywatnoÅ›ci za pomocÄ… moduÅ‚Ã³w</a></h2>
<p>W tej sekcji omÃ³wimy moduÅ‚y i inne czÄ™Å›ci systemu moduÅ‚Ã³w, a mianowicie <em>Å›cieÅ¼ki</em>, ktÃ³re pozwalajÄ… nadawaÄ‡ nazwy elementom; sÅ‚owo kluczowe <code>use</code>, ktÃ³re wprowadza Å›cieÅ¼kÄ™ do zasiÄ™gu; oraz sÅ‚owo kluczowe <code>pub</code>, aby uczyniÄ‡ elementy publicznymi. OmÃ³wimy rÃ³wnieÅ¼ sÅ‚owo kluczowe <code>as</code>, pakiety zewnÄ™trzne i operator glob.</p>
<h3 id="Å›ciÄ…gawka-z-moduÅ‚Ã³w"><a class="header" href="#Å›ciÄ…gawka-z-moduÅ‚Ã³w">ÅšciÄ…gawka z moduÅ‚Ã³w</a></h3>
<p>Zanim przejdziemy do szczegÃ³Å‚Ã³w moduÅ‚Ã³w i Å›cieÅ¼ek, przedstawiamy tutaj szybkie odniesienie do tego, jak dziaÅ‚ajÄ… moduÅ‚y, Å›cieÅ¼ki, sÅ‚owo kluczowe <code>use</code> i sÅ‚owo kluczowe <code>pub</code> w kompilatorze, oraz jak wiÄ™kszoÅ›Ä‡ programistÃ³w organizuje swÃ³j kod. Przejdziemy przez przykÅ‚ady kaÅ¼dej z tych reguÅ‚ w tym rozdziale, ale jest to Å›wietne miejsce, aby odwoÅ‚aÄ‡ siÄ™ do nich jako przypomnienie o tym, jak dziaÅ‚ajÄ… moduÅ‚y.</p>
<ul>
<li><strong>Zacznij od korzenia kapsuÅ‚y (crate root)</strong>: Podczas kompilowania kapsuÅ‚y, kompilator najpierw szuka kodu do skompilowania w pliku korzenia kapsuÅ‚y (zazwyczaj <em>src/lib.rs</em> dla kapsuÅ‚y bibliotecznej i <em>src/main.rs</em> dla kapsuÅ‚y binarnej).</li>
<li><strong>Deklarowanie moduÅ‚Ã³w</strong>: W pliku korzenia kapsuÅ‚y moÅ¼esz zadeklarowaÄ‡ nowe moduÅ‚y; powiedzmy, Å¼e deklarujesz moduÅ‚ â€gardenâ€ za pomocÄ… <code>mod garden;</code>. Kompilator bÄ™dzie szukaÅ‚ kodu moduÅ‚u w tych miejscach:
<ul>
<li>Wbudowane, w nawiasach klamrowych, ktÃ³re zastÄ™pujÄ… Å›rednik po <code>mod garden</code></li>
<li>W pliku <em>src/garden.rs</em></li>
<li>W pliku <em>src/garden/mod.rs</em></li>
</ul>
</li>
<li><strong>Deklarowanie podmoduÅ‚Ã³w</strong>: W dowolnym pliku innym niÅ¼ korzeÅ„ kapsuÅ‚y moÅ¼esz deklarowaÄ‡ podmoduÅ‚y. Na przykÅ‚ad, moÅ¼esz zadeklarowaÄ‡ <code>mod vegetables;</code> w <em>src/garden.rs</em>. Kompilator bÄ™dzie szukaÅ‚ kodu podmoduÅ‚u w katalogu nazwanym dla moduÅ‚u rodzicielskiego w tych miejscach:
<ul>
<li>Wbudowane, bezpoÅ›rednio po <code>mod vegetables</code>, w nawiasach klamrowych zamiast Å›rednika</li>
<li>W pliku <em>src/garden/vegetables.rs</em></li>
<li>W pliku <em>src/garden/vegetables/mod.rs</em></li>
</ul>
</li>
<li><strong>ÅšcieÅ¼ki do kodu w moduÅ‚ach</strong>: Gdy moduÅ‚ jest czÄ™Å›ciÄ… twojej kapsuÅ‚y, moÅ¼esz odwoÅ‚ywaÄ‡ siÄ™ do kodu w tym module z dowolnego innego miejsca w tej samej kapsule, o ile zasady prywatnoÅ›ci na to pozwalajÄ…, uÅ¼ywajÄ…c Å›cieÅ¼ki do kodu. Na przykÅ‚ad, typ <code>Asparagus</code> w module warzyw ogrodowych znajdowaÅ‚by siÄ™ pod <code>crate::garden::vegetables::Asparagus</code>.</li>
<li><strong>Prywatne vs publiczne</strong>: Kod w module jest domyÅ›lnie prywatny dla jego moduÅ‚Ã³w nadrzÄ™dnych. Aby moduÅ‚ byÅ‚ publiczny, zadeklaruj go za pomocÄ… <code>pub mod</code> zamiast <code>mod</code>. Aby elementy w publicznym module byÅ‚y rÃ³wnieÅ¼ publiczne, uÅ¼yj <code>pub</code> przed ich deklaracjami.</li>
<li><strong>SÅ‚owo kluczowe <code>use</code></strong>: W zasiÄ™gu, sÅ‚owo kluczowe <code>use</code> tworzy skrÃ³ty do elementÃ³w, aby zmniejszyÄ‡ powtarzanie dÅ‚ugich Å›cieÅ¼ek. W kaÅ¼dym zasiÄ™gu, ktÃ³ry moÅ¼e odwoÅ‚ywaÄ‡ siÄ™ do <code>crate::garden::vegetables::Asparagus</code>, moÅ¼esz utworzyÄ‡ skrÃ³t za pomocÄ… <code>use crate::garden::vegetables::Asparagus;</code>, a odtÄ…d musisz tylko napisaÄ‡ <code>Asparagus</code>, aby uÅ¼yÄ‡ tego typu w zasiÄ™gu.</li>
</ul>
<p>Tutaj tworzymy binarnÄ… kapsuÅ‚Ä™ o nazwie <code>backyard</code>, ktÃ³ra ilustruje te zasady. Katalog kapsuÅ‚y, rÃ³wnieÅ¼ nazwany <em>backyard</em>, zawiera nastÄ™pujÄ…ce pliki i katalogi:</p>
<pre><code class="language-text">backyard
â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â””â”€â”€ src
    â”œâ”€â”€ garden
    â”‚Â Â  â””â”€â”€ vegetables.rs
    â”œâ”€â”€ garden.rs
    â””â”€â”€ main.rs
</code></pre>
<p>Plik gÅ‚Ã³wny kapsuÅ‚y w tym przypadku to <em>src/main.rs</em>, i zawiera:</p>
<listing file-name="src/main.rs">
<pre><code class="language-rust noplayground ignore">use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!("RosnÄ™ {plant:?}!");
}</code></pre>
</listing>
<p>Linia <code>pub mod garden;</code> informuje kompilator, aby uwzglÄ™dniÅ‚ kod znajdujÄ…cy siÄ™ w pliku <em>src/garden.rs</em>, ktÃ³ry to plik zawiera:</p>
<listing file-name="src/garden.rs">
<pre><code class="language-rust noplayground ignore">pub mod vegetables;</code></pre>
</listing>
<p>Tutaj, <code>pub mod vegetables;</code> oznacza, Å¼e kod z <em>src/garden/vegetables.rs</em> rÃ³wnieÅ¼ jest wÅ‚Ä…czony. Ten kod to:</p>
<pre><code class="language-rust noplayground ignore">#[derive(Debug)]
pub struct Asparagus {}</code></pre>
<p>Teraz przejdÅºmy do szczegÃ³Å‚Ã³w tych zasad i pokaÅ¼my je w dziaÅ‚aniu!</p>
<h3 id="grupowanie-powiÄ…zanego-kodu-w-moduÅ‚ach"><a class="header" href="#grupowanie-powiÄ…zanego-kodu-w-moduÅ‚ach">Grupowanie powiÄ…zanego kodu w moduÅ‚ach</a></h3>
<p><em>ModuÅ‚y</em> pozwalajÄ… nam organizowaÄ‡ kod w ramach kapsuÅ‚y w celu zwiÄ™kszenia czytelnoÅ›ci i Å‚atwego ponownego uÅ¼ycia. ModuÅ‚y pozwalajÄ… nam rÃ³wnieÅ¼ kontrolowaÄ‡ <em>prywatnoÅ›Ä‡</em> elementÃ³w, poniewaÅ¼ kod w module jest domyÅ›lnie prywatny. Prywatne elementy to wewnÄ™trzne szczegÃ³Å‚y implementacji niedostÄ™pne do uÅ¼ytku zewnÄ™trznego. MoÅ¼emy zdecydowaÄ‡ siÄ™ na uczynienie moduÅ‚Ã³w i elementÃ³w w nich publicznymi, co udostÄ™pnia je, aby umoÅ¼liwiÄ‡ zewnÄ™trznemu kodowi ich uÅ¼ywanie i zaleÅ¼noÅ›Ä‡ od nich.</p>
<p>Na przykÅ‚ad, napiszmy bibliotekÄ™, ktÃ³ra zapewnia funkcjonalnoÅ›Ä‡ restauracji. Zdefiniujemy sygnatury funkcji, ale pozostawimy ich ciaÅ‚a puste, aby skoncentrowaÄ‡ siÄ™ na organizacji kodu, a nie na implementacji restauracji.</p>
<p>W branÅ¼y restauracyjnej niektÃ³re czÄ™Å›ci restauracji sÄ… nazywane â€front of houseâ€, a inne â€back of houseâ€. <em>Front of house</em> to miejsce, gdzie sÄ… klienci; obejmuje to miejsca, gdzie gospodarze sadzajÄ… klientÃ³w, kelnerzy przyjmujÄ… zamÃ³wienia i pÅ‚atnoÅ›ci, a barmani przygotowujÄ… napoje. <em>Back of house</em> to miejsce, gdzie szefowie kuchni i kucharze pracujÄ… w kuchni, zmywacze naczyÅ„ sprzÄ…tajÄ…, a menedÅ¼erowie wykonujÄ… prace administracyjne.</p>
<p>Aby ustrukturyzowaÄ‡ naszÄ… kapsuÅ‚Ä™ w ten sposÃ³b, moÅ¼emy zorganizowaÄ‡ jej funkcje w zagnieÅ¼dÅ¼one moduÅ‚y. UtwÃ³rz nowÄ… bibliotekÄ™ o nazwie <code>restaurant</code>, uruchamiajÄ…c <code>cargo new restaurant --lib</code>. NastÄ™pnie wprowadÅº kod z Listingu 7-1 do pliku <em>src/lib.rs</em>, aby zdefiniowaÄ‡ niektÃ³re moduÅ‚y i sygnatury funkcji; ten kod to sekcja â€front of houseâ€.</p>
<listing number="7-1" file-name="src/lib.rs" caption="ModuÅ‚ `front_of_house` zawierajÄ…cy inne moduÅ‚y, ktÃ³re nastÄ™pnie zawierajÄ… funkcje">
<pre><code class="language-rust noplayground">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}</code></pre>
</listing>
<p>Definiujemy moduÅ‚ za pomocÄ… sÅ‚owa kluczowego <code>mod</code>, a nastÄ™pnie nazwÄ™ moduÅ‚u (w tym przypadku <code>front_of_house</code>). CiaÅ‚o moduÅ‚u znajduje siÄ™ nastÄ™pnie w nawiasach klamrowych. WewnÄ…trz moduÅ‚Ã³w moÅ¼emy umieszczaÄ‡ inne moduÅ‚y, jak w tym przypadku moduÅ‚y <code>hosting</code> i <code>serving</code>. ModuÅ‚y mogÄ… rÃ³wnieÅ¼ zawieraÄ‡ definicje innych elementÃ³w, takich jak struktury, typy wyliczeniowe, staÅ‚e, cechy, oraz, jak w Listingu 7-1, funkcje.</p>
<p>UÅ¼ywajÄ…c moduÅ‚Ã³w, moÅ¼emy grupowaÄ‡ powiÄ…zane definicje i nazywaÄ‡ ich relacje. ProgramiÅ›ci korzystajÄ…cy z tego kodu mogÄ… nawigowaÄ‡ po kodzie na podstawie grup, zamiast czytaÄ‡ wszystkie definicje, co uÅ‚atwia im znalezienie odpowiednich definicji. ProgramiÅ›ci dodajÄ…cy nowÄ… funkcjonalnoÅ›Ä‡ do tego kodu wiedzieliby, gdzie umieÅ›ciÄ‡ kod, aby program pozostaÅ‚ uporzÄ…dkowany.</p>
<p>WczeÅ›niej wspomnieliÅ›my, Å¼e pliki <em>src/main.rs</em> i <em>src/lib.rs</em> nazywane sÄ… <em>katalogami gÅ‚Ã³wnymi kapsuÅ‚ (crate roots)</em>. Powodem ich nazwy jest to, Å¼e zawartoÅ›Ä‡ ktÃ³regokolwiek z tych dwÃ³ch plikÃ³w tworzy moduÅ‚ o nazwie <code>crate</code> w katalogu gÅ‚Ã³wnym struktury moduÅ‚Ã³w kapsuÅ‚y, znanego jako <em>drzewo moduÅ‚Ã³w</em>.</p>
<p>Listing 7-2 przedstawia drzewo moduÅ‚Ã³w dla struktury z Listingu 7-1.</p>
<listing number="7-2" caption="Drzewo moduÅ‚Ã³w dla kodu z Listingu 7-1">
<pre><code class="language-text">kapsuÅ‚a (crate)
 â””â”€â”€ front_of_house
     â”œâ”€â”€ hosting
     â”‚   â”œâ”€â”€ add_to_waitlist
     â”‚   â””â”€â”€ seat_at_table
     â””â”€â”€ serving
         â”œâ”€â”€ take_order
         â”œâ”€â”€ serve_order
         â””â”€â”€ take_payment
</code></pre>
</listing>
<p>To drzewo pokazuje, jak niektÃ³re moduÅ‚y zagnieÅ¼dÅ¼ajÄ… siÄ™ w innych moduÅ‚ach; na przykÅ‚ad, <code>hosting</code> zagnieÅ¼dÅ¼a siÄ™ w <code>front_of_house</code>. Drzewo pokazuje rÃ³wnieÅ¼, Å¼e niektÃ³re moduÅ‚y sÄ… <em>sÄ…siadami</em>, co oznacza, Å¼e sÄ… zdefiniowane w tym samym module; <code>hosting</code> i <code>serving</code> sÄ… sÄ…siadami zdefiniowanymi w <code>front_of_house</code>. JeÅ›li moduÅ‚ A jest zawarty w module B, mÃ³wimy, Å¼e moduÅ‚ A jest <em>dzieckiem</em> moduÅ‚u B, a moduÅ‚ B jest <em>rodzicem</em> moduÅ‚u A. ZauwaÅ¼, Å¼e caÅ‚e drzewo moduÅ‚Ã³w jest zakorzenione pod niejawnym moduÅ‚em o nazwie <code>crate</code>.</p>
<p>Drzewo moduÅ‚Ã³w moÅ¼e przypominaÄ‡ drzewo katalogÃ³w systemu plikÃ³w na Twoim komputerze; to bardzo trafne porÃ³wnanie! Podobnie jak katalogi w systemie plikÃ³w, uÅ¼ywasz moduÅ‚Ã³w do organizacji kodu. I podobnie jak pliki w katalogu, potrzebujemy sposobu na znalezienie naszych moduÅ‚Ã³w.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="Å›cieÅ¼ki-do-odwoÅ‚ywania-siÄ™-do-elementu-w-drzewie-moduÅ‚Ã³w-1"><a href="#Å›cieÅ¼ki-do-odwoÅ‚ywania-siÄ™-do-elementu-w-drzewie-moduÅ‚Ã³w-1" class="header">ÅšcieÅ¼ki do odwoÅ‚ywania siÄ™ do elementu w drzewie moduÅ‚Ã³w</a></h1>
<h2 id="Å›cieÅ¼ki-do-odwoÅ‚ywania-siÄ™-do-elementu-w-drzewie-moduÅ‚Ã³w"><a class="header" href="#Å›cieÅ¼ki-do-odwoÅ‚ywania-siÄ™-do-elementu-w-drzewie-moduÅ‚Ã³w">ÅšcieÅ¼ki do odwoÅ‚ywania siÄ™ do elementu w drzewie moduÅ‚Ã³w</a></h2>
<p>Aby wskazaÄ‡ Rustowi, gdzie znaleÅºÄ‡ element w drzewie moduÅ‚Ã³w, uÅ¼ywamy Å›cieÅ¼ki
w taki sam sposÃ³b, jak uÅ¼ywamy Å›cieÅ¼ki podczas nawigowania po systemie plikÃ³w.
Aby wywoÅ‚aÄ‡ funkcjÄ™, musimy znaÄ‡ jej Å›cieÅ¼kÄ™.</p>
<p>ÅšcieÅ¼ka moÅ¼e przyjmowaÄ‡ dwie formy:</p>
<ul>
<li><em>ÅšcieÅ¼ka absolutna</em> to peÅ‚na Å›cieÅ¼ka zaczynajÄ…ca siÄ™ od korzenia pakietu;
dla kodu z zewnÄ™trznego pakietu Å›cieÅ¼ka absolutna zaczyna siÄ™ od nazwy
pakietu, a dla kodu z bieÅ¼Ä…cego pakietu zaczyna siÄ™ od literaÅ‚u <code>crate</code>.</li>
<li><em>ÅšcieÅ¼ka wzglÄ™dna</em> zaczyna siÄ™ od bieÅ¼Ä…cego moduÅ‚u i uÅ¼ywa <code>self</code>, <code>super</code>
lub identyfikatora w bieÅ¼Ä…cym module.</li>
</ul>
<p>ZarÃ³wno Å›cieÅ¼ki absolutne, jak i wzglÄ™dne sÄ… poprzedzone jednym lub wiÄ™kszÄ…
liczbÄ… identyfikatorÃ³w oddzielonych podwÃ³jnymi dwukropkami (<code>::</code>).</p>
<p>WracajÄ…c do Listingu 7-1, powiedzmy, Å¼e chcemy wywoÅ‚aÄ‡ funkcjÄ™
<code>add_to_waitlist</code>. To samo, co zapytaÄ‡: Jaka jest Å›cieÅ¼ka do funkcji
<code>add_to_waitlist</code>? Listing 7-3 zawiera Listing 7-1 z usuniÄ™tymi niektÃ³rymi
moduÅ‚ami i funkcjami.</p>
<p>PokaÅ¼emy dwa sposoby wywoÅ‚ania funkcji <code>add_to_waitlist</code> z nowej funkcji,
<code>eat_at_restaurant</code>, zdefiniowanej w korzeniu pakietu. Te Å›cieÅ¼ki sÄ… poprawne,
ale pozostaje jeszcze jeden problem, ktÃ³ry uniemoÅ¼liwi kompilacjÄ™ tego
przykÅ‚adu w obecnej postaci. WyjaÅ›nimy dlaczego za chwilÄ™.</p>
<p>Funkcja <code>eat_at_restaurant</code> jest czÄ™Å›ciÄ… publicznego API naszego pakietu
bibliotecznego, dlatego oznaczamy jÄ… sÅ‚owem kluczowym <code>pub</code>. W sekcji
<a href="#exposing-paths-with-the-pub-keyword">â€UdostÄ™pnianie Å›cieÅ¼ek za pomocÄ… sÅ‚owa kluczowego
<code>pub</code>â€</a><!-- ignore --> omÃ³wimy <code>pub</code> bardziej szczegÃ³Å‚owo.</p>
<figure class="listing" id="listing-7-3">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // ÅšcieÅ¼ka absolutna
    crate::front_of_house::hosting::add_to_waitlist();

    // ÅšcieÅ¼ka wzglÄ™dna
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
<figcaption><a href="#listing-7-3">Listing 7-3</a>: WywoÅ‚ywanie funkcji <code>add_to_waitlist</code> za pomocÄ… Å›cieÅ¼ek absolutnych i wzglÄ™dnych</figcaption>
</figure>
<p>Za pierwszym razem, gdy wywoÅ‚ujemy funkcjÄ™ <code>add_to_waitlist</code> w
<code>eat_at_restaurant</code>, uÅ¼ywamy Å›cieÅ¼ki absolutnej. Funkcja <code>add_to_waitlist</code> jest
zdefiniowana w tym samym pakiecie co <code>eat_at_restaurant</code>, co oznacza, Å¼e moÅ¼emy
uÅ¼yÄ‡ sÅ‚owa kluczowego <code>crate</code> do rozpoczÄ™cia Å›cieÅ¼ki absolutnej. NastÄ™pnie
doÅ‚Ä…czamy kaÅ¼dy kolejny moduÅ‚, aÅ¼ dotrzemy do <code>add_to_waitlist</code>. MoÅ¼na sobie
wyobraziÄ‡ system plikÃ³w o tej samej strukturze: okreÅ›lilibyÅ›my Å›cieÅ¼kÄ™
<code>/front_of_house/hosting/add_to_waitlist</code>, aby uruchomiÄ‡ program
<code>add_to_waitlist</code>; uÅ¼ycie nazwy <code>crate</code> do rozpoczÄ™cia od korzenia pakietu jest
podobne do uÅ¼ycia <code>/</code> do rozpoczÄ™cia od korzenia systemu plikÃ³w w Twojej
shellu.</p>
<p>Za drugim razem, gdy wywoÅ‚ujemy <code>add_to_waitlist</code> w <code>eat_at_restaurant</code>,
uÅ¼ywamy Å›cieÅ¼ki wzglÄ™dnej. ÅšcieÅ¼ka zaczyna siÄ™ od <code>front_of_house</code>, nazwy
moduÅ‚u zdefiniowanego na tym samym poziomie drzewa moduÅ‚Ã³w co
<code>eat_at_restaurant</code>. Tutaj odpowiednikiem w systemie plikÃ³w byÅ‚aby Å›cieÅ¼ka
<code>front_of_house/hosting/add_to_waitlist</code>. RozpoczÄ™cie od nazwy moduÅ‚u oznacza,
Å¼e Å›cieÅ¼ka jest wzglÄ™dna.</p>
<p>WybÃ³r miÄ™dzy Å›cieÅ¼kÄ… wzglÄ™dnÄ… a absolutnÄ… to decyzja, ktÃ³rÄ… podejmiesz w
zaleÅ¼noÅ›ci od projektu i od tego, czy bardziej prawdopodobne jest, Å¼e bÄ™dziesz
przenosiÄ‡ kod definicji elementu oddzielnie od kodu, ktÃ³ry go uÅ¼ywa, czy teÅ¼
razem z nim. Na przykÅ‚ad, gdybyÅ›my przenieÅ›li moduÅ‚ <code>front_of_house</code> i funkcjÄ™
<code>eat_at_restaurant</code> do moduÅ‚u o nazwie <code>customer_experience</code>, musielibyÅ›my
zaktualizowaÄ‡ Å›cieÅ¼kÄ™ absolutnÄ… do <code>add_to_waitlist</code>, ale Å›cieÅ¼ka wzglÄ™dna
nadal byÅ‚aby prawidÅ‚owa. Jednak gdybyÅ›my przenieÅ›li funkcjÄ™
<code>eat_at_restaurant</code> oddzielnie do moduÅ‚u o nazwie <code>dining</code>, Å›cieÅ¼ka absolutna
do wywoÅ‚ania <code>add_to_waitlist</code> pozostaÅ‚aby taka sama, ale Å›cieÅ¼ka wzglÄ™dna
musiaÅ‚aby zostaÄ‡ zaktualizowana. OgÃ³lnie preferujemy okreÅ›lanie Å›cieÅ¼ek
absolutnych, poniewaÅ¼ bardziej prawdopodobne jest, Å¼e bÄ™dziemy chcieli
przenosiÄ‡ definicje kodu i wywoÅ‚ania elementÃ³w niezaleÅ¼nie od siebie.</p>
<p>SprÃ³bujmy skompilowaÄ‡ Listing 7-3 i dowiedzmy siÄ™, dlaczego jeszcze siÄ™ nie
skompiluje! BÅ‚Ä™dy, ktÃ³re otrzymujemy, sÄ… pokazane w Listingu 7-4.</p>
<figure class="listing" id="listing-7-4">
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
  |                            |
  |                            private module
  |
note: the module `hosting` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
   |                     |
   |                     private module
   |
note: the module `hosting` is defined here
  --&gt; src/lib.rs:2:5
   |
 2 |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
<figcaption><a href="#listing-7-4">Listing 7-4</a>: BÅ‚Ä™dy kompilatora podczas budowania kodu z Listingu 7-3</figcaption>
</figure>
<p>Komunikaty o bÅ‚Ä™dach mÃ³wiÄ…, Å¼e moduÅ‚ <code>hosting</code> jest prywatny. Innymi sÅ‚owy,
mamy poprawne Å›cieÅ¼ki do moduÅ‚u <code>hosting</code> i funkcji <code>add_to_waitlist</code>, ale
Rust nie pozwala nam ich uÅ¼ywaÄ‡, poniewaÅ¼ nie ma dostÄ™pu do prywatnych sekcji.
W Rust wszystkie elementy (funkcje, metody, struktury, wyliczenia, moduÅ‚y
i staÅ‚e) sÄ… domyÅ›lnie prywatne dla moduÅ‚Ã³w nadrzÄ™dnych. JeÅ›li chcesz
uczyniÄ‡ element, taki jak funkcja lub struktura, prywatnym, umieszczasz go
w module.</p>
<p>Elementy w module nadrzÄ™dnym nie mogÄ… uÅ¼ywaÄ‡ prywatnych elementÃ³w w moduÅ‚ach
podrzÄ™dnych, ale elementy w moduÅ‚ach podrzÄ™dnych mogÄ… uÅ¼ywaÄ‡ elementÃ³w w
moduÅ‚ach nadrzÄ™dnych. Dzieje siÄ™ tak, poniewaÅ¼ moduÅ‚y podrzÄ™dne opakowujÄ… i
ukrywajÄ… swoje szczegÃ³Å‚y implementacji, ale moduÅ‚y podrzÄ™dne mogÄ… widzieÄ‡
kontekst, w ktÃ³rym sÄ… zdefiniowane. Aby kontynuowaÄ‡ naszÄ… metaforÄ™, pomyÅ›l o
zasadach prywatnoÅ›ci jako o zapleczu restauracji: to, co siÄ™ tam dzieje, jest
prywatne dla klientÃ³w restauracji, ale menedÅ¼erowie biura mogÄ… widzieÄ‡ i robiÄ‡
wszystko w restauracji, ktÃ³rÄ… prowadzÄ….</p>
<p>Rust zdecydowaÅ‚, aby system moduÅ‚Ã³w dziaÅ‚aÅ‚ w ten sposÃ³b, aby domyÅ›lnie ukrywaÄ‡
wewnÄ™trzne szczegÃ³Å‚y implementacji. W ten sposÃ³b wiesz, ktÃ³re czÄ™Å›ci kodu
wewnÄ™trznego moÅ¼esz zmieniÄ‡ bez uszkadzania kodu zewnÄ™trznego. Jednak Rust
daje moÅ¼liwoÅ›Ä‡ udostÄ™pniania wewnÄ™trznych czÄ™Å›ci kodu moduÅ‚Ã³w podrzÄ™dnych
moduÅ‚om nadrzÄ™dnym za pomocÄ… sÅ‚owa kluczowego <code>pub</code>, aby uczyniÄ‡ element
publicznym.</p>
<h3 id="udostÄ™pnianie-Å›cieÅ¼ek-za-pomocÄ…-sÅ‚owa-kluczowego-pub"><a class="header" href="#udostÄ™pnianie-Å›cieÅ¼ek-za-pomocÄ…-sÅ‚owa-kluczowego-pub">UdostÄ™pnianie Å›cieÅ¼ek za pomocÄ… sÅ‚owa kluczowego <code>pub</code></a></h3>
<p>WrÃ³Ä‡my do bÅ‚Ä™du z Listingu 7-4, ktÃ³ry informowaÅ‚ nas, Å¼e moduÅ‚ <code>hosting</code> jest
prywatny. Chcemy, aby funkcja <code>eat_at_restaurant</code> w module nadrzÄ™dnym miaÅ‚a
dostÄ™p do funkcji <code>add_to_waitlist</code> w module potomnym, wiÄ™c oznaczamy moduÅ‚
<code>hosting</code> sÅ‚owem kluczowym <code>pub</code>, jak pokazano w Listingu 7-5.</p>
<figure class="listing" id="listing-7-5">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

// -- snip --
<span class="boring">pub fn eat_at_restaurant() {
</span><span class="boring">    // Absolute path
</span><span class="boring">    crate::front_of_house::hosting::add_to_waitlist();
</span><span class="boring">
</span><span class="boring">    // Relative path
</span><span class="boring">    front_of_house::hosting::add_to_waitlist();
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-7-5">Listing 7-5</a>: Deklarowanie moduÅ‚u <code>hosting</code> jako <code>pub</code> w celu uÅ¼ycia go z <code>eat_at_restaurant</code></figcaption>
</figure>
<p>Niestety, kod w Listingu 7-5 nadal skutkuje bÅ‚Ä™dami kompilatora, jak pokazano w
Listingu 7-6.</p>
<figure class="listing" id="listing-7-6">
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:10:37
   |
10 |     crate::front_of_house::hosting::add_to_waitlist();
   |                                     ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
 3 |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:13:30
   |
13 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
 3 |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
<figcaption><a href="#listing-7-6">Listing 7-6</a>: BÅ‚Ä™dy kompilatora podczas budowania kodu z Listingu 7-5</figcaption>
</figure>
<p>Co siÄ™ staÅ‚o? Dodanie sÅ‚owa kluczowego <code>pub</code> przed <code>mod hosting</code> sprawia, Å¼e
moduÅ‚ staje siÄ™ publiczny. DziÄ™ki tej zmianie, jeÅ›li mamy dostÄ™p do
<code>front_of_house</code>, moÅ¼emy uzyskaÄ‡ dostÄ™p do <code>hosting</code>. Ale <em>zawartoÅ›Ä‡</em> <code>hosting</code>
jest nadal prywatna; uczynienie moduÅ‚u publicznym nie sprawia, Å¼e jego
zawartoÅ›Ä‡ staje siÄ™ publiczna. SÅ‚owo kluczowe <code>pub</code> na module pozwala tylko
kodowi w jego moduÅ‚ach nadrzÄ™dnych odwoÅ‚ywaÄ‡ siÄ™ do niego, a nie uzyskiwaÄ‡
dostÄ™pu do jego wewnÄ™trznego kodu. PoniewaÅ¼ moduÅ‚y sÄ… kontenerami, nie moÅ¼emy
wiele zdziaÅ‚aÄ‡, jedynie upubliczniajÄ…c moduÅ‚; musimy pÃ³jÅ›Ä‡ dalej i
zdecydowaÄ‡ siÄ™ na upublicznienie jednego lub wiÄ™cej elementÃ³w w module.</p>
<p>BÅ‚Ä™dy w Listingu 7-6 mÃ³wiÄ…, Å¼e funkcja <code>add_to_waitlist</code> jest prywatna.
Zasady prywatnoÅ›ci dotyczÄ… rÃ³wnieÅ¼ struktur, wyliczeÅ„, funkcji i metod, a takÅ¼e
moduÅ‚Ã³w.</p>
<p>Upublicznijmy rÃ³wnieÅ¼ funkcjÄ™ <code>add_to_waitlist</code>, dodajÄ…c sÅ‚owo kluczowe <code>pub</code>
przed jej definicjÄ…, jak w Listingu 7-7.</p>
<figure class="listing" id="listing-7-7">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

// -- snip --
<span class="boring">pub fn eat_at_restaurant() {
</span><span class="boring">    // Absolute path
</span><span class="boring">    crate::front_of_house::hosting::add_to_waitlist();
</span><span class="boring">
</span><span class="boring">    // Relative path
</span><span class="boring">    front_of_house::hosting::add_to_waitlist();
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-7-7">Listing 7-7</a>: Dodanie sÅ‚owa kluczowego <code>pub</code> do <code>mod hosting</code> i <code>fn add_to_waitlist</code> pozwala nam wywoÅ‚aÄ‡ funkcjÄ™ z <code>eat_at_restaurant</code>.</figcaption>
</figure>
<p>Teraz kod siÄ™ skompiluje! Aby zobaczyÄ‡, dlaczego dodanie sÅ‚owa kluczowego <code>pub</code>
pozwala nam uÅ¼ywaÄ‡ tych Å›cieÅ¼ek w <code>eat_at_restaurant</code> w odniesieniu do zasad
prywatnoÅ›ci, spÃ³jrzmy na Å›cieÅ¼ki absolutne i wzglÄ™dne.</p>
<p>W Å›cieÅ¼ce absolutnej zaczynamy od <code>crate</code>, korzenia drzewa moduÅ‚Ã³w naszego
pakietu. ModuÅ‚ <code>front_of_house</code> jest zdefiniowany w korzeniu pakietu. ChociaÅ¼
<code>front_of_house</code> nie jest publiczny, poniewaÅ¼ funkcja <code>eat_at_restaurant</code> jest
zdefiniowana w tym samym module co <code>front_of_house</code> (czyli <code>eat_at_restaurant</code>
i <code>front_of_house</code> sÄ… rodzeÅ„stwem), moÅ¼emy odwoÅ‚ywaÄ‡ siÄ™ do <code>front_of_house</code>
z <code>eat_at_restaurant</code>. NastÄ™pny jest moduÅ‚ <code>hosting</code> oznaczony <code>pub</code>. Mamy
dostÄ™p do moduÅ‚u nadrzÄ™dnego <code>hosting</code>, wiÄ™c moÅ¼emy uzyskaÄ‡ dostÄ™p do
<code>hosting</code>. Na koniec, funkcja <code>add_to_waitlist</code> jest oznaczona <code>pub</code>, a my
mamy dostÄ™p do jej moduÅ‚u nadrzÄ™dnego, wiÄ™c to wywoÅ‚anie funkcji dziaÅ‚a!</p>
<p>W Å›cieÅ¼ce wzglÄ™dnej logika jest taka sama jak w Å›cieÅ¼ce absolutnej, z wyjÄ…tkiem
pierwszego kroku: zamiast zaczynaÄ‡ od korzenia pakietu, Å›cieÅ¼ka zaczyna siÄ™ od
<code>front_of_house</code>. ModuÅ‚ <code>front_of_house</code> jest zdefiniowany w tym samym module
co <code>eat_at_restaurant</code>, wiÄ™c Å›cieÅ¼ka wzglÄ™dna zaczynajÄ…ca siÄ™ od moduÅ‚u, w
ktÃ³rym zdefiniowano <code>eat_at_restaurant</code>, dziaÅ‚a. NastÄ™pnie, poniewaÅ¼ <code>hosting</code>
i <code>add_to_waitlist</code> sÄ… oznaczone jako <code>pub</code>, reszta Å›cieÅ¼ki dziaÅ‚a, a to
wywoÅ‚anie funkcji jest prawidÅ‚owe!</p>
<p>JeÅ›li planujesz udostÄ™pniÄ‡ swÃ³j pakiet biblioteczny, aby inne projekty mogÅ‚y
uÅ¼ywaÄ‡ Twojego kodu, TwÃ³j publiczny interfejs API jest TwojÄ… umowÄ… z
uÅ¼ytkownikami Twojego pakietu, ktÃ³ra okreÅ›la, w jaki sposÃ³b mogÄ… wchodziÄ‡ w
interakcje z Twoim kodem. Istnieje wiele kwestii zwiÄ…zanych z zarzÄ…dzaniem
zmianami w Twoim publicznym interfejsie API, aby uÅ‚atwiÄ‡ innym poleganie na
Twoim pakiecie. Te rozwaÅ¼ania wykraczajÄ… poza zakres tej ksiÄ…Å¼ki; jeÅ›li
interesuje CiÄ™ ten temat, zobacz <a href="https://rust-lang.github.io/api-guidelines/">Rust API Guidelines</a>.</p>
<section class="note" aria-role="note">
<h4 id="najlepsze-praktyki-dla-pakietÃ³w-z-binarnym-i-bibliotecznym"><a class="header" href="#najlepsze-praktyki-dla-pakietÃ³w-z-binarnym-i-bibliotecznym">Najlepsze praktyki dla pakietÃ³w z binarnym i bibliotecznym</a></h4>
<p>WspomnieliÅ›my, Å¼e pakiet moÅ¼e zawieraÄ‡ zarÃ³wno korzeÅ„ pakietu binarnego
<em>src/main.rs</em>, jak i korzeÅ„ pakietu bibliotecznego <em>src/lib.rs</em>, a oba
pakiety bÄ™dÄ… domyÅ›lnie miaÅ‚y nazwÄ™ pakietu. Zazwyczaj pakiety z takim
patternem, zawierajÄ…ce zarÃ³wno bibliotekÄ™, jak i pakiet binarny, bÄ™dÄ… miaÅ‚y
w pakiecie binarnym wystarczajÄ…co duÅ¼o kodu, aby uruchomiÄ‡ plik
wykonywalny, ktÃ³ry wywoÅ‚uje kod zdefiniowany w pakiecie bibliotecznym. Pozwala
to innym projektom korzystaÄ‡ z wiÄ™kszoÅ›ci funkcjonalnoÅ›ci, ktÃ³rÄ… pakiet
zapewnia, poniewaÅ¼ kod pakietu bibliotecznego moÅ¼e byÄ‡ wspÃ³Å‚dzielony.</p>
<p>Drzewo moduÅ‚Ã³w powinno byÄ‡ zdefiniowane w <em>src/lib.rs</em>. NastÄ™pnie wszelkie
publiczne elementy mogÄ… byÄ‡ uÅ¼ywane w pakiecie binarnym, zaczynajÄ…c Å›cieÅ¼ki od
nazwy pakietu. Pakiet binarny staje siÄ™ uÅ¼ytkownikiem pakietu bibliotecznego,
tak jak caÅ‚kowicie zewnÄ™trzny pakiet uÅ¼ywaÅ‚by pakietu bibliotecznego: moÅ¼e
uÅ¼ywaÄ‡ tylko publicznego API. Pomaga to zaprojektowaÄ‡ dobre API; jesteÅ› nie
tylko autorem, ale takÅ¼e klientem!</p>
<p>W <a href="#projekt-io-budowa-programu-wiersza-poleceÅ„">Rozdziale 12</a><!-- ignore --> zademonstrujemy tÄ™ praktykÄ™
organizacyjnÄ… za pomocÄ… programu wiersza poleceÅ„, ktÃ³ry bÄ™dzie zawieraÅ‚
zarÃ³wno pakiet binarny, jak i pakiet biblioteczny.</p>
</section>
<h3 id="rozpoczynanie-Å›cieÅ¼ek-wzglÄ™dnych-za-pomocÄ…-super"><a class="header" href="#rozpoczynanie-Å›cieÅ¼ek-wzglÄ™dnych-za-pomocÄ…-super">Rozpoczynanie Å›cieÅ¼ek wzglÄ™dnych za pomocÄ… <code>super</code></a></h3>
<p>MoÅ¼emy konstruowaÄ‡ Å›cieÅ¼ki wzglÄ™dne, ktÃ³re zaczynajÄ… siÄ™ w module nadrzÄ™dnym,
a nie w bieÅ¼Ä…cym module lub korzeniu pakietu, uÅ¼ywajÄ…c <code>super</code> na poczÄ…tku
Å›cieÅ¼ki. Jest to podobne do rozpoczynania Å›cieÅ¼ki systemu plikÃ³w skÅ‚adniÄ… <code>..</code>,
ktÃ³ra oznacza przejÅ›cie do katalogu nadrzÄ™dnego. UÅ¼ycie <code>super</code> pozwala nam
odwoÅ‚aÄ‡ siÄ™ do elementu, o ktÃ³rym wiemy, Å¼e znajduje siÄ™ w module nadrzÄ™dnym,
co moÅ¼e uÅ‚atwiÄ‡ reorganizacjÄ™ drzewa moduÅ‚Ã³w, gdy moduÅ‚ jest Å›ciÅ›le powiÄ…zany z
nadrzÄ™dnym, ale rodzic moÅ¼e zostaÄ‡ kiedyÅ› przeniesiony w inne miejsce w
drzewie moduÅ‚Ã³w.</p>
<p>RozwaÅ¼my kod w Listingu 7-8, ktÃ³ry modeluje sytuacjÄ™, w ktÃ³rej szef kuchni
poprawia nieprawidÅ‚owe zamÃ³wienie i osobiÅ›cie dostarcza je klientowi. Funkcja
<code>fix_incorrect_order</code> zdefiniowana w module <code>back_of_house</code> wywoÅ‚uje funkcjÄ™
<code>deliver_order</code> zdefiniowanÄ… w module nadrzÄ™dnym, okreÅ›lajÄ…c Å›cieÅ¼kÄ™ do
<code>deliver_order</code>, zaczynajÄ…c od <code>super</code>.</p>
<figure class="listing" id="listing-7-8">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground test_harness">fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}</code></pre>
<figcaption><a href="#listing-7-8">Listing 7-8</a>: WywoÅ‚ywanie funkcji za pomocÄ… Å›cieÅ¼ki wzglÄ™dnej zaczynajÄ…cej siÄ™ od <code>super</code></figcaption>
</figure>
<p>Funkcja <code>fix_incorrect_order</code> znajduje siÄ™ w module <code>back_of_house</code>, wiÄ™c
moÅ¼emy uÅ¼yÄ‡ <code>super</code>, aby przejÅ›Ä‡ do moduÅ‚u nadrzÄ™dnego <code>back_of_house</code>, ktÃ³ry
w tym przypadku jest <code>crate</code>, czyli korzeÅ„. StamtÄ…d szukamy <code>deliver_order</code>
i znajdujemy jÄ…. Sukces! UwaÅ¼amy, Å¼e moduÅ‚ <code>back_of_house</code> i funkcja
<code>deliver_order</code> prawdopodobnie pozostanÄ… w tej samej relacji do siebie i
zostanÄ… przeniesione razem, jeÅ›li zdecydujemy siÄ™ na reorganizacjÄ™ drzewa
moduÅ‚Ã³w pakietu. Dlatego uÅ¼yliÅ›my <code>super</code>, aby w przyszÅ‚oÅ›ci, w przypadku
przeniesienia tego kodu do innego moduÅ‚u, byÅ‚o mniej miejsc do aktualizacji
kodu.</p>
<h3 id="upublicznianie-struktur-i-wyliczeÅ„"><a class="header" href="#upublicznianie-struktur-i-wyliczeÅ„">Upublicznianie struktur i wyliczeÅ„</a></h3>
<p>MoÅ¼emy rÃ³wnieÅ¼ uÅ¼yÄ‡ <code>pub</code> do oznaczenia struktur i wyliczeÅ„ jako publicznych,
ale istnieje kilka dodatkowych szczegÃ³Å‚Ã³w dotyczÄ…cych uÅ¼ycia <code>pub</code> ze
strukturami i wyliczeniami. JeÅ›li uÅ¼yjemy <code>pub</code> przed definicjÄ… struktury,
uczynimy jÄ… publicznÄ…, ale pola struktury nadal bÄ™dÄ… prywatne. MoÅ¼emy
uczyniÄ‡ kaÅ¼de pole publicznym lub nie, w zaleÅ¼noÅ›ci od przypadku. W Listingu
7-9 zdefiniowaliÅ›my publicznÄ… strukturÄ™ <code>back_of_house::Breakfast</code> z
publicznym polem <code>toast</code>, ale prywatnym polem <code>seasonal_fruit</code>. To
modeluje sytuacjÄ™ w restauracji, gdzie klient moÅ¼e wybraÄ‡ rodzaj pieczywa,
ktÃ³re jest podawane do posiÅ‚ku, ale szef kuchni decyduje, jakie owoce
towarzyszÄ… posiÅ‚kowi, w zaleÅ¼noÅ›ci od sezonu i dostÄ™pnoÅ›ci w magazynie.
DostÄ™pne owoce szybko siÄ™ zmieniajÄ…, wiÄ™c klienci nie mogÄ… wybieraÄ‡ owocÃ³w
ani nawet widzieÄ‡, jakie owoce otrzymajÄ….</p>
<figure class="listing" id="listing-7-9">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // ZamÃ³w Å›niadanie latem z tostami Å¼ytnimi.
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Zmieniamy zdanie co do rodzaju pieczywa.
    meal.toast = String::from("Wheat");
    println!("PoproszÄ™ tost {} ", meal.toast);

    // NastÄ™pna linia siÄ™ nie skompiluje, jeÅ›li jÄ… odkomentujemy; nie moÅ¼emy
    // zobaczyÄ‡ ani modyfikowaÄ‡ sezonowych owocÃ³w, ktÃ³re sÄ… podawane do posiÅ‚ku.
    // meal.seasonal_fruit = String::from("blueberries");
}</code></pre>
<figcaption><a href="#listing-7-9">Listing 7-9</a>: Struktura z niektÃ³rymi publicznymi i niektÃ³rymi prywatnymi polami</figcaption>
</figure>
<p>PoniewaÅ¼ pole <code>toast</code> w strukturze <code>back_of_house::Breakfast</code> jest publiczne,
w <code>eat_at_restaurant</code> moÅ¼emy zapisywaÄ‡ i odczytywaÄ‡ do pola <code>toast</code> uÅ¼ywajÄ…c
notacji kropkowej. ZauwaÅ¼, Å¼e nie moÅ¼emy uÅ¼yÄ‡ pola <code>seasonal_fruit</code> w
<code>eat_at_restaurant</code>, poniewaÅ¼ <code>seasonal_fruit</code> jest prywatne. SprÃ³buj
odkomentowaÄ‡ liniÄ™ modyfikujÄ…cÄ… wartoÅ›Ä‡ pola <code>seasonal_fruit</code>, aby zobaczyÄ‡,
jaki bÅ‚Ä…d otrzymasz!</p>
<p>NaleÅ¼y rÃ³wnieÅ¼ zauwaÅ¼yÄ‡, Å¼e poniewaÅ¼ <code>back_of_house::Breakfast</code> ma prywatne
pole, struktura musi udostÄ™pniaÄ‡ publicznÄ… funkcjÄ™ skojarzonÄ…, ktÃ³ra
konstruuje instancjÄ™ <code>Breakfast</code> (nazwaliÅ›my jÄ… tutaj <code>summer</code>). Gdyby
<code>Breakfast</code> nie miaÅ‚a takiej funkcji, nie moglibyÅ›my utworzyÄ‡ instancji
<code>Breakfast</code> w <code>eat_at_restaurant</code>, poniewaÅ¼ nie moglibyÅ›my ustawiÄ‡ wartoÅ›ci
prywatnego pola <code>seasonal_fruit</code> w <code>eat_at_restaurant</code>.</p>
<p>W przeciwieÅ„stwie do tego, jeÅ›li upublicznimy wyliczenie, wszystkie jego
warianty stajÄ… siÄ™ publiczne. Potrzebujemy tylko <code>pub</code> przed sÅ‚owem kluczowym
<code>enum</code>, jak pokazano w Listingu 7-10.</p>
<figure class="listing" id="listing-7-10">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}</code></pre>
<figcaption><a href="#listing-7-10">Listing 7-10</a>: Upublicznienie wyliczenia sprawia, Å¼e wszystkie jego warianty stajÄ… siÄ™ publiczne.</figcaption>
</figure>
<p>PoniewaÅ¼ upubliczniliÅ›my wyliczenie <code>Appetizer</code>, moÅ¼emy uÅ¼ywaÄ‡ wariantÃ³w <code>Soup</code>
i <code>Salad</code> w <code>eat_at_restaurant</code>.</p>
<p>Wyliczenia nie sÄ… zbyt uÅ¼yteczne, chyba Å¼e ich warianty sÄ… publiczne; byÅ‚oby
uciÄ…Å¼liwe, gdybyÅ›my musieli annotowaÄ‡ wszystkie warianty wyliczeÅ„ za pomocÄ…
<code>pub</code> w kaÅ¼dym przypadku, dlatego domyÅ›lnie warianty wyliczeÅ„ sÄ… publiczne.
Struktury sÄ… czÄ™sto uÅ¼yteczne bez publicznych pÃ³l, wiÄ™c pola struktur
podlegajÄ… ogÃ³lnej zasadzie, Å¼e wszystko jest domyÅ›lnie prywatne, chyba Å¼e jest
anotowane za pomocÄ… <code>pub</code>.</p>
<p>Istnieje jeszcze jedna sytuacja zwiÄ…zana z <code>pub</code>, ktÃ³rej nie omÃ³wiliÅ›my, i jest
to nasza ostatnia funkcja systemu moduÅ‚Ã³w: sÅ‚owo kluczowe <code>use</code>. Najpierw
omÃ³wimy <code>use</code> samo w sobie, a nastÄ™pnie pokaÅ¼emy, jak Å‚Ä…czyÄ‡ <code>pub</code> i <code>use</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wprowadzanie-Å›cieÅ¼ek-do-zasiÄ™gu-za-pomocÄ…-sÅ‚owa-kluczowego-use-1"><a href="#wprowadzanie-Å›cieÅ¼ek-do-zasiÄ™gu-za-pomocÄ…-sÅ‚owa-kluczowego-use-1" class="header">Wprowadzanie Å›cieÅ¼ek do zasiÄ™gu za pomocÄ… sÅ‚owa kluczowego use</a></h1>
<h2 id="wprowadzanie-Å›cieÅ¼ek-do-zasiÄ™gu-za-pomocÄ…-sÅ‚owa-kluczowego-use"><a class="header" href="#wprowadzanie-Å›cieÅ¼ek-do-zasiÄ™gu-za-pomocÄ…-sÅ‚owa-kluczowego-use">Wprowadzanie Å›cieÅ¼ek do zasiÄ™gu za pomocÄ… sÅ‚owa kluczowego <code>use</code></a></h2>
<p>KoniecznoÅ›Ä‡ wypisywania peÅ‚nych Å›cieÅ¼ek do wywoÅ‚ywania funkcji moÅ¼e byÄ‡ uciÄ…Å¼liwa i powtarzalna. W Listing 7-7, niezaleÅ¼nie od tego, czy wybraliÅ›my Å›cieÅ¼kÄ™ absolutnÄ…, czy wzglÄ™dnÄ… do funkcji <code>add_to_waitlist</code>, za kaÅ¼dym razem, gdy chcieliÅ›my wywoÅ‚aÄ‡ <code>add_to_waitlist</code>, musieliÅ›my rÃ³wnieÅ¼ okreÅ›laÄ‡ <code>front_of_house</code> i <code>hosting</code>. Na szczÄ™Å›cie istnieje sposÃ³b na uproszczenie tego procesu: MoÅ¼emy utworzyÄ‡ skrÃ³t do Å›cieÅ¼ki za pomocÄ… sÅ‚owa kluczowego <code>use</code> raz, a nastÄ™pnie uÅ¼ywaÄ‡ krÃ³tszej nazwy wszÄ™dzie indziej w danym zasiÄ™gu.</p>
<p>W Listing 7-11 wprowadzamy moduÅ‚ <code>crate::front_of_house::hosting</code> do zasiÄ™gu funkcji <code>eat_at_restaurant</code>, tak abyÅ›my musieli okreÅ›laÄ‡ jedynie <code>hosting::add_to_waitlist</code>, aby wywoÅ‚aÄ‡ funkcjÄ™ <code>add_to_waitlist</code> w <code>eat_at_restaurant</code>.</p>
<listing number="7-11" file-name="src/lib.rs" caption="Wprowadzanie moduÅ‚u do zasiÄ™gu za pomocÄ… `use`">
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
</listing>
<p>Dodanie <code>use</code> i Å›cieÅ¼ki w zasiÄ™gu jest podobne do tworzenia dowiÄ…zania symbolicznego w systemie plikÃ³w. DodajÄ…c <code>use crate::front_of_house::hosting</code> w katalogu gÅ‚Ã³wnym skrzynki, <code>hosting</code> jest teraz prawidÅ‚owÄ… nazwÄ… w tym zasiÄ™gu, tak jakby moduÅ‚ <code>hosting</code> zostaÅ‚ zdefiniowany w katalogu gÅ‚Ã³wnym skrzynki. ÅšcieÅ¼ki wprowadzone do zasiÄ™gu za pomocÄ… <code>use</code> rÃ³wnieÅ¼ sprawdzajÄ… prywatnoÅ›Ä‡, tak jak kaÅ¼da inna Å›cieÅ¼ka.</p>
<p>ZwrÃ³Ä‡ uwagÄ™, Å¼e <code>use</code> tworzy skrÃ³t tylko dla konkretnego zasiÄ™gu, w ktÃ³rym wystÄ™puje <code>use</code>. Listing 7-12 przenosi funkcjÄ™ <code>eat_at_restaurant</code> do nowego moduÅ‚u potomnego o nazwie <code>customer</code>, ktÃ³ry jest wÃ³wczas innym zasiÄ™giem niÅ¼ instrukcja <code>use</code>, wiÄ™c ciaÅ‚o funkcji nie skompiluje siÄ™.</p>
<listing number="7-12" file-name="src/lib.rs" caption="Instrukcja `use` ma zastosowanie tylko w zasiÄ™gu, w ktÃ³rym siÄ™ znajduje.">
<pre><code class="language-rust noplayground test_harness does_not_compile ignore">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}</code></pre>
</listing>
<p>BÅ‚Ä…d kompilatora pokazuje, Å¼e skrÃ³t nie ma juÅ¼ zastosowania w module <code>customer</code>:</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `hosting`
  --&gt; src/lib.rs:11:9
   |
11 |         hosting::add_to_waitlist();
   |         ^^^^^^^ use of unresolved module or unlinked crate `hosting`
   |
   = help: if you wanted to use a crate named `hosting`, use `cargo add hosting` to add it to your `Cargo.toml`
help: consider importing this module through its public re-export
   |
10 +     use crate::hosting;
   |

warning: unused import: `crate::front_of_house::hosting`
 --&gt; src/lib.rs:7:5
  |
7 | use crate::front_of_house::hosting;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

For more information about this error, try `rustc --explain E0433`.
warning: `restaurant` (lib) generated 1 warning
error: could not compile `restaurant` (lib) due to 1 previous error; 1 warning emitted
</code></pre>
<p>ZauwaÅ¼, Å¼e pojawiÅ‚o siÄ™ rÃ³wnieÅ¼ ostrzeÅ¼enie, Å¼e <code>use</code> nie jest juÅ¼ uÅ¼ywane w swoim zasiÄ™gu! Aby rozwiÄ…zaÄ‡ ten problem, przenieÅ› <code>use</code> rÃ³wnieÅ¼ do moduÅ‚u <code>customer</code> lub odwoÅ‚aj siÄ™ do skrÃ³tu w module nadrzÄ™dnym za pomocÄ… <code>super::hosting</code> w module potomnym <code>customer</code>.</p>
<h3 id="tworzenie-idiomatycznych-Å›cieÅ¼ek-use"><a class="header" href="#tworzenie-idiomatycznych-Å›cieÅ¼ek-use">Tworzenie idiomatycznych Å›cieÅ¼ek <code>use</code></a></h3>
<p>W Listing 7-11 mogÅ‚eÅ› siÄ™ zastanawiaÄ‡, dlaczego okreÅ›liliÅ›my <code>use crate::front_of_house::hosting</code>, a nastÄ™pnie wywoÅ‚aliÅ›my <code>hosting::add_to_waitlist</code> w <code>eat_at_restaurant</code>, zamiast okreÅ›laÄ‡ Å›cieÅ¼kÄ™ <code>use</code> aÅ¼ do funkcji <code>add_to_waitlist</code>, aby osiÄ…gnÄ…Ä‡ ten sam rezultat, jak w Listing 7-13.</p>
<listing number="7-13" file-name="src/lib.rs" caption="Wprowadzanie funkcji `add_to_waitlist` do zasiÄ™gu za pomocÄ… `use`, co jest nieidiomatyczne">
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}</code></pre>
</listing>
<p>ChociaÅ¼ zarÃ³wno Listing 7-11, jak i Listing 7-13 wykonujÄ… to samo zadanie, Listing 7-11 jest idiomatycznym sposobem wprowadzania funkcji do zasiÄ™gu za pomocÄ… <code>use</code>. Wprowadzenie moduÅ‚u nadrzÄ™dnego funkcji do zasiÄ™gu za pomocÄ… <code>use</code> oznacza, Å¼e musimy okreÅ›liÄ‡ moduÅ‚ nadrzÄ™dny podczas wywoÅ‚ywania funkcji. OkreÅ›lanie moduÅ‚u nadrzÄ™dnego podczas wywoÅ‚ywania funkcji jasno informuje, Å¼e funkcja nie jest zdefiniowana lokalnie, jednoczeÅ›nie minimalizujÄ…c powtarzanie peÅ‚nej Å›cieÅ¼ki. Kod w Listing 7-13 niejasno okreÅ›la, gdzie zdefiniowano <code>add_to_waitlist</code>.</p>
<p>Z drugiej strony, podczas wprowadzania struktur, wyliczeÅ„ i innych elementÃ³w za pomocÄ… <code>use</code>, idiomatyczne jest okreÅ›lanie peÅ‚nej Å›cieÅ¼ki. Listing 7-14 pokazuje idiomatyczny sposÃ³b wprowadzania struktury <code>HashMap</code> ze standardowej biblioteki do zasiÄ™gu skrzynki binarnej.</p>
<listing number="7-14" file-name="src/main.rs" caption="Idiomatyczne wprowadzanie `HashMap` do zasiÄ™gu">
<pre class="playground"><code class="language-rust edition2024">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}</code></pre>
</listing>
<p>Nie ma mocnego powodu, dla ktÃ³rego ten idiom: to po prostu konwencja, ktÃ³ra siÄ™ wyksztaÅ‚ciÅ‚a, a ludzie przyzwyczaili siÄ™ do czytania i pisania kodu w Rust w ten sposÃ³b.</p>
<p>WyjÄ…tkiem od tego idiomu jest sytuacja, gdy wprowadzamy dwa elementy o tej samej nazwie do zasiÄ™gu za pomocÄ… instrukcji <code>use</code>, poniewaÅ¼ Rust na to nie pozwala. Listing 7-15 pokazuje, jak wprowadziÄ‡ dwa typy <code>Result</code> do zasiÄ™gu, ktÃ³re majÄ… tÄ™ samÄ… nazwÄ™, ale rÃ³Å¼ne moduÅ‚y nadrzÄ™dne, oraz jak siÄ™ do nich odwoÅ‚ywaÄ‡.</p>
<listing number="7-15" file-name="src/lib.rs" caption="Wprowadzanie dwÃ³ch typÃ³w o tej samej nazwie do tego samego zasiÄ™gu wymaga uÅ¼ycia ich moduÅ‚Ã³w nadrzÄ™dnych.">
<pre><code class="language-rust noplayground">use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}</code></pre>
</listing>
<p>Jak widaÄ‡, uÅ¼ycie moduÅ‚Ã³w nadrzÄ™dnych odrÃ³Å¼nia dwa typy <code>Result</code>. GdybyÅ›my zamiast tego okreÅ›lili <code>use std::fmt::Result</code> i <code>use std::io::Result</code>, mielibyÅ›my dwa typy <code>Result</code> w tym samym zasiÄ™gu, a Rust nie wiedziaÅ‚by, o ktÃ³ry nam chodzi, gdybyÅ›my uÅ¼yli <code>Result</code>.</p>
<h3 id="nadawanie-nowych-nazw-za-pomocÄ…-sÅ‚owa-kluczowego-as"><a class="header" href="#nadawanie-nowych-nazw-za-pomocÄ…-sÅ‚owa-kluczowego-as">Nadawanie nowych nazw za pomocÄ… sÅ‚owa kluczowego <code>as</code></a></h3>
<p>Istnieje inne rozwiÄ…zanie problemu wprowadzania dwÃ³ch typÃ³w o tej samej nazwie do tego samego zasiÄ™gu za pomocÄ… <code>use</code>: Po Å›cieÅ¼ce moÅ¼emy okreÅ›liÄ‡ <code>as</code> i nowÄ… lokalnÄ… nazwÄ™, czyli <em>alias</em>, dla typu. Listing 7-16 pokazuje inny sposÃ³b napisania kodu z Listing 7-15 poprzez zmianÄ™ nazwy jednego z dwÃ³ch typÃ³w <code>Result</code> za pomocÄ… <code>as</code>.</p>
<listing number="7-16" file-name="src/lib.rs" caption="Zmiana nazwy typu po wprowadzeniu go do zasiÄ™gu za pomocÄ… sÅ‚owa kluczowego `as`">
<pre><code class="language-rust noplayground">use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}</code></pre>
</listing>
<p>W drugiej instrukcji <code>use</code> wybraliÅ›my nowÄ… nazwÄ™ <code>IoResult</code> dla typu <code>std::io::Result</code>, ktÃ³ra nie bÄ™dzie kolidowaÄ‡ z <code>Result</code> z <code>std::fmt</code>, ktÃ³ry rÃ³wnieÅ¼ wprowadziliÅ›my do zasiÄ™gu. Listing 7-15 i Listing 7-16 sÄ… uwaÅ¼ane za idiomatyczne, wiÄ™c wybÃ³r naleÅ¼y do Ciebie!</p>
<h3 id="ponowne-eksportowanie-nazw-za-pomocÄ…-pub-use"><a class="header" href="#ponowne-eksportowanie-nazw-za-pomocÄ…-pub-use">Ponowne eksportowanie nazw za pomocÄ… <code>pub use</code></a></h3>
<p>Kiedy wprowadzamy nazwÄ™ do zasiÄ™gu za pomocÄ… sÅ‚owa kluczowego <code>use</code>, nazwa jest prywatna dla zasiÄ™gu, do ktÃ³rego jÄ… zaimportowaliÅ›my. Aby umoÅ¼liwiÄ‡ kodowi spoza tego zasiÄ™gu odwoÅ‚ywanie siÄ™ do tej nazwy tak, jakby zostaÅ‚a zdefiniowana w tym zasiÄ™gu, moÅ¼emy poÅ‚Ä…czyÄ‡ <code>pub</code> i <code>use</code>. Ta technika nazywa siÄ™ <em>re-eksportowaniem</em>, poniewaÅ¼ wprowadzamy element do zasiÄ™gu, ale takÅ¼e udostÄ™pniamy ten element innym, aby mogli go wprowadziÄ‡ do swojego zasiÄ™gu.</p>
<p>Listing 7-17 pokazuje kod z Listing 7-11, w ktÃ³rym <code>use</code> w module gÅ‚Ã³wnym zostaÅ‚o zmienione na <code>pub use</code>.</p>
<listing number="7-17" file-name="src/lib.rs" caption="UdostÄ™pnianie nazwy dowolnemu kodowi z nowego zasiÄ™gu za pomocÄ… `pub use`">
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
</listing>
<p>Przed tÄ… zmianÄ…, kod zewnÄ™trzny musiaÅ‚by wywoÅ‚ywaÄ‡ funkcjÄ™ <code>add_to_waitlist</code> uÅ¼ywajÄ…c Å›cieÅ¼ki <code>restaurant::front_of_house::hosting::add_to_waitlist()</code>, co wymagaÅ‚oby rÃ³wnieÅ¼, aby moduÅ‚ <code>front_of_house</code> byÅ‚ oznaczony jako <code>pub</code>. Teraz, gdy <code>pub use</code> ponownie wyeksportowaÅ‚o moduÅ‚ <code>hosting</code> z moduÅ‚u gÅ‚Ã³wnego, kod zewnÄ™trzny moÅ¼e zamiast tego uÅ¼ywaÄ‡ Å›cieÅ¼ki <code>restaurant::hosting::add_to_waitlist()</code>.</p>
<p>Ponowny eksport jest przydatny, gdy wewnÄ™trzna struktura kodu rÃ³Å¼ni siÄ™ od sposobu, w jaki programiÅ›ci wywoÅ‚ujÄ…cy kod myÅ›leliby o domenie. Na przykÅ‚ad, w tej metaforze restauracji, osoby prowadzÄ…ce restauracjÄ™ myÅ›lÄ… o â€front of houseâ€ i â€back of houseâ€. Ale klienci odwiedzajÄ…cy restauracjÄ™ prawdopodobnie nie bÄ™dÄ… myÅ›leÄ‡ o czÄ™Å›ciach restauracji w tych kategoriach. DziÄ™ki <code>pub use</code> moÅ¼emy pisaÄ‡ kod o jednej strukturze, ale udostÄ™pniaÄ‡ innÄ… strukturÄ™. DziÄ™ki temu nasza biblioteka jest dobrze zorganizowana dla programistÃ³w pracujÄ…cych nad bibliotekÄ… i programistÃ³w wywoÅ‚ujÄ…cych bibliotekÄ™. Inny przykÅ‚ad <code>pub use</code> i jego wpÅ‚ywu na dokumentacjÄ™ skrzynki omÃ³wimy w rozdziale 14 w sekcji <a href="#exporting-a-convenient-public-api">â€Eksportowanie wygodnego publicznego APIâ€</a>.<!-- ignore --></p>
<h3 id="uÅ¼ywanie-pakietÃ³w-zewnÄ™trznych"><a class="header" href="#uÅ¼ywanie-pakietÃ³w-zewnÄ™trznych">UÅ¼ywanie pakietÃ³w zewnÄ™trznych</a></h3>
<p>W Rozdziale 2 programowaliÅ›my projekt gry zgadywanek, ktÃ³ry uÅ¼ywaÅ‚ zewnÄ™trznego pakietu <code>rand</code> do generowania liczb losowych. Aby uÅ¼yÄ‡ <code>rand</code> w naszym projekcie, dodaliÅ›my nastÄ™pujÄ…cÄ… liniÄ™ do <em>Cargo.toml</em>:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch14-03-cargo-workspaces.md
-->
<listing file-name="Cargo.toml">
<pre><code class="language-toml">rand = "0.8.5"
</code></pre>
</listing>
<p>Dodanie <code>rand</code> jako zaleÅ¼noÅ›ci w <em>Cargo.toml</em> informuje Cargo, aby pobraÅ‚ pakiet <code>rand</code> i wszystkie jego zaleÅ¼noÅ›ci z <a href="https://crates.io/">crates.io</a> i udostÄ™pniÅ‚ <code>rand</code> naszemu projektowi.</p>
<p>NastÄ™pnie, aby wprowadziÄ‡ definicje <code>rand</code> do zasiÄ™gu naszego pakietu, dodaliÅ›my liniÄ™ <code>use</code> zaczynajÄ…cÄ… siÄ™ od nazwy skrzynki, <code>rand</code>, i wymieniliÅ›my elementy, ktÃ³re chcieliÅ›my wprowadziÄ‡ do zasiÄ™gu. Przypomnij sobie, Å¼e w sekcji <a href="#generating-a-random-number">â€Generowanie liczby losowejâ€</a><!-- ignore --> w Rozdziale 2 wprowadziliÅ›my cechÄ™ <code>Rng</code> do zasiÄ™gu i wywoÅ‚aliÅ›my funkcjÄ™ <code>rand::thread_rng</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>use rand::Rng;

fn main() {
<span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span>    let secret_number = rand::thread_rng().gen_range(1..=100);
<span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span>}</code></pre>
<p>CzÅ‚onkowie spoÅ‚ecznoÅ›ci Rust udostÄ™pnili wiele pakietÃ³w na <a href="https://crates.io/">crates.io</a>, a wÅ‚Ä…czenie ktÃ³regokolwiek z nich do Twojego pakietu obejmuje te same kroki: wymienienie ich w pliku <em>Cargo.toml</em> Twojego pakietu i uÅ¼ycie <code>use</code> do wprowadzenia elementÃ³w z ich skrzynek do zasiÄ™gu.</p>
<p>ZauwaÅ¼, Å¼e standardowa biblioteka <code>std</code> jest rÃ³wnieÅ¼ skrzynkÄ… zewnÄ™trznÄ… dla naszego pakietu. PoniewaÅ¼ standardowa biblioteka jest dostarczana z jÄ™zykiem Rust, nie musimy zmieniaÄ‡ <em>Cargo.toml</em>, aby uwzglÄ™dniÄ‡ <code>std</code>. Musimy jednak odwoÅ‚aÄ‡ siÄ™ do niej za pomocÄ… <code>use</code>, aby wprowadziÄ‡ z niej elementy do zasiÄ™gu naszego pakietu. Na przykÅ‚ad, w przypadku <code>HashMap</code> uÅ¼ylibyÅ›my tej linii:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}</span></code></pre>
<p>Jest to Å›cieÅ¼ka absolutna zaczynajÄ…ca siÄ™ od <code>std</code>, nazwy skrzynki standardowej biblioteki.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="using-nested-paths-to-clean-up-large-use-lists"></a></p>
<h3 id="uÅ¼ywanie-zagnieÅ¼dÅ¼onych-Å›cieÅ¼ek-do-porzÄ…dkowania-list-use"><a class="header" href="#uÅ¼ywanie-zagnieÅ¼dÅ¼onych-Å›cieÅ¼ek-do-porzÄ…dkowania-list-use">UÅ¼ywanie zagnieÅ¼dÅ¼onych Å›cieÅ¼ek do porzÄ…dkowania list <code>use</code></a></h3>
<p>JeÅ›li uÅ¼ywamy wielu elementÃ³w zdefiniowanych w tej samej skrzynce lub tym samym module, wymienianie kaÅ¼dego elementu w osobnej linii moÅ¼e zajmowaÄ‡ duÅ¼o miejsca w naszych plikach. Na przykÅ‚ad, te dwie instrukcje <code>use</code> z gry zgadywanek w Listing 2-4 wprowadzajÄ… elementy z <code>std</code> do zasiÄ™gu:</p>
<listing file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">        Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">        Ordering::Equal =&gt; println!("You win!"),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</listing>
<p>Zamiast tego moÅ¼emy uÅ¼yÄ‡ zagnieÅ¼dÅ¼onych Å›cieÅ¼ek, aby wprowadziÄ‡ te same elementy do zasiÄ™gu w jednej linii. Robimy to, okreÅ›lajÄ…c wspÃ³lnÄ… czÄ™Å›Ä‡ Å›cieÅ¼ki, po ktÃ³rej nastÄ™pujÄ… dwa dwukropki, a nastÄ™pnie nawiasy klamrowe wokÃ³Å‚ listy czÄ™Å›ci Å›cieÅ¼ek, ktÃ³re siÄ™ rÃ³Å¼niÄ…, jak pokazano w Listing 7-18.</p>
<listing number="7-18" file-name="src/main.rs" caption="OkreÅ›lanie zagnieÅ¼dÅ¼onej Å›cieÅ¼ki w celu wprowadzenia wielu elementÃ³w z tym samym prefiksem do zasiÄ™gu">
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::{cmp::Ordering, io};
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Failed to read line");
</span><span class="boring">
</span><span class="boring">    let guess: u32 = guess.trim().parse().expect("Please type a number!");
</span><span class="boring">
</span><span class="boring">    println!("You guessed: {guess}");
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">        Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">        Ordering::Equal =&gt; println!("You win!"),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</listing>
<p>W wiÄ™kszych programach wprowadzanie wielu elementÃ³w do zasiÄ™gu z tej samej skrzynki lub moduÅ‚u za pomocÄ… zagnieÅ¼dÅ¼onych Å›cieÅ¼ek moÅ¼e znacznie zmniejszyÄ‡ liczbÄ™ oddzielnych instrukcji <code>use</code>!</p>
<p>MoÅ¼emy uÅ¼ywaÄ‡ zagnieÅ¼dÅ¼onych Å›cieÅ¼ek na dowolnym poziomie Å›cieÅ¼ki, co jest przydatne przy Å‚Ä…czeniu dwÃ³ch instrukcji <code>use</code>, ktÃ³re wspÃ³Å‚dzielÄ… podÅ›cieÅ¼kÄ™. Na przykÅ‚ad, Listing 7-19 pokazuje dwie instrukcje <code>use</code>: jedna, ktÃ³ra wprowadza <code>std::io</code> do zasiÄ™gu, i druga, ktÃ³ra wprowadza <code>std::io::Write</code> do zasiÄ™gu.</p>
<listing number="7-19" file-name="src/lib.rs" caption="Dwie instrukcje `use`, gdzie jedna jest podÅ›cieÅ¼kÄ… drugiej">
<pre><code class="language-rust noplayground">use std::io;
use std::io::Write;</code></pre>
</listing>
<p>WspÃ³lnÄ… czÄ™Å›ciÄ… tych dwÃ³ch Å›cieÅ¼ek jest <code>std::io</code>, i to jest kompletna pierwsza Å›cieÅ¼ka. Aby poÅ‚Ä…czyÄ‡ te dwie Å›cieÅ¼ki w jednÄ… instrukcjÄ™ <code>use</code>, moÅ¼emy uÅ¼yÄ‡ <code>self</code> w zagnieÅ¼dÅ¼onej Å›cieÅ¼ce, jak pokazano w Listing 7-20.</p>
<listing number="7-20" file-name="src/lib.rs" caption="ÅÄ…czenie Å›cieÅ¼ek z Listing 7-19 w jednÄ… instrukcjÄ™ `use`">
<pre><code class="language-rust noplayground">use std::io::{self, Write};</code></pre>
</listing>
<p>Ta linia wprowadza <code>std::io</code> i <code>std::io::Write</code> do zasiÄ™gu.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="the-glob-operator"></a></p>
<h3 id="importowanie-elementÃ³w-za-pomocÄ…-operatora-glob"><a class="header" href="#importowanie-elementÃ³w-za-pomocÄ…-operatora-glob">Importowanie elementÃ³w za pomocÄ… operatora glob</a></h3>
<p>JeÅ›li chcemy wprowadziÄ‡ <em>wszystkie</em> publiczne elementy zdefiniowane w Å›cieÅ¼ce do zasiÄ™gu, moÅ¼emy okreÅ›liÄ‡ tÄ™ Å›cieÅ¼kÄ™, po ktÃ³rej nastÄ™puje operator glob <code>*</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}</span></code></pre>
<p>Ta instrukcja <code>use</code> wprowadza wszystkie publiczne elementy zdefiniowane w <code>std::collections</code> do bieÅ¼Ä…cego zasiÄ™gu. Zachowaj ostroÅ¼noÅ›Ä‡ podczas uÅ¼ywania operatora glob! Glob moÅ¼e utrudniÄ‡ okreÅ›lenie, jakie nazwy sÄ… w zasiÄ™gu i gdzie nazwa uÅ¼yta w programie zostaÅ‚a zdefiniowana. Dodatkowo, jeÅ›li zaleÅ¼noÅ›Ä‡ zmieni swoje definicje, to co zostaÅ‚o zaimportowane, rÃ³wnieÅ¼ siÄ™ zmieni, co moÅ¼e prowadziÄ‡ do bÅ‚Ä™dÃ³w kompilatora podczas aktualizacji zaleÅ¼noÅ›ci, jeÅ›li zaleÅ¼noÅ›Ä‡ doda definicjÄ™ o tej samej nazwie co Twoja definicja w tym samym zasiÄ™gu, na przykÅ‚ad.</p>
<p>Operator glob jest czÄ™sto uÅ¼ywany podczas testowania, aby wprowadziÄ‡ wszystko, co jest testowane, do moduÅ‚u <code>tests</code>; omÃ³wimy to w sekcji <a href="#how-to-write-tests">â€Jak pisaÄ‡ testyâ€</a><!-- ignore --> w Rozdziale 11. Operator glob jest rÃ³wnieÅ¼ czasami uÅ¼ywany jako czÄ™Å›Ä‡ wzorca preludium: zobacz <a href="../std/prelude/index.html#other-preludes">dokumentacjÄ™ standardowej biblioteki</a><!-- ignore -->, aby uzyskaÄ‡ wiÄ™cej informacji na temat tego wzorca.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dzielenie-moduÅ‚Ã³w-na-rÃ³Å¼ne-pliki-1"><a href="#dzielenie-moduÅ‚Ã³w-na-rÃ³Å¼ne-pliki-1" class="header">Dzielenie moduÅ‚Ã³w na rÃ³Å¼ne pliki</a></h1>
<h2 id="dzielenie-moduÅ‚Ã³w-na-rÃ³Å¼ne-pliki"><a class="header" href="#dzielenie-moduÅ‚Ã³w-na-rÃ³Å¼ne-pliki">Dzielenie moduÅ‚Ã³w na rÃ³Å¼ne pliki</a></h2>
<p>Do tej pory wszystkie przykÅ‚ady w tym rozdziale definiowaÅ‚y wiele moduÅ‚Ã³w w jednym pliku. Kiedy moduÅ‚y stajÄ… siÄ™ duÅ¼e, moÅ¼esz chcieÄ‡ przenieÅ›Ä‡ ich definicje do oddzielnego pliku, aby uÅ‚atwiÄ‡ nawigacjÄ™ po kodzie.</p>
<p>Na przykÅ‚ad, zacznijmy od kodu z Listing 7-17, ktÃ³ry miaÅ‚ wiele moduÅ‚Ã³w restauracji. WyodrÄ™bnimy moduÅ‚y do plikÃ³w zamiast definiowaÄ‡ wszystkie moduÅ‚y w pliku gÅ‚Ã³wnym skrzynki. W tym przypadku plikiem gÅ‚Ã³wnym skrzynki jest <em>src/lib.rs</em>, ale ta procedura dziaÅ‚a rÃ³wnieÅ¼ w przypadku skrzynek binarnych, ktÃ³rych plikiem gÅ‚Ã³wnym skrzynki jest <em>src/main.rs</em>.</p>
<p>Najpierw wyodrÄ™bnimy moduÅ‚ <code>front_of_house</code> do jego wÅ‚asnego pliku. UsuÅ„ kod w nawiasach klamrowych dla moduÅ‚u <code>front_of_house</code>, pozostawiajÄ…c tylko deklaracjÄ™ <code>mod front_of_house;</code>, tak aby <em>src/lib.rs</em> zawieraÅ‚ kod pokazany w Listing 7-21. ZauwaÅ¼, Å¼e to nie skompiluje siÄ™, dopÃ³ki nie utworzymy pliku <em>src/front_of_house.rs</em> w Listing 7-22.</p>
<listing number="7-21" file-name="src/lib.rs" caption="Deklaracja moduÅ‚u `front_of_house`, ktÃ³rego ciaÅ‚o bÄ™dzie znajdowaÄ‡ siÄ™ w *src/front_of_house.rs*">
<pre><code class="language-rust ignore does_not_compile">mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
</listing>
<p>NastÄ™pnie umieÅ›Ä‡ kod, ktÃ³ry znajdowaÅ‚ siÄ™ w nawiasach klamrowych, w nowym pliku o nazwie <em>src/front_of_house.rs</em>, jak pokazano w Listing 7-22. Kompilator wie, aby szukaÄ‡ w tym pliku, poniewaÅ¼ napotkaÅ‚ deklaracjÄ™ moduÅ‚u w katalogu gÅ‚Ã³wnym skrzynki o nazwie <code>front_of_house</code>.</p>
<listing number="7-22" file-name="src/front_of_house.rs" caption="Definicje w module `front_of_house` w *src/front_of_house.rs*">
<pre><code class="language-rust ignore">pub mod hosting {
    pub fn add_to_waitlist() {}
}</code></pre>
</listing>
<p>ZauwaÅ¼, Å¼e plik naleÅ¼y zaÅ‚adowaÄ‡ za pomocÄ… deklaracji <code>mod</code> <em>tylko raz</em> w drzewie moduÅ‚Ã³w. Kiedy kompilator dowie siÄ™, Å¼e plik jest czÄ™Å›ciÄ… projektu (i wie, gdzie w drzewie moduÅ‚Ã³w znajduje siÄ™ kod, ze wzglÄ™du na miejsce, w ktÃ³rym umieszczono instrukcjÄ™ <code>mod</code>), inne pliki w projekcie powinny odwoÅ‚ywaÄ‡ siÄ™ do kodu zaÅ‚adowanego pliku, uÅ¼ywajÄ…c Å›cieÅ¼ki do miejsca, w ktÃ³rym zostaÅ‚ zadeklarowany, jak opisano w sekcji <a href="#Å›cieÅ¼ki-do-odwoÅ‚ywania-siÄ™-do-elementu-w-drzewie-moduÅ‚Ã³w-1">â€ÅšcieÅ¼ki do odwoÅ‚ywania siÄ™ do elementu w drzewie moduÅ‚Ã³wâ€</a>.<!-- ignore --> Innymi sÅ‚owy, <code>mod</code> <em>nie</em> jest operacjÄ… â€includeâ€, ktÃ³rÄ… mogÅ‚eÅ› widzieÄ‡ w innych jÄ™zykach programowania.</p>
<p>NastÄ™pnie wyodrÄ™bnimy moduÅ‚ <code>hosting</code> do jego wÅ‚asnego pliku. Proces jest nieco inny, poniewaÅ¼ <code>hosting</code> jest moduÅ‚em podrzÄ™dnym <code>front_of_house</code>, a nie moduÅ‚u gÅ‚Ã³wnego. Plik dla <code>hosting</code> umieÅ›cimy w nowym katalogu, ktÃ³ry bÄ™dzie nazwany od jego przodkÃ³w w drzewie moduÅ‚Ã³w, w tym przypadku <em>src/front_of_house</em>.</p>
<p>Aby rozpoczÄ…Ä‡ przenoszenie <code>hosting</code>, zmieniamy <em>src/front_of_house.rs</em>, tak aby zawieraÅ‚ tylko deklaracjÄ™ moduÅ‚u <code>hosting</code>:</p>
<listing file-name="src/front_of_house.rs">
<pre><code class="language-rust ignore">pub mod hosting;</code></pre>
</listing>
<p>NastÄ™pnie tworzymy katalog <em>src/front_of_house</em> i plik <em>hosting.rs</em>, aby zawieraÄ‡ definicje z moduÅ‚u <code>hosting</code>:</p>
<listing file-name="src/front_of_house/hosting.rs">
<pre><code class="language-rust ignore">pub fn add_to_waitlist() {}</code></pre>
</listing>
<p>GdybyÅ›my zamiast tego umieÅ›cili <em>hosting.rs</em> w katalogu <em>src</em>, kompilator oczekiwaÅ‚by, Å¼e kod <em>hosting.rs</em> bÄ™dzie w module <code>hosting</code> zadeklarowanym w katalogu gÅ‚Ã³wnym skrzynki, a nie zadeklarowanym jako dziecko moduÅ‚u <code>front_of_house</code>. Zasady kompilatora dotyczÄ…ce tego, ktÃ³re pliki sprawdziÄ‡ pod kÄ…tem kodu poszczegÃ³lnych moduÅ‚Ã³w, oznaczajÄ…, Å¼e katalogi i pliki bardziej Å›ciÅ›le odpowiadajÄ… drzewu moduÅ‚Ã³w.</p>
<blockquote>
<h3 id="alternatywne-Å›cieÅ¼ki-plikÃ³w"><a class="header" href="#alternatywne-Å›cieÅ¼ki-plikÃ³w">Alternatywne Å›cieÅ¼ki plikÃ³w</a></h3>
<p>Do tej pory omÃ³wiliÅ›my najbardziej idiomatyczne Å›cieÅ¼ki plikÃ³w uÅ¼ywane przez kompilator Rust, ale Rust obsÅ‚uguje rÃ³wnieÅ¼ starszy styl Å›cieÅ¼ek plikÃ³w. Dla moduÅ‚u o nazwie <code>front_of_house</code> zadeklarowanego w katalogu gÅ‚Ã³wnym skrzynki, kompilator bÄ™dzie szukaÅ‚ kodu moduÅ‚u w:</p>
<ul>
<li><em>src/front_of_house.rs</em> (to, co omÃ³wiliÅ›my)</li>
<li><em>src/front_of_house/mod.rs</em> (starszy styl, nadal obsÅ‚ugiwana Å›cieÅ¼ka)</li>
</ul>
<p>Dla moduÅ‚u o nazwie <code>hosting</code>, ktÃ³ry jest podmoduÅ‚em <code>front_of_house</code>, kompilator bÄ™dzie szukaÅ‚ kodu moduÅ‚u w:</p>
<ul>
<li><em>src/front_of_house/hosting.rs</em> (to, co omÃ³wiliÅ›my)</li>
<li><em>src/front_of_house/hosting/mod.rs</em> (starszy styl, nadal obsÅ‚ugiwana Å›cieÅ¼ka)</li>
</ul>
<p>JeÅ›li uÅ¼yjesz obu stylÃ³w dla tego samego moduÅ‚u, otrzymasz bÅ‚Ä…d kompilacji. Mieszanie obu stylÃ³w dla rÃ³Å¼nych moduÅ‚Ã³w w tym samym projekcie jest dozwolone, ale moÅ¼e byÄ‡ mylÄ…ce dla osÃ³b nawigujÄ…cych po Twoim projekcie.</p>
<p>GÅ‚Ã³wnÄ… wadÄ… stylu, ktÃ³ry uÅ¼ywa plikÃ³w o nazwie <em>mod.rs</em>, jest to, Å¼e projekt moÅ¼e zawieraÄ‡ wiele plikÃ³w o nazwie <em>mod.rs</em>, co moÅ¼e prowadziÄ‡ do zamieszania, gdy masz je otwarte w edytorze w tym samym czasie.</p>
</blockquote>
<p>PrzenieÅ›liÅ›my kod kaÅ¼dego moduÅ‚u do osobnego pliku, a drzewo moduÅ‚Ã³w pozostaÅ‚o takie samo. WywoÅ‚ania funkcji w <code>eat_at_restaurant</code> bÄ™dÄ… dziaÅ‚aÄ‡ bez Å¼adnych modyfikacji, mimo Å¼e definicje znajdujÄ… siÄ™ w rÃ³Å¼nych plikach. Ta technika pozwala przenosiÄ‡ moduÅ‚y do nowych plikÃ³w, gdy rosnÄ….</p>
<p>ZauwaÅ¼, Å¼e instrukcja <code>pub use crate::front_of_house::hosting</code> w <em>src/lib.rs</em> rÃ³wnieÅ¼ nie ulegÅ‚a zmianie, ani <code>use</code> nie ma wpÅ‚ywu na to, ktÃ³re pliki sÄ… kompilowane jako czÄ™Å›Ä‡ skrzynki. SÅ‚owo kluczowe <code>mod</code> deklaruje moduÅ‚y, a Rust szuka w pliku o tej samej nazwie co moduÅ‚ kodu, ktÃ³ry naleÅ¼y do tego moduÅ‚u.</p>
<h2 id="podsumowanie-6"><a class="header" href="#podsumowanie-6">Podsumowanie</a></h2>
<p>Rust pozwala dzieliÄ‡ pakiet na wiele skrzynek, a skrzynkÄ™ na moduÅ‚y, tak aby moÅ¼na byÅ‚o odwoÅ‚ywaÄ‡ siÄ™ do elementÃ³w zdefiniowanych w jednym module z innego moduÅ‚u. MoÅ¼na to zrobiÄ‡, okreÅ›lajÄ…c Å›cieÅ¼ki absolutne lub wzglÄ™dne. Te Å›cieÅ¼ki moÅ¼na wprowadziÄ‡ do zasiÄ™gu za pomocÄ… instrukcji <code>use</code>, aby moÅ¼na byÅ‚o uÅ¼ywaÄ‡ krÃ³tszej Å›cieÅ¼ki dla wielokrotnego uÅ¼ycia elementu w tym zasiÄ™gu. Kod moduÅ‚u jest domyÅ›lnie prywatny, ale moÅ¼na uczyniÄ‡ definicje publicznymi, dodajÄ…c sÅ‚owo kluczowe <code>pub</code>.</p>
<p>W nastÄ™pnym rozdziale przyjrzymy siÄ™ niektÃ³rym strukturom danych kolekcji w standardowej bibliotece, ktÃ³rych moÅ¼na uÅ¼yÄ‡ w swoim schludnie zorganizowanym kodzie.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wspÃ³lne-kolekcje"><a class="header" href="#wspÃ³lne-kolekcje">WspÃ³lne kolekcje</a></h1>
<p>Standardowa biblioteka Rusta zawiera szereg bardzo przydatnych struktur danych zwanych <em>kolekcjami</em>. WiÄ™kszoÅ›Ä‡ innych typÃ³w danych reprezentuje jednÄ… konkretnÄ… wartoÅ›Ä‡, ale kolekcje mogÄ… zawieraÄ‡ wiele wartoÅ›ci. W przeciwieÅ„stwie do wbudowanych typÃ³w tablicowych i krotkowych, dane, na ktÃ³re wskazujÄ… te kolekcje, sÄ… przechowywane na stercie, co oznacza, Å¼e iloÅ›Ä‡ danych nie musi byÄ‡ znana w czasie kompilacji i moÅ¼e rosnÄ…Ä‡ lub zmniejszaÄ‡ siÄ™ w trakcie dziaÅ‚ania programu. KaÅ¼dy rodzaj kolekcji ma inne moÅ¼liwoÅ›ci i koszty, a wybÃ³r odpowiedniej dla bieÅ¼Ä…cej sytuacji to umiejÄ™tnoÅ›Ä‡, ktÃ³rÄ… rozwiniesz z czasem. W tym rozdziale omÃ³wimy trzy kolekcje, ktÃ³re sÄ… bardzo czÄ™sto uÅ¼ywane w programach Rust:</p>
<ul>
<li><em>Wektor</em> umoÅ¼liwia przechowywanie zmiennej liczby wartoÅ›ci obok siebie.</li>
<li><em>CiÄ…g znakÃ³w</em> to kolekcja znakÃ³w. WspomnieliÅ›my juÅ¼ o typie <code>String</code>, ale w tym rozdziale omÃ³wimy go szczegÃ³Å‚owo.</li>
<li><em>Mapa haszujÄ…ca</em> umoÅ¼liwia powiÄ…zanie wartoÅ›ci z konkretnym kluczem. Jest to szczegÃ³lna implementacja bardziej ogÃ³lnej struktury danych zwanej <em>mapÄ…</em>.</li>
</ul>
<p>Aby dowiedzieÄ‡ siÄ™ o innych rodzajach kolekcji dostarczanych przez standardowÄ… bibliotekÄ™, zobacz <a href="../std/collections/index.html">dokumentacjÄ™</a>.</p>
<p>OmÃ³wimy, jak tworzyÄ‡ i aktualizowaÄ‡ wektory, ciÄ…gi znakÃ³w i mapy haszujÄ…ce, a takÅ¼e co sprawia, Å¼e kaÅ¼da z nich jest wyjÄ…tkowa.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="przechowywanie-list-wartoÅ›ci-za-pomocÄ…-wektorÃ³w-1"><a href="#przechowywanie-list-wartoÅ›ci-za-pomocÄ…-wektorÃ³w-1" class="header">Przechowywanie list wartoÅ›ci za pomocÄ… wektorÃ³w</a></h1>
<h2 id="przechowywanie-list-wartoÅ›ci-za-pomocÄ…-wektorÃ³w"><a class="header" href="#przechowywanie-list-wartoÅ›ci-za-pomocÄ…-wektorÃ³w">Przechowywanie list wartoÅ›ci za pomocÄ… wektorÃ³w</a></h2>
<p>Pierwszym typem kolekcji, ktÃ³ry omÃ³wimy, jest <code>Vec&lt;T&gt;</code>, znany rÃ³wnieÅ¼ jako wektor. Wektory umoÅ¼liwiajÄ… przechowywanie wielu wartoÅ›ci w jednej strukturze danych, ktÃ³ra umieszcza wszystkie wartoÅ›ci obok siebie w pamiÄ™ci. Wektory mogÄ… przechowywaÄ‡ tylko wartoÅ›ci tego samego typu. SÄ… przydatne, gdy masz listÄ™ elementÃ³w, takich jak linie tekstu w pliku lub ceny przedmiotÃ³w w koszyku na zakupy.</p>
<h3 id="tworzenie-nowego-wektora"><a class="header" href="#tworzenie-nowego-wektora">Tworzenie nowego wektora</a></h3>
<p>Aby utworzyÄ‡ nowy, pusty wektor, wywoÅ‚ujemy funkcjÄ™ <code>Vec::new</code>, jak pokazano w Listing 8-1.</p>
<listing number="8-1" caption="Tworzenie nowego, pustego wektora do przechowywania wartoÅ›ci typu `i32`">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}</span></code></pre>
</listing>
<p>ZauwaÅ¼, Å¼e dodaliÅ›my tutaj adnotacjÄ™ typu. PoniewaÅ¼ nie wstawiamy Å¼adnych wartoÅ›ci do tego wektora, Rust nie wie, jakiego rodzaju elementy zamierzamy przechowywaÄ‡. Jest to waÅ¼na uwaga. Wektory sÄ… implementowane przy uÅ¼yciu generykÃ³w; jak uÅ¼ywaÄ‡ generykÃ³w z wÅ‚asnymi typami, omÃ³wimy w Rozdziale 10. Na razie wiedz, Å¼e typ <code>Vec&lt;T&gt;</code> dostarczany przez standardowÄ… bibliotekÄ™ moÅ¼e przechowywaÄ‡ dowolny typ. Kiedy tworzymy wektor do przechowywania okreÅ›lonego typu, moÅ¼emy okreÅ›liÄ‡ typ w nawiasach ostrych. W Listing 8-1 poinformowaliÅ›my Rusta, Å¼e <code>Vec&lt;T&gt;</code> w <code>v</code> bÄ™dzie przechowywaÄ‡ elementy typu <code>i32</code>.</p>
<p>CzÄ™Å›ciej bÄ™dziesz tworzyÄ‡ <code>Vec&lt;T&gt;</code> z wartoÅ›ciami poczÄ…tkowymi, a Rust wywnioskuje typ wartoÅ›ci, ktÃ³rÄ… chcesz przechowywaÄ‡, wiÄ™c rzadko bÄ™dziesz musiaÅ‚ dodawaÄ‡ adnotacje typu. Rust wygodnie udostÄ™pnia makro <code>vec!</code>, ktÃ³re utworzy nowy wektor przechowujÄ…cy podane wartoÅ›ci. Listing 8-2 tworzy nowy <code>Vec&lt;i32&gt;</code> przechowujÄ…cy wartoÅ›ci <code>1</code>, <code>2</code> i <code>3</code>. Typ liczby caÅ‚kowitej to <code>i32</code>, poniewaÅ¼ jest to domyÅ›lny typ liczby caÅ‚kowitej, jak omÃ³wiliÅ›my w sekcji <a href="#data-types">â€Typy danychâ€</a><!-- ignore --> w Rozdziale 3.</p>
<listing number="8-2" caption="Tworzenie nowego wektora zawierajÄ…cego wartoÅ›ci">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3];
<span class="boring">}</span></code></pre>
</listing>
<p>PoniewaÅ¼ podaliÅ›my poczÄ…tkowe wartoÅ›ci <code>i32</code>, Rust moÅ¼e wywnioskowaÄ‡, Å¼e typ <code>v</code> to <code>Vec&lt;i32&gt;</code>, a adnotacja typu nie jest konieczna. NastÄ™pnie przyjrzymy siÄ™, jak modyfikowaÄ‡ wektor.</p>
<h3 id="aktualizowanie-wektora"><a class="header" href="#aktualizowanie-wektora">Aktualizowanie wektora</a></h3>
<p>Aby utworzyÄ‡ wektor, a nastÄ™pnie dodaÄ‡ do niego elementy, moÅ¼emy uÅ¼yÄ‡ metody <code>push</code>, jak pokazano w Listing 8-3.</p>
<listing number="8-3" caption="UÅ¼ycie metody `push` do dodawania wartoÅ›ci do wektora">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
<span class="boring">}</span></code></pre>
</listing>
<p>Jak w przypadku kaÅ¼dej zmiennej, jeÅ›li chcemy mÃ³c zmieniaÄ‡ jej wartoÅ›Ä‡, musimy uczyniÄ‡ jÄ… mutowalnÄ… za pomocÄ… sÅ‚owa kluczowego <code>mut</code>, jak omÃ³wiono w Rozdziale 3. Liczby, ktÃ³re umieszczamy wewnÄ…trz, sÄ… wszystkie typu <code>i32</code>, a Rust wnioskuje to z danych, wiÄ™c nie potrzebujemy adnotacji <code>Vec&lt;i32&gt;</code>.</p>
<h3 id="odczytywanie-elementÃ³w-wektorÃ³w"><a class="header" href="#odczytywanie-elementÃ³w-wektorÃ³w">Odczytywanie elementÃ³w wektorÃ³w</a></h3>
<p>IstniejÄ… dwa sposoby odwoÅ‚ywania siÄ™ do wartoÅ›ci przechowywanej w wektorze: poprzez indeksowanie lub za pomocÄ… metody <code>get</code>. W poniÅ¼szych przykÅ‚adach dodaliÅ›my adnotacje typÃ³w wartoÅ›ci zwracanych przez te funkcje dla dodatkowej przejrzystoÅ›ci.</p>
<p>Listing 8-4 pokazuje obie metody dostÄ™pu do wartoÅ›ci w wektorze, ze skÅ‚adniÄ… indeksowania i metodÄ… <code>get</code>.</p>
<listing number="8-4" caption="UÅ¼ycie skÅ‚adni indeksowania i metody `get` do dostÄ™pu do elementu w wektorze">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let third: &amp;i32 = &amp;v[2];
    println!("Trzeci element to {third}");

    let third: Option&lt;&amp;i32&gt; = v.get(2);
    match third {
        Some(third) =&gt; println!("Trzeci element to {third}"),
        None =&gt; println!("Nie ma trzeciego elementu."),
    }
<span class="boring">}</span></code></pre>
</listing>
<p>ZauwaÅ¼my kilka szczegÃ³Å‚Ã³w. UÅ¼ywamy wartoÅ›ci indeksu <code>2</code>, aby uzyskaÄ‡ trzeci element, poniewaÅ¼ wektory sÄ… indeksowane liczbami, zaczynajÄ…c od zera. UÅ¼ycie <code>&amp;</code> i <code>[]</code> daje nam odniesienie do elementu o wartoÅ›ci indeksu. Kiedy uÅ¼ywamy metody <code>get</code> z indeksem przekazanym jako argument, otrzymujemy <code>Option&lt;&amp;T&gt;</code>, ktÃ³rego moÅ¼emy uÅ¼yÄ‡ z <code>match</code>.</p>
<p>Rust udostÄ™pnia te dwa sposoby odwoÅ‚ywania siÄ™ do elementu, abyÅ› mÃ³gÅ‚ wybraÄ‡, jak program zachowa siÄ™, gdy sprÃ³bujesz uÅ¼yÄ‡ wartoÅ›ci indeksu spoza zakresu istniejÄ…cych elementÃ³w. Na przykÅ‚ad, zobaczmy, co siÄ™ stanie, gdy mamy wektor piÄ™ciu elementÃ³w, a nastÄ™pnie sprÃ³bujemy uzyskaÄ‡ dostÄ™p do elementu o indeksie 100 za pomocÄ… kaÅ¼dej techniki, jak pokazano w Listing 8-5.</p>
<listing number="8-5" caption="PrÃ³ba dostÄ™pu do elementu o indeksie 100 w wektorze zawierajÄ…cym piÄ™Ä‡ elementÃ³w">
<pre class="playground"><code class="language-rust should_panic panics edition2024"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let does_not_exist = &amp;v[100];
    let does_not_exist = v.get(100);
<span class="boring">}</span></code></pre>
</listing>
<p>Kiedy uruchomimy ten kod, pierwsza metoda <code>[]</code> spowoduje panikÄ™ programu, poniewaÅ¼ odwoÅ‚uje siÄ™ do nieistniejÄ…cego elementu. Ta metoda jest najlepiej uÅ¼ywana, gdy chcesz, aby program ulegÅ‚ awarii, jeÅ›li istnieje prÃ³ba dostÄ™pu do elementu poza koÅ„cem wektora.</p>
<p>JeÅ›li do metody <code>get</code> zostanie przekazany indeks spoza zakresu wektora, zwraca <code>None</code> bez paniki. UÅ¼yÅ‚byÅ› tej metody, jeÅ›li dostÄ™p do elementu spoza zakresu wektora moÅ¼e sporadycznie wystÄ™powaÄ‡ w normalnych okolicznoÅ›ciach. TwÃ³j kod bÄ™dzie wtedy zawieraÅ‚ logikÄ™ do obsÅ‚ugi <code>Some(&amp;element)</code> lub <code>None</code>, jak omÃ³wiono w Rozdziale 6. Na przykÅ‚ad, indeks moÅ¼e pochodziÄ‡ od osoby wpisujÄ…cej liczbÄ™. JeÅ›li przypadkowo wpisze zbyt duÅ¼Ä… liczbÄ™, a program otrzyma wartoÅ›Ä‡ <code>None</code>, moÅ¼esz poinformowaÄ‡ uÅ¼ytkownika, ile elementÃ³w znajduje siÄ™ w bieÅ¼Ä…cym wektorze i daÄ‡ mu kolejnÄ… szansÄ™ na wprowadzenie prawidÅ‚owej wartoÅ›ci. ByÅ‚oby to bardziej przyjazne dla uÅ¼ytkownika niÅ¼ awaria programu z powodu literÃ³wki!</p>
<p>Gdy program ma prawidÅ‚owÄ… referencjÄ™, sprawdzanie poÅ¼yczek (borrow checker) egzekwuje zasady wÅ‚asnoÅ›ci i poÅ¼yczania (omÃ³wione w Rozdziale 4), aby upewniÄ‡ siÄ™, Å¼e ta referencja i wszelkie inne referencje do zawartoÅ›ci wektora pozostajÄ… prawidÅ‚owe.
Przypomnijmy sobie zasadÄ™, ktÃ³ra mÃ³wi, Å¼e nie moÅ¼na mieÄ‡ jednoczeÅ›nie mutowalnych i niemutowalnych referencji w tym samym zakresie. Ta zasada ma zastosowanie w Listing 8-6, gdzie trzymamy niemutowalnÄ… referencjÄ™ do pierwszego elementu w wektorze i prÃ³bujemy dodaÄ‡ element na koÅ„cu. Ten program nie zadziaÅ‚a, jeÅ›li pÃ³Åºniej sprÃ³bujemy odwoÅ‚aÄ‡ siÄ™ do tego elementu w funkcji.</p>
<listing number="8-6" caption="PrÃ³ba dodania elementu do wektora przy jednoczesnym utrzymywaniu referencji do elementu">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5];

    let first = &amp;v[0];

    v.push(6);

    println!("Pierwszy element to: {first}");
<span class="boring">}</span></code></pre>
</listing>
<p>Kompilowanie tego kodu spowoduje nastÄ™pujÄ…cy bÅ‚Ä…d:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!("The first element is: {first}");
  |                                      ----- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` (bin "collections") due to 1 previous error
</code></pre>
<p>Kod w Listing 8-6 moÅ¼e wyglÄ…daÄ‡, jakby powinien dziaÅ‚aÄ‡: Dlaczego referencja do pierwszego elementu miaÅ‚aby przejmowaÄ‡ siÄ™ zmianami na koÅ„cu wektora? Ten bÅ‚Ä…d wynika ze sposobu dziaÅ‚ania wektorÃ³w: PoniewaÅ¼ wektory umieszczajÄ… wartoÅ›ci obok siebie w pamiÄ™ci, dodanie nowego elementu na koÅ„cu wektora moÅ¼e wymagaÄ‡ alokacji nowej pamiÄ™ci i skopiowania starych elementÃ³w do nowej przestrzeni, jeÅ›li nie ma wystarczajÄ…co duÅ¼o miejsca, aby umieÅ›ciÄ‡ wszystkie elementy obok siebie tam, gdzie wektor jest obecnie przechowywany. W takim przypadku referencja do pierwszego elementu wskazywaÅ‚aby na zwolnionÄ… pamiÄ™Ä‡. Zasady poÅ¼yczania zapobiegajÄ… programom wpadaniu w takÄ… sytuacjÄ™.</p>
<blockquote>
<p>Uwaga: Aby uzyskaÄ‡ wiÄ™cej informacji na temat szczegÃ³Å‚Ã³w implementacji typu <code>Vec&lt;T&gt;</code>, zobacz <a href="../nomicon/vec/vec.html">â€Rustonomiconâ€</a>.</p>
</blockquote>
<h3 id="iteracja-po-wartoÅ›ciach-w-wektorze"><a class="header" href="#iteracja-po-wartoÅ›ciach-w-wektorze">Iteracja po wartoÅ›ciach w wektorze</a></h3>
<p>Aby kolejno uzyskiwaÄ‡ dostÄ™p do kaÅ¼dego elementu w wektorze, iterowalibyÅ›my po wszystkich elementach, zamiast uÅ¼ywaÄ‡ indeksÃ³w do jednoczesnego dostÄ™pu do jednego. Listing 8-7 pokazuje, jak uÅ¼yÄ‡ pÄ™tli <code>for</code> do uzyskania niemutowalnych referencji do kaÅ¼dego elementu w wektorze wartoÅ›ci <code>i32</code> i ich wydrukowania.</p>
<listing number="8-7" caption="Drukowanie kaÅ¼dego elementu w wektorze poprzez iteracjÄ™ po elementach za pomocÄ… pÄ™tli `for`">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let v = vec![100, 32, 57];
    for i in &amp;v {
        println!("{i}");
    }
<span class="boring">}</span></code></pre>
</listing>
<p>MoÅ¼emy rÃ³wnieÅ¼ iterowaÄ‡ po mutowalnych referencjach do kaÅ¼dego elementu w mutowalnym wektorze, aby wprowadziÄ‡ zmiany do wszystkich elementÃ³w. PÄ™tla <code>for</code> w Listing 8-8 doda <code>50</code> do kaÅ¼dego elementu.</p>
<listing number="8-8" caption="Iteracja po mutowalnych referencjach do elementÃ³w w wektorze">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50;
    }
<span class="boring">}</span></code></pre>
</listing>
<p>Aby zmieniÄ‡ wartoÅ›Ä‡, do ktÃ³rej odwoÅ‚uje siÄ™ mutowalna referencja, musimy uÅ¼yÄ‡ operatora dereferencji <code>*</code>, aby uzyskaÄ‡ dostÄ™p do wartoÅ›ci w <code>i</code>, zanim bÄ™dziemy mogli uÅ¼yÄ‡ operatora <code>+=</code>. WiÄ™cej o operatorze dereferencji omÃ³wimy w sekcji <a href="#following-the-pointer-to-the-value-with-the-dereference-operator">â€Åšledzenie referencji do wartoÅ›ciâ€</a><!-- ignore --> w Rozdziale 15.</p>
<p>Iteracja po wektorze, niezaleÅ¼nie od tego, czy jest niemutowalna, czy mutowalna, jest bezpieczna dziÄ™ki zasadom sprawdzania poÅ¼yczek. GdybyÅ›my prÃ³bowali wstawiaÄ‡ lub usuwaÄ‡ elementy w treÅ›ciach pÄ™tli <code>for</code> w Listing 8-7 i Listing 8-8, otrzymalibyÅ›my bÅ‚Ä…d kompilacji podobny do tego, ktÃ³ry otrzymaliÅ›my w kodzie w Listing 8-6. Referencja do wektora, ktÃ³rÄ… przechowuje pÄ™tla <code>for</code>, zapobiega jednoczesnej modyfikacji caÅ‚ego wektora.</p>
<h3 id="uÅ¼ywanie-enum-do-przechowywania-wielu-typÃ³w"><a class="header" href="#uÅ¼ywanie-enum-do-przechowywania-wielu-typÃ³w">UÅ¼ywanie Enum do przechowywania wielu typÃ³w</a></h3>
<p>Wektory mogÄ… przechowywaÄ‡ tylko wartoÅ›ci tego samego typu. MoÅ¼e to byÄ‡ niewygodne; z pewnoÅ›ciÄ… istniejÄ… przypadki uÅ¼ycia, w ktÃ³rych trzeba przechowywaÄ‡ listÄ™ elementÃ³w rÃ³Å¼nych typÃ³w. Na szczÄ™Å›cie warianty enum sÄ… zdefiniowane pod tym samym typem enum, wiÄ™c gdy potrzebujemy jednego typu do reprezentowania elementÃ³w rÃ³Å¼nych typÃ³w, moÅ¼emy zdefiniowaÄ‡ i uÅ¼yÄ‡ enum!</p>
<p>Na przykÅ‚ad, powiedzmy, Å¼e chcemy pobraÄ‡ wartoÅ›ci z wiersza w arkuszu kalkulacyjnym, w ktÃ³rym niektÃ³re kolumny w wierszu zawierajÄ… liczby caÅ‚kowite, niektÃ³re liczby zmiennoprzecinkowe, a niektÃ³re ciÄ…gi znakÃ³w. MoÅ¼emy zdefiniowaÄ‡ enum, ktÃ³rego warianty bÄ™dÄ… przechowywaÄ‡ rÃ³Å¼ne typy wartoÅ›ci, a wszystkie warianty enum bÄ™dÄ… traktowane jako ten sam typ: typ enum. NastÄ™pnie moÅ¼emy utworzyÄ‡ wektor do przechowywania tego enum i w ten sposÃ³b ostatecznie przechowywaÄ‡ rÃ³Å¼ne typy. ZilustrowaliÅ›my to w Listing 8-9.</p>
<listing number="8-9" caption="Definiowanie enum do przechowywania wartoÅ›ci rÃ³Å¼nych typÃ³w w jednym wektorze">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("niebieski")),
        SpreadsheetCell::Float(10.12),
    ];
<span class="boring">}</span></code></pre>
</listing>
<p>Rust musi znaÄ‡ typy, ktÃ³re bÄ™dÄ… znajdowaÄ‡ siÄ™ w wektorze w czasie kompilacji, aby dokÅ‚adnie wiedzieÄ‡, ile pamiÄ™ci na stercie bÄ™dzie potrzebne do przechowywania kaÅ¼dego elementu. Musimy rÃ³wnieÅ¼ wyraÅºnie okreÅ›liÄ‡, jakie typy sÄ… dozwolone w tym wektorze. Gdyby Rust pozwalaÅ‚ na przechowywanie dowolnego typu w wektorze, istniaÅ‚oby ryzyko, Å¼e jeden lub wiÄ™cej typÃ³w spowodowaÅ‚oby bÅ‚Ä™dy w operacjach wykonywanych na elementach wektora. UÅ¼ycie enum plus wyraÅ¼enia <code>match</code> oznacza, Å¼e Rust zapewni w czasie kompilacji, Å¼e kaÅ¼dy moÅ¼liwy przypadek zostanie obsÅ‚uÅ¼ony, jak omÃ³wiono w Rozdziale 6.</p>
<p>JeÅ›li nie znasz wyczerpujÄ…cego zestawu typÃ³w, ktÃ³re program otrzyma w czasie wykonywania, aby przechowywaÄ‡ w wektorze, technika enum nie zadziaÅ‚a. Zamiast tego moÅ¼esz uÅ¼yÄ‡ obiektu cechy, ktÃ³ry omÃ³wimy w Rozdziale 18.</p>
<p>Teraz, gdy omÃ³wiliÅ›my niektÃ³re z najczÄ™stszych sposobÃ³w uÅ¼ycia wektorÃ³w, upewnij siÄ™, Å¼e zapoznaÅ‚eÅ› siÄ™ z <a href="../std/vec/struct.Vec.html">dokumentacjÄ… API</a><!-- ignore -->, aby zapoznaÄ‡ siÄ™ ze wszystkimi wieloma przydatnymi metodami zdefiniowanymi w <code>Vec&lt;T&gt;</code> przez standardowÄ… bibliotekÄ™. Na przykÅ‚ad, oprÃ³cz <code>push</code>, metoda <code>pop</code> usuwa i zwraca ostatni element.</p>
<h3 id="usuwanie-wektora-usuwa-jego-elementy"><a class="header" href="#usuwanie-wektora-usuwa-jego-elementy">Usuwanie wektora usuwa jego elementy</a></h3>
<p>Podobnie jak kaÅ¼da inna <code>struct</code>, wektor jest zwalniany, gdy wychodzi poza zasiÄ™g, jak to zanotowano w Listing 8-10.</p>
<listing number="8-10" caption="Pokazywanie, gdzie wektor i jego elementy sÄ… usuwane">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    {
        let v = vec![1, 2, 3, 4];

        // rÃ³b coÅ› z v
    } // &lt;- v wychodzi z zasiÄ™gu i jest zwalniane tutaj
<span class="boring">}</span></code></pre>
</listing>
<p>Kiedy wektor zostaje usuniÄ™ty, caÅ‚a jego zawartoÅ›Ä‡ rÃ³wnieÅ¼ zostaje usuniÄ™ta, co oznacza, Å¼e przechowywane w nim liczby caÅ‚kowite zostanÄ… posprzÄ…tane. SprawdzajÄ…cy poÅ¼yczki zapewnia, Å¼e wszelkie referencje do zawartoÅ›ci wektora sÄ… uÅ¼ywane tylko wtedy, gdy sam wektor jest prawidÅ‚owy.</p>
<p>PrzejdÅºmy do nastÄ™pnego typu kolekcji: <code>String</code>!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="przechowywanie-tekstu-zakodowanego-w-utf-8-za-pomocÄ…-ciÄ…gÃ³w-znakÃ³w-1"><a href="#przechowywanie-tekstu-zakodowanego-w-utf-8-za-pomocÄ…-ciÄ…gÃ³w-znakÃ³w-1" class="header">Przechowywanie tekstu zakodowanego w UTF-8 za pomocÄ… ciÄ…gÃ³w znakÃ³w</a></h1>
<h2 id="przechowywanie-tekstu-zakodowanego-w-utf-8-za-pomocÄ…-ciÄ…gÃ³w-znakÃ³w"><a class="header" href="#przechowywanie-tekstu-zakodowanego-w-utf-8-za-pomocÄ…-ciÄ…gÃ³w-znakÃ³w">Przechowywanie tekstu zakodowanego w UTF-8 za pomocÄ… ciÄ…gÃ³w znakÃ³w</a></h2>
<p>O ciÄ…gach znakÃ³w rozmawialiÅ›my w Rozdziale 4, ale teraz przyjrzymy siÄ™ im bardziej szczegÃ³Å‚owo. Nowi uÅ¼ytkownicy Rusta czÄ™sto majÄ… problemy z ciÄ…gami znakÃ³w z powodu poÅ‚Ä…czenia trzech czynnikÃ³w: skÅ‚onnoÅ›ci Rusta do ujawniania moÅ¼liwych bÅ‚Ä™dÃ³w, ciÄ…gÃ³w znakÃ³w bÄ™dÄ…cych bardziej skomplikowanÄ… strukturÄ… danych, niÅ¼ wielu programistÃ³w im przypisuje, oraz UTF-8. Czynniki te Å‚Ä…czÄ… siÄ™ w sposÃ³b, ktÃ³ry moÅ¼e wydawaÄ‡ siÄ™ trudny, gdy pochodzisz z innych jÄ™zykÃ³w programowania.</p>
<p>CiÄ…gi znakÃ³w omawiamy w kontekÅ›cie kolekcji, poniewaÅ¼ sÄ… one implementowane jako kolekcja bajtÃ³w, plus kilka metod zapewniajÄ…cych uÅ¼ytecznÄ… funkcjonalnoÅ›Ä‡, gdy te bajty sÄ… interpretowane jako tekst. W tej sekcji omÃ³wimy operacje na <code>String</code>, ktÃ³re posiada kaÅ¼dy typ kolekcji, takie jak tworzenie, aktualizowanie i odczytywanie. OmÃ³wimy rÃ³wnieÅ¼ rÃ³Å¼nice miÄ™dzy <code>String</code> a innymi kolekcjami, a mianowicie, jak indeksowanie <code>String</code> jest skomplikowane przez rÃ³Å¼nice miÄ™dzy tym, jak ludzie i komputery interpretujÄ… dane <code>String</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="what-is-a-string"></a></p>
<h3 id="definiowanie-ciÄ…gÃ³w-znakÃ³w"><a class="header" href="#definiowanie-ciÄ…gÃ³w-znakÃ³w">Definiowanie ciÄ…gÃ³w znakÃ³w</a></h3>
<p>Najpierw zdefiniujemy, co rozumiemy przez termin <em>ciÄ…g znakÃ³w</em>. Rust ma tylko jeden typ ciÄ…gu znakÃ³w w podstawowym jÄ™zyku, ktÃ³ry jest wycinkiem ciÄ…gu <code>str</code>, zazwyczaj wystÄ™pujÄ…cym w formie poÅ¼yczonej, <code>&amp;str</code>. W Rozdziale 4 rozmawialiÅ›my o wycinkach ciÄ…gÃ³w znakÃ³w, ktÃ³re sÄ… referencjami do danych ciÄ…gu znakÃ³w zakodowanych w UTF-8, przechowywanych gdzie indziej. LiteraÅ‚y ciÄ…gÃ³w znakÃ³w, na przykÅ‚ad, sÄ… przechowywane w binarnym pliku programu i dlatego sÄ… wycinkami ciÄ…gÃ³w znakÃ³w.</p>
<p>Typ <code>String</code>, ktÃ³ry jest dostarczany przez standardowÄ… bibliotekÄ™ Rusta, a nie zakodowany w podstawowym jÄ™zyku, jest rosnÄ…cym, mutowalnym, posiadajÄ…cym wÅ‚asnoÅ›Ä‡, zakodowanym w UTF-8 typem ciÄ…gu znakÃ³w. Kiedy uÅ¼ytkownicy Rusta odwoÅ‚ujÄ… siÄ™ do â€ciÄ…gÃ³w znakÃ³wâ€ w Rust, mogÄ… odnosiÄ‡ siÄ™ zarÃ³wno do typÃ³w <code>String</code>, jak i wycinkÃ³w ciÄ…gu <code>&amp;str</code>, a nie tylko do jednego z tych typÃ³w. ChociaÅ¼ ta sekcja dotyczy gÅ‚Ã³wnie <code>String</code>, oba typy sÄ… intensywnie uÅ¼ywane w standardowej bibliotece Rusta, a zarÃ³wno <code>String</code>, jak i wycinki ciÄ…gÃ³w znakÃ³w sÄ… zakodowane w UTF-8.</p>
<h3 id="tworzenie-nowego-ciÄ…gu-znakÃ³w"><a class="header" href="#tworzenie-nowego-ciÄ…gu-znakÃ³w">Tworzenie nowego ciÄ…gu znakÃ³w</a></h3>
<p>Wiele z tych samych operacji dostÄ™pnych dla <code>Vec&lt;T&gt;</code> jest rÃ³wnieÅ¼ dostÄ™pnych dla <code>String</code>, poniewaÅ¼ <code>String</code> jest faktycznie implementowane jako opakowanie wokÃ³Å‚ wektora bajtÃ³w z dodatkowymi gwarancjami, ograniczeniami i moÅ¼liwoÅ›ciami. PrzykÅ‚adem funkcji, ktÃ³ra dziaÅ‚a w ten sam sposÃ³b z <code>Vec&lt;T&gt;</code> i <code>String</code>, jest funkcja <code>new</code> do tworzenia instancji, pokazana w Listing 8-11.</p>
<listing number="8-11" caption="Tworzenie nowego, pustego `String`">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}</span></code></pre>
</listing>
<p>Ta linia tworzy nowy, pusty ciÄ…g znakÃ³w o nazwie <code>s</code>, do ktÃ³rego moÅ¼emy nastÄ™pnie zaÅ‚adowaÄ‡ dane. CzÄ™sto bÄ™dziemy mieli pewne poczÄ…tkowe dane, ktÃ³rymi chcemy rozpoczÄ…Ä‡ ciÄ…g znakÃ³w. W tym celu uÅ¼ywamy metody <code>to_string</code>, ktÃ³ra jest dostÄ™pna dla kaÅ¼dego typu implementujÄ…cego cechÄ™ <code>Display</code>, tak jak literaÅ‚y ciÄ…gÃ³w znakÃ³w. Listing 8-12 pokazuje dwa przykÅ‚ady.</p>
<listing number="8-12" caption="UÅ¼ycie metody `to_string` do utworzenia `String` z literaÅ‚u ciÄ…gu znakÃ³w">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let data = "poczÄ…tkowa zawartoÅ›Ä‡";

    let s = data.to_string();

    // Metoda dziaÅ‚a rÃ³wnieÅ¼ bezpoÅ›rednio na literale:
    let s = "poczÄ…tkowa zawartoÅ›Ä‡".to_string();
<span class="boring">}</span></code></pre>
</listing>
<p>Ten kod tworzy ciÄ…g znakÃ³w zawierajÄ…cy <code>poczÄ…tkowÄ… zawartoÅ›Ä‡</code>.</p>
<p>MoÅ¼emy rÃ³wnieÅ¼ uÅ¼yÄ‡ funkcji <code>String::from</code> do utworzenia <code>String</code> z literaÅ‚u ciÄ…gu znakÃ³w. Kod w Listing 8-13 jest rÃ³wnowaÅ¼ny kodowi w Listing 8-12, ktÃ³ry uÅ¼ywa <code>to_string</code>.</p>
<listing number="8-13" caption="UÅ¼ycie funkcji `String::from` do utworzenia `String` z literaÅ‚u ciÄ…gu znakÃ³w">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s = String::from("poczÄ…tkowa zawartoÅ›Ä‡");
<span class="boring">}</span></code></pre>
</listing>
<p>PoniewaÅ¼ ciÄ…gi znakÃ³w sÄ… uÅ¼ywane do wielu rzeczy, moÅ¼emy uÅ¼ywaÄ‡ wielu rÃ³Å¼nych generycznych API dla ciÄ…gÃ³w znakÃ³w, co daje nam wiele opcji. NiektÃ³re z nich mogÄ… wydawaÄ‡ siÄ™ nadmiarowe, ale wszystkie majÄ… swoje miejsce! W tym przypadku <code>String::from</code> i <code>to_string</code> robiÄ… to samo, wiÄ™c wybÃ³r zaleÅ¼y od stylu i czytelnoÅ›ci.</p>
<p>PamiÄ™taj, Å¼e ciÄ…gi znakÃ³w sÄ… zakodowane w UTF-8, wiÄ™c moÅ¼emy w nich zawrzeÄ‡ dowolne poprawnie zakodowane dane, jak pokazano w Listing 8-14.</p>
<listing number="8-14" caption="Przechowywanie pozdrowieÅ„ w rÃ³Å¼nych jÄ™zykach w ciÄ…gach znakÃ³w">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let hello = String::from("Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…");
    let hello = String::from("DobrÃ½ den");
    let hello = String::from("Hello");
    let hello = String::from("×©×œ×•×");
    let hello = String::from("à¤¨à¤®à¤¸à¥à¤¤à¥‡");
    let hello = String::from("ã“ã‚“ã«ã¡ã¯");
    let hello = String::from("ì•ˆë…•í•˜ì„¸ìš”");
    let hello = String::from("ä½ å¥½");
    let hello = String::from("OlÃ¡");
    let hello = String::from("Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ");
    let hello = String::from("Hola");
<span class="boring">}</span></code></pre>
</listing>
<p>Wszystkie te wartoÅ›ci <code>String</code> sÄ… prawidÅ‚owe.</p>
<h3 id="aktualizowanie-ciÄ…gu-znakÃ³w"><a class="header" href="#aktualizowanie-ciÄ…gu-znakÃ³w">Aktualizowanie ciÄ…gu znakÃ³w</a></h3>
<p><code>String</code> moÅ¼e rosnÄ…Ä‡ i zmieniaÄ‡ swojÄ… zawartoÅ›Ä‡, podobnie jak zawartoÅ›Ä‡ <code>Vec&lt;T&gt;</code>, jeÅ›li dodasz do niego wiÄ™cej danych. Ponadto moÅ¼esz wygodnie uÅ¼yÄ‡ operatora <code>+</code> lub makra <code>format!</code> do Å‚Ä…czenia wartoÅ›ci <code>String</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="appending-to-a-string-with-push_str-and-push"></a></p>
<h4 id="doÅ‚Ä…czanie-za-pomocÄ…-push_str-lub-push"><a class="header" href="#doÅ‚Ä…czanie-za-pomocÄ…-push_str-lub-push">DoÅ‚Ä…czanie za pomocÄ… <code>push_str</code> lub <code>push</code></a></h4>
<p>MoÅ¼emy powiÄ™kszyÄ‡ <code>String</code>, uÅ¼ywajÄ…c metody <code>push_str</code> do doÅ‚Ä…czenia wycinka ciÄ…gu znakÃ³w, jak pokazano w Listing 8-15.</p>
<listing number="8-15" caption="DoÅ‚Ä…czanie wycinka ciÄ…gu znakÃ³w do `String` za pomocÄ… metody `push_str`">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s = String::from("foo");
    s.push_str("bar");
<span class="boring">}</span></code></pre>
</listing>
<p>Po tych dwÃ³ch liniach <code>s</code> bÄ™dzie zawieraÄ‡ <code>foobar</code>. Metoda <code>push_str</code> przyjmuje wycinek ciÄ…gu znakÃ³w, poniewaÅ¼ niekoniecznie chcemy przejÄ…Ä‡ wÅ‚asnoÅ›Ä‡ parametru. Na przykÅ‚ad w kodzie w Listing 8-16 chcemy mÃ³c uÅ¼yÄ‡ <code>s2</code> po doÅ‚Ä…czeniu jego zawartoÅ›ci do <code>s1</code>.</p>
<listing number="8-16" caption="UÅ¼ycie wycinka ciÄ…gu znakÃ³w po doÅ‚Ä…czeniu jego zawartoÅ›ci do `String`">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s2 to {s2}");
<span class="boring">}</span></code></pre>
</listing>
<p>Gdyby metoda <code>push_str</code> przejÄ™Å‚a wÅ‚asnoÅ›Ä‡ <code>s2</code>, nie moglibyÅ›my wydrukowaÄ‡ jego wartoÅ›ci w ostatniej linii. Jednak ten kod dziaÅ‚a zgodnie z oczekiwaniami!</p>
<p>Metoda <code>push</code> przyjmuje pojedynczy znak jako parametr i dodaje go do <code>String</code>. Listing 8-17 dodaje literÄ™ <em>l</em> do <code>String</code> za pomocÄ… metody <code>push</code>.</p>
<listing number="8-17" caption="Dodawanie jednego znaku do wartoÅ›ci `String` za pomocÄ… `push`">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s = String::from("lo");
    s.push('l');
<span class="boring">}</span></code></pre>
</listing>
<p>W rezultacie <code>s</code> bÄ™dzie zawieraÄ‡ <code>lol</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="concatenation-with-the--operator-or-the-format-macro"></a></p>
<h4 id="Å‚Ä…czenie-za-pomocÄ…--lub-format"><a class="header" href="#Å‚Ä…czenie-za-pomocÄ…--lub-format">ÅÄ…czenie za pomocÄ… <code>+</code> lub <code>format!</code></a></h4>
<p>CzÄ™sto bÄ™dziesz chciaÅ‚ poÅ‚Ä…czyÄ‡ dwa istniejÄ…ce ciÄ…gi znakÃ³w. Jednym ze sposobÃ³w na to jest uÅ¼ycie operatora <code>+</code>, jak pokazano w Listing 8-18.</p>
<listing number="8-18" caption="UÅ¼ycie operatora `+` do poÅ‚Ä…czenia dwÃ³ch wartoÅ›ci `String` w nowÄ… wartoÅ›Ä‡ `String`">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s1 = String::from("Witaj, ");
    let s2 = String::from("Å›wiecie!");
    let s3 = s1 + &amp;s2; // uwaga, s1 zostaÅ‚o przeniesione i nie moÅ¼e byÄ‡ juÅ¼ uÅ¼yte
<span class="boring">}</span></code></pre>
</listing>
<p>CiÄ…g <code>s3</code> bÄ™dzie zawieraÅ‚ <code>Witaj, Å›wiecie!</code>. PowÃ³d, dla ktÃ³rego <code>s1</code> jest juÅ¼ niewaÅ¼ne po dodaniu, oraz powÃ³d, dla ktÃ³rego uÅ¼yliÅ›my referencji do <code>s2</code>, ma zwiÄ…zek z sygnaturÄ… metody, ktÃ³ra jest wywoÅ‚ywana, gdy uÅ¼ywamy operatora <code>+</code>. Operator <code>+</code> uÅ¼ywa metody <code>add</code>, ktÃ³rej sygnatura wyglÄ…da mniej wiÄ™cej tak:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {</code></pre>
<p>W standardowej bibliotece zobaczysz <code>add</code> zdefiniowane przy uÅ¼yciu generykÃ³w i typÃ³w skojarzonych. Tutaj podstawiliÅ›my konkretne typy, co dzieje siÄ™, gdy wywoÅ‚ujemy tÄ™ metodÄ™ z wartoÅ›ciami <code>String</code>. Generyki omÃ³wimy w Rozdziale 10. Ta sygnatura daje nam wskazÃ³wki potrzebne do zrozumienia trudnych aspektÃ³w operatora <code>+</code>.</p>
<p>Po pierwsze, <code>s2</code> ma <code>&amp;</code>, co oznacza, Å¼e dodajemy referencjÄ™ drugiego ciÄ…gu znakÃ³w do pierwszego ciÄ…gu znakÃ³w. Dzieje siÄ™ tak z powodu parametru <code>s</code> w funkcji <code>add</code>: moÅ¼emy dodaÄ‡ tylko wycinek ciÄ…gu znakÃ³w do <code>String</code>; nie moÅ¼emy dodaÄ‡ dwÃ³ch wartoÅ›ci <code>String</code> razem. Ale czekaj â€“ typ <code>&amp;s2</code> to <code>&amp;String</code>, a nie <code>&amp;str</code>, jak okreÅ›lono w drugim parametrze <code>add</code>. Dlaczego wiÄ™c Listing 8-18 kompiluje siÄ™?</p>
<p>Powodem, dla ktÃ³rego moÅ¼emy uÅ¼yÄ‡ <code>&amp;s2</code> w wywoÅ‚aniu <code>add</code>, jest to, Å¼e kompilator moÅ¼e wymusiÄ‡ konwersjÄ™ argumentu <code>&amp;String</code> na <code>&amp;str</code>. Kiedy wywoÅ‚ujemy metodÄ™ <code>add</code>, Rust uÅ¼ywa deref coercion, ktÃ³ra tutaj zmienia <code>&amp;s2</code> na <code>&amp;s2[..]</code>. OmÃ³wimy deref coercion szczegÃ³Å‚owo w Rozdziale 15. PoniewaÅ¼ <code>add</code> nie przejmuje wÅ‚asnoÅ›ci parametru <code>s</code>, <code>s2</code> nadal bÄ™dzie prawidÅ‚owym <code>String</code> po tej operacji.</p>
<p>Po drugie, w sygnaturze widzimy, Å¼e <code>add</code> przejmuje wÅ‚asnoÅ›Ä‡ <code>self</code>, poniewaÅ¼ <code>self</code> <em>nie</em> ma <code>&amp;</code>. Oznacza to, Å¼e <code>s1</code> w Listing 8-18 zostanie przeniesione do wywoÅ‚ania <code>add</code> i po tym nie bÄ™dzie juÅ¼ waÅ¼ne. Tak wiÄ™c, chociaÅ¼ <code>let s3 = s1 + &amp;s2;</code> wyglÄ…da na to, Å¼e skopiuje oba ciÄ…gi i stworzy nowy, to faktycznie przejmuje wÅ‚asnoÅ›Ä‡ <code>s1</code>, doÅ‚Ä…cza kopiÄ™ zawartoÅ›ci <code>s2</code>, a nastÄ™pnie zwraca wÅ‚asnoÅ›Ä‡ wyniku. Innymi sÅ‚owy, wyglÄ…da na to, Å¼e wykonuje wiele kopii, ale tak nie jest; implementacja jest bardziej wydajna niÅ¼ kopiowanie.</p>
<p>JeÅ›li potrzebujemy poÅ‚Ä…czyÄ‡ wiele ciÄ…gÃ³w znakÃ³w, zachowanie operatora <code>+</code> staje siÄ™ nieporÄ™czne:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &amp;s2 + "-" + &amp;s3;
<span class="boring">}</span></code></pre>
<p>W tym momencie <code>s</code> bÄ™dzie <code>tic-tac-toe</code>. Z tymi wszystkimi znakami <code>+</code> i <code>"</code> trudno jest zrozumieÄ‡, co siÄ™ dzieje. Do Å‚Ä…czenia ciÄ…gÃ³w znakÃ³w w bardziej skomplikowany sposÃ³b moÅ¼emy zamiast tego uÅ¼yÄ‡ makra <code>format!</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{s1}-{s2}-{s3}");
<span class="boring">}</span></code></pre>
<p>Ten kod rÃ³wnieÅ¼ ustawia <code>s</code> na <code>tic-tac-toe</code>. Makro <code>format!</code> dziaÅ‚a jak <code>println!</code>, ale zamiast drukowaÄ‡ wynik na ekranie, zwraca <code>String</code> z zawartoÅ›ciÄ…. Wersja kodu uÅ¼ywajÄ…ca <code>format!</code> jest znacznie Å‚atwiejsza do odczytania, a kod generowany przez makro <code>format!</code> uÅ¼ywa referencji, dziÄ™ki czemu to wywoÅ‚anie nie przejmuje wÅ‚asnoÅ›ci Å¼adnego z jego parametrÃ³w.</p>
<h3 id="indeksowanie-w-ciÄ…gach-znakÃ³w"><a class="header" href="#indeksowanie-w-ciÄ…gach-znakÃ³w">Indeksowanie w ciÄ…gach znakÃ³w</a></h3>
<p>W wielu innych jÄ™zykach programowania, dostÄ™p do pojedynczych znakÃ³w w ciÄ…gu znakÃ³w poprzez odwoÅ‚ywanie siÄ™ do nich za pomocÄ… indeksu jest prawidÅ‚owÄ… i powszechnÄ… operacjÄ…. JednakÅ¼e, jeÅ›li sprÃ³bujesz uzyskaÄ‡ dostÄ™p do czÄ™Å›ci <code>String</code> za pomocÄ… skÅ‚adni indeksowania w Rust, otrzymasz bÅ‚Ä…d. RozwaÅ¼ nieprawidÅ‚owy kod w Listing 8-19.</p>
<listing number="8-19" caption="PrÃ³ba uÅ¼ycia skÅ‚adni indeksowania z `String`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from("hi");
    let h = s1[0];
<span class="boring">}</span></code></pre>
</listing>
<p>Ten kod spowoduje nastÄ™pujÄ…cy bÅ‚Ä…d:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `str` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:16
  |
3 |     let h = s1[0];
  |                ^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex&lt;str&gt;` is not implemented for `{integer}`
  = note: you can use `.chars().nth()` or `.bytes().nth()`
          for more information, see chapter 8 in The Book: &lt;https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings&gt;
  = help: the following other types implement trait `SliceIndex&lt;T&gt;`:
            `usize` implements `SliceIndex&lt;ByteStr&gt;`
            `usize` implements `SliceIndex&lt;[T]&gt;`
  = note: required for `String` to implement `Index&lt;{integer}&gt;`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` (bin "collections") due to 1 previous error
</code></pre>
<p>BÅ‚Ä…d opowiada historiÄ™: ciÄ…gi znakÃ³w w Rust nie obsÅ‚ugujÄ… indeksowania. Ale dlaczego? Aby odpowiedzieÄ‡ na to pytanie, musimy omÃ³wiÄ‡, jak Rust przechowuje ciÄ…gi znakÃ³w w pamiÄ™ci.</p>
<h4 id="reprezentacja-wewnÄ™trzna"><a class="header" href="#reprezentacja-wewnÄ™trzna">Reprezentacja wewnÄ™trzna</a></h4>
<p><code>String</code> jest opakowaniem na <code>Vec&lt;u8&gt;</code>. SpÃ³jrzmy na niektÃ³re z naszych poprawnie zakodowanych przykÅ‚adÃ³w ciÄ…gÃ³w znakÃ³w UTF-8 z Listing 8-14. Najpierw ten:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from("Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…");
</span><span class="boring">    let hello = String::from("DobrÃ½ den");
</span><span class="boring">    let hello = String::from("Hello");
</span><span class="boring">    let hello = String::from("×©×œ×•×");
</span><span class="boring">    let hello = String::from("à¤¨à¤®à¤¸à¥à¤¤à¥‡");
</span><span class="boring">    let hello = String::from("ã“ã‚“ã«ã¡ã¯");
</span><span class="boring">    let hello = String::from("ì•ˆë…•í•˜ì„¸ìš”");
</span><span class="boring">    let hello = String::from("ä½ å¥½");
</span><span class="boring">    let hello = String::from("OlÃ¡");
</span><span class="boring">    let hello = String::from("Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ");
</span>    let hello = String::from("Hola");
<span class="boring">}</span></code></pre>
<p>W tym przypadku <code>len</code> bÄ™dzie rÃ³wne <code>4</code>, co oznacza, Å¼e wektor przechowujÄ…cy ciÄ…g znakÃ³w <code>"Hola"</code> ma 4 bajty dÅ‚ugoÅ›ci. KaÅ¼da z tych liter zajmuje 1 bajt po zakodowaniu w UTF-8. NastÄ™pna linia moÅ¼e CiÄ™ jednak zaskoczyÄ‡ (zauwaÅ¼, Å¼e ten ciÄ…g zaczyna siÄ™ od wielkiej cyrylicznej litery <em>Ze</em>, a nie liczby 3):</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from("Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…");
</span><span class="boring">    let hello = String::from("DobrÃ½ den");
</span><span class="boring">    let hello = String::from("Hello");
</span><span class="boring">    let hello = String::from("×©×œ×•×");
</span><span class="boring">    let hello = String::from("à¤¨à¤®à¤¸à¥à¤¤à¥‡");
</span><span class="boring">    let hello = String::from("ã“ã‚“ã«ã¡ã¯");
</span><span class="boring">    let hello = String::from("ì•ˆë…•í•˜ì„¸ìš”");
</span><span class="boring">    let hello = String::from("ä½ å¥½");
</span><span class="boring">    let hello = String::from("OlÃ¡");
</span>    let hello = String::from("Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ");
<span class="boring">    let hello = String::from("Hola");
</span><span class="boring">}</span></code></pre>
<p>GdybyÅ› zostaÅ‚ zapytany, jak dÅ‚ugi jest ten ciÄ…g znakÃ³w, mÃ³gÅ‚byÅ› powiedzieÄ‡ 12. W rzeczywistoÅ›ci odpowiedÅº Rusta to 24: to liczba bajtÃ³w potrzebna do zakodowania â€Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµâ€ w UTF-8, poniewaÅ¼ kaÅ¼da skalarna wartoÅ›Ä‡ Unicode w tym ciÄ…gu zajmuje 2 bajty pamiÄ™ci. Dlatego indeksowanie bajtÃ³w ciÄ…gu nie zawsze bÄ™dzie korelowaÄ‡ z prawidÅ‚owÄ… skalarnÄ… wartoÅ›ciÄ… Unicode. Aby to zademonstrowaÄ‡, rozwaÅ¼ ten nieprawidÅ‚owy kod w Rust:</p>
<pre><code class="language-rust ignore does_not_compile">let hello = "Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ";
let answer = &amp;hello[0];</code></pre>
<p>Wiesz juÅ¼, Å¼e <code>answer</code> nie bÄ™dzie <code>Ğ—</code>, pierwszÄ… literÄ…. Po zakodowaniu w UTF-8 pierwszy bajt <code>Ğ—</code> to <code>208</code>, a drugi to <code>151</code>, wiÄ™c wydawaÅ‚oby siÄ™, Å¼e <code>answer</code> powinien faktycznie wynosiÄ‡ <code>208</code>, ale <code>208</code> sam w sobie nie jest prawidÅ‚owym znakiem. Zwracanie <code>208</code> prawdopodobnie nie jest tym, czego uÅ¼ytkownik chciaÅ‚by, gdyby poprosiÅ‚ o pierwszÄ… literÄ™ tego ciÄ…gu; jednak to jedyne dane, ktÃ³re Rust ma pod indeksem bajtowym 0. UÅ¼ytkownicy generalnie nie chcÄ…, aby zwracana byÅ‚a wartoÅ›Ä‡ bajtowa, nawet jeÅ›li ciÄ…g zawiera tylko litery Å‚aciÅ„skie: Gdyby <code>&amp;"hi"[0]</code> byÅ‚ prawidÅ‚owym kodem zwracajÄ…cym wartoÅ›Ä‡ bajtowÄ…, zwrÃ³ciÅ‚by <code>104</code>, a nie <code>h</code>.</p>
<p>OdpowiedÅº brzmi zatem, Å¼e aby uniknÄ…Ä‡ zwracania nieoczekiwanej wartoÅ›ci i powodowania bÅ‚Ä™dÃ³w, ktÃ³re mogÄ… nie zostaÄ‡ natychmiast wykryte, Rust w ogÃ³le nie kompiluje tego kodu i zapobiega nieporozumieniom na wczesnym etapie procesu rozwoju.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="bytes-and-scalar-values-and-grapheme-clusters-oh-my"></a></p>
<h4 id="bajty-wartoÅ›ci-skalarne-i-klastry-grafemÃ³w"><a class="header" href="#bajty-wartoÅ›ci-skalarne-i-klastry-grafemÃ³w">Bajty, wartoÅ›ci skalarne i klastry grafemÃ³w</a></h4>
<p>InnÄ… kwestiÄ… dotyczÄ…cÄ… UTF-8 jest to, Å¼e istniejÄ… faktycznie trzy istotne sposoby patrzenia na ciÄ…gi znakÃ³w z perspektywy Rusta: jako bajty, wartoÅ›ci skalarne i klastry grafemÃ³w (najbliÅ¼sze temu, co nazwalibyÅ›my <em>literami</em>).</p>
<p>JeÅ›li spojrzymy na hinduskie sÅ‚owo â€à¤¨à¤®à¤¸à¥à¤¤à¥‡â€ napisane pismem dewanagari, jest ono przechowywane jako wektor wartoÅ›ci <code>u8</code>, ktÃ³ry wyglÄ…da tak:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>To 18 bajtÃ³w i tak ostatecznie komputery przechowujÄ… te dane. JeÅ›li spojrzymy na nie jako skalarne wartoÅ›ci Unicode, czyli to, czym jest typ <code>char</code> w Rust, te bajty wyglÄ…dajÄ… tak:</p>
<pre><code class="language-text">['à¤¨', 'à¤®', 'à¤¸', 'à¥', 'à¤¤', 'à¥‡']
</code></pre>
<p>Jest tu szeÅ›Ä‡ wartoÅ›ci <code>char</code>, ale czwarta i szÃ³sta nie sÄ… literami: to znaki diakrytyczne, ktÃ³re same w sobie nie majÄ… sensu. W koÅ„cu, jeÅ›li spojrzymy na nie jako klastry grafemÃ³w, otrzymamy to, co czÅ‚owiek nazwaÅ‚by czterema literami tworzÄ…cymi hinduskie sÅ‚owo:</p>
<pre><code class="language-text">["à¤¨", "à¤®", "à¤¸à¥", "à¤¤à¥‡"]
</code></pre>
<p>Rust udostÄ™pnia rÃ³Å¼ne sposoby interpretacji surowych danych ciÄ…gu znakÃ³w, ktÃ³re przechowujÄ… komputery, tak aby kaÅ¼dy program mÃ³gÅ‚ wybraÄ‡ interpretacjÄ™, ktÃ³rej potrzebuje, niezaleÅ¼nie od tego, w jakim jÄ™zyku ludzkim sÄ… dane.</p>
<p>Ostatnim powodem, dla ktÃ³rego Rust nie pozwala nam indeksowaÄ‡ <code>String</code> w celu uzyskania znaku, jest to, Å¼e operacje indeksowania majÄ… zawsze zajmowaÄ‡ staÅ‚y czas (O(1)). Nie jest jednak moÅ¼liwe zagwarantowanie takiej wydajnoÅ›ci w przypadku <code>String</code>, poniewaÅ¼ Rust musiaÅ‚by przechodziÄ‡ przez zawartoÅ›Ä‡ od poczÄ…tku do indeksu, aby okreÅ›liÄ‡, ile jest prawidÅ‚owych znakÃ³w.</p>
<h3 id="krojenie-ciÄ…gÃ³w-znakÃ³w"><a class="header" href="#krojenie-ciÄ…gÃ³w-znakÃ³w">Krojenie ciÄ…gÃ³w znakÃ³w</a></h3>
<p>Indeksowanie ciÄ…gu znakÃ³w jest czÄ™sto zÅ‚ym pomysÅ‚em, poniewaÅ¼ nie jest jasne, jaki powinien byÄ‡ typ zwracany przez operacjÄ™ indeksowania ciÄ…gu znakÃ³w: wartoÅ›Ä‡ bajtowa, znak, klaster grafemÃ³w czy wycinek ciÄ…gu znakÃ³w. JeÅ›li naprawdÄ™ potrzebujesz uÅ¼ywaÄ‡ indeksÃ³w do tworzenia wycinkÃ³w ciÄ…gu znakÃ³w, Rust prosi o wiÄ™kszÄ… precyzjÄ™.</p>
<p>Zamiast indeksowania za pomocÄ… <code>[]</code> z pojedynczÄ… liczbÄ…, moÅ¼esz uÅ¼yÄ‡ <code>[]</code> z zakresem, aby utworzyÄ‡ wycinek ciÄ…gu znakÃ³w zawierajÄ…cy okreÅ›lone bajty:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = "Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ";

let s = &amp;hello[0..4];
<span class="boring">}</span></code></pre>
<p>W tym przypadku <code>s</code> bÄ™dzie <code>&amp;str</code>, ktÃ³ry zawiera pierwsze 4 bajty ciÄ…gu. WczeÅ›niej wspomnieliÅ›my, Å¼e kaÅ¼dy z tych znakÃ³w miaÅ‚ 2 bajty, co oznacza, Å¼e <code>s</code> bÄ™dzie <code>Ğ—Ğ´</code>.</p>
<p>GdybyÅ›my sprÃ³bowali podzieliÄ‡ tylko czÄ™Å›Ä‡ bajtÃ³w znaku za pomocÄ… czegoÅ› takiego jak <code>&amp;hello[0..1]</code>, Rust panikowaÅ‚by w czasie wykonywania w taki sam sposÃ³b, jakbyÅ›my uzyskali dostÄ™p do nieprawidÅ‚owego indeksu w wektorze:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`

thread 'main' panicked at src/main.rs:4:19:
byte index 1 is not a char boundary; it is inside 'Ğ—' (bytes 0..2) of `Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>PowinieneÅ› zachowaÄ‡ ostroÅ¼noÅ›Ä‡ podczas tworzenia wycinkÃ³w ciÄ…gÃ³w znakÃ³w za pomocÄ… zakresÃ³w, poniewaÅ¼ moÅ¼e to spowodowaÄ‡ awariÄ™ programu.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="methods-for-iterating-over-strings"></a></p>
<h3 id="iterowanie-po-ciÄ…gach-znakÃ³w"><a class="header" href="#iterowanie-po-ciÄ…gach-znakÃ³w">Iterowanie po ciÄ…gach znakÃ³w</a></h3>
<p>Najlepszym sposobem na operowanie na fragmentach ciÄ…gÃ³w znakÃ³w jest wyraÅºne okreÅ›lenie, czy chcemy znakÃ³w, czy bajtÃ³w. W przypadku pojedynczych skalarnych wartoÅ›ci Unicode, uÅ¼yj metody <code>chars</code>. WywoÅ‚anie <code>chars</code> na â€Ğ—Ğ´â€ rozdziela i zwraca dwie wartoÅ›ci typu <code>char</code>, i moÅ¼esz iterowaÄ‡ po wyniku, aby uzyskaÄ‡ dostÄ™p do kaÅ¼dego elementu:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in "Ğ—Ğ´".chars() {
    println!("{c}");
}
<span class="boring">}</span></code></pre>
<p>Ten kod wydrukuje nastÄ™pujÄ…ce:</p>
<pre><code class="language-text">Ğ—
Ğ´
</code></pre>
<p>Alternatywnie, metoda <code>bytes</code> zwraca kaÅ¼dy surowy bajt, co moÅ¼e byÄ‡ odpowiednie dla twojej domeny:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in "Ğ—Ğ´".bytes() {
    println!("{b}");
}
<span class="boring">}</span></code></pre>
<p>Ten kod wydrukuje 4 bajty, ktÃ³re skÅ‚adajÄ… siÄ™ na ten ciÄ…g znakÃ³w:</p>
<pre><code class="language-text">208
151
208
180
</code></pre>
<p>Ale pamiÄ™taj, Å¼e prawidÅ‚owe skalarne wartoÅ›ci Unicode mogÄ… skÅ‚adaÄ‡ siÄ™ z wiÄ™cej niÅ¼ 1 bajta.</p>
<p>Uzyskiwanie klastrÃ³w grafemÃ³w z ciÄ…gÃ³w znakÃ³w, tak jak w przypadku pisma dewanagari, jest zÅ‚oÅ¼one, dlatego ta funkcjonalnoÅ›Ä‡ nie jest dostarczana przez standardowÄ… bibliotekÄ™. Skrzynki sÄ… dostÄ™pne na <a href="https://crates.io/">crates.io</a><!-- ignore -->, jeÅ›li to jest funkcjonalnoÅ›Ä‡, ktÃ³rej potrzebujesz.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="strings-are-not-so-simple"></a></p>
<h3 id="obsÅ‚uga-zÅ‚oÅ¼onoÅ›ci-ciÄ…gÃ³w-znakÃ³w"><a class="header" href="#obsÅ‚uga-zÅ‚oÅ¼onoÅ›ci-ciÄ…gÃ³w-znakÃ³w">ObsÅ‚uga zÅ‚oÅ¼onoÅ›ci ciÄ…gÃ³w znakÃ³w</a></h3>
<p>PodsumowujÄ…c, ciÄ…gi znakÃ³w sÄ… skomplikowane. RÃ³Å¼ne jÄ™zyki programowania podejmujÄ… rÃ³Å¼ne decyzje dotyczÄ…ce tego, jak przedstawiÄ‡ tÄ™ zÅ‚oÅ¼onoÅ›Ä‡ programistom. Rust wybraÅ‚, aby prawidÅ‚owe obchodzenie siÄ™ z danymi <code>String</code> byÅ‚o domyÅ›lnym zachowaniem dla wszystkich programÃ³w Rust, co oznacza, Å¼e programiÅ›ci muszÄ… z wyprzedzeniem poÅ›wiÄ™ciÄ‡ wiÄ™cej uwagi obsÅ‚udze danych UTF-8. Ten kompromis ujawnia wiÄ™cej zÅ‚oÅ¼onoÅ›ci ciÄ…gÃ³w znakÃ³w, niÅ¼ jest to widoczne w innych jÄ™zykach programowania, ale zapobiega koniecznoÅ›ci obsÅ‚ugi bÅ‚Ä™dÃ³w zwiÄ…zanych ze znakami spoza ASCII w pÃ³Åºniejszym cyklu rozwoju.</p>
<p>DobrÄ… wiadomoÅ›ciÄ… jest to, Å¼e standardowa biblioteka oferuje wiele funkcjonalnoÅ›ci zbudowanych na typach <code>String</code> i <code>&amp;str</code>, aby pomÃ³c w prawidÅ‚owym radzeniu sobie z tymi zÅ‚oÅ¼onymi sytuacjami. Koniecznie sprawdÅº dokumentacjÄ™ pod kÄ…tem przydatnych metod, takich jak <code>contains</code> do wyszukiwania w ciÄ…gu znakÃ³w i <code>replace</code> do zastÄ™powania czÄ™Å›ci ciÄ…gu znakÃ³w innym ciÄ…giem znakÃ³w.</p>
<p>PrzejdÅºmy do czegoÅ› nieco mniej skomplikowanego: mapy haszujÄ…ce!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="przechowywanie-kluczy-z-powiÄ…zanymi-wartoÅ›ciami-w-mapach-haszujÄ…cych-1"><a href="#przechowywanie-kluczy-z-powiÄ…zanymi-wartoÅ›ciami-w-mapach-haszujÄ…cych-1" class="header">Przechowywanie kluczy z powiÄ…zanymi wartoÅ›ciami w mapach haszujÄ…cych</a></h1>
<h2 id="przechowywanie-kluczy-z-powiÄ…zanymi-wartoÅ›ciami-w-mapach-haszujÄ…cych"><a class="header" href="#przechowywanie-kluczy-z-powiÄ…zanymi-wartoÅ›ciami-w-mapach-haszujÄ…cych">Przechowywanie kluczy z powiÄ…zanymi wartoÅ›ciami w mapach haszujÄ…cych</a></h2>
<p>OstatniÄ… z naszych wspÃ³lnych kolekcji jest mapa haszujÄ…ca. Typ <code>HashMap&lt;K, V&gt;</code> przechowuje mapowanie kluczy typu <code>K</code> na wartoÅ›ci typu <code>V</code> za pomocÄ… <em>funkcji haszujÄ…cej</em>, ktÃ³ra okreÅ›la, w jaki sposÃ³b umieszcza te klucze i wartoÅ›ci w pamiÄ™ci. Wiele jÄ™zykÃ³w programowania obsÅ‚uguje tego rodzaju strukturÄ™ danych, ale czÄ™sto uÅ¼ywajÄ… innej nazwy, takiej jak <em>hash</em>, <em>map</em>, <em>object</em>, <em>hash table</em>, <em>dictionary</em> lub <em>associative array</em>, by wymieniÄ‡ tylko kilka.</p>
<p>Mapy haszujÄ…ce sÄ… przydatne, gdy chcesz wyszukiwaÄ‡ dane nie za pomocÄ… indeksu, jak w przypadku wektorÃ³w, ale za pomocÄ… klucza, ktÃ³ry moÅ¼e byÄ‡ dowolnego typu. Na przykÅ‚ad w grze moÅ¼esz Å›ledziÄ‡ wyniki kaÅ¼dej druÅ¼yny w mapie haszujÄ…cej, w ktÃ³rej kaÅ¼dy klucz to nazwa druÅ¼yny, a wartoÅ›ci to wyniki kaÅ¼dej druÅ¼yny. MajÄ…c nazwÄ™ druÅ¼yny, moÅ¼esz pobraÄ‡ jej wynik.</p>
<p>W tej sekcji omÃ³wimy podstawowe API map haszujÄ…cych, ale wiele innych dobrodziejstw kryje siÄ™ w funkcjach zdefiniowanych dla <code>HashMap&lt;K, V&gt;</code> przez standardowÄ… bibliotekÄ™. Jak zawsze, sprawdÅº dokumentacjÄ™ standardowej biblioteki, aby uzyskaÄ‡ wiÄ™cej informacji.</p>
<h3 id="tworzenie-nowej-mapy-haszujÄ…cej"><a class="header" href="#tworzenie-nowej-mapy-haszujÄ…cej">Tworzenie nowej mapy haszujÄ…cej</a></h3>
<p>Jednym ze sposobÃ³w utworzenia pustej mapy haszujÄ…cej jest uÅ¼ycie <code>new</code> i dodanie elementÃ³w za pomocÄ… <code>insert</code>. W Listing 8-20 Å›ledzimy wyniki dwÃ³ch druÅ¼yn, ktÃ³rych nazwy to <em>Niebiescy</em> i <em>Å»Ã³Å‚ci</em>. DruÅ¼yna Niebieskich zaczyna z 10 punktami, a druÅ¼yna Å»Ã³Å‚tych z 50.</p>
<listing number="8-20" caption="Tworzenie nowej mapy haszujÄ…cej i wstawianie niektÃ³rych kluczy i wartoÅ›ci">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Niebiescy"), 10);
    scores.insert(String::from("Å»Ã³Å‚ci"), 50);
<span class="boring">}</span></code></pre>
</listing>
<p>ZauwaÅ¼, Å¼e musimy najpierw <code>use</code> <code>HashMap</code> z czÄ™Å›ci kolekcji standardowej biblioteki. SpoÅ›rÃ³d naszych trzech wspÃ³lnych kolekcji, ta jest najrzadziej uÅ¼ywana, wiÄ™c nie jest ona domyÅ›lnie doÅ‚Ä…czana do zasiÄ™gu w preludium. Mapy haszujÄ…ce majÄ… rÃ³wnieÅ¼ mniejsze wsparcie ze strony standardowej biblioteki; nie ma na przykÅ‚ad wbudowanego makra do ich konstruowania.</p>
<p>Podobnie jak wektory, mapy haszujÄ…ce przechowujÄ… swoje dane na stercie. Ta <code>HashMap</code> ma klucze typu <code>String</code> i wartoÅ›ci typu <code>i32</code>. Podobnie jak wektory, mapy haszujÄ…ce sÄ… jednorodne: wszystkie klucze muszÄ… mieÄ‡ ten sam typ, a wszystkie wartoÅ›ci muszÄ… mieÄ‡ ten sam typ.</p>
<h3 id="dostÄ™p-do-wartoÅ›ci-w-mapie-haszujÄ…cej"><a class="header" href="#dostÄ™p-do-wartoÅ›ci-w-mapie-haszujÄ…cej">DostÄ™p do wartoÅ›ci w mapie haszujÄ…cej</a></h3>
<p>MoÅ¼emy pobraÄ‡ wartoÅ›Ä‡ z mapy haszujÄ…cej, podajÄ…c jej klucz do metody <code>get</code>, jak pokazano w Listing 8-21.</p>
<listing number="8-21" caption="DostÄ™p do wyniku druÅ¼yny Niebieskich przechowywanego w mapie haszujÄ…cej">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Niebiescy"), 10);
    scores.insert(String::from("Å»Ã³Å‚ci"), 50);

    let team_name = String::from("Niebiescy");
    let score = scores.get(&amp;team_name).copied().unwrap_or(0);
<span class="boring">}</span></code></pre>
</listing>
<p>Tutaj <code>score</code> bÄ™dzie miaÅ‚o wartoÅ›Ä‡ powiÄ…zanÄ… z druÅ¼ynÄ… Niebieskich, a wynik bÄ™dzie wynosiÅ‚ <code>10</code>. Metoda <code>get</code> zwraca <code>Option&lt;&amp;V&gt;</code>; jeÅ›li dla tego klucza nie ma wartoÅ›ci w mapie haszujÄ…cej, <code>get</code> zwrÃ³ci <code>None</code>. Ten program obsÅ‚uguje <code>Option</code> wywoÅ‚ujÄ…c <code>copied</code>, aby uzyskaÄ‡ <code>Option&lt;i32&gt;</code> zamiast <code>Option&lt;&amp;i32&gt;</code>, a nastÄ™pnie <code>unwrap_or</code>, aby ustawiÄ‡ <code>score</code> na zero, jeÅ›li <code>scores</code> nie ma wpisu dla klucza.</p>
<p>MoÅ¼emy iterowaÄ‡ po kaÅ¼dej parze klucz-wartoÅ›Ä‡ w mapie haszujÄ…cej w podobny sposÃ³b, jak to robimy z wektorami, uÅ¼ywajÄ…c pÄ™tli <code>for</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Niebiescy"), 10);
    scores.insert(String::from("Å»Ã³Å‚ci"), 50);

    for (key, value) in &amp;scores {
        println!("{key}: {value}");
    }
<span class="boring">}</span></code></pre>
<p>Ten kod wydrukuje kaÅ¼dÄ… parÄ™ w dowolnej kolejnoÅ›ci:</p>
<pre><code class="language-text">Å»Ã³Å‚ci: 50
Niebiescy: 10
</code></pre>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="hash-maps-and-ownership"></a></p>
<h3 id="zarzÄ…dzanie-wÅ‚asnoÅ›ciÄ…-w-mapach-haszujÄ…cych"><a class="header" href="#zarzÄ…dzanie-wÅ‚asnoÅ›ciÄ…-w-mapach-haszujÄ…cych">ZarzÄ…dzanie wÅ‚asnoÅ›ciÄ… w mapach haszujÄ…cych</a></h3>
<p>W przypadku typÃ³w implementujÄ…cych cechÄ™ <code>Copy</code>, takich jak <code>i32</code>, wartoÅ›ci sÄ… kopiowane do mapy haszujÄ…cej. W przypadku wartoÅ›ci posiadanych, takich jak <code>String</code>, wartoÅ›ci zostanÄ… przeniesione, a mapa haszujÄ…ca bÄ™dzie wÅ‚aÅ›cicielem tych wartoÅ›ci, jak pokazano w Listing 8-22.</p>
<listing number="8-22" caption="Pokazywanie, Å¼e klucze i wartoÅ›ci sÄ… wÅ‚asnoÅ›ciÄ… mapy haszujÄ…cej po ich wstawieniu">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let field_name = String::from("Ulubiony kolor");
    let field_value = String::from("Niebieski");

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // field_name i field_value sÄ… w tym momencie nieprawidÅ‚owe, sprÃ³buj ich uÅ¼yÄ‡ i
    // zobacz, jaki bÅ‚Ä…d kompilacji otrzymasz!
<span class="boring">}</span></code></pre>
</listing>
<p>Nie moÅ¼emy uÅ¼ywaÄ‡ zmiennych <code>field_name</code> i <code>field_value</code> po ich przeniesieniu do mapy haszujÄ…cej za pomocÄ… wywoÅ‚ania <code>insert</code>.</p>
<p>JeÅ›li wstawimy referencje do wartoÅ›ci do mapy haszujÄ…cej, wartoÅ›ci nie zostanÄ… przeniesione do mapy haszujÄ…cej. WartoÅ›ci, na ktÃ³re wskazujÄ… referencje, muszÄ… byÄ‡ waÅ¼ne przynajmniej tak dÅ‚ugo, jak dÅ‚ugo waÅ¼na jest mapa haszujÄ…ca. WiÄ™cej o tych problemach omÃ³wimy w sekcji <a href="#validating-references-with-lifetimes">â€Walidacja referencji za pomocÄ… czasÃ³w Å¼yciaâ€</a><!-- ignore --> w Rozdziale 10.</p>
<h3 id="aktualizowanie-mapy-haszujÄ…cej"><a class="header" href="#aktualizowanie-mapy-haszujÄ…cej">Aktualizowanie mapy haszujÄ…cej</a></h3>
<p>ChociaÅ¼ liczba par klucz-wartoÅ›Ä‡ moÅ¼e rosnÄ…Ä‡, kaÅ¼dy unikalny klucz moÅ¼e mieÄ‡ w danym momencie tylko jednÄ… powiÄ…zanÄ… wartoÅ›Ä‡ (ale nie na odwrÃ³t: na przykÅ‚ad, zarÃ³wno druÅ¼yna Niebieskich, jak i druÅ¼yna Å»Ã³Å‚tych mogÅ‚yby mieÄ‡ wartoÅ›Ä‡ <code>10</code> przechowywanÄ… w mapie haszujÄ…cej <code>scores</code>).</p>
<p>Kiedy chcesz zmieniÄ‡ dane w mapie haszujÄ…cej, musisz zdecydowaÄ‡, jak postÄ…piÄ‡ w przypadku, gdy klucz juÅ¼ ma przypisanÄ… wartoÅ›Ä‡. MoÅ¼esz zastÄ…piÄ‡ starÄ… wartoÅ›Ä‡ nowÄ…, caÅ‚kowicie ignorujÄ…c starÄ… wartoÅ›Ä‡. MoÅ¼esz zachowaÄ‡ starÄ… wartoÅ›Ä‡ i zignorowaÄ‡ nowÄ… wartoÅ›Ä‡, dodajÄ…c nowÄ… wartoÅ›Ä‡ tylko wtedy, gdy klucz <em>nie</em> ma jeszcze wartoÅ›ci. Lub moÅ¼esz poÅ‚Ä…czyÄ‡ starÄ… wartoÅ›Ä‡ i nowÄ… wartoÅ›Ä‡. Przyjrzyjmy siÄ™, jak wykonaÄ‡ kaÅ¼dÄ… z tych czynnoÅ›ci!</p>
<h4 id="nadpisywanie-wartoÅ›ci"><a class="header" href="#nadpisywanie-wartoÅ›ci">Nadpisywanie wartoÅ›ci</a></h4>
<p>JeÅ›li wstawimy klucz i wartoÅ›Ä‡ do mapy haszujÄ…cej, a nastÄ™pnie wstawimy ten sam klucz z innÄ… wartoÅ›ciÄ…, wartoÅ›Ä‡ powiÄ…zana z tym kluczem zostanie zastÄ…piona. Mimo Å¼e kod w Listing 8-23 wywoÅ‚uje <code>insert</code> dwukrotnie, mapa haszujÄ…ca bÄ™dzie zawieraÄ‡ tylko jednÄ… parÄ™ klucz-wartoÅ›Ä‡, poniewaÅ¼ dwukrotnie wstawiamy wartoÅ›Ä‡ dla klucza druÅ¼yny Niebieskich.</p>
<listing number="8-23" caption="ZastÄ™powanie wartoÅ›ci przechowywanej pod okreÅ›lonym kluczem">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Niebiescy"), 10);
    scores.insert(String::from("Niebiescy"), 25);

    println!("{scores:?}");
<span class="boring">}</span></code></pre>
</listing>
<p>Ten kod wydrukuje <code>{"Niebiescy": 25}</code>. Pierwotna wartoÅ›Ä‡ <code>10</code> zostaÅ‚a nadpisana.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="only-inserting-a-value-if-the-key-has-no-value"></a></p>
<h4 id="dodawanie-klucza-i-wartoÅ›ci-tylko-wtedy-gdy-klucz-nie-jest-obecny"><a class="header" href="#dodawanie-klucza-i-wartoÅ›ci-tylko-wtedy-gdy-klucz-nie-jest-obecny">Dodawanie klucza i wartoÅ›ci tylko wtedy, gdy klucz nie jest obecny</a></h4>
<p>CzÄ™sto sprawdza siÄ™, czy dany klucz juÅ¼ istnieje w mapie haszujÄ…cej z wartoÅ›ciÄ…, a nastÄ™pnie wykonuje nastÄ™pujÄ…ce dziaÅ‚ania: JeÅ›li klucz istnieje w mapie haszujÄ…cej, istniejÄ…ca wartoÅ›Ä‡ powinna pozostaÄ‡ taka, jaka jest; jeÅ›li klucz nie istnieje, wstawia siÄ™ go i wartoÅ›Ä‡ dla niego.</p>
<p>Mapy haszujÄ…ce posiadajÄ… specjalne API do tego celu, zwane <code>entry</code>, ktÃ³re jako parametr przyjmuje klucz, ktÃ³ry chcesz sprawdziÄ‡. WartoÅ›ciÄ… zwracanÄ… przez metodÄ™ <code>entry</code> jest enum o nazwie <code>Entry</code>, ktÃ³ry reprezentuje wartoÅ›Ä‡, ktÃ³ra moÅ¼e istnieÄ‡ lub nie. ZaÅ‚Ã³Å¼my, Å¼e chcemy sprawdziÄ‡, czy klucz dla druÅ¼yny Å»Ã³Å‚tych ma przypisanÄ… wartoÅ›Ä‡. JeÅ›li nie, chcemy wstawiÄ‡ wartoÅ›Ä‡ <code>50</code>, i to samo dla druÅ¼yny Niebieskich. UÅ¼ywajÄ…c API <code>entry</code>, kod wyglÄ…da jak w Listing 8-24.</p>
<listing number="8-24" caption="UÅ¼ycie metody `entry` do wstawiania tylko wtedy, gdy klucz nie ma jeszcze wartoÅ›ci">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from("Niebiescy"), 10);

    scores.entry(String::from("Å»Ã³Å‚ci")).or_insert(50);
    scores.entry(String::from("Niebiescy")).or_insert(50);

    println!("{scores:?}");
<span class="boring">}</span></code></pre>
</listing>
<p>Metoda <code>or_insert</code> w <code>Entry</code> jest zdefiniowana tak, aby zwracaÄ‡ mutowalnÄ… referencjÄ™ do wartoÅ›ci dla odpowiadajÄ…cego klucza <code>Entry</code>, jeÅ›li ten klucz istnieje, a jeÅ›li nie, wstawia parametr jako nowÄ… wartoÅ›Ä‡ dla tego klucza i zwraca mutowalnÄ… referencjÄ™ do nowej wartoÅ›ci. Ta technika jest znacznie czystsza niÅ¼ samodzielne pisanie logiki i, co wiÄ™cej, lepiej wspÃ³Å‚pracuje z mechanizmem sprawdzania poÅ¼yczek.</p>
<p>Uruchomienie kodu w Listing 8-24 wydrukuje <code>{"Å»Ã³Å‚ci": 50, "Niebiescy": 10}</code>. Pierwsze wywoÅ‚anie <code>entry</code> wstawi klucz dla druÅ¼yny Å»Ã³Å‚tych z wartoÅ›ciÄ… <code>50</code>, poniewaÅ¼ druÅ¼yna Å»Ã³Å‚tych nie ma jeszcze wartoÅ›ci. Drugie wywoÅ‚anie <code>entry</code> nie zmieni mapy haszujÄ…cej, poniewaÅ¼ druÅ¼yna Niebieskich ma juÅ¼ wartoÅ›Ä‡ <code>10</code>.</p>
<h4 id="aktualizowanie-wartoÅ›ci-na-podstawie-starej-wartoÅ›ci"><a class="header" href="#aktualizowanie-wartoÅ›ci-na-podstawie-starej-wartoÅ›ci">Aktualizowanie wartoÅ›ci na podstawie starej wartoÅ›ci</a></h4>
<p>Innym czÄ™stym przypadkiem uÅ¼ycia map haszujÄ…cych jest wyszukiwanie wartoÅ›ci klucza, a nastÄ™pnie aktualizowanie jej na podstawie starej wartoÅ›ci. Na przykÅ‚ad, Listing 8-25 pokazuje kod, ktÃ³ry zlicza, ile razy kaÅ¼de sÅ‚owo pojawia siÄ™ w tekÅ›cie. UÅ¼ywamy mapy haszujÄ…cej ze sÅ‚owami jako kluczami i inkrementujemy wartoÅ›Ä‡, aby Å›ledziÄ‡, ile razy widzieliÅ›my to sÅ‚owo. JeÅ›li jest to pierwszy raz, kiedy widzieliÅ›my sÅ‚owo, najpierw wstawimy wartoÅ›Ä‡ <code>0</code>.</p>
<listing number="8-25" caption="Zliczanie wystÄ…pieÅ„ sÅ‚Ã³w za pomocÄ… mapy haszujÄ…cej, ktÃ³ra przechowuje sÅ‚owa i ich liczbÄ™">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let text = "czeÅ›Ä‡ Å›wiat cudowny Å›wiat";

    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!("{map:?}");
<span class="boring">}</span></code></pre>
</listing>
<p>Ten kod wydrukuje <code>{"Å›wiat": 2, "czeÅ›Ä‡": 1, "cudowny": 1}</code>. MoÅ¼esz zobaczyÄ‡ te same pary klucz-wartoÅ›Ä‡ wydrukowane w innej kolejnoÅ›ci: przypomnij sobie z sekcji <a href="#accessing-values-in-a-hash-map">â€DostÄ™p do wartoÅ›ci w mapie haszujÄ…cejâ€</a><!-- ignore -->, Å¼e iteracja po mapie haszujÄ…cej odbywa siÄ™ w dowolnej kolejnoÅ›ci.</p>
<p>Metoda <code>split_whitespace</code> zwraca iterator po podsekcjach, rozdzielonych spacjami, wartoÅ›ci w <code>text</code>. Metoda <code>or_insert</code> zwraca mutowalnÄ… referencjÄ™ (<code>&amp;mut V</code>) do wartoÅ›ci dla okreÅ›lonego klucza. Tutaj przechowujemy tÄ™ mutowalnÄ… referencjÄ™ w zmiennej <code>count</code>, wiÄ™c aby przypisaÄ‡ do tej wartoÅ›ci, musimy najpierw dereferencjowaÄ‡ <code>count</code> za pomocÄ… gwiazdki (<code>*</code>). Mutowalna referencja wychodzi poza zasiÄ™g na koÅ„cu pÄ™tli <code>for</code>, wiÄ™c wszystkie te zmiany sÄ… bezpieczne i dozwolone przez zasady poÅ¼yczania.</p>
<h3 id="funkcje-haszujÄ…ce"><a class="header" href="#funkcje-haszujÄ…ce">Funkcje haszujÄ…ce</a></h3>
<p>DomyÅ›lnie <code>HashMap</code> uÅ¼ywa funkcji haszujÄ…cej zwanej <em>SipHash</em>, ktÃ³ra moÅ¼e zapewniÄ‡ odpornoÅ›Ä‡ na ataki typu denial-of-service (DoS) zwiÄ…zane z tabelami haszujÄ…cymi<sup class="footnote-reference" id="fr-siphash-1"><a href="#footnote-siphash">1</a></sup>. Nie jest to najszybszy dostÄ™pny algorytm haszujÄ…cy, ale kompromis miÄ™dzy lepszym bezpieczeÅ„stwem a spadkiem wydajnoÅ›ci jest tego wart. JeÅ›li profilujesz swÃ³j kod i stwierdzisz, Å¼e domyÅ›lna funkcja haszujÄ…ca jest zbyt wolna dla Twoich celÃ³w, moÅ¼esz przeÅ‚Ä…czyÄ‡ siÄ™ na innÄ… funkcjÄ™, okreÅ›lajÄ…c inny haszer. <em>Haszer</em> to typ, ktÃ³ry implementuje cechÄ™ <code>BuildHasher</code>. O cechach i sposobie ich implementacji omÃ³wimy w <a href="#definiowanie-wspÃ³lnego-zachowania-za-pomocÄ…-cech-1">Rozdziale 10</a><!-- ignore -->. Nie musisz koniecznie implementowaÄ‡ wÅ‚asnego haszera od podstaw; <a href="https://crates.io/">crates.io</a><!-- ignore --> posiada biblioteki udostÄ™pnione przez innych uÅ¼ytkownikÃ³w Rusta, ktÃ³re dostarczajÄ… haszerÃ³w implementujÄ…cych wiele popularnych algorytmÃ³w haszujÄ…cych.</p>
<h2 id="podsumowanie-7"><a class="header" href="#podsumowanie-7">Podsumowanie</a></h2>
<p>Wektory, ciÄ…gi znakÃ³w i mapy haszujÄ…ce zapewniÄ… duÅ¼Ä… funkcjonalnoÅ›Ä‡ niezbÄ™dnÄ… w programach, gdy trzeba przechowywaÄ‡, uzyskiwaÄ‡ dostÄ™p i modyfikowaÄ‡ dane. Oto kilka Ä‡wiczeÅ„, ktÃ³re powinieneÅ› byÄ‡ teraz w stanie rozwiÄ…zaÄ‡:</p>
<ol>
<li>MajÄ…c listÄ™ liczb caÅ‚kowitych, uÅ¼yj wektora i zwrÃ³Ä‡ medianÄ™ (po posortowaniu, wartoÅ›Ä‡ na Å›rodkowej pozycji) i dominantÄ™ (wartoÅ›Ä‡, ktÃ³ra wystÄ™puje najczÄ™Å›ciej; tutaj pomocna bÄ™dzie mapa haszujÄ…ca) listy.</li>
<li>PrzeksztaÅ‚Ä‡ ciÄ…gi znakÃ³w na jÄ™zyka Pig Latin. Pierwsza spÃ³Å‚gÅ‚oska kaÅ¼dego sÅ‚owa jest przenoszona na koniec sÅ‚owa i dodawane jest <em>ay</em>, wiÄ™c <em>first</em> staje siÄ™ <em>irst-fay</em>. SÅ‚owa, ktÃ³re zaczynajÄ… siÄ™ samogÅ‚oskÄ…, majÄ… dodane <em>hay</em> na koÅ„cu (<em>apple</em> staje siÄ™ <em>apple-hay</em>). PamiÄ™taj o szczegÃ³Å‚ach kodowania UTF-8!</li>
<li>KorzystajÄ…c z mapy haszujÄ…cej i wektorÃ³w, stwÃ³rz interfejs tekstowy, aby umoÅ¼liwiÄ‡ uÅ¼ytkownikowi dodawanie nazw pracownikÃ³w do dziaÅ‚u w firmie; na przykÅ‚ad â€Dodaj Sally do InÅ¼ynieriiâ€ lub â€Dodaj Amira do SprzedaÅ¼yâ€. NastÄ™pnie pozwÃ³l uÅ¼ytkownikowi pobraÄ‡ listÄ™ wszystkich osÃ³b w dziale lub wszystkich osÃ³b w firmie wedÅ‚ug dziaÅ‚u, posortowanych alfabetycznie.</li>
</ol>
<p>Dokumentacja API standardowej biblioteki opisuje metody, ktÃ³re majÄ… wektory, ciÄ…gi znakÃ³w i mapy haszujÄ…ce, ktÃ³re bÄ™dÄ… pomocne w tych Ä‡wiczeniach!</p>
<p>Przechodzimy do bardziej zÅ‚oÅ¼onych programÃ³w, w ktÃ³rych operacje mogÄ… zakoÅ„czyÄ‡ siÄ™ niepowodzeniem, wiÄ™c to idealny czas, aby omÃ³wiÄ‡ obsÅ‚ugÄ™ bÅ‚Ä™dÃ³w. Zrobimy to w nastÄ™pnej kolejnoÅ›ci!</p>
<hr>
<ol class="footnote-definition">
<li id="footnote-siphash">
<p><a href="https://en.wikipedia.org/wiki/SipHash">https://en.wikipedia.org/wiki/SipHash</a> <a href="#fr-siphash-1">â†©</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="obsÅ‚uga-bÅ‚Ä™dÃ³w"><a class="header" href="#obsÅ‚uga-bÅ‚Ä™dÃ³w">ObsÅ‚uga bÅ‚Ä™dÃ³w</a></h1>
<p>BÅ‚Ä™dy sÄ… faktem w oprogramowaniu, dlatego Rust posiada szereg funkcji do obsÅ‚ugi sytuacji, w ktÃ³rych coÅ› idzie nie tak. W wielu przypadkach Rust wymaga od Ciebie uznania moÅ¼liwoÅ›ci bÅ‚Ä™du i podjÄ™cia pewnych dziaÅ‚aÅ„, zanim TwÃ³j kod siÄ™ skompiluje. Ten wymÃ³g sprawia, Å¼e TwÃ³j program jest bardziej niezawodny, zapewniajÄ…c, Å¼e odkryjesz bÅ‚Ä™dy i obsÅ‚uÅ¼ysz je odpowiednio, zanim wdroÅ¼ysz swÃ³j kod do produkcji!</p>
<p>Rust dzieli bÅ‚Ä™dy na dwie gÅ‚Ã³wne kategorie: bÅ‚Ä™dy odzyskiwalne i nieodzyskiwalne. W przypadku <em>bÅ‚Ä™du odzyskiwalnego</em>, takiego jak bÅ‚Ä…d <em>pliku nie znaleziono</em>, najprawdopodobniej chcemy po prostu zgÅ‚osiÄ‡ problem uÅ¼ytkownikowi i ponowiÄ‡ operacjÄ™. <em>BÅ‚Ä™dy nieodzyskiwalne</em> sÄ… zawsze objawami bÅ‚Ä™dÃ³w, takich jak prÃ³ba dostÄ™pu do lokalizacji poza koÅ„cem tablicy, dlatego chcemy natychmiast zatrzymaÄ‡ program.</p>
<p>WiÄ™kszoÅ›Ä‡ jÄ™zykÃ³w nie rozrÃ³Å¼nia tych dwÃ³ch rodzajÃ³w bÅ‚Ä™dÃ³w i obsÅ‚uguje oba w ten sam sposÃ³b, uÅ¼ywajÄ…c mechanizmÃ³w takich jak wyjÄ…tki. Rust nie ma wyjÄ…tkÃ³w. Zamiast tego, ma typ <code>Result&lt;T, E&gt;</code> dla bÅ‚Ä™dÃ³w odzyskiwalnych i makro <code>panic!</code> ktÃ³re zatrzymuje wykonanie, gdy program napotka bÅ‚Ä…d nieodzyskiwalny. Ten rozdziaÅ‚ najpierw omawia wywoÅ‚ywanie <code>panic!</code>, a nastÄ™pnie mÃ³wi o zwracaniu wartoÅ›ci <code>Result&lt;T, E&gt;</code>. Dodatkowo, zbadamy rozwaÅ¼ania przy podejmowaniu decyzji, czy sprÃ³bowaÄ‡ odzyskaÄ‡ siÄ™ po bÅ‚Ä™dzie, czy zatrzymaÄ‡ wykonanie.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="nieodwracalne-bÅ‚Ä™dy-z-panic-1"><a href="#nieodwracalne-bÅ‚Ä™dy-z-panic-1" class="header">Nieodwracalne bÅ‚Ä™dy z panic!</a></h1>
<h2 id="nieodwracalne-bÅ‚Ä™dy-z-panic"><a class="header" href="#nieodwracalne-bÅ‚Ä™dy-z-panic">Nieodwracalne bÅ‚Ä™dy z <code>panic!</code></a></h2>
<p>Czasami w twoim kodzie dziejÄ… siÄ™ zÅ‚e rzeczy i nic nie moÅ¼esz na to poradziÄ‡. W takich przypadkach Rust ma makro <code>panic!</code>. W praktyce istniejÄ… dwa sposoby wywoÅ‚ania paniki: poprzez wykonanie akcji, ktÃ³ra powoduje panikÄ™ kodu (takiej jak dostÄ™p do tablicy poza jej zakresem) lub poprzez jawne wywoÅ‚anie makra <code>panic!</code>. W obu przypadkach powodujemy panikÄ™ w naszym programie. DomyÅ›lnie te paniki wyÅ›wietlÄ… komunikat o bÅ‚Ä™dzie, rozwinÄ… stos, wyczyszczÄ… stos i zakoÅ„czÄ… dziaÅ‚anie. Za pomocÄ… zmiennej Å›rodowiskowej moÅ¼esz rÃ³wnieÅ¼ sprawiÄ‡, Å¼e Rust wyÅ›wietli stos wywoÅ‚aÅ„, gdy wystÄ…pi panika, co uÅ‚atwi Å›ledzenie ÅºrÃ³dÅ‚a paniki.</p>
<blockquote>
<h3 id="rozwijanie-stosu-lub-przerywanie-dziaÅ‚ania-w-odpowiedzi-na-panikÄ™"><a class="header" href="#rozwijanie-stosu-lub-przerywanie-dziaÅ‚ania-w-odpowiedzi-na-panikÄ™">Rozwijanie stosu lub przerywanie dziaÅ‚ania w odpowiedzi na panikÄ™</a></h3>
<p>DomyÅ›lnie, gdy wystÄ…pi panika, program zaczyna siÄ™ <em>rozwijaÄ‡</em>, co oznacza, Å¼e Rust cofa siÄ™ po stosie i czyÅ›ci dane z kaÅ¼dej napotkanej funkcji. Jednak cofanie siÄ™ i czyszczenie to duÅ¼o pracy. Rust pozwala zatem wybraÄ‡ alternatywÄ™ natychmiastowego <em>przerwania</em>, ktÃ³re koÅ„czy program bez czyszczenia.</p>
<p>PamiÄ™Ä‡ uÅ¼ywana przez program bÄ™dzie musiaÅ‚a zostaÄ‡ wyczyszczona przez system operacyjny. JeÅ›li w twoim projekcie musisz sprawiÄ‡, aby wynikowy plik binarny byÅ‚ jak najmniejszy, moÅ¼esz przeÅ‚Ä…czyÄ‡ siÄ™ z rozwijania na przerwanie po panice, dodajÄ…c <code>panic = 'abort'</code> do odpowiednich sekcji <code>[profile]</code> w pliku <em>Cargo.toml</em>. Na przykÅ‚ad, jeÅ›li chcesz przerwaÄ‡ dziaÅ‚anie po panice w trybie wydania, dodaj to:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>SprÃ³bujmy wywoÅ‚aÄ‡ <code>panic!</code> w prostym programie:</p>
<listing file-name="src/main.rs">
<pre class="playground"><code class="language-rust should_panic panics edition2024">fn main() {
    panic!("awaria i spalenie");
}</code></pre>
</listing>
<p>Po uruchomieniu programu zobaczysz coÅ› takiego:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`

thread 'main' panicked at src/main.rs:2:5:
crash and burn
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>WywoÅ‚anie <code>panic!</code> powoduje komunikat o bÅ‚Ä™dzie zawarty w ostatnich dwÃ³ch liniach. Pierwsza linia pokazuje nasz komunikat paniki i miejsce w kodzie ÅºrÃ³dÅ‚owym, gdzie nastÄ…piÅ‚a panika: <em>src/main.rs:2:5</em> wskazuje, Å¼e jest to druga linia, piÄ…ty znak naszego pliku <em>src/main.rs</em>.</p>
<p>W tym przypadku wskazana linia jest czÄ™Å›ciÄ… naszego kodu, a jeÅ›li przejdziemy do tej linii, zobaczymy wywoÅ‚anie makra <code>panic!</code>. W innych przypadkach wywoÅ‚anie <code>panic!</code> moÅ¼e znajdowaÄ‡ siÄ™ w kodzie, ktÃ³ry wywoÅ‚uje nasz kod, a nazwa pliku i numer linii zgÅ‚oszone przez komunikat o bÅ‚Ä™dzie bÄ™dÄ… kodem kogoÅ› innego, gdzie wywoÅ‚ano makro <code>panic!</code>, a nie liniÄ… naszego kodu, ktÃ³ra ostatecznie doprowadziÅ‚a do wywoÅ‚ania <code>panic!</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="using-a-panic-backtrace"></a></p>
<p>MoÅ¼emy uÅ¼yÄ‡ Å›ledzenia stosu funkcji, z ktÃ³rych pochodzi wywoÅ‚anie <code>panic!</code>, aby ustaliÄ‡, ktÃ³ra czÄ™Å›Ä‡ naszego kodu powoduje problem. Aby zrozumieÄ‡, jak uÅ¼ywaÄ‡ Å›ledzenia stosu <code>panic!</code>, przyjrzyjmy siÄ™ innemu przykÅ‚adowi i zobaczmy, jak to wyglÄ…da, gdy wywoÅ‚anie <code>panic!</code> pochodzi z biblioteki z powodu bÅ‚Ä™du w naszym kodzie, a nie z naszego kodu bezpoÅ›rednio wywoÅ‚ujÄ…cego makro. Listing 9-1 zawiera kod, ktÃ³ry prÃ³buje uzyskaÄ‡ dostÄ™p do indeksu w wektorze poza zakresem prawidÅ‚owych indeksÃ³w.</p>
<listing number="9-1" file-name="src/main.rs" caption="PrÃ³ba dostÄ™pu do elementu poza koÅ„cem wektora, co spowoduje wywoÅ‚anie `panic!`">
<pre class="playground"><code class="language-rust should_panic panics edition2024">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}</code></pre>
</listing>
<p>Tutaj prÃ³bujemy uzyskaÄ‡ dostÄ™p do 100. elementu naszego wektora (ktÃ³ry znajduje siÄ™ pod indeksem 99, poniewaÅ¼ indeksowanie zaczyna siÄ™ od zera), ale wektor ma tylko trzy elementy. W tej sytuacji Rust wywoÅ‚a panikÄ™. UÅ¼ycie <code>[]</code> ma zwrÃ³ciÄ‡ element, ale jeÅ›li podasz nieprawidÅ‚owy indeks, Rust nie mÃ³gÅ‚by zwrÃ³ciÄ‡ Å¼adnego prawidÅ‚owego elementu.</p>
<p>W C, prÃ³ba odczytu poza koÅ„cem struktury danych jest niezdefiniowanym zachowaniem. MoÅ¼esz otrzymaÄ‡ cokolwiek, co znajduje siÄ™ w miejscu w pamiÄ™ci, ktÃ³re odpowiadaÅ‚oby temu elementowi w strukturze danych, mimo Å¼e pamiÄ™Ä‡ nie naleÅ¼y do tej struktury. Nazywa siÄ™ to <em>przepeÅ‚nieniem bufora</em> i moÅ¼e prowadziÄ‡ do luk w zabezpieczeniach, jeÅ›li atakujÄ…cy jest w stanie manipulowaÄ‡ indeksem w taki sposÃ³b, aby odczytaÄ‡ dane, do ktÃ³rych nie powinien mieÄ‡ dostÄ™pu, a ktÃ³re sÄ… przechowywane po strukturze danych.</p>
<p>Aby chroniÄ‡ program przed tego rodzaju lukami, jeÅ›li sprÃ³bujesz odczytaÄ‡ element o indeksie, ktÃ³ry nie istnieje, Rust zatrzyma wykonanie i odmÃ³wi kontynuowania. SprÃ³bujmy i zobaczmy:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`

thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Ten bÅ‚Ä…d wskazuje na liniÄ™ 4 naszego <em>main.rs</em>, gdzie prÃ³bujemy uzyskaÄ‡ dostÄ™p do indeksu 99 wektora w <code>v</code>.</p>
<p>Linia <code>note:</code> mÃ³wi nam, Å¼e moÅ¼emy ustawiÄ‡ zmiennÄ… Å›rodowiskowÄ… <code>RUST_BACKTRACE</code> na dowolnÄ… wartoÅ›Ä‡ innÄ… niÅ¼ <code>0</code>, aby uzyskaÄ‡ Å›ledzenie stosu (backtrace) dokÅ‚adnie tego, co siÄ™ staÅ‚o, aby spowodowaÄ‡ bÅ‚Ä…d. <em>Åšledzenie stosu</em> to lista wszystkich funkcji, ktÃ³re zostaÅ‚y wywoÅ‚ane, aby dojÅ›Ä‡ do tego punktu. Åšledzenia stosu w Rust dziaÅ‚ajÄ… tak samo jak w innych jÄ™zykach: kluczem do odczytania Å›ledzenia stosu jest rozpoczÄ™cie od gÃ³ry i czytanie, aÅ¼ zobaczysz pliki, ktÃ³re napisaÅ‚eÅ›. To jest miejsce, w ktÃ³rym problem siÄ™ rozpoczÄ…Å‚. Linie powyÅ¼ej tego miejsca to kod, ktÃ³ry wywoÅ‚aÅ‚ TwÃ³j kod; linie poniÅ¼ej to kod, ktÃ³ry wywoÅ‚aÅ‚ TwÃ³j kod. Te linie przed i po mogÄ… zawieraÄ‡ podstawowy kod Rust, kod standardowej biblioteki lub skrzynki, ktÃ³rych uÅ¼ywasz. SprÃ³bujmy uzyskaÄ‡ Å›ledzenie stosu, ustawiajÄ…c zmiennÄ… Å›rodowiskowÄ… <code>RUST_BACKTRACE</code> na dowolnÄ… wartoÅ›Ä‡ innÄ… niÅ¼ <code>0</code>. Listing 9-2 pokazuje wyjÅ›cie podobne do tego, co zobaczysz.</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/listing-09-01
RUST_BACKTRACE=1 cargo run
copy the backtrace output below
check the backtrace number mentioned in the text below the listing
-->
<listing number="9-2" caption="Åšledzenie stosu wygenerowane przez wywoÅ‚anie `panic!`, wyÅ›wietlane, gdy zmienna Å›rodowiskowa `RUST_BACKTRACE` jest ustawiona">
<pre><code class="language-console">$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
stack backtrace:
   0: rust_begin_unwind
             at /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/panicking.rs:692:5
   1: core::panicking::panic_fmt
             at /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/panicking.rs:75:14
   2: core::panicking::panic_bounds_check
             at /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/panicking.rs:273:5
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/slice/index.rs:274:10
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/slice/index.rs:16:9
   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3361:9
   6: panic::main
             at ./src/main.rs:4:6
   7: core::ops::function::FnOnce::call_once
             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/ops/function.rs:250:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
</listing>
<p>To duÅ¼o danych wyjÅ›ciowych! DokÅ‚adne dane wyjÅ›ciowe mogÄ… siÄ™ rÃ³Å¼niÄ‡ w zaleÅ¼noÅ›ci od systemu operacyjnego i wersji Rusta. Aby uzyskaÄ‡ Å›ledzenia stosu z tymi informacjami, symbole debugowania muszÄ… byÄ‡ wÅ‚Ä…czone. Symbole debugowania sÄ… domyÅ›lnie wÅ‚Ä…czone przy uÅ¼yciu <code>cargo build</code> lub <code>cargo run</code> bez flagi <code>--release</code>, jak to zrobiliÅ›my tutaj.</p>
<p>W danych wyjÅ›ciowych w Listing 9-2, linia 6 Å›ledzenia stosu wskazuje na liniÄ™ w naszym projekcie, ktÃ³ra powoduje problem: linia 4 pliku <em>src/main.rs</em>. JeÅ›li nie chcemy, aby nasz program panikowaÅ‚, powinniÅ›my rozpoczÄ…Ä‡ nasze dochodzenie w miejscu wskazanym przez pierwszÄ… liniÄ™ wspomniajÄ…cÄ… o pliku, ktÃ³ry napisaliÅ›my. W Listing 9-1, gdzie celowo napisaliÅ›my kod, ktÃ³ry wywoÅ‚aÅ‚by panikÄ™, sposobem na naprawienie paniki jest nie Å¼Ä…danie elementu poza zakresem indeksÃ³w wektora. Gdy TwÃ³j kod panikuje w przyszÅ‚oÅ›ci, bÄ™dziesz musiaÅ‚ dowiedzieÄ‡ siÄ™, jakÄ… akcjÄ™ podejmuje kod z jakimi wartoÅ›ciami, aby spowodowaÄ‡ panikÄ™, i co kod powinien zrobiÄ‡ zamiast tego.</p>
<p>PowrÃ³cimy do <code>panic!</code> i do tego, kiedy powinniÅ›my, a kiedy nie powinniÅ›my uÅ¼ywaÄ‡ <code>panic!</code> do obsÅ‚ugi warunkÃ³w bÅ‚Ä™du, w sekcji <a href="#to-panic-or-not-to-panic">â€PanikowaÄ‡ czy nie panikowaÄ‡!â€</a><!-- ignore --> w dalszej czÄ™Å›ci tego rozdziaÅ‚u. NastÄ™pnie przyjrzymy siÄ™, jak odzyskaÄ‡ siÄ™ po bÅ‚Ä™dzie za pomocÄ… <code>Result</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="bÅ‚Ä™dy-odzyskiwalne-za-pomocÄ…-result-1"><a href="#bÅ‚Ä™dy-odzyskiwalne-za-pomocÄ…-result-1" class="header">BÅ‚Ä™dy odzyskiwalne za pomocÄ… Result</a></h1>
<h2 id="bÅ‚Ä™dy-odzyskiwalne-za-pomocÄ…-result"><a class="header" href="#bÅ‚Ä™dy-odzyskiwalne-za-pomocÄ…-result">BÅ‚Ä™dy odzyskiwalne za pomocÄ… <code>Result</code></a></h2>
<p>WiÄ™kszoÅ›Ä‡ bÅ‚Ä™dÃ³w nie jest na tyle powaÅ¼na, aby wymagaÄ‡ caÅ‚kowitego zatrzymania programu. Czasami, gdy funkcja zawodzi, dzieje siÄ™ tak z powodu, ktÃ³ry moÅ¼na Å‚atwo zinterpretowaÄ‡ i na niego zareagowaÄ‡. Na przykÅ‚ad, jeÅ›li prÃ³bujesz otworzyÄ‡ plik, a ta operacja koÅ„czy siÄ™ niepowodzeniem, poniewaÅ¼ plik nie istnieje, moÅ¼esz chcieÄ‡ utworzyÄ‡ plik zamiast zakoÅ„czyÄ‡ proces.</p>
<p>Przypomnij sobie z sekcji <a href="#handling-potential-failure-with-result">â€ObsÅ‚uga potencjalnych awarii za pomocÄ… <code>Result</code>â€</a><!-- ignore --> w Rozdziale 2, Å¼e enum <code>Result</code> jest zdefiniowany tak, aby miaÅ‚ dwa warianty, <code>Ok</code> i <code>Err</code>, w nastÄ™pujÄ…cy sposÃ³b:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre>
<p><code>T</code> i <code>E</code> to generyczne parametry typu: bardziej szczegÃ³Å‚owo omÃ³wimy generyki w Rozdziale 10. To, co musisz teraz wiedzieÄ‡, to to, Å¼e <code>T</code> reprezentuje typ wartoÅ›ci, ktÃ³ra zostanie zwrÃ³cona w przypadku sukcesu w wariancie <code>Ok</code>, a <code>E</code> reprezentuje typ bÅ‚Ä™du, ktÃ³ry zostanie zwrÃ³cony w przypadku niepowodzenia w wariancie <code>Err</code>. PoniewaÅ¼ <code>Result</code> ma te generyczne parametry typu, moÅ¼emy uÅ¼ywaÄ‡ typu <code>Result</code> i zdefiniowanych na nim funkcji w wielu rÃ³Å¼nych sytuacjach, gdy wartoÅ›Ä‡ sukcesu i wartoÅ›Ä‡ bÅ‚Ä™du, ktÃ³rÄ… chcemy zwrÃ³ciÄ‡, mogÄ… siÄ™ rÃ³Å¼niÄ‡.</p>
<p>WywoÅ‚ajmy funkcjÄ™, ktÃ³ra zwraca wartoÅ›Ä‡ <code>Result</code>, poniewaÅ¼ funkcja moÅ¼e zawieÅ›Ä‡. W Listing 9-3 prÃ³bujemy otworzyÄ‡ plik.</p>
<listing number="9-3" file-name="src/main.rs" caption="Otwieranie pliku">
<pre class="playground"><code class="language-rust edition2024">use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");
}</code></pre>
</listing>
<p>Typ zwracany przez <code>File::open</code> to <code>Result&lt;T, E&gt;</code>. Generyczny parametr <code>T</code> zostaÅ‚ wypeÅ‚niony przez implementacjÄ™ <code>File::open</code> typem wartoÅ›ci sukcesu, <code>std::fs::File</code>, ktÃ³ry jest uchwytem pliku. Typ <code>E</code> uÅ¼ywany w wartoÅ›ci bÅ‚Ä™du to <code>std::io::Error</code>. Ten typ zwracany oznacza, Å¼e wywoÅ‚anie <code>File::open</code> moÅ¼e zakoÅ„czyÄ‡ siÄ™ sukcesem i zwrÃ³ciÄ‡ uchwyt pliku, z ktÃ³rego moÅ¼emy czytaÄ‡ lub do ktÃ³rego moÅ¼emy pisaÄ‡. WywoÅ‚anie funkcji moÅ¼e rÃ³wnieÅ¼ zakoÅ„czyÄ‡ siÄ™ niepowodzeniem: na przykÅ‚ad plik moÅ¼e nie istnieÄ‡ lub moÅ¼emy nie mieÄ‡ uprawnieÅ„ do dostÄ™pu do pliku. Funkcja <code>File::open</code> musi mieÄ‡ sposÃ³b, aby poinformowaÄ‡ nas, czy zakoÅ„czyÅ‚a siÄ™ sukcesem, czy niepowodzeniem, i jednoczeÅ›nie podaÄ‡ nam uchwyt pliku lub informacje o bÅ‚Ä™dzie. Te informacje to dokÅ‚adnie to, co przekazuje enum <code>Result</code>.</p>
<p>W przypadku, gdy <code>File::open</code> zakoÅ„czy siÄ™ sukcesem, wartoÅ›Ä‡ w zmiennej <code>greeting_file_result</code> bÄ™dzie instancjÄ… <code>Ok</code>, ktÃ³ra zawiera uchwyt pliku. W przypadku, gdy zawiedzie, wartoÅ›Ä‡ w <code>greeting_file_result</code> bÄ™dzie instancjÄ… <code>Err</code>, ktÃ³ra zawiera wiÄ™cej informacji o rodzaju bÅ‚Ä™du, ktÃ³ry wystÄ…piÅ‚.</p>
<p>Musimy uzupeÅ‚niÄ‡ kod w Listing 9-3, aby podejmowaÄ‡ rÃ³Å¼ne dziaÅ‚ania w zaleÅ¼noÅ›ci od wartoÅ›ci zwracanej przez <code>File::open</code>. Listing 9-4 pokazuje jeden ze sposobÃ³w obsÅ‚ugi <code>Result</code> za pomocÄ… podstawowego narzÄ™dzia, wyraÅ¼enia <code>match</code>, ktÃ³re omÃ³wiliÅ›my w Rozdziale 6.</p>
<listing number="9-4" file-name="src/main.rs" caption="UÅ¼ycie wyraÅ¼enia `match` do obsÅ‚ugi wariantÃ³w `Result`, ktÃ³re mogÄ… zostaÄ‡ zwrÃ³cone">
<pre class="playground"><code class="language-rust should_panic edition2024">use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!("Problem z otwarciem pliku: {error:?}"),
    };
}</code></pre>
</listing>
<p>ZauwaÅ¼, Å¼e, podobnie jak enum <code>Option</code>, enum <code>Result</code> i jego warianty zostaÅ‚y wprowadzone do zasiÄ™gu przez preludium, wiÄ™c nie musimy okreÅ›laÄ‡ <code>Result::</code> przed wariantami <code>Ok</code> i <code>Err</code> w ramionach <code>match</code>.</p>
<p>Kiedy wynik jest <code>Ok</code>, ten kod zwrÃ³ci wewnÄ™trznÄ… wartoÅ›Ä‡ <code>file</code> z wariantu <code>Ok</code>, a nastÄ™pnie przypisujemy tÄ™ wartoÅ›Ä‡ uchwytu pliku do zmiennej <code>greeting_file</code>. Po <code>match</code> moÅ¼emy uÅ¼yÄ‡ uchwytu pliku do odczytu lub zapisu.</p>
<p>Drugie ramiÄ™ <code>match</code> obsÅ‚uguje przypadek, w ktÃ³rym otrzymujemy wartoÅ›Ä‡ <code>Err</code> z <code>File::open</code>. W tym przykÅ‚adzie zdecydowaliÅ›my siÄ™ wywoÅ‚aÄ‡ makro <code>panic!</code>. JeÅ›li w naszym bieÅ¼Ä…cym katalogu nie ma pliku o nazwie <em>hello.txt</em> i uruchomimy ten kod, zobaczymy nastÄ™pujÄ…ce dane wyjÅ›ciowe z makra <code>panic!</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`

thread 'main' panicked at src/main.rs:8:23:
Problem opening the file: Os { code: 2, kind: NotFound, message: "No such file or directory" }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Jak zwykle, to wyjÅ›cie mÃ³wi nam dokÅ‚adnie, co poszÅ‚o nie tak.</p>
<h3 id="dopasowywanie-rÃ³Å¼nych-bÅ‚Ä™dÃ³w"><a class="header" href="#dopasowywanie-rÃ³Å¼nych-bÅ‚Ä™dÃ³w">Dopasowywanie rÃ³Å¼nych bÅ‚Ä™dÃ³w</a></h3>
<p>Kod w Listing 9-4 spowoduje <code>panic!</code> niezaleÅ¼nie od tego, dlaczego <code>File::open</code> zakoÅ„czyÅ‚o siÄ™ niepowodzeniem. My jednak chcemy podejmowaÄ‡ rÃ³Å¼ne dziaÅ‚ania z rÃ³Å¼nych powodÃ³w awarii. JeÅ›li <code>File::open</code> zakoÅ„czyÅ‚o siÄ™ niepowodzeniem, poniewaÅ¼ plik nie istnieje, chcemy utworzyÄ‡ plik i zwrÃ³ciÄ‡ uchwyt do nowego pliku. JeÅ›li <code>File::open</code> zakoÅ„czyÅ‚o siÄ™ niepowodzeniem z jakiegokolwiek innego powodu â€” na przykÅ‚ad, poniewaÅ¼ nie mieliÅ›my uprawnieÅ„ do otwarcia pliku â€” nadal chcemy, aby kod spowodowaÅ‚ <code>panic!</code> w ten sam sposÃ³b, jak w Listing 9-4. W tym celu dodajemy wewnÄ™trzne wyraÅ¼enie <code>match</code>, pokazane w Listing 9-5.</p>
<listing number="9-5" file-name="src/main.rs" caption="ObsÅ‚uga rÃ³Å¼nych rodzajÃ³w bÅ‚Ä™dÃ³w na rÃ³Å¼ne sposoby">
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create("hello.txt") {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!("Problem z tworzeniem pliku: {e:?}"),
            },
            _ =&gt; {
                panic!("Problem z otwarciem pliku: {error:?}");
            }
        },
    };
}</code></pre>
</listing>
<p>Typ wartoÅ›ci zwracanej przez <code>File::open</code> w wariancie <code>Err</code> to <code>io::Error</code>, ktÃ³ry jest strukturÄ… dostarczanÄ… przez standardowÄ… bibliotekÄ™. Ta struktura posiada metodÄ™ <code>kind</code>, ktÃ³rÄ… moÅ¼emy wywoÅ‚aÄ‡, aby uzyskaÄ‡ wartoÅ›Ä‡ <code>io::ErrorKind</code>. Enum <code>io::ErrorKind</code> jest dostarczany przez standardowÄ… bibliotekÄ™ i ma warianty reprezentujÄ…ce rÃ³Å¼ne rodzaje bÅ‚Ä™dÃ³w, ktÃ³re mogÄ… wynikaÄ‡ z operacji <code>io</code>. Wariant, ktÃ³rego chcemy uÅ¼yÄ‡, to <code>ErrorKind::NotFound</code>, ktÃ³ry wskazuje, Å¼e plik, ktÃ³ry prÃ³bujemy otworzyÄ‡, jeszcze nie istnieje. Zatem dopasowujemy <code>greeting_file_result</code>, ale mamy rÃ³wnieÅ¼ wewnÄ™trzne dopasowanie na <code>error.kind()</code>.</p>
<p>Warunkiem, ktÃ³ry chcemy sprawdziÄ‡ w wewnÄ™trznym dopasowaniu, jest to, czy wartoÅ›Ä‡ zwrÃ³cona przez <code>error.kind()</code> jest wariantem <code>NotFound</code> enum <code>ErrorKind</code>. JeÅ›li tak, prÃ³bujemy utworzyÄ‡ plik za pomocÄ… <code>File::create</code>. JednakÅ¼e, poniewaÅ¼ <code>File::create</code> rÃ³wnieÅ¼ moÅ¼e zakoÅ„czyÄ‡ siÄ™ niepowodzeniem, potrzebujemy drugiego ramienia w wewnÄ™trznym wyraÅ¼eniu <code>match</code>. Kiedy plik nie moÅ¼e zostaÄ‡ utworzony, wyÅ›wietlany jest inny komunikat o bÅ‚Ä™dzie. Drugie ramiÄ™ zewnÄ™trznego <code>match</code> pozostaje takie samo, wiÄ™c program panikuje przy kaÅ¼dym bÅ‚Ä™dzie innym niÅ¼ bÅ‚Ä…d braku pliku.</p>
<blockquote>
<h4 id="alternatywy-dla-uÅ¼ywania-match-z-resultt-e"><a class="header" href="#alternatywy-dla-uÅ¼ywania-match-z-resultt-e">Alternatywy dla uÅ¼ywania <code>match</code> z <code>Result&lt;T, E&gt;</code></a></h4>
<p>To duÅ¼o <code>match</code>! WyraÅ¼enie <code>match</code> jest bardzo przydatne, ale takÅ¼e bardzo prymitywne. W Rozdziale 13 poznasz domkniÄ™cia, ktÃ³re sÄ… uÅ¼ywane z wieloma metodami zdefiniowanymi dla <code>Result&lt;T, E&gt;</code>. Te metody mogÄ… byÄ‡ bardziej zwiÄ™zÅ‚e niÅ¼ uÅ¼ywanie <code>match</code> podczas obsÅ‚ugi wartoÅ›ci <code>Result&lt;T, E&gt;</code> w Twoim kodzie.</p>
<p>Na przykÅ‚ad, oto inny sposÃ³b napisania tej samej logiki, jak pokazano w Listing 9-5, tym razem uÅ¼ywajÄ…c domkniÄ™Ä‡ i metody <code>unwrap_or_else</code>:</p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem z tworzeniem pliku: {error:?}");
            })
        } else {
            panic!("Problem z otwarciem pliku: {error:?}");
        }
    });
}</code></pre>
<p>ChociaÅ¼ ten kod ma takie samo zachowanie jak Listing 9-5, nie zawiera Å¼adnych wyraÅ¼eÅ„ <code>match</code> i jest czytelniejszy. WrÃ³Ä‡ do tego przykÅ‚adu po przeczytaniu RozdziaÅ‚u 13 i wyszukaj metodÄ™ <code>unwrap_or_else</code> w dokumentacji standardowej biblioteki. Wiele innych z tych metod moÅ¼e uporzÄ…dkowaÄ‡ ogromne, zagnieÅ¼dÅ¼one wyraÅ¼enia <code>match</code>, gdy masz do czynienia z bÅ‚Ä™dami.</p>
</blockquote>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="shortcuts-for-panic-on-error-unwrap-and-expect"></a></p>
<h4 id="skrÃ³ty-do-paniki-przy-bÅ‚Ä™dzie-unwrap-i-expect"><a class="header" href="#skrÃ³ty-do-paniki-przy-bÅ‚Ä™dzie-unwrap-i-expect">SkrÃ³ty do paniki przy bÅ‚Ä™dzie: <code>unwrap</code> i <code>expect</code></a></h4>
<p>UÅ¼ycie <code>match</code> dziaÅ‚a wystarczajÄ…co dobrze, ale moÅ¼e byÄ‡ nieco gadatliwe i nie zawsze dobrze komunikuje intencje. Typ <code>Result&lt;T, E&gt;</code> ma wiele pomocniczych metod zdefiniowanych na nim do wykonywania rÃ³Å¼nych, bardziej specyficznych zadaÅ„. Metoda <code>unwrap</code> jest skrÃ³tem zaimplementowanym tak samo jak wyraÅ¼enie <code>match</code>, ktÃ³re napisaliÅ›my w Listing 9-4. JeÅ›li wartoÅ›Ä‡ <code>Result</code> jest wariantem <code>Ok</code>, <code>unwrap</code> zwrÃ³ci wartoÅ›Ä‡ wewnÄ…trz <code>Ok</code>. JeÅ›li <code>Result</code> jest wariantem <code>Err</code>, <code>unwrap</code> wywoÅ‚a dla nas makro <code>panic!</code>. Oto przykÅ‚ad <code>unwrap</code> w dziaÅ‚aniu:</p>
<listing file-name="src/main.rs">
<pre class="playground"><code class="language-rust should_panic edition2024">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}</code></pre>
</listing>
<p>JeÅ›li uruchomimy ten kod bez pliku <em>hello.txt</em>, zobaczymy komunikat o bÅ‚Ä™dzie z wywoÅ‚ania <code>panic!</code>, ktÃ³re wykonuje metoda <code>unwrap</code>:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-04-unwrap
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at src/main.rs:4:49:
called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: "No such file or directory" }
</code></pre>
<p>Podobnie, metoda <code>expect</code> pozwala nam rÃ³wnieÅ¼ wybraÄ‡ komunikat o bÅ‚Ä™dzie <code>panic!</code>. UÅ¼ycie <code>expect</code> zamiast <code>unwrap</code> i dostarczenie dobrych komunikatÃ³w o bÅ‚Ä™dach moÅ¼e przekazaÄ‡ twoje intencje i uÅ‚atwiÄ‡ Å›ledzenie ÅºrÃ³dÅ‚a paniki. SkÅ‚adnia <code>expect</code> wyglÄ…da tak:</p>
<listing file-name="src/main.rs">
<pre class="playground"><code class="language-rust should_panic edition2024">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt powinien byÄ‡ doÅ‚Ä…czony do tego projektu");
}</code></pre>
</listing>
<p>UÅ¼ywamy <code>expect</code> w ten sam sposÃ³b co <code>unwrap</code>: aby zwrÃ³ciÄ‡ uchwyt pliku lub wywoÅ‚aÄ‡ makro <code>panic!</code>. Komunikat o bÅ‚Ä™dzie uÅ¼ywany przez <code>expect</code> w jego wywoÅ‚aniu <code>panic!</code> bÄ™dzie parametrem, ktÃ³ry przekazujemy do <code>expect</code>, zamiast domyÅ›lnego komunikatu <code>panic!</code>, ktÃ³rego uÅ¼ywa <code>unwrap</code>. Oto jak to wyglÄ…da:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-05-expect
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at src/main.rs:5:10:
hello.txt should be included in this project: Os { code: 2, kind: NotFound, message: "No such file or directory" }
</code></pre>
<p>W kodzie produkcyjnym wiÄ™kszoÅ›Ä‡ Rustacean preferuje <code>expect</code> zamiast <code>unwrap</code> i podaje wiÄ™cej kontekstu, dlaczego operacja ma zawsze zakoÅ„czyÄ‡ siÄ™ sukcesem. W ten sposÃ³b, jeÅ›li twoje zaÅ‚oÅ¼enia kiedykolwiek okaÅ¼Ä… siÄ™ bÅ‚Ä™dne, masz wiÄ™cej informacji do wykorzystania w debugowaniu.</p>
<h3 id="propagacja-bÅ‚Ä™dÃ³w"><a class="header" href="#propagacja-bÅ‚Ä™dÃ³w">Propagacja bÅ‚Ä™dÃ³w</a></h3>
<p>Kiedy implementacja funkcji wywoÅ‚uje coÅ›, co moÅ¼e zawieÅ›Ä‡, zamiast obsÅ‚ugiwaÄ‡ bÅ‚Ä…d w samej funkcji, moÅ¼esz zwrÃ³ciÄ‡ bÅ‚Ä…d do kodu wywoÅ‚ujÄ…cego, aby ten mÃ³gÅ‚ zdecydowaÄ‡, co zrobiÄ‡. Jest to znane jako <em>propagacja</em> bÅ‚Ä™du i daje wiÄ™kszÄ… kontrolÄ™ kodowi wywoÅ‚ujÄ…cemu, gdzie moÅ¼e byÄ‡ wiÄ™cej informacji lub logiki, ktÃ³ra dyktuje, jak bÅ‚Ä…d powinien byÄ‡ obsÅ‚uÅ¼ony, niÅ¼ to, co masz dostÄ™pne w kontekÅ›cie swojego kodu.</p>
<p>Na przykÅ‚ad, Listing 9-6 pokazuje funkcjÄ™, ktÃ³ra odczytuje nazwÄ™ uÅ¼ytkownika z pliku. JeÅ›li plik nie istnieje lub nie moÅ¼na go odczytaÄ‡, funkcja zwrÃ³ci te bÅ‚Ä™dy do kodu, ktÃ³ry wywoÅ‚aÅ‚ funkcjÄ™.</p>
<listing number="9-6" file-name="src/main.rs" caption="Funkcja, ktÃ³ra zwraca bÅ‚Ä™dy do kodu wywoÅ‚ujÄ…cego za pomocÄ… `match`">
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}</span></code></pre>
</listing>
<p>Ta funkcja moÅ¼e byÄ‡ napisana w znacznie krÃ³tszy sposÃ³b, ale zaczniemy od jej rÄ™cznego implementowania, aby zbadaÄ‡ obsÅ‚ugÄ™ bÅ‚Ä™dÃ³w; na koÅ„cu pokaÅ¼emy krÃ³tszy sposÃ³b. SpÃ³jrzmy najpierw na typ zwracany przez funkcjÄ™: <code>Result&lt;String, io::Error&gt;</code>. Oznacza to, Å¼e funkcja zwraca wartoÅ›Ä‡ typu <code>Result&lt;T, E&gt;</code>, gdzie generyczny parametr <code>T</code> zostaÅ‚ wypeÅ‚niony konkretnym typem <code>String</code>, a generyczny typ <code>E</code> zostaÅ‚ wypeÅ‚niony konkretnym typem <code>io::Error</code>.</p>
<p>JeÅ›li ta funkcja zakoÅ„czy siÄ™ sukcesem bez Å¼adnych problemÃ³w, kod, ktÃ³ry jÄ… wywoÅ‚uje, otrzyma wartoÅ›Ä‡ <code>Ok</code>, ktÃ³ra zawiera <code>String</code> â€“ <code>username</code>, ktÃ³ry ta funkcja odczytaÅ‚a z pliku. JeÅ›li ta funkcja napotka jakiekolwiek problemy, kod wywoÅ‚ujÄ…cy otrzyma wartoÅ›Ä‡ <code>Err</code>, ktÃ³ra zawiera wiÄ™cej informacji o tym, jakie byÅ‚y problemy. WybraliÅ›my <code>io::Error</code> jako typ zwracany tej funkcji, poniewaÅ¼ jest to typ wartoÅ›ci bÅ‚Ä™du zwracany przez obie operacje, ktÃ³re wywoÅ‚ujemy w treÅ›ci tej funkcji i ktÃ³re mogÄ… zawieÅ›Ä‡: funkcja <code>File::open</code> i metoda <code>read_to_string</code>.</p>
<p>CiaÅ‚o funkcji zaczyna siÄ™ od wywoÅ‚ania funkcji <code>File::open</code>. NastÄ™pnie obsÅ‚ugujemy wartoÅ›Ä‡ <code>Result</code> za pomocÄ… <code>match</code>, podobnego do <code>match</code> w Listing 9-4. JeÅ›li <code>File::open</code> zakoÅ„czy siÄ™ sukcesem, uchwyt pliku w zmiennej wzorca <code>file</code> staje siÄ™ wartoÅ›ciÄ… w mutowalnej zmiennej <code>username_file</code>, a funkcja kontynuuje. W przypadku <code>Err</code>, zamiast wywoÅ‚ywaÄ‡ <code>panic!</code>, uÅ¼ywamy sÅ‚owa kluczowego <code>return</code>, aby natychmiast wyjÅ›Ä‡ z funkcji i przekazaÄ‡ wartoÅ›Ä‡ bÅ‚Ä™du z <code>File::open</code>, teraz w zmiennej wzorca <code>e</code>, z powrotem do kodu wywoÅ‚ujÄ…cego jako wartoÅ›Ä‡ bÅ‚Ä™du tej funkcji.</p>
<p>Zatem, jeÅ›li mamy uchwyt pliku w <code>username_file</code>, funkcja nastÄ™pnie tworzy nowy <code>String</code> w zmiennej <code>username</code> i wywoÅ‚uje metodÄ™ <code>read_to_string</code> na uchwycie pliku w <code>username_file</code>, aby odczytaÄ‡ zawartoÅ›Ä‡ pliku do <code>username</code>. Metoda <code>read_to_string</code> rÃ³wnieÅ¼ zwraca <code>Result</code>, poniewaÅ¼ moÅ¼e zawieÅ›Ä‡, nawet jeÅ›li <code>File::open</code> zakoÅ„czyÅ‚o siÄ™ sukcesem. Musimy wiÄ™c uÅ¼yÄ‡ kolejnego <code>match</code> do obsÅ‚ugi tego <code>Result</code>: JeÅ›li <code>read_to_string</code> zakoÅ„czy siÄ™ sukcesem, to nasza funkcja zakoÅ„czyÅ‚a siÄ™ sukcesem, i zwracamy nazwÄ™ uÅ¼ytkownika z pliku, ktÃ³ra jest teraz w <code>username</code>, zawiniÄ™tÄ… w <code>Ok</code>. JeÅ›li <code>read_to_string</code> zawiedzie, zwracamy wartoÅ›Ä‡ bÅ‚Ä™du w taki sam sposÃ³b, w jaki zwrÃ³ciliÅ›my wartoÅ›Ä‡ bÅ‚Ä™du w <code>match</code>, ktÃ³re obsÅ‚ugiwaÅ‚o wartoÅ›Ä‡ zwracanÄ… przez <code>File::open</code>. Nie musimy jednak jawnie mÃ³wiÄ‡ <code>return</code>, poniewaÅ¼ jest to ostatnie wyraÅ¼enie w funkcji.</p>
<p>Kod wywoÅ‚ujÄ…cy ten kod bÄ™dzie nastÄ™pnie obsÅ‚ugiwaÅ‚ otrzymanie wartoÅ›ci <code>Ok</code>, ktÃ³ra zawiera nazwÄ™ uÅ¼ytkownika, lub wartoÅ›ci <code>Err</code>, ktÃ³ra zawiera <code>io::Error</code>. To od kodu wywoÅ‚ujÄ…cego zaleÅ¼y, co zrobiÄ‡ z tymi wartoÅ›ciami. JeÅ›li kod wywoÅ‚ujÄ…cy otrzyma wartoÅ›Ä‡ <code>Err</code>, mÃ³gÅ‚by wywoÅ‚aÄ‡ <code>panic!</code> i zniszczyÄ‡ program, uÅ¼yÄ‡ domyÅ›lnej nazwy uÅ¼ytkownika lub wyszukaÄ‡ nazwÄ™ uÅ¼ytkownika gdzie indziej niÅ¼ w pliku, na przykÅ‚ad. Nie mamy wystarczajÄ…cych informacji o tym, co kod wywoÅ‚ujÄ…cy faktycznie prÃ³buje zrobiÄ‡, wiÄ™c propagujemy wszystkie informacje o sukcesie lub bÅ‚Ä™dzie w gÃ³rÄ™, aby zostaÅ‚y odpowiednio obsÅ‚uÅ¼one.</p>
<p>Ten wzorzec propagacji bÅ‚Ä™dÃ³w jest tak powszechny w Rust, Å¼e Rust udostÄ™pnia operator znak zapytania <code>?</code>, aby to uÅ‚atwiÄ‡.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="a-shortcut-for-propagating-errors-the--operator"></a></p>
<h4 id="skrÃ³t-operatora--do-propagacji-bÅ‚Ä™dÃ³w"><a class="header" href="#skrÃ³t-operatora--do-propagacji-bÅ‚Ä™dÃ³w">SkrÃ³t operatora <code>?</code> do propagacji bÅ‚Ä™dÃ³w</a></h4>
<p>Listing 9-7 pokazuje implementacjÄ™ <code>read_username_from_file</code>, ktÃ³ra ma tÄ™ samÄ… funkcjonalnoÅ›Ä‡ co w Listing 9-6, ale ta implementacja uÅ¼ywa operatora <code>?</code>.</p>
<listing number="9-7" file-name="src/main.rs" caption="Funkcja, ktÃ³ra zwraca bÅ‚Ä™dy do kodu wywoÅ‚ujÄ…cego za pomocÄ… operatora `?`">
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&amp;mut username)?;
    Ok(username)
}
<span class="boring">}</span></code></pre>
</listing>
<p>Operator <code>?</code> umieszczony po wartoÅ›ci <code>Result</code> dziaÅ‚a prawie tak samo jak wyraÅ¼enia <code>match</code>, ktÃ³re zdefiniowaliÅ›my do obsÅ‚ugi wartoÅ›ci <code>Result</code> w Listing 9-6. JeÅ›li wartoÅ›Ä‡ <code>Result</code> to <code>Ok</code>, wartoÅ›Ä‡ wewnÄ…trz <code>Ok</code> zostanie zwrÃ³cona z tego wyraÅ¼enia, a program bÄ™dzie kontynuowaÅ‚. JeÅ›li wartoÅ›Ä‡ to <code>Err</code>, <code>Err</code> zostanie zwrÃ³cone z caÅ‚ej funkcji tak, jakbyÅ›my uÅ¼yli sÅ‚owa kluczowego <code>return</code>, tak aby wartoÅ›Ä‡ bÅ‚Ä™du zostaÅ‚a propagowana do kodu wywoÅ‚ujÄ…cego.</p>
<p>Istnieje rÃ³Å¼nica miÄ™dzy tym, co robi wyraÅ¼enie <code>match</code> z Listing 9-6, a tym, co robi operator <code>?</code>: wartoÅ›ci bÅ‚Ä™dÃ³w, na ktÃ³rych wywoÅ‚ano operator <code>?</code>, przechodzÄ… przez funkcjÄ™ <code>from</code>, zdefiniowanÄ… w cesze <code>From</code> w standardowej bibliotece, ktÃ³ra jest uÅ¼ywana do konwertowania wartoÅ›ci z jednego typu na inny. Gdy operator <code>?</code> wywoÅ‚uje funkcjÄ™ <code>from</code>, otrzymany typ bÅ‚Ä™du jest konwertowany na typ bÅ‚Ä™du zdefiniowany w typie zwracanym bieÅ¼Ä…cej funkcji. Jest to przydatne, gdy funkcja zwraca jeden typ bÅ‚Ä™du, aby reprezentowaÄ‡ wszystkie sposoby, w jakie funkcja moÅ¼e zawieÅ›Ä‡, nawet jeÅ›li czÄ™Å›ci mogÄ… zawieÅ›Ä‡ z wielu rÃ³Å¼nych powodÃ³w.</p>
<p>Na przykÅ‚ad, moglibyÅ›my zmieniÄ‡ funkcjÄ™ <code>read_username_from_file</code> w Listing 9-7 tak, aby zwracaÅ‚a niestandardowy typ bÅ‚Ä™du o nazwie <code>OurError</code>, ktÃ³ry zdefiniujemy. JeÅ›li zdefiniujemy rÃ³wnieÅ¼ <code>impl From&lt;io::Error&gt; for OurError</code>, aby skonstruowaÄ‡ instancjÄ™ <code>OurError</code> z <code>io::Error</code>, to wywoÅ‚ania operatora <code>?</code> w ciele <code>read_username_from_file</code> wywoÅ‚ajÄ… <code>from</code> i przekonwertujÄ… typy bÅ‚Ä™dÃ³w bez potrzeby dodawania do funkcji Å¼adnego dodatkowego kodu.</p>
<p>W kontekÅ›cie Listing 9-7, <code>?</code> na koÅ„cu wywoÅ‚ania <code>File::open</code> zwrÃ³ci wartoÅ›Ä‡ wewnÄ…trz <code>Ok</code> do zmiennej <code>username_file</code>. JeÅ›li wystÄ…pi bÅ‚Ä…d, operator <code>?</code> natychmiast wyjdzie z caÅ‚ej funkcji i przekaÅ¼e dowolnÄ… wartoÅ›Ä‡ <code>Err</code> do kodu wywoÅ‚ujÄ…cego. To samo dotyczy <code>?</code> na koÅ„cu wywoÅ‚ania <code>read_to_string</code>.</p>
<p>Operator <code>?</code> eliminuje wiele szablonowego kodu i upraszcza implementacjÄ™ tej funkcji. MoglibyÅ›my nawet skrÃ³ciÄ‡ ten kod, Å‚Ä…czÄ…c wywoÅ‚ania metod bezpoÅ›rednio po <code>?</code>, jak pokazano w Listing 9-8.</p>
<listing number="9-8" file-name="src/main.rs" caption="ÅÄ…czenie wywoÅ‚aÅ„ metod po operatorze `?`">
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username = String::new();

    File::open("hello.txt")?.read_to_string(&amp;mut username)?;

    Ok(username)
}
<span class="boring">}</span></code></pre>
</listing>
<p>Tworzenie nowego <code>String</code> w <code>username</code> przenieÅ›liÅ›my na poczÄ…tek funkcji; ta czÄ™Å›Ä‡ nie ulegÅ‚a zmianie. Zamiast tworzyÄ‡ zmiennÄ… <code>username_file</code>, poÅ‚Ä…czyliÅ›my wywoÅ‚anie <code>read_to_string</code> bezpoÅ›rednio z wynikiem <code>File::open("hello.txt")?</code>. Nadal mamy <code>?</code> na koÅ„cu wywoÅ‚ania <code>read_to_string</code> i nadal zwracamy wartoÅ›Ä‡ <code>Ok</code> zawierajÄ…cÄ… <code>username</code>, gdy zarÃ³wno <code>File::open</code>, jak i <code>read_to_string</code> zakoÅ„czÄ… siÄ™ sukcesem, zamiast zwracaÄ‡ bÅ‚Ä™dy. FunkcjonalnoÅ›Ä‡ jest ponownie taka sama jak w Listing 9-6 i Listing 9-7; jest to po prostu inny, bardziej ergonomiczny sposÃ³b zapisu.</p>
<p>Listing 9-9 pokazuje sposÃ³b na jeszcze wiÄ™ksze skrÃ³cenie tego za pomocÄ… <code>fs::read_to_string</code>.</p>
<listing number="9-9" file-name="src/main.rs" caption="UÅ¼ycie `fs::read_to_string` zamiast otwierania, a nastÄ™pnie czytania pliku">
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string("hello.txt")
}
<span class="boring">}</span></code></pre>
</listing>
<p>Odczytywanie pliku do ciÄ…gu znakÃ³w jest doÅ›Ä‡ powszechnÄ… operacjÄ…, dlatego standardowa biblioteka udostÄ™pnia wygodnÄ… funkcjÄ™ <code>fs::read_to_string</code>, ktÃ³ra otwiera plik, tworzy nowy <code>String</code>, odczytuje zawartoÅ›Ä‡ pliku, umieszcza zawartoÅ›Ä‡ w tym <code>String</code> i zwraca go. OczywiÅ›cie, uÅ¼ycie <code>fs::read_to_string</code> nie daje nam moÅ¼liwoÅ›ci wyjaÅ›nienia caÅ‚ej obsÅ‚ugi bÅ‚Ä™dÃ³w, dlatego najpierw zrobiliÅ›my to w dÅ‚uÅ¼szy sposÃ³b.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="where-the--operator-can-be-used"></a></p>
<h4 id="gdzie-moÅ¼na-uÅ¼ywaÄ‡-operatora-"><a class="header" href="#gdzie-moÅ¼na-uÅ¼ywaÄ‡-operatora-">Gdzie moÅ¼na uÅ¼ywaÄ‡ operatora <code>?</code></a></h4>
<p>Operator <code>?</code> moÅ¼e byÄ‡ uÅ¼ywany tylko w funkcjach, ktÃ³rych typ zwracany jest zgodny z wartoÅ›ciÄ…, na ktÃ³rej uÅ¼yto <code>?</code>. Dzieje siÄ™ tak, poniewaÅ¼ operator <code>?</code> jest zdefiniowany do wykonania wczesnego zwrÃ³cenia wartoÅ›ci z funkcji, w ten sam sposÃ³b, co wyraÅ¼enie <code>match</code>, ktÃ³re zdefiniowaliÅ›my w Listing 9-6. W Listing 9-6 <code>match</code> uÅ¼ywaÅ‚ wartoÅ›ci <code>Result</code>, a ramiÄ™ wczesnego zwrÃ³cenia zwracaÅ‚o wartoÅ›Ä‡ <code>Err(e)</code>. Typ zwracany funkcji musi byÄ‡ <code>Result</code>, aby byÅ‚ zgodny z tym <code>return</code>.</p>
<p>W Listing 9-10 przyjrzyjmy siÄ™ bÅ‚Ä™dowi, ktÃ³ry otrzymamy, jeÅ›li uÅ¼yjemy operatora <code>?</code> w funkcji <code>main</code> z typem zwracanym niezgodnym z typem wartoÅ›ci, na ktÃ³rej uÅ¼ywamy <code>?</code>.</p>
<listing number="9-10" file-name="src/main.rs" caption="PrÃ³ba uÅ¼ycia `?` w funkcji `main`, ktÃ³ra zwraca `()`, nie skompiluje siÄ™.">
<pre><code class="language-rust ignore does_not_compile">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")?;
}</code></pre>
</listing>
<p>Ten kod otwiera plik, co moÅ¼e zakoÅ„czyÄ‡ siÄ™ niepowodzeniem. Operator <code>?</code> nastÄ™puje po wartoÅ›ci <code>Result</code> zwracanej przez <code>File::open</code>, ale ta funkcja <code>main</code> ma typ zwracany <code>()</code>, a nie <code>Result</code>. Kiedy skompilujemy ten kod, otrzymamy nastÄ™pujÄ…cy komunikat o bÅ‚Ä™dzie:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --&gt; src/main.rs:4:48
  |
3 | fn main() {
  | --------- this function should return `Result` or `Option` to accept `?`
4 |     let greeting_file = File::open("hello.txt")?;
  |                                                ^ cannot use the `?` operator in a function that returns `()`
  |
help: consider adding return type
  |
3 ~ fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
4 |     let greeting_file = File::open("hello.txt")?;
5 +     Ok(())
  |

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` (bin "error-handling") due to 1 previous error
</code></pre>
<p>Ten bÅ‚Ä…d wskazuje, Å¼e moÅ¼emy uÅ¼ywaÄ‡ operatora <code>?</code> tylko w funkcji, ktÃ³ra zwraca <code>Result</code>, <code>Option</code> lub inny typ implementujÄ…cy <code>FromResidual</code>.</p>
<p>Aby naprawiÄ‡ bÅ‚Ä…d, masz dwie moÅ¼liwoÅ›ci. Jedna to zmiana typu zwracanego przez funkcjÄ™, aby byÅ‚ zgodny z wartoÅ›ciÄ…, na ktÃ³rej uÅ¼ywasz operatora <code>?</code>, o ile nie ma Å¼adnych ograniczeÅ„, ktÃ³re by to uniemoÅ¼liwiaÅ‚y. Druga to uÅ¼ycie <code>match</code> lub jednej z metod <code>Result&lt;T, E&gt;</code>, aby obsÅ‚uÅ¼yÄ‡ <code>Result&lt;T, E&gt;</code> w dowolny odpowiedni sposÃ³b.</p>
<p>Komunikat o bÅ‚Ä™dzie wspominaÅ‚ rÃ³wnieÅ¼, Å¼e <code>?</code> moÅ¼e byÄ‡ uÅ¼ywany z wartoÅ›ciami <code>Option&lt;T&gt;</code>. Podobnie jak w przypadku uÅ¼ycia <code>?</code> na <code>Result</code>, moÅ¼esz uÅ¼ywaÄ‡ <code>?</code> na <code>Option</code> tylko w funkcji, ktÃ³ra zwraca <code>Option</code>. Zachowanie operatora <code>?</code> wywoÅ‚ywanego na <code>Option&lt;T&gt;</code> jest podobne do jego zachowania wywoÅ‚ywanego na <code>Result&lt;T, E&gt;</code>: JeÅ›li wartoÅ›Ä‡ to <code>None</code>, <code>None</code> zostanie zwrÃ³cone z funkcji w tym momencie. JeÅ›li wartoÅ›Ä‡ to <code>Some</code>, wartoÅ›Ä‡ wewnÄ…trz <code>Some</code> jest wartoÅ›ciÄ… wynikowÄ… wyraÅ¼enia, a funkcja kontynuuje. Listing 9-11 zawiera przykÅ‚ad funkcji, ktÃ³ra znajduje ostatni znak pierwszej linii w danym tekÅ›cie.</p>
<listing number="9-11" caption="UÅ¼ycie operatora `?` na wartoÅ›ci `Option&lt;T&gt;`">
<pre class="playground"><code class="language-rust edition2024">fn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {
    text.lines().next()?.chars().last()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(
</span><span class="boring">        last_char_of_first_line("Witaj, Å›wiecie\nJak siÄ™ masz dzisiaj?"),
</span><span class="boring">        Some('e')
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(last_char_of_first_line(""), None);
</span><span class="boring">    assert_eq!(last_char_of_first_line("\nhi"), None);
</span><span class="boring">}</span></code></pre>
</listing>
<p>Ta funkcja zwraca <code>Option&lt;char&gt;</code>, poniewaÅ¼ moÅ¼liwe jest, Å¼e tam jest znak, ale moÅ¼liwe jest rÃ³wnieÅ¼, Å¼e go nie ma. Ten kod pobiera argument wycinka ciÄ…gu <code>text</code> i wywoÅ‚uje na nim metodÄ™ <code>lines</code>, ktÃ³ra zwraca iterator po liniach w ciÄ…gu. PoniewaÅ¼ ta funkcja chce zbadaÄ‡ pierwszÄ… liniÄ™, wywoÅ‚uje <code>next</code> na iteratorze, aby uzyskaÄ‡ pierwszÄ… wartoÅ›Ä‡ z iteratora. JeÅ›li <code>text</code> jest pustym ciÄ…giem, to wywoÅ‚anie <code>next</code> zwrÃ³ci <code>None</code>, w ktÃ³rym to przypadku uÅ¼ywamy <code>?</code>, aby zatrzymaÄ‡ i zwrÃ³ciÄ‡ <code>None</code> z <code>last_char_of_first_line</code>. JeÅ›li <code>text</code> nie jest pustym ciÄ…giem, <code>next</code> zwrÃ³ci wartoÅ›Ä‡ <code>Some</code> zawierajÄ…cÄ… wycinek ciÄ…gu pierwszej linii w <code>text</code>.</p>
<p>Operator <code>?</code> wyodrÄ™bnia wycinek ciÄ…gu znakÃ³w, a my moÅ¼emy wywoÅ‚aÄ‡ <code>chars</code> na tym wycinku ciÄ…gu znakÃ³w, aby uzyskaÄ‡ iterator jego znakÃ³w. Interesuje nas ostatni znak w tej pierwszej linii, wiÄ™c wywoÅ‚ujemy <code>last</code>, aby zwrÃ³ciÄ‡ ostatni element w iteratorze. Jest to <code>Option</code>, poniewaÅ¼ moÅ¼liwe jest, Å¼e pierwsza linia jest pustym ciÄ…giem; na przykÅ‚ad, jeÅ›li <code>text</code> zaczyna siÄ™ od pustej linii, ale ma znaki w innych liniach, jak w <code>"\nhi"</code>. JednakÅ¼e, jeÅ›li istnieje ostatni znak w pierwszej linii, zostanie on zwrÃ³cony w wariancie <code>Some</code>. Operator <code>?</code> w Å›rodku daje nam zwiÄ™zÅ‚y sposÃ³b wyraÅ¼enia tej logiki, pozwalajÄ…c nam zaimplementowaÄ‡ funkcjÄ™ w jednej linii. GdybyÅ›my nie mogli uÅ¼yÄ‡ operatora <code>?</code> na <code>Option</code>, musielibyÅ›my zaimplementowaÄ‡ tÄ™ logikÄ™, uÅ¼ywajÄ…c wiÄ™kszej liczby wywoÅ‚aÅ„ metod lub wyraÅ¼enia <code>match</code>.</p>
<p>ZauwaÅ¼, Å¼e moÅ¼esz uÅ¼ywaÄ‡ operatora <code>?</code> na <code>Result</code> w funkcji, ktÃ³ra zwraca <code>Result</code>, i moÅ¼esz uÅ¼ywaÄ‡ operatora <code>?</code> na <code>Option</code> w funkcji, ktÃ³ra zwraca <code>Option</code>, ale nie moÅ¼esz ich mieszaÄ‡. Operator <code>?</code> nie przekonwertuje automatycznie <code>Result</code> na <code>Option</code> ani na odwrÃ³t; w tych przypadkach moÅ¼esz uÅ¼yÄ‡ metod, takich jak metoda <code>ok</code> na <code>Result</code> lub metoda <code>ok_or</code> na <code>Option</code>, aby wykonaÄ‡ konwersjÄ™ jawnie.</p>
<p>Do tej pory wszystkie uÅ¼ywane przez nas funkcje <code>main</code> zwracaÅ‚y <code>()</code>. Funkcja <code>main</code> jest specjalna, poniewaÅ¼ jest punktem wejÅ›cia i wyjÅ›cia programu wykonywalnego, a istniejÄ… ograniczenia dotyczÄ…ce jej typu zwracanego, aby program dziaÅ‚aÅ‚ zgodnie z oczekiwaniami.</p>
<p>Na szczÄ™Å›cie, <code>main</code> moÅ¼e rÃ³wnieÅ¼ zwrÃ³ciÄ‡ <code>Result&lt;(), E&gt;</code>. Listing 9-12 zawiera kod z Listing 9-10, ale zmieniliÅ›my typ zwracany <code>main</code> na <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> i dodaliÅ›my wartoÅ›Ä‡ zwracanÄ… <code>Ok(())</code> na koÅ„cu. Ten kod teraz siÄ™ skompiluje.</p>
<listing number="9-12" file-name="src/main.rs" caption="Zmiana `main` na zwracanie `Result&lt;(), E&gt;` umoÅ¼liwia uÅ¼ycie operatora `?` na wartoÅ›ciach `Result`.">
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let greeting_file = File::open("hello.txt")?;

    Ok(())
}</code></pre>
</listing>
<p>Typ <code>Box&lt;dyn Error&gt;</code> to obiekt cechy, o ktÃ³rym bÄ™dziemy mÃ³wiÄ‡ w sekcji <a href="#using-trait-objects-to-abstract-over-shared-behavior">â€UÅ¼ywanie obiektÃ³w cech do abstrakcji wspÃ³lnego zachowaniaâ€</a><!-- ignore --> w Rozdziale 18. Na razie moÅ¼esz czytaÄ‡ <code>Box&lt;dyn Error&gt;</code> jako â€dowolny rodzaj bÅ‚Ä™duâ€. UÅ¼ycie <code>?</code> na wartoÅ›ci <code>Result</code> w funkcji <code>main</code> z typem bÅ‚Ä™du <code>Box&lt;dyn Error&gt;</code> jest dozwolone, poniewaÅ¼ pozwala to na wczesne zwrÃ³cenie dowolnej wartoÅ›ci <code>Err</code>. Mimo Å¼e ciaÅ‚o tej funkcji <code>main</code> zawsze bÄ™dzie zwracaÄ‡ bÅ‚Ä™dy typu <code>std::io::Error</code>, poprzez okreÅ›lenie <code>Box&lt;dyn Error&gt;</code>, ta sygnatura bÄ™dzie nadal poprawna, nawet jeÅ›li do ciaÅ‚a <code>main</code> zostanie dodany wiÄ™cej kodu, ktÃ³ry zwraca inne bÅ‚Ä™dy.</p>
<p>Kiedy funkcja <code>main</code> zwraca <code>Result&lt;(), E&gt;</code>, plik wykonywalny zakoÅ„czy dziaÅ‚anie z wartoÅ›ciÄ… <code>0</code>, jeÅ›li <code>main</code> zwrÃ³ci <code>Ok(())</code>, a zakoÅ„czy dziaÅ‚anie z wartoÅ›ciÄ… rÃ³Å¼nÄ… od zera, jeÅ›li <code>main</code> zwrÃ³ci wartoÅ›Ä‡ <code>Err</code>. Pliki wykonywalne napisane w C zwracajÄ… liczby caÅ‚kowite po zakoÅ„czeniu dziaÅ‚ania: programy, ktÃ³re zakoÅ„czyÅ‚y dziaÅ‚anie pomyÅ›lnie, zwracajÄ… liczbÄ™ caÅ‚kowitÄ… <code>0</code>, a programy, ktÃ³re zakoÅ„czyÅ‚y siÄ™ bÅ‚Ä™dem, zwracajÄ… jakÄ…Å› liczbÄ™ caÅ‚kowitÄ… innÄ… niÅ¼ <code>0</code>. Rust rÃ³wnieÅ¼ zwraca liczby caÅ‚kowite z plikÃ³w wykonywalnych, aby byÄ‡ zgodnym z tÄ… konwencjÄ….</p>
<p>Funkcja <code>main</code> moÅ¼e zwracaÄ‡ dowolne typy implementujÄ…ce <a href="../std/process/trait.Termination.html">cechÄ™ <code>std::process::Termination</code></a><!-- ignore -->, ktÃ³ra zawiera funkcjÄ™ <code>report</code> zwracajÄ…cÄ… <code>ExitCode</code>. Zapoznaj siÄ™ z dokumentacjÄ… standardowej biblioteki, aby uzyskaÄ‡ wiÄ™cej informacji na temat implementacji cechy <code>Termination</code> dla wÅ‚asnych typÃ³w.</p>
<p>Teraz, gdy omÃ³wiliÅ›my szczegÃ³Å‚y wywoÅ‚ywania <code>panic!</code> lub zwracania <code>Result</code>, wrÃ³Ä‡my do tematu, jak zdecydowaÄ‡, ktÃ³ry z nich jest odpowiedni do uÅ¼ycia w jakich przypadkach.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="panikowaÄ‡-czy-nie-panikowaÄ‡-1"><a href="#panikowaÄ‡-czy-nie-panikowaÄ‡-1" class="header">PanikowaÄ‡ czy nie panikowaÄ‡!</a></h1>
<h2 id="panikowaÄ‡-czy-nie-panikowaÄ‡"><a class="header" href="#panikowaÄ‡-czy-nie-panikowaÄ‡">PanikowaÄ‡ czy nie panikowaÄ‡!</a></h2>
<p>Jak wiÄ™c zdecydowaÄ‡, kiedy naleÅ¼y wywoÅ‚aÄ‡ <code>panic!</code>, a kiedy zwrÃ³ciÄ‡ <code>Result</code>? Kiedy kod panikuje, nie ma sposobu na odzyskanie. MoÅ¼esz wywoÅ‚aÄ‡ <code>panic!</code> w kaÅ¼dej sytuacji bÅ‚Ä™du, niezaleÅ¼nie od tego, czy istnieje moÅ¼liwoÅ›Ä‡ odzyskania, czy nie, ale wtedy podejmujesz decyzjÄ™, Å¼e sytuacja jest nie do odzyskania w imieniu kodu wywoÅ‚ujÄ…cego. Kiedy zdecydujesz siÄ™ zwrÃ³ciÄ‡ wartoÅ›Ä‡ <code>Result</code>, dajesz kodowi wywoÅ‚ujÄ…cemu opcje. Kod wywoÅ‚ujÄ…cy moÅ¼e sprÃ³bowaÄ‡ odzyskaÄ‡ siÄ™ w sposÃ³b odpowiedni dla swojej sytuacji, lub moÅ¼e zdecydowaÄ‡, Å¼e wartoÅ›Ä‡ <code>Err</code> w tym przypadku jest nie do odzyskania, wiÄ™c moÅ¼e wywoÅ‚aÄ‡ <code>panic!</code> i zmieniÄ‡ TwÃ³j odzyskiwalny bÅ‚Ä…d w bÅ‚Ä…d nie do odzyskania. Dlatego zwracanie <code>Result</code> jest dobrym domyÅ›lnym wyborem, gdy definiujesz funkcjÄ™, ktÃ³ra moÅ¼e zawieÅ›Ä‡.</p>
<p>W sytuacjach takich jak przykÅ‚ady, kod prototypowy i testy, bardziej odpowiednie jest pisanie kodu, ktÃ³ry panikuje zamiast zwracaÄ‡ <code>Result</code>. Zbadajmy dlaczego, a nastÄ™pnie omÃ³wmy sytuacje, w ktÃ³rych kompilator nie moÅ¼e stwierdziÄ‡, Å¼e awaria jest niemoÅ¼liwa, ale Ty jako czÅ‚owiek moÅ¼esz. RozdziaÅ‚ zakoÅ„czy siÄ™ ogÃ³lnymi wytycznymi dotyczÄ…cymi tego, jak zdecydowaÄ‡, czy panikowaÄ‡ w kodzie biblioteki.</p>
<h3 id="przykÅ‚ady-kod-prototypowy-i-testy"><a class="header" href="#przykÅ‚ady-kod-prototypowy-i-testy">PrzykÅ‚ady, kod prototypowy i testy</a></h3>
<p>Kiedy piszesz przykÅ‚ad, aby zilustrowaÄ‡ jakÄ…Å› koncepcjÄ™, rÃ³wnieÅ¼ uwzglÄ™dnianie solidnego kodu do obsÅ‚ugi bÅ‚Ä™dÃ³w moÅ¼e uczyniÄ‡ przykÅ‚ad mniej jasnym. W przykÅ‚adach rozumie siÄ™, Å¼e wywoÅ‚anie metody, takiej jak <code>unwrap</code>, ktÃ³ra moÅ¼e spowodowaÄ‡ panikÄ™, ma byÄ‡ jedynie symulatorem sposobu, w jaki Twoja aplikacja obsÅ‚ugiwaÅ‚aby bÅ‚Ä™dy, co moÅ¼e siÄ™ rÃ³Å¼niÄ‡ w zaleÅ¼noÅ›ci od tego, co robi reszta Twojego kodu.</p>
<p>Podobnie, metody <code>unwrap</code> i <code>expect</code> sÄ… bardzo przydatne, gdy prototypujesz i nie jesteÅ› jeszcze gotowy, aby zdecydowaÄ‡, jak obsÅ‚ugiwaÄ‡ bÅ‚Ä™dy. PozostawiajÄ… one jasne znaczniki w kodzie, na wypadek gdy bÄ™dziesz gotowy, aby uczyniÄ‡ swÃ³j program bardziej niezawodnym.</p>
<p>JeÅ›li wywoÅ‚anie metody zakoÅ„czy siÄ™ niepowodzeniem w teÅ›cie, chciaÅ‚byÅ›, aby caÅ‚y test zakoÅ„czyÅ‚ siÄ™ niepowodzeniem, nawet jeÅ›li ta metoda nie jest testowanÄ… funkcjonalnoÅ›ciÄ…. PoniewaÅ¼ <code>panic!</code> oznacza, Å¼e test zakoÅ„czyÅ‚ siÄ™ niepowodzeniem, wywoÅ‚anie <code>unwrap</code> lub <code>expect</code> jest dokÅ‚adnie tym, co powinno siÄ™ staÄ‡.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="cases-in-which-you-have-more-information-than-the-compiler"></a></p>
<h3 id="kiedy-masz-wiÄ™cej-informacji-niÅ¼-kompilator"><a class="header" href="#kiedy-masz-wiÄ™cej-informacji-niÅ¼-kompilator">Kiedy masz wiÄ™cej informacji niÅ¼ kompilator</a></h3>
<p>Odpowiednie byÅ‚oby rÃ³wnieÅ¼ wywoÅ‚anie <code>expect</code>, gdy masz innÄ… logikÄ™, ktÃ³ra gwarantuje, Å¼e <code>Result</code> bÄ™dzie miaÅ‚ wartoÅ›Ä‡ <code>Ok</code>, ale logika nie jest czymÅ›, co kompilator rozumie. Nadal bÄ™dziesz mieÄ‡ wartoÅ›Ä‡ <code>Result</code>, ktÃ³rÄ… musisz obsÅ‚uÅ¼yÄ‡: kaÅ¼da operacja, ktÃ³rÄ… wywoÅ‚ujesz, nadal ma moÅ¼liwoÅ›Ä‡ ogÃ³lnego niepowodzenia, nawet jeÅ›li jest to logicznie niemoÅ¼liwe w Twojej konkretnej sytuacji. JeÅ›li moÅ¼esz upewniÄ‡ siÄ™, rÄ™cznie sprawdzajÄ…c kod, Å¼e nigdy nie bÄ™dziesz mieÄ‡ wariantu <code>Err</code>, jest caÅ‚kowicie dopuszczalne wywoÅ‚anie <code>expect</code> i udokumentowanie powodu, dla ktÃ³rego uwaÅ¼asz, Å¼e nigdy nie bÄ™dziesz mieÄ‡ wariantu <code>Err</code> w tekÅ›cie argumentu. Oto przykÅ‚ad:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    use std::net::IpAddr;

    let home: IpAddr = "127.0.0.1"
        .parse()
        .expect("Zakodowany na staÅ‚e adres IP powinien byÄ‡ prawidÅ‚owy");
<span class="boring">}</span></code></pre>
<p>Tworzymy instancjÄ™ <code>IpAddr</code> poprzez parsowanie zakodowanego na staÅ‚e ciÄ…gu znakÃ³w. Widzimy, Å¼e <code>127.0.0.1</code> jest prawidÅ‚owym adresem IP, wiÄ™c w tym przypadku uÅ¼ycie <code>expect</code> jest dopuszczalne. Jednak posiadanie zakodowanego na staÅ‚e, prawidÅ‚owego ciÄ…gu znakÃ³w nie zmienia typu zwracanego przez metodÄ™ <code>parse</code>: nadal otrzymujemy wartoÅ›Ä‡ <code>Result</code>, a kompilator nadal bÄ™dzie nas zmuszaÅ‚ do obsÅ‚ugi <code>Result</code>, tak jakby wariant <code>Err</code> byÅ‚ moÅ¼liwy, poniewaÅ¼ kompilator nie jest wystarczajÄ…co sprytny, aby zobaczyÄ‡, Å¼e ten ciÄ…g znakÃ³w jest zawsze prawidÅ‚owym adresem IP. Gdyby ciÄ…g znakÃ³w adresu IP pochodziÅ‚ od uÅ¼ytkownika, a nie byÅ‚ zakodowany na staÅ‚e w programie i dlatego <em>miaÅ‚</em> moÅ¼liwoÅ›Ä‡ awarii, z pewnoÅ›ciÄ… chcielibyÅ›my obsÅ‚uÅ¼yÄ‡ <code>Result</code> w bardziej niezawodny sposÃ³b.
Wspomnienie o zaÅ‚oÅ¼eniu, Å¼e ten adres IP jest zakodowany na staÅ‚e, skÅ‚oni nas do zmiany <code>expect</code> na lepszy kod obsÅ‚ugi bÅ‚Ä™dÃ³w, jeÅ›li w przyszÅ‚oÅ›ci bÄ™dziemy musieli uzyskaÄ‡ adres IP z innego ÅºrÃ³dÅ‚a.</p>
<h3 id="wytyczne-dotyczÄ…ce-obsÅ‚ugi-bÅ‚Ä™dÃ³w"><a class="header" href="#wytyczne-dotyczÄ…ce-obsÅ‚ugi-bÅ‚Ä™dÃ³w">Wytyczne dotyczÄ…ce obsÅ‚ugi bÅ‚Ä™dÃ³w</a></h3>
<p>Zaleca siÄ™, aby kod panikowaÅ‚, gdy moÅ¼liwe jest, Å¼e kod moÅ¼e znaleÅºÄ‡ siÄ™ w zÅ‚ym stanie. W tym kontekÅ›cie <em>zÅ‚y stan</em> to sytuacja, w ktÃ³rej zostaÅ‚o naruszone jakieÅ› zaÅ‚oÅ¼enie, gwarancja, kontrakt lub niezmiennik, na przykÅ‚ad, gdy do kodu przekazywane sÄ… nieprawidÅ‚owe wartoÅ›ci, wartoÅ›ci sprzeczne lub brakujÄ…ce wartoÅ›ci â€” plus jeden lub wiÄ™cej z poniÅ¼szych:</p>
<ul>
<li>ZÅ‚y stan jest czymÅ› nieoczekiwanym, w przeciwieÅ„stwie do czegoÅ›, co prawdopodobnie bÄ™dzie siÄ™ sporadycznie zdarzaÄ‡, jak na przykÅ‚ad uÅ¼ytkownik wprowadzajÄ…cy dane w niewÅ‚aÅ›ciwym formacie.</li>
<li>TwÃ³j kod po tym punkcie musi polegaÄ‡ na tym, Å¼e nie jest w tym zÅ‚ym stanie, zamiast sprawdzaÄ‡ problem na kaÅ¼dym kroku.</li>
<li>Nie ma dobrego sposobu na zakodowanie tych informacji w uÅ¼ywanych typach. OmÃ³wimy przykÅ‚ad tego, co mamy na myÅ›li, w sekcji <a href="#encoding-states-and-behavior-as-types">â€Kodowanie stanÃ³w i zachowaÅ„ jako typyâ€</a><!-- ignore --> w Rozdziale 18.</li>
</ul>
<p>JeÅ›li ktoÅ› wywoÅ‚a TwÃ³j kod i przekaÅ¼e wartoÅ›ci, ktÃ³re nie majÄ… sensu, najlepiej jest zwrÃ³ciÄ‡ bÅ‚Ä…d, jeÅ›li to moÅ¼liwe, aby uÅ¼ytkownik biblioteki mÃ³gÅ‚ zdecydowaÄ‡, co chce zrobiÄ‡ w takim przypadku. Jednak w przypadkach, gdy kontynuowanie mogÅ‚oby byÄ‡ niebezpieczne lub szkodliwe, najlepszym wyborem moÅ¼e byÄ‡ wywoÅ‚anie <code>panic!</code> i ostrzeÅ¼enie osoby uÅ¼ywajÄ…cej Twojej biblioteki o bÅ‚Ä™dzie w jej kodzie, aby mogÅ‚a go naprawiÄ‡ podczas developmentu. Podobnie, <code>panic!</code> jest czÄ™sto odpowiednie, jeÅ›li wywoÅ‚ujesz kod zewnÄ™trzny, ktÃ³ry jest poza TwojÄ… kontrolÄ… i zwraca nieprawidÅ‚owy stan, ktÃ³rego nie masz jak naprawiÄ‡.</p>
<p>JednakÅ¼e, gdy awaria jest oczekiwana, bardziej odpowiednie jest zwrÃ³cenie <code>Result</code> niÅ¼ wywoÅ‚anie <code>panic!</code>. PrzykÅ‚ady obejmujÄ… parser, ktÃ³ry otrzymuje Åºle sformatowane dane, lub Å¼Ä…danie HTTP zwracajÄ…ce status wskazujÄ…cy, Å¼e osiÄ…gniÄ™to limit szybkoÅ›ci. W takich przypadkach zwrÃ³cenie <code>Result</code> wskazuje, Å¼e awaria jest oczekiwanÄ… moÅ¼liwoÅ›ciÄ…, ktÃ³rÄ… kod wywoÅ‚ujÄ…cy musi zdecydowaÄ‡, jak obsÅ‚uÅ¼yÄ‡.</p>
<p>Kiedy TwÃ³j kod wykonuje operacjÄ™, ktÃ³ra mogÅ‚aby naraziÄ‡ uÅ¼ytkownika na ryzyko, jeÅ›li zostanie wywoÅ‚ana z nieprawidÅ‚owymi wartoÅ›ciami, TwÃ³j kod powinien najpierw zweryfikowaÄ‡, czy wartoÅ›ci sÄ… prawidÅ‚owe, i wywoÅ‚aÄ‡ panikÄ™, jeÅ›li wartoÅ›ci sÄ… nieprawidÅ‚owe. Jest to gÅ‚Ã³wnie ze wzglÄ™dÃ³w bezpieczeÅ„stwa: prÃ³ba operowania na nieprawidÅ‚owych danych moÅ¼e naraziÄ‡ TwÃ³j kod na luki. To gÅ‚Ã³wny powÃ³d, dla ktÃ³rego standardowa biblioteka wywoÅ‚a <code>panic!</code>, jeÅ›li sprÃ³bujesz uzyskaÄ‡ dostÄ™p do pamiÄ™ci poza jej granicami: prÃ³ba dostÄ™pu do pamiÄ™ci, ktÃ³ra nie naleÅ¼y do bieÅ¼Ä…cej struktury danych, jest czÄ™stym problemem bezpieczeÅ„stwa. Funkcje czÄ™sto majÄ… <em>kontrakty</em>: ich zachowanie jest gwarantowane tylko wtedy, gdy dane wejÅ›ciowe speÅ‚niajÄ… okreÅ›lone wymagania. Panika, gdy kontrakt jest naruszony, ma sens, poniewaÅ¼ naruszenie kontraktu zawsze wskazuje na bÅ‚Ä…d po stronie wywoÅ‚ujÄ…cego, i nie jest to rodzaj bÅ‚Ä™du, ktÃ³ry kod wywoÅ‚ujÄ…cy powinien jawnie obsÅ‚ugiwaÄ‡. W rzeczywistoÅ›ci nie ma rozsÄ…dnego sposobu, aby kod wywoÅ‚ujÄ…cy siÄ™ odzyskaÅ‚; programiÅ›ci wywoÅ‚ujÄ…cy muszÄ… naprawiÄ‡ kod. Kontrakty funkcji, zwÅ‚aszcza gdy naruszenie spowoduje panikÄ™, powinny byÄ‡ wyjaÅ›nione w dokumentacji API funkcji.</p>
<p>JednakÅ¼e, posiadanie wielu kontroli bÅ‚Ä™dÃ³w we wszystkich funkcjach byÅ‚oby rozbudowane i uciÄ…Å¼liwe. Na szczÄ™Å›cie, moÅ¼esz uÅ¼yÄ‡ systemu typÃ³w Rusta (a co za tym idzie, sprawdzania typÃ³w wykonywanego przez kompilator), aby wykonaÄ‡ wiele kontroli za Ciebie. JeÅ›li Twoja funkcja ma okreÅ›lony typ jako parametr, moÅ¼esz kontynuowaÄ‡ logikÄ™ kodu, wiedzÄ…c, Å¼e kompilator juÅ¼ zapewniÅ‚, Å¼e masz prawidÅ‚owÄ… wartoÅ›Ä‡. Na przykÅ‚ad, jeÅ›li masz typ zamiast <code>Option</code>, TwÃ³j program oczekuje <em>czegoÅ›</em> zamiast <em>niczego</em>. TwÃ³j kod nie musi wtedy obsÅ‚ugiwaÄ‡ dwÃ³ch przypadkÃ³w dla wariantÃ³w <code>Some</code> i <code>None</code>: bÄ™dzie miaÅ‚ tylko jeden przypadek dla zdecydowanego posiadania wartoÅ›ci. Kod prÃ³bujÄ…cy przekazaÄ‡ nic do Twojej funkcji nawet siÄ™ nie skompiluje, wiÄ™c Twoja funkcja nie musi sprawdzaÄ‡ tego przypadku w czasie wykonywania. Innym przykÅ‚adem jest uÅ¼ycie typu liczby caÅ‚kowitej bez znaku, takiego jak <code>u32</code>, co zapewnia, Å¼e parametr nigdy nie jest ujemny.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-custom-types-for-validation"></a></p>
<h3 id="niestandardowe-typy-do-walidacji"><a class="header" href="#niestandardowe-typy-do-walidacji">Niestandardowe typy do walidacji</a></h3>
<p>RozwiÅ„my ideÄ™ uÅ¼ywania systemu typÃ³w Rusta do zapewnienia, Å¼e mamy prawidÅ‚owÄ… wartoÅ›Ä‡, idÄ…c o krok dalej i przyjrzyjmy siÄ™ tworzeniu niestandardowego typu do walidacji. Przypomnij sobie grÄ™ zgadywanek z RozdziaÅ‚u 2, w ktÃ³rej nasz kod prosiÅ‚ uÅ¼ytkownika o odgadniÄ™cie liczby od 1 do 100. Nigdy nie walidowaliÅ›my, czy odgadniÄ™ta przez uÅ¼ytkownika liczba mieÅ›ciÅ‚a siÄ™ w tym zakresie, zanim porÃ³wnaliÅ›my jÄ… z naszÄ… tajnÄ… liczbÄ…; walidowaliÅ›my tylko, czy odgadniÄ™ta liczba byÅ‚a dodatnia. W tym przypadku konsekwencje nie byÅ‚y zbyt powaÅ¼ne: nasze komunikaty â€Za maÅ‚aâ€ lub â€Za duÅ¼aâ€ nadal byÅ‚yby poprawne. Ale przydatnym ulepszeniem byÅ‚oby pokierowanie uÅ¼ytkownika w stronÄ™ prawidÅ‚owych zgadywanek i zapewnienie innego zachowania, gdy uÅ¼ytkownik odgadnie liczbÄ™ spoza zakresu, niÅ¼ gdy uÅ¼ytkownik wpisze na przykÅ‚ad litery.</p>
<p>Jednym ze sposobÃ³w na to byÅ‚oby parsowanie odgadniÄ™tej liczby jako <code>i32</code> zamiast tylko <code>u32</code>, aby umoÅ¼liwiÄ‡ potencjalnie ujemne liczby, a nastÄ™pnie dodanie sprawdzenia, czy liczba mieÅ›ci siÄ™ w zakresie, tak jak poniÅ¼ej:</p>
<listing file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Odgadnij liczbÄ™!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    loop {
        // --snip--

<span class="boring">        println!("WprowadÅº swoje odgadniÄ™cie.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Nie udaÅ‚o siÄ™ odczytaÄ‡ linii");
</span><span class="boring">
</span>        let guess: i32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        if guess &lt; 1 || guess &gt; 100 {
            println!("Tajny numer bÄ™dzie miÄ™dzy 1 a 100.");
            continue;
        }

        match guess.cmp(&amp;secret_number) {
            // --snip--
<span class="boring">            Ordering::Less =&gt; println!("Za maÅ‚a!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Za duÅ¼a!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("WygraÅ‚eÅ›!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}</span></code></pre>
</listing>
<p>WyraÅ¼enie <code>if</code> sprawdza, czy nasza wartoÅ›Ä‡ jest poza zakresem, informuje uÅ¼ytkownika o problemie i wywoÅ‚uje <code>continue</code>, aby rozpoczÄ…Ä‡ kolejnÄ… iteracjÄ™ pÄ™tli i poprosiÄ‡ o kolejne odgadniÄ™cie. Po wyraÅ¼eniu <code>if</code> moÅ¼emy kontynuowaÄ‡ porÃ³wnania miÄ™dzy <code>guess</code> a tajnÄ… liczbÄ…, wiedzÄ…c, Å¼e <code>guess</code> znajduje siÄ™ miÄ™dzy 1 a 100.</p>
<p>Jednak to nie jest idealne rozwiÄ…zanie: gdyby absolutnie kluczowe byÅ‚o to, aby program operowaÅ‚ tylko na wartoÅ›ciach od 1 do 100, i miaÅ‚ wiele funkcji z tym wymogiem, posiadanie takiego sprawdzenia w kaÅ¼dej funkcji byÅ‚oby uciÄ…Å¼liwe (i mogÅ‚oby wpÅ‚ynÄ…Ä‡ na wydajnoÅ›Ä‡).</p>
<p>Zamiast tego, moÅ¼emy utworzyÄ‡ nowy typ w dedykowanym module i umieÅ›ciÄ‡ walidacje w funkcji, aby utworzyÄ‡ instancjÄ™ tego typu, zamiast powtarzaÄ‡ walidacje wszÄ™dzie. W ten sposÃ³b funkcje bÄ™dÄ… mogÅ‚y bezpiecznie uÅ¼ywaÄ‡ nowego typu w swoich sygnaturach i Å›miaÅ‚o uÅ¼ywaÄ‡ otrzymanych wartoÅ›ci. Listing 9-13 pokazuje jeden ze sposobÃ³w definiowania typu <code>Guess</code>, ktÃ³ry utworzy instancjÄ™ <code>Guess</code> tylko wtedy, gdy funkcja <code>new</code> otrzyma wartoÅ›Ä‡ z zakresu od 1 do 100.</p>
<listing number="9-13" caption="Typ `Guess`, ktÃ³ry bÄ™dzie dziaÅ‚aÄ‡ tylko z wartoÅ›ciami od 1 do 100" file-name="src/guessing_game.rs">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!("WartoÅ›Ä‡ odgadniÄ™cia musi byÄ‡ miÄ™dzy 1 a 100, otrzymano {value}.");
        }

        Guess { value }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
<span class="boring">}</span></code></pre>
</listing>
<p>ZauwaÅ¼, Å¼e ten kod w <em>src/guessing_game.rs</em> zaleÅ¼y od dodania deklaracji moduÅ‚u <code>mod guessing_game;</code> w <em>src/lib.rs</em>, ktÃ³rej tutaj nie pokazaliÅ›my. W pliku tego nowego moduÅ‚u definiujemy strukturÄ™ o nazwie <code>Guess</code>, ktÃ³ra ma pole o nazwie <code>value</code>, przechowujÄ…ce <code>i32</code>. Tutaj bÄ™dzie przechowywana liczba.</p>
<p>NastÄ™pnie implementujemy funkcjÄ™ skojarzonÄ… o nazwie <code>new</code> dla <code>Guess</code>, ktÃ³ra tworzy instancje wartoÅ›ci <code>Guess</code>. Funkcja <code>new</code> jest zdefiniowana tak, aby miaÅ‚a jeden parametr o nazwie <code>value</code> typu <code>i32</code> i zwracaÅ‚a <code>Guess</code>. Kod w treÅ›ci funkcji <code>new</code> testuje <code>value</code>, aby upewniÄ‡ siÄ™, Å¼e mieÅ›ci siÄ™ ono w zakresie od 1 do 100. JeÅ›li <code>value</code> nie przejdzie tego testu, wywoÅ‚ujemy <code>panic!</code>, co ostrzeÅ¼e programistÄ™ piszÄ…cego kod wywoÅ‚ujÄ…cy, Å¼e ma bÅ‚Ä…d do naprawienia, poniewaÅ¼ utworzenie <code>Guess</code> z <code>value</code> spoza tego zakresu naruszyÅ‚oby kontrakt, na ktÃ³rym polega <code>Guess::new</code>. Warunki, w ktÃ³rych <code>Guess::new</code> moÅ¼e panikowaÄ‡, powinny byÄ‡ omÃ³wione w jego publicznie dostÄ™pnej dokumentacji API; konwencje dokumentacji wskazujÄ…ce na moÅ¼liwoÅ›Ä‡ paniki w dokumentacji API, ktÃ³rÄ… tworzysz, omÃ³wimy w rozdziale 14. JeÅ›li <code>value</code> przejdzie test, tworzymy nowy <code>Guess</code> z jego polem <code>value</code> ustawionym na parametr <code>value</code> i zwracamy <code>Guess</code>.</p>
<p>NastÄ™pnie implementujemy metodÄ™ o nazwie <code>value</code>, ktÃ³ra poÅ¼ycza <code>self</code>, nie ma Å¼adnych innych parametrÃ³w i zwraca <code>i32</code>. Taki rodzaj metody jest czasami nazywany <em>getterem</em>, poniewaÅ¼ jego celem jest pobranie danych z pÃ³l i zwrÃ³cenie ich. Ta publiczna metoda jest niezbÄ™dna, poniewaÅ¼ pole <code>value</code> struktury <code>Guess</code> jest prywatne. WaÅ¼ne jest, aby pole <code>value</code> byÅ‚o prywatne, aby kod uÅ¼ywajÄ…cy struktury <code>Guess</code> nie mÃ³gÅ‚ bezpoÅ›rednio ustawiaÄ‡ <code>value</code>: kod spoza moduÅ‚u <code>guessing_game</code> <em>musi</em> uÅ¼ywaÄ‡ funkcji <code>Guess::new</code> do tworzenia instancji <code>Guess</code>, zapewniajÄ…c w ten sposÃ³b, Å¼e nie ma moÅ¼liwoÅ›ci, aby <code>Guess</code> miaÅ‚o <code>value</code>, ktÃ³re nie zostaÅ‚o sprawdzone przez warunki w funkcji <code>Guess::new</code>.</p>
<p>Funkcja, ktÃ³ra ma parametr lub zwraca tylko liczby z zakresu od 1 do 100, mogÅ‚aby nastÄ™pnie zadeklarowaÄ‡ w swojej sygnaturze, Å¼e przyjmuje lub zwraca <code>Guess</code> zamiast <code>i32</code> i nie musiaÅ‚aby wykonywaÄ‡ Å¼adnych dodatkowych sprawdzeÅ„ w swoim ciele.</p>
<h2 id="podsumowanie-8"><a class="header" href="#podsumowanie-8">Podsumowanie</a></h2>
<p>Funkcje obsÅ‚ugi bÅ‚Ä™dÃ³w w Rust sÄ… zaprojektowane tak, aby pomÃ³c Ci pisaÄ‡ bardziej niezawodny kod. Makro <code>panic!</code> sygnalizuje, Å¼e TwÃ³j program jest w stanie, ktÃ³rego nie jest w stanie obsÅ‚uÅ¼yÄ‡, i pozwala Ci nakazaÄ‡ procesowi zatrzymanie siÄ™, zamiast prÃ³bowaÄ‡ kontynuowaÄ‡ z nieprawidÅ‚owymi lub bÅ‚Ä™dnymi wartoÅ›ciami. Enum <code>Result</code> uÅ¼ywa systemu typÃ³w Rusta, aby wskazaÄ‡, Å¼e operacje mogÄ… zakoÅ„czyÄ‡ siÄ™ niepowodzeniem w sposÃ³b, ktÃ³ry TwÃ³j kod mÃ³gÅ‚by odzyskaÄ‡. MoÅ¼esz uÅ¼yÄ‡ <code>Result</code>, aby powiedzieÄ‡ kodowi, ktÃ³ry wywoÅ‚uje TwÃ³j kod, Å¼e musi on rÃ³wnieÅ¼ obsÅ‚uÅ¼yÄ‡ potencjalny sukces lub niepowodzenie. UÅ¼ycie <code>panic!</code> i <code>Result</code> w odpowiednich sytuacjach sprawi, Å¼e TwÃ³j kod bÄ™dzie bardziej niezawodny w obliczu nieuniknionych problemÃ³w.</p>
<p>Teraz, gdy widziaÅ‚eÅ› przydatne sposoby, w jakie standardowa biblioteka uÅ¼ywa generykÃ³w z enumami <code>Option</code> i <code>Result</code>, porozmawiamy o tym, jak dziaÅ‚ajÄ… generyki i jak moÅ¼esz ich uÅ¼ywaÄ‡ w swoim kodzie.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="typy-generyczne-cechy-i-czasy-Å¼ycia"><a class="header" href="#typy-generyczne-cechy-i-czasy-Å¼ycia">Typy generyczne, cechy i czasy Å¼ycia</a></h1>
<p>KaÅ¼dy jÄ™zyk programowania posiada narzÄ™dzia do efektywnego zarzÄ…dzania powtarzalnoÅ›ciÄ… koncepcji. W Rust, jednym z takich narzÄ™dzi sÄ… <em>generyki</em>: abstrakcyjne zamienniki dla konkretnych typÃ³w lub innych wÅ‚aÅ›ciwoÅ›ci. MoÅ¼emy wyraziÄ‡ zachowanie generykÃ³w lub ich relacje z innymi generykami, nie wiedzÄ…c, co znajdzie siÄ™ na ich miejscu podczas kompilacji i uruchamiania kodu.</p>
<p>Funkcje mogÄ… przyjmowaÄ‡ parametry jakiegoÅ› typu generycznego, zamiast konkretnego typu, takiego jak <code>i32</code> lub <code>String</code>, w ten sam sposÃ³b, w jaki przyjmujÄ… parametry o nieznanych wartoÅ›ciach, aby uruchamiaÄ‡ ten sam kod na wielu konkretnych wartoÅ›ciach. W rzeczywistoÅ›ci, juÅ¼ uÅ¼ywaliÅ›my generykÃ³w w Rozdziale 6 z <code>Option&lt;T&gt;</code>, w Rozdziale 8 z <code>Vec&lt;T&gt;</code> i <code>HashMap&lt;K, V&gt;</code>, oraz w Rozdziale 9 z <code>Result&lt;T, E&gt;</code>. W tym rozdziale poznasz, jak definiowaÄ‡ wÅ‚asne typy, funkcje i metody za pomocÄ… generykÃ³w!</p>
<p>Najpierw przypomnimy, jak wyodrÄ™bniÄ‡ funkcjÄ™, aby zmniejszyÄ‡ duplikacjÄ™ kodu. NastÄ™pnie uÅ¼yjemy tej samej techniki, aby stworzyÄ‡ funkcjÄ™ generycznÄ… z dwÃ³ch funkcji, ktÃ³re rÃ³Å¼niÄ… siÄ™ tylko typami swoich parametrÃ³w. WyjaÅ›nimy rÃ³wnieÅ¼, jak uÅ¼ywaÄ‡ typÃ³w generycznych w definicjach struktur i wyliczeÅ„.</p>
<p>NastÄ™pnie dowiesz siÄ™, jak uÅ¼ywaÄ‡ cech (traits) do definiowania zachowania w sposÃ³b generyczny. MoÅ¼esz Å‚Ä…czyÄ‡ cechy z typami generycznymi, aby ograniczyÄ‡ typ generyczny do akceptowania tylko tych typÃ³w, ktÃ³re majÄ… okreÅ›lone zachowanie, w przeciwieÅ„stwie do dowolnego typu.</p>
<p>Na koniec omÃ³wimy <em>czasy Å¼ycia</em>: odmianÄ™ generykÃ³w, ktÃ³ra dostarcza kompilatorowi informacji o tym, jak referencje odnoszÄ… siÄ™ do siebie. Czasy Å¼ycia pozwalajÄ… nam dostarczyÄ‡ kompilatorowi wystarczajÄ…cych informacji o poÅ¼yczonych wartoÅ›ciach, aby mÃ³gÅ‚ on zapewniÄ‡, Å¼e referencje bÄ™dÄ… waÅ¼ne w wiÄ™kszej liczbie sytuacji, niÅ¼ byÅ‚oby to moÅ¼liwe bez naszej pomocy.</p>
<h2 id="usuwanie-duplikacji-poprzez-wyodrÄ™bnianie-funkcji"><a class="header" href="#usuwanie-duplikacji-poprzez-wyodrÄ™bnianie-funkcji">Usuwanie duplikacji poprzez wyodrÄ™bnianie funkcji</a></h2>
<p>Generyki pozwalajÄ… nam zastÄ™powaÄ‡ konkretne typy przez placeholder, ktÃ³ry reprezentuje wiele typÃ³w, aby usunÄ…Ä‡ duplikacjÄ™ kodu. Zanim zagÅ‚Ä™bimy siÄ™ w skÅ‚adniÄ™ generykÃ³w, najpierw przyjrzyjmy siÄ™, jak usunÄ…Ä‡ duplikacjÄ™ w sposÃ³b, ktÃ³ry nie obejmuje typÃ³w generycznych, poprzez wyodrÄ™bnienie funkcji, ktÃ³ra zastÄ™puje konkretne wartoÅ›ci przez placeholder reprezentujÄ…cy wiele wartoÅ›ci. NastÄ™pnie zastosujemy tÄ™ samÄ… technikÄ™ do wyodrÄ™bnienia funkcji generycznej! PatrzÄ…c na to, jak rozpoznaÄ‡ zduplikowany kod, ktÃ³ry moÅ¼na wyodrÄ™bniÄ‡ do funkcji, zaczniesz rozpoznawaÄ‡ zduplikowany kod, ktÃ³ry moÅ¼e uÅ¼ywaÄ‡ generykÃ³w.</p>
<p>Zaczniemy od krÃ³tkiego programu w Listing 10-1, ktÃ³ry znajduje najwiÄ™kszÄ… liczbÄ™ na liÅ›cie.</p>
<listing number="10-1" file-name="src/main.rs" caption="Znajdowanie najwiÄ™kszej liczby na liÅ›cie liczb">
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("NajwiÄ™ksza liczba to {largest}");
<span class="boring">    assert_eq!(*largest, 100);
</span>}</code></pre>
</listing>
<p>Przechowujemy listÄ™ liczb caÅ‚kowitych w zmiennej <code>number_list</code> i umieszczamy referencjÄ™ do pierwszej liczby na liÅ›cie w zmiennej o nazwie <code>largest</code>. NastÄ™pnie iterujemy po wszystkich liczbach na liÅ›cie, a jeÅ›li bieÅ¼Ä…ca liczba jest wiÄ™ksza niÅ¼ liczba przechowywana w <code>largest</code>, zastÄ™pujemy referencjÄ™ w tej zmiennej. JednakÅ¼e, jeÅ›li bieÅ¼Ä…ca liczba jest mniejsza lub rÃ³wna najwiÄ™kszej liczbie widzianej do tej pory, zmienna nie zmienia siÄ™, a kod przechodzi do nastÄ™pnej liczby na liÅ›cie. Po rozwaÅ¼eniu wszystkich liczb na liÅ›cie, <code>largest</code> powinien odnosiÄ‡ siÄ™ do najwiÄ™kszej liczby, ktÃ³ra w tym przypadku wynosi 100.</p>
<p>Teraz postawiono nam zadanie znalezienia najwiÄ™kszej liczby na dwÃ³ch rÃ³Å¼nych listach liczb. Aby to zrobiÄ‡, moÅ¼emy zdecydowaÄ‡ siÄ™ na zduplikowanie kodu z Listing 10-1 i uÅ¼ycie tej samej logiki w dwÃ³ch rÃ³Å¼nych miejscach w programie, jak pokazano w Listing 10-2.</p>
<listing number="10-2" file-name="src/main.rs" caption="Kod do znajdowania najwiÄ™kszej liczby na *dwÃ³ch* listach liczb">
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("NajwiÄ™ksza liczba to {largest}");

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("NajwiÄ™ksza liczba to {largest}");
}</code></pre>
</listing>
<p>ChociaÅ¼ ten kod dziaÅ‚a, duplikowanie kodu jest uciÄ…Å¼liwe i podatne na bÅ‚Ä™dy. Musimy rÃ³wnieÅ¼ pamiÄ™taÄ‡ o aktualizowaniu kodu w wielu miejscach, gdy chcemy go zmieniÄ‡.</p>
<p>Aby wyeliminowaÄ‡ tÄ™ duplikacjÄ™, stworzymy abstrakcjÄ™, definiujÄ…c funkcjÄ™, ktÃ³ra operuje na dowolnej liÅ›cie liczb caÅ‚kowitych przekazanej jako parametr. To rozwiÄ…zanie czyni nasz kod jaÅ›niejszym i pozwala nam abstrakcyjnie wyraziÄ‡ koncepcjÄ™ znajdowania najwiÄ™kszej liczby na liÅ›cie.</p>
<p>W Listing 10-3 wyodrÄ™bniamy kod, ktÃ³ry znajduje najwiÄ™kszÄ… liczbÄ™, do funkcji o nazwie <code>largest</code>. NastÄ™pnie wywoÅ‚ujemy funkcjÄ™, aby znaleÅºÄ‡ najwiÄ™kszÄ… liczbÄ™ na dwÃ³ch listach z Listing 10-2. MoglibyÅ›my rÃ³wnieÅ¼ uÅ¼yÄ‡ tej funkcji na dowolnej innej liÅ›cie wartoÅ›ci <code>i32</code>, ktÃ³re moglibyÅ›my mieÄ‡ w przyszÅ‚oÅ›ci.</p>
<listing number="10-3" file-name="src/main.rs" caption="Zabstrahowany kod do znajdowania najwiÄ™kszej liczby na dwÃ³ch listach">
<pre class="playground"><code class="language-rust edition2024">fn largest(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("NajwiÄ™ksza liczba to {result}");
<span class="boring">    assert_eq!(*result, 100);
</span>
    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!("NajwiÄ™ksza liczba to {result}");
<span class="boring">    assert_eq!(*result, 6000);
</span>}</code></pre>
</listing>
<p>Funkcja <code>largest</code> ma parametr <code>list</code>, ktÃ³ry reprezentuje dowolny konkretny wycinek wartoÅ›ci <code>i32</code>, ktÃ³ry moÅ¼emy przekazaÄ‡ do funkcji. W rezultacie, gdy wywoÅ‚ujemy funkcjÄ™, kod dziaÅ‚a na konkretnych wartoÅ›ciach, ktÃ³re przekazujemy.</p>
<p>PodsumowujÄ…c, oto kroki, ktÃ³re podjÄ™liÅ›my, aby zmieniÄ‡ kod z Listing 10-2 na Listing 10-3:</p>
<ol>
<li>Zidentyfikuj zduplikowany kod.</li>
<li>WyodrÄ™bnij zduplikowany kod do ciaÅ‚a funkcji i okreÅ›l wejÅ›cia i wartoÅ›ci zwracane tego kodu w sygnaturze funkcji.</li>
<li>Zaktualizuj dwa wystÄ…pienia zduplikowanego kodu, aby zamiast tego wywoÅ‚ywaÅ‚y funkcjÄ™.</li>
</ol>
<p>NastÄ™pnie uÅ¼yjemy tych samych krokÃ³w z generykami, aby zmniejszyÄ‡ duplikacjÄ™ kodu. W ten sam sposÃ³b, w jaki ciaÅ‚o funkcji moÅ¼e dziaÅ‚aÄ‡ na abstrakcyjnej <code>liÅ›cie</code> zamiast na konkretnych wartoÅ›ciach, generyki pozwalajÄ… kodowi dziaÅ‚aÄ‡ na abstrakcyjnych typach.</p>
<p>Na przykÅ‚ad, powiedzmy, Å¼e mieliÅ›my dwie funkcje: jednÄ…, ktÃ³ra znajduje najwiÄ™kszy element w wycinku wartoÅ›ci <code>i32</code>, i drugÄ…, ktÃ³ra znajduje najwiÄ™kszy element w wycinku wartoÅ›ci <code>char</code>. Jak wyeliminowalibyÅ›my tÄ™ duplikacjÄ™? Dowiedzmy siÄ™!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="generyczne-typy-danych-1"><a href="#generyczne-typy-danych-1" class="header">Generyczne typy danych</a></h1>
<h2 id="generyczne-typy-danych"><a class="header" href="#generyczne-typy-danych">Generyczne typy danych</a></h2>
<p>UÅ¼ywamy generykÃ³w do tworzenia definicji dla elementÃ³w, takich jak sygnatury funkcji lub struktury, ktÃ³re moÅ¼emy nastÄ™pnie wykorzystaÄ‡ z wieloma rÃ³Å¼nymi konkretnymi typami danych. Najpierw przyjrzymy siÄ™, jak definiowaÄ‡ funkcje, struktury, wyliczenia i metody za pomocÄ… generykÃ³w. NastÄ™pnie omÃ³wimy, jak generyki wpÅ‚ywajÄ… na wydajnoÅ›Ä‡ kodu.</p>
<h3 id="w-definicjach-funkcji"><a class="header" href="#w-definicjach-funkcji">W definicjach funkcji</a></h3>
<p>Podczas definiowania funkcji uÅ¼ywajÄ…cej generykÃ³w, umieszczamy generyki w sygnaturze funkcji, tam gdzie zazwyczaj okreÅ›lamy typy danych parametrÃ³w i wartoÅ›Ä‡ zwracanÄ…. DziÄ™ki temu nasz kod jest bardziej elastyczny i zapewnia wiÄ™kszÄ… funkcjonalnoÅ›Ä‡ wywoÅ‚ujÄ…cym naszÄ… funkcjÄ™, jednoczeÅ›nie zapobiegajÄ…c duplikacji kodu.</p>
<p>KontynuujÄ…c naszÄ… funkcjÄ™ <code>largest</code>, Listing 10-4 pokazuje dwie funkcje, ktÃ³re obie znajdujÄ… najwiÄ™kszÄ… wartoÅ›Ä‡ w wycinku. NastÄ™pnie poÅ‚Ä…czymy je w jednÄ… funkcjÄ™, ktÃ³ra uÅ¼ywa generykÃ³w.</p>
<listing number="10-4" file-name="src/main.rs" caption="Dwie funkcje, ktÃ³re rÃ³Å¼niÄ… siÄ™ tylko nazwami i typami w sygnaturach">
<pre class="playground"><code class="language-rust edition2024">fn largest_i32(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; &amp;char {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!("NajwiÄ™ksza liczba to {result}");
<span class="boring">    assert_eq!(*result, 100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!("NajwiÄ™kszy znak to {result}");
<span class="boring">    assert_eq!(*result, 'y');
</span>}</code></pre>
</listing>
<p>Funkcja <code>largest_i32</code> jest tÄ…, ktÃ³rÄ… wyodrÄ™bniliÅ›my w Listing 10-3, ktÃ³ra znajduje najwiÄ™kszÄ… <code>i32</code> w wycinku. Funkcja <code>largest_char</code> znajduje najwiÄ™kszy <code>char</code> w wycinku. CiaÅ‚a funkcji majÄ… ten sam kod, wiÄ™c wyeliminujmy duplikacjÄ™, wprowadzajÄ…c generyczny parametr typu w jednej funkcji.</p>
<p>Aby sparametryzowaÄ‡ typy w nowej pojedynczej funkcji, musimy nadaÄ‡ nazwÄ™ parametrowi typu, tak jak to robimy dla parametrÃ³w wartoÅ›ci funkcji. MoÅ¼esz uÅ¼yÄ‡ dowolnego identyfikatora jako nazwy parametru typu. My jednak uÅ¼yjemy <code>T</code>, poniewaÅ¼, zgodnie z konwencjÄ…, nazwy parametrÃ³w typu w Rust sÄ… krÃ³tkie, czÄ™sto skÅ‚adajÄ… siÄ™ tylko z jednej litery, a konwencja nazewnictwa typÃ³w w Rust to UpperCamelCase. <code>T</code> (skrÃ³t od <em>type</em>) jest domyÅ›lnym wyborem wiÄ™kszoÅ›ci programistÃ³w Rusta.</p>
<p>Kiedy uÅ¼ywamy parametru w ciele funkcji, musimy zadeklarowaÄ‡ nazwÄ™ parametru w sygnaturze, aby kompilator wiedziaÅ‚, co ta nazwa oznacza. Podobnie, kiedy uÅ¼ywamy nazwy parametru typu w sygnaturze funkcji, musimy zadeklarowaÄ‡ nazwÄ™ parametru typu, zanim jej uÅ¼yjemy. Aby zdefiniowaÄ‡ generycznÄ… funkcjÄ™ <code>largest</code>, umieszczamy deklaracje nazw typÃ³w w nawiasach ostrych, <code>&lt;&gt;</code>, miÄ™dzy nazwÄ… funkcji a listÄ… parametrÃ³w, tak:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {</code></pre>
<p>TÄ™ definicjÄ™ czytamy jako â€funkcja <code>largest</code> jest generyczna wzglÄ™dem jakiegoÅ› typu <code>T</code>â€. Ta funkcja ma jeden parametr o nazwie <code>list</code>, ktÃ³ry jest wycinkiem wartoÅ›ci typu <code>T</code>. Funkcja <code>largest</code> zwrÃ³ci referencjÄ™ do wartoÅ›ci tego samego typu <code>T</code>.</p>
<p>Listing 10-5 pokazuje poÅ‚Ä…czonÄ… definicjÄ™ funkcji <code>largest</code> uÅ¼ywajÄ…cÄ… generycznego typu danych w swojej sygnaturze. Listing pokazuje rÃ³wnieÅ¼, jak moÅ¼emy wywoÅ‚aÄ‡ funkcjÄ™ z wycinkiem wartoÅ›ci <code>i32</code> lub <code>char</code>. ZauwaÅ¼, Å¼e ten kod jeszcze siÄ™ nie skompiluje.</p>
<listing number="10-5" file-name="src/main.rs" caption="Funkcja `largest` uÅ¼ywajÄ…ca generycznych parametrÃ³w typu; jeszcze siÄ™ nie kompiluje">
<pre><code class="language-rust ignore does_not_compile">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("NajwiÄ™ksza liczba to {result}");

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!("NajwiÄ™kszy znak to {result}");
}</code></pre>
</listing>
<p>JeÅ›li skompilujemy ten kod teraz, otrzymamy nastÄ™pujÄ…cy bÅ‚Ä…d:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `&amp;T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- &amp;T
  |            |
  |            &amp;T
  |
help: consider restricting type parameter `T` with trait `PartialOrd`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>Tekst pomocy wspomina o <code>std::cmp::PartialOrd</code>, ktÃ³ry jest cechÄ… (trait), a o cechach bÄ™dziemy mÃ³wiÄ‡ w nastÄ™pnej sekcji. Na razie wiedz, Å¼e ten bÅ‚Ä…d oznacza, Å¼e ciaÅ‚o funkcji <code>largest</code> nie zadziaÅ‚a dla wszystkich moÅ¼liwych typÃ³w, ktÃ³rymi mogÅ‚oby byÄ‡ <code>T</code>. PoniewaÅ¼ chcemy porÃ³wnywaÄ‡ wartoÅ›ci typu <code>T</code> w ciele funkcji, moÅ¼emy uÅ¼ywaÄ‡ tylko typÃ³w, ktÃ³rych wartoÅ›ci moÅ¼na uporzÄ…dkowaÄ‡. Aby umoÅ¼liwiÄ‡ porÃ³wnania, standardowa biblioteka posiada cechÄ™ <code>std::cmp::PartialOrd</code>, ktÃ³rÄ… moÅ¼na zaimplementowaÄ‡ na typach (wiÄ™cej na temat tej cechy znajdziesz w Dodatku C). Aby naprawiÄ‡ Listing 10-5, moÅ¼emy zastosowaÄ‡ siÄ™ do sugestii tekstu pomocy i ograniczyÄ‡ typy dozwolone dla <code>T</code> tylko do tych, ktÃ³re implementujÄ… <code>PartialOrd</code>. Listing nastÄ™pnie siÄ™ skompiluje, poniewaÅ¼ standardowa biblioteka implementuje <code>PartialOrd</code> zarÃ³wno dla <code>i32</code>, jak i <code>char</code>.</p>
<h3 id="w-definicjach-struktur"><a class="header" href="#w-definicjach-struktur">W definicjach struktur</a></h3>
<p>MoÅ¼emy rÃ³wnieÅ¼ definiowaÄ‡ struktury, aby uÅ¼ywaÅ‚y generycznego parametru typu w jednym lub wiÄ™cej polach, uÅ¼ywajÄ…c skÅ‚adni <code>&lt;&gt;</code>. Listing 10-6 definiuje strukturÄ™ <code>Point&lt;T&gt;</code> do przechowywania wartoÅ›ci wspÃ³Å‚rzÄ™dnych <code>x</code> i <code>y</code> dowolnego typu.</p>
<listing number="10-6" file-name="src/main.rs" caption="Struktura `Point&lt;T&gt;`, ktÃ³ra przechowuje wartoÅ›ci `x` i `y` typu `T`">
<pre class="playground"><code class="language-rust edition2024">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}</code></pre>
</listing>
<p>SkÅ‚adnia uÅ¼ywania generykÃ³w w definicjach struktur jest podobna do tej uÅ¼ywanej w definicjach funkcji. Najpierw deklarujemy nazwÄ™ parametru typu w nawiasach ostrych tuÅ¼ po nazwie struktury. NastÄ™pnie uÅ¼ywamy typu generycznego w definicji struktury tam, gdzie w przeciwnym razie okreÅ›lilibyÅ›my konkretne typy danych.</p>
<p>ZauwaÅ¼, Å¼e poniewaÅ¼ uÅ¼yliÅ›my tylko jednego typu generycznego do zdefiniowania <code>Point&lt;T&gt;</code>, ta definicja mÃ³wi, Å¼e struktura <code>Point&lt;T&gt;</code> jest generyczna wzglÄ™dem jakiegoÅ› typu <code>T</code>, a pola <code>x</code> i <code>y</code> sÄ… <em>obydwa</em> tego samego typu, niezaleÅ¼nie od tego, jaki to typ. JeÅ›li stworzymy instancjÄ™ <code>Point&lt;T&gt;</code>, ktÃ³ra ma wartoÅ›ci rÃ³Å¼nych typÃ³w, jak w Listing 10-7, nasz kod siÄ™ nie skompiluje.</p>
<listing number="10-7" file-name="src/main.rs" caption="Pola `x` i `y` muszÄ… byÄ‡ tego samego typu, poniewaÅ¼ oba majÄ… ten sam generyczny typ danych `T`.">
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}</code></pre>
</listing>
<p>W tym przykÅ‚adzie, gdy przypisujemy wartoÅ›Ä‡ caÅ‚kowitÄ… <code>5</code> do <code>x</code>, informujemy kompilator, Å¼e generyczny typ <code>T</code> bÄ™dzie liczbÄ… caÅ‚kowitÄ… dla tej instancji <code>Point&lt;T&gt;</code>. NastÄ™pnie, gdy okreÅ›lamy <code>4.0</code> dla <code>y</code>, ktÃ³re zdefiniowaliÅ›my jako majÄ…ce ten sam typ co <code>x</code>, otrzymamy bÅ‚Ä…d niezgodnoÅ›ci typÃ³w, taki jak ten:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>Aby zdefiniowaÄ‡ strukturÄ™ <code>Point</code>, w ktÃ³rej <code>x</code> i <code>y</code> sÄ… obydwa generyczne, ale mogÄ… mieÄ‡ rÃ³Å¼ne typy, moÅ¼emy uÅ¼yÄ‡ wielu generycznych parametrÃ³w typu. Na przykÅ‚ad, w Listing 10-8 zmieniamy definicjÄ™ <code>Point</code> tak, aby byÅ‚a generyczna wzglÄ™dem typÃ³w <code>T</code> i <code>U</code>, gdzie <code>x</code> jest typu <code>T</code>, a <code>y</code> jest typu <code>U</code>.</p>
<listing number="10-8" file-name="src/main.rs" caption="`Point&lt;T, U&gt;` generyczny wzglÄ™dem dwÃ³ch typÃ³w, tak aby `x` i `y` mogÅ‚y byÄ‡ wartoÅ›ciami rÃ³Å¼nych typÃ³w">
<pre class="playground"><code class="language-rust edition2024">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}</code></pre>
</listing>
<p>Teraz wszystkie pokazane instancje <code>Point</code> sÄ… dozwolone! MoÅ¼esz uÅ¼ywaÄ‡ tylu generycznych parametrÃ³w typu w definicji, ile chcesz, ale uÅ¼ywanie wiÄ™cej niÅ¼ kilku utrudnia czytanie kodu. JeÅ›li okaÅ¼e siÄ™, Å¼e potrzebujesz wielu typÃ³w generycznych w swoim kodzie, moÅ¼e to wskazywaÄ‡ na potrzebÄ™ restrukturyzacji kodu na mniejsze czÄ™Å›ci.</p>
<h3 id="w-definicjach-wyliczeÅ„"><a class="header" href="#w-definicjach-wyliczeÅ„">W definicjach wyliczeÅ„</a></h3>
<p>Podobnie jak w przypadku struktur, moÅ¼emy definiowaÄ‡ wyliczenia, aby zawieraÅ‚y generyczne typy danych w swoich wariantach. Przyjrzyjmy siÄ™ ponownie wyliczeniu <code>Option&lt;T&gt;</code> dostarczanemu przez standardowÄ… bibliotekÄ™, ktÃ³rego uÅ¼yliÅ›my w Rozdziale 6:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}</span></code></pre>
<p>Ta definicja powinna byÄ‡ teraz bardziej zrozumiaÅ‚a. Jak widaÄ‡, enum <code>Option&lt;T&gt;</code> jest generyczny wzglÄ™dem typu <code>T</code> i ma dwa warianty: <code>Some</code>, ktÃ³ry przechowuje jednÄ… wartoÅ›Ä‡ typu <code>T</code>, oraz wariant <code>None</code>, ktÃ³ry nie przechowuje Å¼adnej wartoÅ›ci. UÅ¼ywajÄ…c enum <code>Option&lt;T&gt;</code>, moÅ¼emy wyraziÄ‡ abstrakcyjnÄ… koncepcjÄ™ wartoÅ›ci opcjonalnej, a poniewaÅ¼ <code>Option&lt;T&gt;</code> jest generyczny, moÅ¼emy uÅ¼ywaÄ‡ tej abstrakcji niezaleÅ¼nie od typu wartoÅ›ci opcjonalnej.</p>
<p>Wyliczenia mogÄ… rÃ³wnieÅ¼ uÅ¼ywaÄ‡ wielu typÃ³w generycznych. Definicja wyliczenia <code>Result</code>, ktÃ³rego uÅ¼yliÅ›my w Rozdziale 9, jest jednym z przykÅ‚adÃ³w:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre>
<p>Enum <code>Result</code> jest generyczny wzglÄ™dem dwÃ³ch typÃ³w, <code>T</code> i <code>E</code>, i ma dwa warianty: <code>Ok</code>, ktÃ³ry przechowuje wartoÅ›Ä‡ typu <code>T</code>, oraz <code>Err</code>, ktÃ³ry przechowuje wartoÅ›Ä‡ typu <code>E</code>. Ta definicja sprawia, Å¼e wygodnie jest uÅ¼ywaÄ‡ enum <code>Result</code> wszÄ™dzie tam, gdzie mamy operacjÄ™, ktÃ³ra moÅ¼e zakoÅ„czyÄ‡ siÄ™ sukcesem (zwrÃ³ciÄ‡ wartoÅ›Ä‡ jakiegoÅ› typu <code>T</code>) lub niepowodzeniem (zwrÃ³ciÄ‡ bÅ‚Ä…d jakiegoÅ› typu <code>E</code>). W rzeczywistoÅ›ci, tego wÅ‚aÅ›nie uÅ¼yliÅ›my do otwarcia pliku w Listing 9-3, gdzie <code>T</code> zostaÅ‚o wypeÅ‚nione typem <code>std::fs::File</code>, gdy plik zostaÅ‚ pomyÅ›lnie otwarty, a <code>E</code> zostaÅ‚o wypeÅ‚nione typem <code>std::io::Error</code>, gdy wystÄ…piÅ‚y problemy z otwarciem pliku.</p>
<p>Kiedy rozpoznajesz sytuacje w swoim kodzie z wieloma definicjami struktur lub wyliczeÅ„, ktÃ³re rÃ³Å¼niÄ… siÄ™ tylko typami przechowywanych wartoÅ›ci, moÅ¼esz uniknÄ…Ä‡ duplikacji, uÅ¼ywajÄ…c zamiast tego typÃ³w generycznych.</p>
<h3 id="w-definicjach-metod"><a class="header" href="#w-definicjach-metod">W definicjach metod</a></h3>
<p>MoÅ¼emy implementowaÄ‡ metody na strukturach i wyliczeniach (jak to zrobiliÅ›my w Rozdziale 5) i uÅ¼ywaÄ‡ generycznych typÃ³w rÃ³wnieÅ¼ w ich definicjach. Listing 10-9 pokazuje strukturÄ™ <code>Point&lt;T&gt;</code>, ktÃ³rÄ… zdefiniowaliÅ›my w Listing 10-6 z zaimplementowanÄ… na niej metodÄ… o nazwie <code>x</code>.</p>
<listing number="10-9" file-name="src/main.rs" caption="Implementacja metody o nazwie `x` na strukturze `Point&lt;T&gt;`, ktÃ³ra zwrÃ³ci referencjÄ™ do pola `x` typu `T`">
<pre class="playground"><code class="language-rust edition2024">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}</code></pre>
</listing>
<p>Tutaj zdefiniowaliÅ›my metodÄ™ o nazwie <code>x</code> na <code>Point&lt;T&gt;</code>, ktÃ³ra zwraca referencjÄ™ do danych w polu <code>x</code>.</p>
<p>ZauwaÅ¼, Å¼e musimy zadeklarowaÄ‡ <code>T</code> tuÅ¼ po <code>impl</code>, abyÅ›my mogli uÅ¼yÄ‡ <code>T</code> do okreÅ›lenia, Å¼e implementujemy metody na typie <code>Point&lt;T&gt;</code>. DeklarujÄ…c <code>T</code> jako typ generyczny po <code>impl</code>, Rust moÅ¼e zidentyfikowaÄ‡, Å¼e typ w nawiasach ostrych w <code>Point</code> jest typem generycznym, a nie typem konkretnym. MoglibyÅ›my wybraÄ‡ innÄ… nazwÄ™ dla tego parametru generycznego niÅ¼ parametr generyczny zadeklarowany w definicji struktury, ale uÅ¼ywanie tej samej nazwy jest konwencjonalne. JeÅ›li napiszesz metodÄ™ w <code>impl</code>, ktÃ³ra deklaruje typ generyczny, ta metoda zostanie zdefiniowana dla kaÅ¼dej instancji typu, niezaleÅ¼nie od tego, jaki konkretny typ ostatecznie zastÄ…pi typ generyczny.</p>
<p>MoÅ¼emy rÃ³wnieÅ¼ okreÅ›laÄ‡ ograniczenia dla typÃ³w generycznych podczas definiowania metod na tym typie. MoglibyÅ›my, na przykÅ‚ad, zaimplementowaÄ‡ metody tylko na instancjach <code>Point&lt;f32&gt;</code> zamiast na instancjach <code>Point&lt;T&gt;</code> z dowolnym typem generycznym. W Listing 10-10 uÅ¼ywamy konkretnego typu <code>f32</code>, co oznacza, Å¼e nie deklarujemy Å¼adnych typÃ³w po <code>impl</code>.</p>
<listing number="10-10" file-name="src/main.rs" caption="Blok `impl`, ktÃ³ry ma zastosowanie tylko do struktury z okreÅ›lonym typem konkretnym dla generycznego parametru typu `T`">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!("p.x = {}", p.x());
</span><span class="boring">}</span></code></pre>
</listing>
<p>Ten kod oznacza, Å¼e typ <code>Point&lt;f32&gt;</code> bÄ™dzie miaÅ‚ metodÄ™ <code>distance_from_origin</code>; inne instancje <code>Point&lt;T&gt;</code>, gdzie <code>T</code> nie jest typu <code>f32</code>, nie bÄ™dÄ… miaÅ‚y tej metody zdefiniowanej. Metoda mierzy, jak daleko nasz punkt znajduje siÄ™ od punktu o wspÃ³Å‚rzÄ™dnych (0.0, 0.0) i uÅ¼ywa operacji matematycznych, ktÃ³re sÄ… dostÄ™pne tylko dla typÃ³w zmiennoprzecinkowych.</p>
<p>Generyczne parametry typu w definicji struktury nie zawsze sÄ… takie same, jak te, ktÃ³rych uÅ¼ywasz w sygnaturach metod tej samej struktury. Listing 10-11 uÅ¼ywa generycznych typÃ³w <code>X1</code> i <code>Y1</code> dla struktury <code>Point</code> oraz <code>X2</code> i <code>Y2</code> dla sygnatury metody <code>mixup</code>, aby przykÅ‚ad byÅ‚ jaÅ›niejszy. Metoda tworzy nowÄ… instancjÄ™ <code>Point</code> z wartoÅ›ciÄ… <code>x</code> z <code>self</code> <code>Point</code> (typu <code>X1</code>) i wartoÅ›ciÄ… <code>y</code> z przekazanego <code>Point</code> (typu <code>Y2</code>).</p>
<listing number="10-11" file-name="src/main.rs" caption="Metoda uÅ¼ywajÄ…ca typÃ³w generycznych, ktÃ³re rÃ³Å¼niÄ… siÄ™ od definicji jej struktury">
<pre class="playground"><code class="language-rust edition2024">struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Witaj", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}</code></pre>
</listing>
<p>W funkcji <code>main</code> zdefiniowaliÅ›my <code>Point</code>, ktÃ³ry ma <code>i32</code> dla <code>x</code> (o wartoÅ›ci <code>5</code>) i <code>f64</code> dla <code>y</code> (o wartoÅ›ci <code>10.4</code>). Zmienna <code>p2</code> to struktura <code>Point</code>, ktÃ³ra ma wycinek ciÄ…gu znakÃ³w dla <code>x</code> (o wartoÅ›ci <code>"Witaj"</code>) i <code>char</code> dla <code>y</code> (o wartoÅ›ci <code>c</code>). WywoÅ‚anie <code>mixup</code> na <code>p1</code> z argumentem <code>p2</code> daje nam <code>p3</code>, ktÃ³ry bÄ™dzie miaÅ‚ <code>i32</code> dla <code>x</code>, poniewaÅ¼ <code>x</code> pochodzi z <code>p1</code>. Zmienna <code>p3</code> bÄ™dzie miaÅ‚a <code>char</code> dla <code>y</code>, poniewaÅ¼ <code>y</code> pochodzi z <code>p2</code>. WywoÅ‚anie makra <code>println!</code> wydrukuje <code>p3.x = 5, p3.y = c</code>.</p>
<p>Celem tego przykÅ‚adu jest zademonstrowanie sytuacji, w ktÃ³rej niektÃ³re parametry generyczne sÄ… zadeklarowane za pomocÄ… <code>impl</code>, a niektÃ³re za pomocÄ… definicji metody. Tutaj parametry generyczne <code>X1</code> i <code>Y1</code> sÄ… zadeklarowane po <code>impl</code>, poniewaÅ¼ pasujÄ… do definicji struktury. Parametry generyczne <code>X2</code> i <code>Y2</code> sÄ… zadeklarowane po <code>fn mixup</code>, poniewaÅ¼ sÄ… istotne tylko dla metody.</p>
<h3 id="wydajnoÅ›Ä‡-kodu-uÅ¼ywajÄ…cego-generykÃ³w"><a class="header" href="#wydajnoÅ›Ä‡-kodu-uÅ¼ywajÄ…cego-generykÃ³w">WydajnoÅ›Ä‡ kodu uÅ¼ywajÄ…cego generykÃ³w</a></h3>
<p>MoÅ¼esz zastanawiaÄ‡ siÄ™, czy istnieje koszt czasu wykonania przy uÅ¼ywaniu generycznych parametrÃ³w typu. Dobra wiadomoÅ›Ä‡ jest taka, Å¼e uÅ¼ywanie typÃ³w generycznych nie spowolni programu bardziej niÅ¼ uÅ¼ycie konkretnych typÃ³w.</p>
<p>Rust osiÄ…ga to, wykonujÄ…c monomorfizacjÄ™ kodu uÅ¼ywajÄ…cego generykÃ³w w czasie kompilacji. <em>Monomorfizacja</em> to proces przeksztaÅ‚cania kodu generycznego w kod specyficzny poprzez wypeÅ‚nienie konkretnych typÃ³w uÅ¼ywanych podczas kompilacji. W tym procesie kompilator wykonuje przeciwieÅ„stwo krokÃ³w, ktÃ³rych uÅ¼yliÅ›my do utworzenia funkcji generycznej w Listing 10-5: kompilator przeglÄ…da wszystkie miejsca, w ktÃ³rych wywoÅ‚ywany jest kod generyczny, i generuje kod dla konkretnych typÃ³w, z ktÃ³rymi wywoÅ‚ywany jest kod generyczny.</p>
<p>Przyjrzyjmy siÄ™, jak to dziaÅ‚a, uÅ¼ywajÄ…c generycznego enum <code>Option&lt;T&gt;</code> ze standardowej biblioteki:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}</span></code></pre>
<p>Kiedy Rust kompiluje ten kod, wykonuje monomorfizacjÄ™. Podczas tego procesu kompilator odczytuje wartoÅ›ci, ktÃ³re zostaÅ‚y uÅ¼yte w instancjach <code>Option&lt;T&gt;</code>, i identyfikuje dwa rodzaje <code>Option&lt;T&gt;</code>: jeden to <code>i32</code>, a drugi to <code>f64</code>. W zwiÄ…zku z tym rozszerza generycznÄ… definicjÄ™ <code>Option&lt;T&gt;</code> na dwie definicje wyspecjalizowane dla <code>i32</code> i <code>f64</code>, zastÄ™pujÄ…c w ten sposÃ³b generycznÄ… definicjÄ™ specyficznymi.</p>
<p>Monomorfizowana wersja kodu wyglÄ…da podobnie do nastÄ™pujÄ…cej (kompilator uÅ¼ywa innych nazw niÅ¼ te, ktÃ³rych uÅ¼ywamy tutaj dla ilustracji):</p>
<listing file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}</code></pre>
</listing>
<p>Generyczny <code>Option&lt;T&gt;</code> jest zastÄ™powany przez specyficzne definicje utworzone przez kompilator. PoniewaÅ¼ Rust kompiluje kod generyczny do kodu, ktÃ³ry okreÅ›la typ w kaÅ¼dej instancji, nie ponosimy kosztÃ³w wykonania za uÅ¼ywanie generykÃ³w. Gdy kod dziaÅ‚a, zachowuje siÄ™ tak samo, jakbyÅ›my rÄ™cznie zduplikowali kaÅ¼dÄ… definicjÄ™. Proces monomorfizacji sprawia, Å¼e generyki Rusta sÄ… niezwykle wydajne w czasie wykonywania.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="definiowanie-wspÃ³lnego-zachowania-za-pomocÄ…-cech-1"><a href="#definiowanie-wspÃ³lnego-zachowania-za-pomocÄ…-cech-1" class="header">Definiowanie wspÃ³lnego zachowania za pomocÄ… cech</a></h1>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="traits-defining-shared-behavior"></a></p>
<h2 id="definiowanie-wspÃ³lnego-zachowania-za-pomocÄ…-cech"><a class="header" href="#definiowanie-wspÃ³lnego-zachowania-za-pomocÄ…-cech">Definiowanie wspÃ³lnego zachowania za pomocÄ… cech</a></h2>
<p><em>Cecha</em> (trait) definiuje funkcjonalnoÅ›Ä‡, ktÃ³rÄ… posiada dany typ i ktÃ³rÄ… moÅ¼e dzieliÄ‡ z innymi typami. MoÅ¼emy uÅ¼ywaÄ‡ cech do definiowania wspÃ³lnego zachowania w sposÃ³b abstrakcyjny. MoÅ¼emy uÅ¼ywaÄ‡ <em>ograniczeÅ„ cech</em> (trait bounds) do okreÅ›lania, Å¼e typ generyczny moÅ¼e byÄ‡ dowolnym typem, ktÃ³ry ma okreÅ›lone zachowanie.</p>
<blockquote>
<p>Uwaga: Cechy sÄ… podobne do funkcji czÄ™sto nazywanych <em>interfejsami</em> w innych jÄ™zykach, choÄ‡ z pewnymi rÃ³Å¼nicami.</p>
</blockquote>
<h3 id="definiowanie-cechy"><a class="header" href="#definiowanie-cechy">Definiowanie cechy</a></h3>
<p>Zachowanie typu skÅ‚ada siÄ™ z metod, ktÃ³re moÅ¼emy wywoÅ‚aÄ‡ dla tego typu. RÃ³Å¼ne typy dzielÄ… to samo zachowanie, jeÅ›li moÅ¼emy wywoÅ‚aÄ‡ te same metody dla wszystkich tych typÃ³w. Definicje cech to sposÃ³b grupowania sygnatur metod w celu zdefiniowania zestawu zachowaÅ„ niezbÄ™dnych do osiÄ…gniÄ™cia pewnego celu.</p>
<p>Na przykÅ‚ad, powiedzmy, Å¼e mamy wiele struktur, ktÃ³re przechowujÄ… rÃ³Å¼ne rodzaje i iloÅ›ci tekstu: struktura <code>NewsArticle</code>, ktÃ³ra przechowuje artykuÅ‚ informacyjny z okreÅ›lonej lokalizacji, i <code>SocialPost</code>, ktÃ³ra moÅ¼e mieÄ‡ co najwyÅ¼ej 280 znakÃ³w wraz z metadanymi wskazujÄ…cymi, czy byÅ‚ to nowy post, repost, czy odpowiedÅº na inny post.</p>
<p>Chcemy stworzyÄ‡ skrzynkÄ™ bibliotecznÄ… agregujÄ…cÄ… media o nazwie <code>aggregator</code>, ktÃ³ra bÄ™dzie mogÅ‚a wyÅ›wietlaÄ‡ podsumowania danych przechowywanych w instancji <code>NewsArticle</code> lub <code>SocialPost</code>. Aby to zrobiÄ‡, potrzebujemy podsumowania z kaÅ¼dego typu, a to podsumowanie uzyskamy, wywoÅ‚ujÄ…c metodÄ™ <code>summarize</code> na instancji. Listing 10-12 pokazuje definicjÄ™ publicznej cechy <code>Summary</code>, ktÃ³ra wyraÅ¼a to zachowanie.</p>
<listing number="10-12" file-name="src/lib.rs" caption="Cecha `Summary`, ktÃ³ra skÅ‚ada siÄ™ z zachowania zapewnianego przez metodÄ™ `summarize`">
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}</code></pre>
</listing>
<p>Tutaj deklarujemy cechÄ™ za pomocÄ… sÅ‚owa kluczowego <code>trait</code>, a nastÄ™pnie nazwÄ™ cechy, ktÃ³ra w tym przypadku to <code>Summary</code>. Deklarujemy rÃ³wnieÅ¼ cechÄ™ jako <code>pub</code>, aby skrzynki zaleÅ¼ne od tej skrzynki mogÅ‚y rÃ³wnieÅ¼ korzystaÄ‡ z tej cechy, jak zobaczymy w kilku przykÅ‚adach. W nawiasach klamrowych deklarujemy sygnatury metod, ktÃ³re opisujÄ… zachowania typÃ³w implementujÄ…cych tÄ™ cechÄ™, co w tym przypadku jest <code>fn summarize(&amp;self) -&gt; String</code>.</p>
<p>Po sygnaturze metody, zamiast dostarczaÄ‡ implementacji w nawiasach klamrowych, uÅ¼ywamy Å›rednika. KaÅ¼dy typ implementujÄ…cy tÄ™ cechÄ™ musi dostarczyÄ‡ wÅ‚asne, niestandardowe zachowanie dla ciaÅ‚a metody. Kompilator wymusi, aby kaÅ¼dy typ posiadajÄ…cy cechÄ™ <code>Summary</code> miaÅ‚ metodÄ™ <code>summarize</code> zdefiniowanÄ… dokÅ‚adnie z tÄ… sygnaturÄ….</p>
<p>Cecha moÅ¼e mieÄ‡ wiele metod w swoim ciele: sygnatury metod sÄ… wymienione jedna na liniÄ™, a kaÅ¼da linia koÅ„czy siÄ™ Å›rednikiem.</p>
<h3 id="implementowanie-cechy-na-typie"><a class="header" href="#implementowanie-cechy-na-typie">Implementowanie cechy na typie</a></h3>
<p>Teraz, gdy zdefiniowaliÅ›my poÅ¼Ä…dane sygnatury metod cechy <code>Summary</code>, moÅ¼emy zaimplementowaÄ‡ jÄ… na typach w naszym agregatorze mediÃ³w. Listing 10-13 pokazuje implementacjÄ™ cechy <code>Summary</code> na strukturze <code>NewsArticle</code>, ktÃ³ra uÅ¼ywa nagÅ‚Ã³wka, autora i lokalizacji do utworzenia wartoÅ›ci zwracanej przez <code>summarize</code>. Dla struktury <code>SocialPost</code> definiujemy <code>summarize</code> jako nazwÄ™ uÅ¼ytkownika, a nastÄ™pnie caÅ‚y tekst posta, zakÅ‚adajÄ…c, Å¼e zawartoÅ›Ä‡ posta jest juÅ¼ ograniczona do 280 znakÃ³w.</p>
<listing number="10-13" file-name="src/lib.rs" caption="Implementacja cechy `Summary` na typach `NewsArticle` i `SocialPost`">
<pre><code class="language-rust noplayground"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct SocialPost {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub repost: bool,
}

impl Summary for SocialPost {
    fn summarize(&amp;self) -&gt; String {
        format!("{}: {}", self.username, self.content)
    }
}</code></pre>
</listing>
<p>Implementowanie cechy na typie jest podobne do implementowania zwykÅ‚ych metod. RÃ³Å¼nica polega na tym, Å¼e po <code>impl</code> umieszczamy nazwÄ™ cechy, ktÃ³rÄ… chcemy zaimplementowaÄ‡, nastÄ™pnie uÅ¼ywamy sÅ‚owa kluczowego <code>for</code>, a nastÄ™pnie okreÅ›lamy nazwÄ™ typu, dla ktÃ³rego chcemy zaimplementowaÄ‡ cechÄ™. W bloku <code>impl</code> umieszczamy sygnatury metod, ktÃ³re zdefiniowano w definicji cechy. Zamiast dodawaÄ‡ Å›rednik po kaÅ¼dej sygnaturze, uÅ¼ywamy nawiasÃ³w klamrowych i wypeÅ‚niamy ciaÅ‚o metody konkretnym zachowaniem, ktÃ³re chcemy, aby metody cechy miaÅ‚y dla danego typu.</p>
<p>Teraz, gdy biblioteka zaimplementowaÅ‚a cechÄ™ <code>Summary</code> dla <code>NewsArticle</code> i <code>SocialPost</code>, uÅ¼ytkownicy skrzynki mogÄ… wywoÅ‚ywaÄ‡ metody cech na instancjach <code>NewsArticle</code> i <code>SocialPost</code> w taki sam sposÃ³b, jak wywoÅ‚ujemy zwykÅ‚e metody. JedynÄ… rÃ³Å¼nicÄ… jest to, Å¼e uÅ¼ytkownik musi wprowadziÄ‡ cechÄ™ do zasiÄ™gu, a takÅ¼e typy. Oto przykÅ‚ad, jak skrzynka binarna mogÅ‚aby uÅ¼yÄ‡ naszej skrzynki bibliotecznej <code>aggregator</code>:</p>
<pre><code class="language-rust ignore">use aggregator::{SocialPost, Summary};

fn main() {
    let post = SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from(
            "oczywiÅ›cie, jak zapewne juÅ¼ wiesz, ludzie",
        ),
        reply: false,
        repost: false,
    };

    println!("1 nowy post: {}", post.summarize());
}</code></pre>
<p>Ten kod drukuje <code>1 nowy post: horse_ebooks: oczywiÅ›cie, jak zapewne juÅ¼ wiesz, ludzie</code>.</p>
<p>Inne skrzynki zaleÅ¼ne od skrzynki <code>aggregator</code> mogÄ… rÃ³wnieÅ¼ wprowadziÄ‡ cechÄ™ <code>Summary</code> do zasiÄ™gu, aby zaimplementowaÄ‡ <code>Summary</code> na swoich wÅ‚asnych typach. Jednym z ograniczeÅ„ jest to, Å¼e moÅ¼emy zaimplementowaÄ‡ cechÄ™ na typie tylko wtedy, gdy cecha lub typ, albo oba, sÄ… lokalne dla naszej skrzynki. Na przykÅ‚ad, moÅ¼emy zaimplementowaÄ‡ cechy standardowej biblioteki, takie jak <code>Display</code>, na niestandardowym typie, takim jak <code>SocialPost</code>, jako czÄ™Å›Ä‡ funkcjonalnoÅ›ci naszej skrzynki <code>aggregator</code>, poniewaÅ¼ typ <code>SocialPost</code> jest lokalny dla naszej skrzynki <code>aggregator</code>. MoÅ¼emy rÃ³wnieÅ¼ zaimplementowaÄ‡ <code>Summary</code> na <code>Vec&lt;T&gt;</code> w naszej skrzynce <code>aggregator</code>, poniewaÅ¼ cecha <code>Summary</code> jest lokalna dla naszej skrzynki <code>aggregator</code>.</p>
<p>Ale nie moÅ¼emy implementowaÄ‡ zewnÄ™trznych cech na zewnÄ™trznych typach. Na przykÅ‚ad, nie moÅ¼emy implementowaÄ‡ cechy <code>Display</code> na <code>Vec&lt;T&gt;</code> w naszej skrzynce <code>aggregator</code>, poniewaÅ¼ <code>Display</code> i <code>Vec&lt;T&gt;</code> sÄ… zdefiniowane w standardowej bibliotece i nie sÄ… lokalne dla naszej skrzynki <code>aggregator</code>. To ograniczenie jest czÄ™Å›ciÄ… wÅ‚aÅ›ciwoÅ›ci zwanej <em>spÃ³jnoÅ›ciÄ…</em>, a dokÅ‚adniej <em>zasadÄ… sieroty</em> (orphan rule), nazwanÄ… tak, poniewaÅ¼ typ nadrzÄ™dny nie jest obecny. Ta zasada zapewnia, Å¼e kod innych ludzi nie moÅ¼e zepsuÄ‡ twojego kodu i vice versa. Bez tej zasady, dwie skrzynki mogÅ‚yby zaimplementowaÄ‡ tÄ™ samÄ… cechÄ™ dla tego samego typu, a Rust nie wiedziaÅ‚by, ktÃ³rej implementacji uÅ¼yÄ‡.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="default-implementations"></a></p>
<h3 id="uÅ¼ywanie-domyÅ›lnych-implementacji"><a class="header" href="#uÅ¼ywanie-domyÅ›lnych-implementacji">UÅ¼ywanie domyÅ›lnych implementacji</a></h3>
<p>Czasami przydatne jest posiadanie domyÅ›lnego zachowania dla niektÃ³rych lub wszystkich metod w cesze, zamiast wymagaÄ‡ implementacji dla wszystkich metod na kaÅ¼dym typie. NastÄ™pnie, implementujÄ…c cechÄ™ na konkretnym typie, moÅ¼emy zachowaÄ‡ lub nadpisaÄ‡ domyÅ›lne zachowanie kaÅ¼dej metody.</p>
<p>W Listing 10-14 okreÅ›lamy domyÅ›lny ciÄ…g znakÃ³w dla metody <code>summarize</code> cechy <code>Summary</code>, zamiast definiowaÄ‡ tylko sygnaturÄ™ metody, jak to zrobiliÅ›my w Listing 10-12.</p>
<listing number="10-14" file-name="src/lib.rs" caption="Definiowanie cechy `Summary` z domyÅ›lnÄ… implementacjÄ… metody `summarize`">
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from("(Czytaj wiÄ™cej...)")
    }
}
<span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</listing>
<p>Aby uÅ¼yÄ‡ domyÅ›lnej implementacji do podsumowywania instancji <code>NewsArticle</code>, okreÅ›lamy pusty blok <code>impl</code> za pomocÄ… <code>impl Summary for NewsArticle {}</code>.</p>
<p>ChociaÅ¼ nie definiujemy juÅ¼ bezpoÅ›rednio metody <code>summarize</code> w <code>NewsArticle</code>, dostarczyliÅ›my domyÅ›lnÄ… implementacjÄ™ i okreÅ›liliÅ›my, Å¼e <code>NewsArticle</code> implementuje cechÄ™ <code>Summary</code>. W rezultacie nadal moÅ¼emy wywoÅ‚aÄ‡ metodÄ™ <code>summarize</code> na instancji <code>NewsArticle</code>, tak jak poniÅ¼ej:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        headline: String::from("Pingwiny wygrywajÄ… Puchar Stanleya!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from(
            "Pittsburgh Penguins po raz kolejny sÄ… najlepszÄ… \
             druÅ¼ynÄ… hokejowÄ… w NHL.",
        ),
    };

    println!("Nowy artykuÅ‚ dostÄ™pny! {}", article.summarize());
<span class="boring">}</span></code></pre>
<p>Ten kod drukuje <code>Nowy artykuÅ‚ dostÄ™pny! (Czytaj wiÄ™cej...)</code>.</p>
<p>Stworzenie domyÅ›lnej implementacji nie wymaga od nas zmiany czegokolwiek w implementacji <code>Summary</code> na <code>SocialPost</code> w Listing 10-13. Powodem jest to, Å¼e skÅ‚adnia nadpisywania domyÅ›lnej implementacji jest taka sama jak skÅ‚adnia implementacji metody cechy, ktÃ³ra nie ma domyÅ›lnej implementacji.</p>
<p>DomyÅ›lne implementacje mogÄ… wywoÅ‚ywaÄ‡ inne metody w tej samej cesze, nawet jeÅ›li te inne metody nie majÄ… domyÅ›lnej implementacji. W ten sposÃ³b cecha moÅ¼e dostarczyÄ‡ wiele uÅ¼ytecznej funkcjonalnoÅ›ci i wymagaÄ‡ od implementatorÃ³w jedynie okreÅ›lenia jej maÅ‚ej czÄ™Å›ci. Na przykÅ‚ad, moglibyÅ›my zdefiniowaÄ‡ cechÄ™ <code>Summary</code> tak, aby miaÅ‚a metodÄ™ <code>summarize_author</code>, ktÃ³rej implementacja jest wymagana, a nastÄ™pnie zdefiniowaÄ‡ metodÄ™ <code>summarize</code>, ktÃ³ra ma domyÅ›lnÄ… implementacjÄ™, ktÃ³ra wywoÅ‚uje metodÄ™ <code>summarize_author</code>:</p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!("(Czytaj wiÄ™cej od {}...)", self.summarize_author())
    }
}
<span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String {
</span><span class="boring">        format!("@{}", self.username)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Aby uÅ¼yÄ‡ tej wersji <code>Summary</code>, wystarczy zdefiniowaÄ‡ <code>summarize_author</code> podczas implementacji cechy na typie:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("(Czytaj wiÄ™cej od {}...)", self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for SocialPost {
    fn summarize_author(&amp;self) -&gt; String {
        format!("@{}", self.username)
    }
}</code></pre>
<p>Po zdefiniowaniu <code>summarize_author</code> moÅ¼emy wywoÅ‚aÄ‡ <code>summarize</code> na instancjach struktury <code>SocialPost</code>, a domyÅ›lna implementacja <code>summarize</code> wywoÅ‚a zdefiniowanÄ… przez nas <code>summarize_author</code>. PoniewaÅ¼ zaimplementowaliÅ›my <code>summarize_author</code>, cecha <code>Summary</code> daÅ‚a nam zachowanie metody <code>summarize</code> bez koniecznoÅ›ci pisania dodatkowego kodu. Oto jak to wyglÄ…da:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, SocialPost, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let post = SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from(
            "oczywiÅ›cie, jak zapewne juÅ¼ wiesz, ludzie",
        ),
        reply: false,
        repost: false,
    };

    println!("1 nowy post: {}", post.summarize());
<span class="boring">}</span></code></pre>
<p>Ten kod drukuje <code>1 nowy post: (Czytaj wiÄ™cej od @horse_ebooks...)</code>.</p>
<p>ZauwaÅ¼, Å¼e nie jest moÅ¼liwe wywoÅ‚anie domyÅ›lnej implementacji z nadpisujÄ…cej implementacji tej samej metody.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="traits-as-parameters"></a></p>
<h3 id="uÅ¼ywanie-cech-jako-parametrÃ³w"><a class="header" href="#uÅ¼ywanie-cech-jako-parametrÃ³w">UÅ¼ywanie cech jako parametrÃ³w</a></h3>
<p>Teraz, gdy wiesz, jak definiowaÄ‡ i implementowaÄ‡ cechy, moÅ¼emy zbadaÄ‡, jak uÅ¼ywaÄ‡ cech do definiowania funkcji, ktÃ³re akceptujÄ… wiele rÃ³Å¼nych typÃ³w. UÅ¼yjemy cechy <code>Summary</code>, ktÃ³rÄ… zaimplementowaliÅ›my na typach <code>NewsArticle</code> i <code>SocialPost</code> w Listing 10-13, aby zdefiniowaÄ‡ funkcjÄ™ <code>notify</code>, ktÃ³ra wywoÅ‚uje metodÄ™ <code>summarize</code> na swoim parametrze <code>item</code>, ktÃ³ry jest jakiegoÅ› typu implementujÄ…cego cechÄ™ <code>Summary</code>. Aby to zrobiÄ‡, uÅ¼ywamy skÅ‚adni <code>impl Trait</code>, tak jak poniÅ¼ej:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, by {} ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify(item: &amp;impl Summary) {
    println!("NajÅ›wieÅ¼sze wiadomoÅ›ci! {}", item.summarize());
}</code></pre>
<p>Zamiast konkretnego typu dla parametru <code>item</code>, okreÅ›lamy sÅ‚owo kluczowe <code>impl</code> i nazwÄ™ cechy. Ten parametr akceptuje dowolny typ, ktÃ³ry implementuje okreÅ›lonÄ… cechÄ™. W ciele <code>notify</code> moÅ¼emy wywoÅ‚aÄ‡ dowolne metody na <code>item</code>, ktÃ³re pochodzÄ… z cechy <code>Summary</code>, takie jak <code>summarize</code>. MoÅ¼emy wywoÅ‚aÄ‡ <code>notify</code> i przekazaÄ‡ dowolnÄ… instancjÄ™ <code>NewsArticle</code> lub <code>SocialPost</code>. Kod, ktÃ³ry wywoÅ‚uje funkcjÄ™ z dowolnym innym typem, takim jak <code>String</code> lub <code>i32</code>, nie skompiluje siÄ™, poniewaÅ¼ te typy nie implementujÄ… <code>Summary</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="fixing-the-largest-function-with-trait-bounds"></a></p>
<h4 id="skÅ‚adnia-ograniczeÅ„-cech"><a class="header" href="#skÅ‚adnia-ograniczeÅ„-cech">SkÅ‚adnia ograniczeÅ„ cech</a></h4>
<p>SkÅ‚adnia <code>impl Trait</code> dziaÅ‚a w prostych przypadkach, ale w rzeczywistoÅ›ci jest to cukier syntaktyczny dla dÅ‚uÅ¼szej formy znanej jako <em>ograniczenie cechy</em> (trait bound); wyglÄ…da to tak:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!("NajÅ›wieÅ¼sze wiadomoÅ›ci! {}", item.summarize());
}</code></pre>
<p>Ta dÅ‚uÅ¼sza forma jest rÃ³wnowaÅ¼na przykÅ‚adowi z poprzedniej sekcji, ale jest bardziej rozwlekÅ‚a. Ograniczenia cech umieszczamy wraz z deklaracjÄ… generycznego parametru typu po dwukropku i w nawiasach ostrych.</p>
<p>SkÅ‚adnia <code>impl Trait</code> jest wygodna i sprawia, Å¼e kod jest bardziej zwiÄ™zÅ‚y w prostych przypadkach, podczas gdy peÅ‚niejsza skÅ‚adnia ograniczeÅ„ cech moÅ¼e wyraÅ¼aÄ‡ wiÄ™kszÄ… zÅ‚oÅ¼onoÅ›Ä‡ w innych przypadkach. Na przykÅ‚ad, moÅ¼emy mieÄ‡ dwa parametry, ktÃ³re implementujÄ… <code>Summary</code>. UÅ¼ycie skÅ‚adni <code>impl Trait</code> wyglÄ…da tak:</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {</code></pre>
<p>UÅ¼ycie <code>impl Trait</code> jest odpowiednie, jeÅ›li chcemy, aby ta funkcja pozwalaÅ‚a <code>item1</code> i <code>item2</code> na posiadanie rÃ³Å¼nych typÃ³w (o ile oba typy implementujÄ… <code>Summary</code>). JeÅ›li jednak chcemy wymusiÄ‡, aby oba parametry miaÅ‚y ten sam typ, musimy uÅ¼yÄ‡ ograniczenia cechy, tak jak poniÅ¼ej:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {</code></pre>
<p>Generyczny typ <code>T</code> okreÅ›lony jako typ parametrÃ³w <code>item1</code> i <code>item2</code> ogranicza funkcjÄ™ tak, Å¼e konkretny typ wartoÅ›ci przekazanej jako argument dla <code>item1</code> i <code>item2</code> musi byÄ‡ taki sam.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="specifying-multiple-trait-bounds-with-the--syntax"></a></p>
<h4 id="wiele-ograniczeÅ„-cech-za-pomocÄ…-skÅ‚adni-"><a class="header" href="#wiele-ograniczeÅ„-cech-za-pomocÄ…-skÅ‚adni-">Wiele ograniczeÅ„ cech za pomocÄ… skÅ‚adni <code>+</code></a></h4>
<p>MoÅ¼emy rÃ³wnieÅ¼ okreÅ›liÄ‡ wiÄ™cej niÅ¼ jedno ograniczenie cechy. Powiedzmy, Å¼e chcieliÅ›my, aby <code>notify</code> uÅ¼ywaÅ‚o formatowania wyÅ›wietlania, a takÅ¼e <code>summarize</code> na <code>item</code>: okreÅ›lamy w definicji <code>notify</code>, Å¼e <code>item</code> musi implementowaÄ‡ zarÃ³wno <code>Display</code>, jak i <code>Summary</code>. MoÅ¼emy to zrobiÄ‡ za pomocÄ… skÅ‚adni <code>+</code>:</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {</code></pre>
<p>SkÅ‚adnia <code>+</code> jest rÃ³wnieÅ¼ prawidÅ‚owa z ograniczeniami cech na typach generycznych:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {</code></pre>
<p>DziÄ™ki dwÃ³m okreÅ›lonym ograniczeniom cech, ciaÅ‚o <code>notify</code> moÅ¼e wywoÅ‚ywaÄ‡ <code>summarize</code> i uÅ¼ywaÄ‡ <code>{}</code> do formatowania <code>item</code>.</p>
<h4 id="jaÅ›niejsze-ograniczenia-cech-za-pomocÄ…-klauzul-where"><a class="header" href="#jaÅ›niejsze-ograniczenia-cech-za-pomocÄ…-klauzul-where">JaÅ›niejsze ograniczenia cech za pomocÄ… klauzul <code>where</code></a></h4>
<p>Zbyt wiele ograniczeÅ„ cech ma swoje wady. KaÅ¼dy typ generyczny ma swoje wÅ‚asne ograniczenia cech, wiÄ™c funkcje z wieloma generycznymi parametrami typu mogÄ… zawieraÄ‡ wiele informacji o ograniczeniach cech miÄ™dzy nazwÄ… funkcji a listÄ… jej parametrÃ³w, co utrudnia czytanie sygnatury funkcji. Z tego powodu Rust ma alternatywnÄ… skÅ‚adniÄ™ do okreÅ›lania ograniczeÅ„ cech w klauzuli <code>where</code> po sygnaturze funkcji. Tak wiÄ™c, zamiast pisaÄ‡ tak:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {</code></pre>
<p>moÅ¼emy uÅ¼yÄ‡ klauzuli <code>where</code>, tak jak poniÅ¼ej:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
<span class="boring">    unimplemented!()
</span><span class="boring">}</span></code></pre>
<p>Sygnatura tej funkcji jest mniej zaÅ›miecona: nazwa funkcji, lista parametrÃ³w i typ zwracany sÄ… blisko siebie, podobnie jak w funkcji bez wielu ograniczeÅ„ cech.</p>
<h3 id="zwracanie-typÃ³w-ktÃ³re-implementujÄ…-cechy"><a class="header" href="#zwracanie-typÃ³w-ktÃ³re-implementujÄ…-cechy">Zwracanie typÃ³w, ktÃ³re implementujÄ… cechy</a></h3>
<p>MoÅ¼emy rÃ³wnieÅ¼ uÅ¼yÄ‡ skÅ‚adni <code>impl Trait</code> w pozycji zwracanej, aby zwrÃ³ciÄ‡ wartoÅ›Ä‡ jakiegoÅ› typu, ktÃ³ry implementuje cechÄ™, jak pokazano tutaj:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, by {} ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable() -&gt; impl Summary {
    SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from(
            "oczywiÅ›cie, jak zapewne juÅ¼ wiesz, ludzie",
        ),
        reply: false,
        repost: false,
    }
}</code></pre>
<p>UÅ¼ywajÄ…c <code>impl Summary</code> jako typu zwracanego, okreÅ›lamy, Å¼e funkcja <code>returns_summarizable</code> zwraca pewien typ, ktÃ³ry implementuje cechÄ™ <code>Summary</code>, bez nazywania konkretnego typu. W tym przypadku <code>returns_summarizable</code> zwraca <code>SocialPost</code>, ale kod wywoÅ‚ujÄ…cy tÄ™ funkcjÄ™ nie musi o tym wiedzieÄ‡.</p>
<p>MoÅ¼liwoÅ›Ä‡ okreÅ›lenia typu zwracanego tylko przez cechÄ™, ktÃ³rÄ… implementuje, jest szczegÃ³lnie przydatna w kontekÅ›cie domkniÄ™Ä‡ i iteratorÃ³w, ktÃ³re omÃ³wimy w Rozdziale 13. DomkniÄ™cia i iteratory tworzÄ… typy, ktÃ³re zna tylko kompilator, lub typy, ktÃ³re sÄ… bardzo dÅ‚ugie do okreÅ›lenia. SkÅ‚adnia <code>impl Trait</code> pozwala zwiÄ™Åºle okreÅ›liÄ‡, Å¼e funkcja zwraca jakiÅ› typ, ktÃ³ry implementuje cechÄ™ <code>Iterator</code>, bez koniecznoÅ›ci wypisywania bardzo dÅ‚ugiego typu.</p>
<p>MoÅ¼esz jednak uÅ¼ywaÄ‡ <code>impl Trait</code> tylko wtedy, gdy zwracasz pojedynczy typ. Na przykÅ‚ad, ten kod, ktÃ³ry zwraca <code>NewsArticle</code> lub <code>SocialPost</code> z typem zwracanym okreÅ›lonym jako <code>impl Summary</code>, nie zadziaÅ‚a:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, by {} ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                "Pingwiny wygrywajÄ… Puchar Stanleya!",
            ),
            location: String::from("Pittsburgh, PA, USA"),
            author: String::from("Iceburgh"),
            content: String::from(
                "Pittsburgh Penguins po raz kolejny sÄ… najlepszÄ… \
                 druÅ¼ynÄ… hokejowÄ… w NHL.",
            ),
        }
    } else {
        SocialPost {
            username: String::from("horse_ebooks"),
            content: String::from(
                "oczywiÅ›cie, jak zapewne juÅ¼ wiesz, ludzie",
            ),
            reply: false,
            repost: false,
        }
    }
}</code></pre>
<p>Zwracanie <code>NewsArticle</code> lub <code>SocialPost</code> nie jest dozwolone z powodu ograniczeÅ„ zwiÄ…zanych z implementacjÄ… skÅ‚adni <code>impl Trait</code> w kompilatorze. OmÃ³wimy, jak napisaÄ‡ funkcjÄ™ o takim zachowaniu w sekcji <a href="#using-trait-objects-to-abstract-over-shared-behavior">â€UÅ¼ywanie obiektÃ³w cech do abstrakcji wspÃ³lnego zachowaniaâ€</a><!-- ignore --> w Rozdziale 18.</p>
<h3 id="uÅ¼ywanie-ograniczeÅ„-cech-do-warunkowej-implementacji-metod"><a class="header" href="#uÅ¼ywanie-ograniczeÅ„-cech-do-warunkowej-implementacji-metod">UÅ¼ywanie ograniczeÅ„ cech do warunkowej implementacji metod</a></h3>
<p>UÅ¼ywajÄ…c ograniczenia cechy z blokiem <code>impl</code>, ktÃ³ry uÅ¼ywa generycznych parametrÃ³w typu, moÅ¼emy warunkowo implementowaÄ‡ metody dla typÃ³w, ktÃ³re implementujÄ… okreÅ›lone cechy. Na przykÅ‚ad, typ <code>Pair&lt;T&gt;</code> w Listing 10-15 zawsze implementuje funkcjÄ™ <code>new</code>, aby zwrÃ³ciÄ‡ nowÄ… instancjÄ™ <code>Pair&lt;T&gt;</code> (przypomnij sobie z sekcji <a href="#method-syntax">â€SkÅ‚adnia metodyâ€</a><!-- ignore --> w Rozdziale 5, Å¼e <code>Self</code> jest aliasem typu dla typu bloku <code>impl</code>, ktÃ³ry w tym przypadku to <code>Pair&lt;T&gt;</code>). Ale w nastÄ™pnym bloku <code>impl</code>, <code>Pair&lt;T&gt;</code> implementuje metodÄ™ <code>cmp_display</code> tylko wtedy, gdy jej wewnÄ™trzny typ <code>T</code> implementuje cechÄ™ <code>PartialOrd</code>, ktÃ³ra umoÅ¼liwia porÃ³wnanie <em>i</em> cechÄ™ <code>Display</code>, ktÃ³ra umoÅ¼liwia drukowanie.</p>
<listing number="10-15" file-name="src/lib.rs" caption="Warunkowe implementowanie metod na typie generycznym w zaleÅ¼noÅ›ci od ograniczeÅ„ cech">
<pre><code class="language-rust noplayground">use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!("NajwiÄ™kszy element to x = {}", self.x);
        } else {
            println!("NajwiÄ™kszy element to y = {}", self.y);
        }
    }
}</code></pre>
</listing>
<p>MoÅ¼emy rÃ³wnieÅ¼ warunkowo implementowaÄ‡ cechÄ™ dla dowolnego typu, ktÃ³ry implementuje innÄ… cechÄ™. Implementacje cechy na dowolnym typie, ktÃ³ry speÅ‚nia ograniczenia cechy, nazywane sÄ… <em>implementacjami ogÃ³lnymi</em> (blanket implementations) i sÄ… szeroko stosowane w standardowej bibliotece Rusta. Na przykÅ‚ad, standardowa biblioteka implementuje cechÄ™ <code>ToString</code> dla kaÅ¼dego typu, ktÃ³ry implementuje cechÄ™ <code>Display</code>. Blok <code>impl</code> w standardowej bibliotece wyglÄ…da podobnie do tego kodu:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}</code></pre>
<p>PoniewaÅ¼ standardowa biblioteka ma tÄ™ ogÃ³lnÄ… implementacjÄ™, moÅ¼emy wywoÅ‚aÄ‡ metodÄ™ <code>to_string</code> zdefiniowanÄ… przez cechÄ™ <code>ToString</code> na dowolnym typie, ktÃ³ry implementuje cechÄ™ <code>Display</code>. Na przykÅ‚ad, moÅ¼emy zamieniÄ‡ liczby caÅ‚kowite na odpowiadajÄ…ce im wartoÅ›ci <code>String</code> w ten sposÃ³b, poniewaÅ¼ liczby caÅ‚kowite implementujÄ… <code>Display</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}</span></code></pre>
<p>Implementacje ogÃ³lne pojawiajÄ… siÄ™ w dokumentacji cechy w sekcji â€Implementacjeâ€.</p>
<p>Cechy i ograniczenia cech pozwalajÄ… nam pisaÄ‡ kod, ktÃ³ry uÅ¼ywa generycznych parametrÃ³w typu, aby zmniejszyÄ‡ duplikacjÄ™, ale takÅ¼e okreÅ›laÄ‡ kompilatorowi, Å¼e chcemy, aby generyczny typ miaÅ‚ okreÅ›lone zachowanie. Kompilator moÅ¼e nastÄ™pnie uÅ¼yÄ‡ informacji o ograniczeniach cech, aby sprawdziÄ‡, czy wszystkie konkretne typy uÅ¼ywane z naszym kodem zapewniajÄ… prawidÅ‚owe zachowanie. W jÄ™zykach z dynamicznym typowaniem otrzymalibyÅ›my bÅ‚Ä…d w czasie wykonywania, gdybyÅ›my wywoÅ‚ali metodÄ™ na typie, ktÃ³ry nie definiuje tej metody. Ale Rust przenosi te bÅ‚Ä™dy do czasu kompilacji, tak abyÅ›my byli zmuszeni do naprawienia problemÃ³w, zanim nasz kod w ogÃ³le bÄ™dzie mÃ³gÅ‚ dziaÅ‚aÄ‡. Dodatkowo, nie musimy pisaÄ‡ kodu, ktÃ³ry sprawdza zachowanie w czasie wykonywania, poniewaÅ¼ sprawdziliÅ›my to juÅ¼ w czasie kompilacji. Robienie tego poprawia wydajnoÅ›Ä‡ bez koniecznoÅ›ci rezygnacji z elastycznoÅ›ci generykÃ³w.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="walidacja-referencji-za-pomocÄ…-czasÃ³w-Å¼ycia-1"><a href="#walidacja-referencji-za-pomocÄ…-czasÃ³w-Å¼ycia-1" class="header">Walidacja referencji za pomocÄ… czasÃ³w Å¼ycia</a></h1>
<h2 id="walidacja-referencji-za-pomocÄ…-czasÃ³w-Å¼ycia"><a class="header" href="#walidacja-referencji-za-pomocÄ…-czasÃ³w-Å¼ycia">Walidacja referencji za pomocÄ… czasÃ³w Å¼ycia</a></h2>
<p>Czasy Å¼ycia to kolejny rodzaj generykÃ³w, ktÃ³rych juÅ¼ uÅ¼ywaliÅ›my. Zamiast zapewniaÄ‡, Å¼e typ ma poÅ¼Ä…dane przez nas zachowanie, czasy Å¼ycia zapewniajÄ…, Å¼e referencje sÄ… waÅ¼ne tak dÅ‚ugo, jak tego potrzebujemy.</p>
<p>Jednym szczegÃ³Å‚em, o ktÃ³rym nie rozmawialiÅ›my w sekcji <a href="#references-and-borrowing">â€Referencje i poÅ¼yczanieâ€</a><!-- ignore --> w Rozdziale 4, jest to, Å¼e kaÅ¼da referencja w Rust ma czas Å¼ycia, ktÃ³ry jest zasiÄ™giem, w ktÃ³rym ta referencja jest waÅ¼na. Przez wiÄ™kszoÅ›Ä‡ czasu, czasy Å¼ycia sÄ… domyÅ›lne i wnioskowane, tak jak przez wiÄ™kszoÅ›Ä‡ czasu, typy sÄ… wnioskowane. JesteÅ›my zobowiÄ…zani do adnotowania typÃ³w tylko wtedy, gdy moÅ¼liwych jest wiele typÃ³w. W podobny sposÃ³b musimy adnotowaÄ‡ czasy Å¼ycia, gdy czasy Å¼ycia referencji mogÄ… byÄ‡ powiÄ…zane na kilka rÃ³Å¼nych sposobÃ³w. Rust wymaga od nas adnotowania relacji za pomocÄ… ogÃ³lnych parametrÃ³w czasÃ³w Å¼ycia, aby zapewniÄ‡, Å¼e rzeczywiste referencje uÅ¼ywane w czasie wykonania bÄ™dÄ… z pewnoÅ›ciÄ… waÅ¼ne.</p>
<p>Adnotowanie czasÃ³w Å¼ycia nie jest nawet koncepcjÄ…, ktÃ³rÄ… posiada wiÄ™kszoÅ›Ä‡ innych jÄ™zykÃ³w programowania, wiÄ™c bÄ™dzie to wydawaÄ‡ siÄ™ nieznane. ChociaÅ¼ w tym rozdziale nie omÃ³wimy czasÃ³w Å¼ycia w caÅ‚oÅ›ci, to jednak przedstawimy typowe sposoby, w jakie moÅ¼na napotkaÄ‡ skÅ‚adniÄ™ czasÃ³w Å¼ycia, aby moÅ¼na byÅ‚o siÄ™ z niÄ… oswoiÄ‡.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="preventing-dangling-references-with-lifetimes"></a></p>
<h3 id="wiszÄ…ce-referencje"><a class="header" href="#wiszÄ…ce-referencje">WiszÄ…ce referencje</a></h3>
<p>GÅ‚Ã³wnym celem czasÃ³w Å¼ycia jest zapobieganie wiszÄ…cym referencjom, ktÃ³re, gdyby byÅ‚y dozwolone, spowodowaÅ‚yby, Å¼e program odnosiÅ‚by siÄ™ do danych innych niÅ¼ te, do ktÃ³rych miaÅ‚ siÄ™ odnosiÄ‡. RozwaÅ¼ program z Listingu 10-16, ktÃ³ry ma zasiÄ™g zewnÄ™trzny i zasiÄ™g wewnÄ™trzny.</p>
<listing number="10-16" caption="PrÃ³ba uÅ¼ycia referencji, ktÃ³rej wartoÅ›Ä‡ wyszÅ‚a poza zasiÄ™g">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!("r: {r}");
}</code></pre>
</listing>
<blockquote>
<p>Uwaga: PrzykÅ‚ady z ListingÃ³w 10-16, 10-17 i 10-23 deklarujÄ… zmienne bez nadawania im wartoÅ›ci poczÄ…tkowej, wiÄ™c nazwa zmiennej istnieje w zasiÄ™gu zewnÄ™trznym. Na pierwszy rzut oka moÅ¼e to wydawaÄ‡ siÄ™ sprzeczne z tym, Å¼e Rust nie ma wartoÅ›ci null. JednakÅ¼e, jeÅ›li sprÃ³bujemy uÅ¼yÄ‡ zmiennej przed nadaniem jej wartoÅ›ci, otrzymamy bÅ‚Ä…d kompilacji, co pokazuje, Å¼e Rust faktycznie nie zezwala na wartoÅ›ci null.</p>
</blockquote>
<p>ZasiÄ™g zewnÄ™trzny deklaruje zmiennÄ… <code>r</code> bez wartoÅ›ci poczÄ…tkowej, a zasiÄ™g wewnÄ™trzny deklaruje zmiennÄ… <code>x</code> z wartoÅ›ciÄ… poczÄ…tkowÄ… <code>5</code>. WewnÄ…trz zasiÄ™gu wewnÄ™trznego prÃ³bujemy ustawiÄ‡ wartoÅ›Ä‡ <code>r</code> jako referencjÄ™ do <code>x</code>. NastÄ™pnie zasiÄ™g wewnÄ™trzny koÅ„czy siÄ™, a my prÃ³bujemy wypisaÄ‡ wartoÅ›Ä‡ <code>r</code>. Ten kod nie skompiluje siÄ™, poniewaÅ¼ wartoÅ›Ä‡, do ktÃ³rej odnosi siÄ™ <code>r</code>, wyszÅ‚a poza zasiÄ™g, zanim sprÃ³bowaliÅ›my jej uÅ¼yÄ‡. Oto komunikat o bÅ‚Ä™dzie:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
 --&gt; src/main.rs:6:13
  |
5 |         let x = 5;
  |             - binding `x` declared here
6 |         r = &amp;x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |
9 |     println!("r: {r}");
  |                   - borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>Komunikat o bÅ‚Ä™dzie mÃ³wi, Å¼e zmienna <code>x</code> â€nie Å¼yje wystarczajÄ…co dÅ‚ugoâ€. Powodem jest to, Å¼e <code>x</code> wyjdzie poza zasiÄ™g, gdy zasiÄ™g wewnÄ™trzny zakoÅ„czy siÄ™ w wierszu 7. Ale <code>r</code> jest nadal waÅ¼ne dla zasiÄ™gu zewnÄ™trznego; poniewaÅ¼ jego zasiÄ™g jest wiÄ™kszy, mÃ³wimy, Å¼e â€Å¼yje dÅ‚uÅ¼ejâ€. Gdyby Rust pozwoliÅ‚ na dziaÅ‚anie tego kodu, <code>r</code> odwoÅ‚ywaÅ‚oby siÄ™ do pamiÄ™ci, ktÃ³ra zostaÅ‚a zwolniona, gdy <code>x</code> wyszÅ‚o poza zasiÄ™g, a wszystko, co prÃ³bowalibyÅ›my zrobiÄ‡ z <code>r</code>, nie dziaÅ‚aÅ‚oby poprawnie. Jak wiÄ™c Rust ustala, Å¼e ten kod jest nieprawidÅ‚owy? UÅ¼ywa sprawdzacza poÅ¼yczeÅ„.</p>
<h3 id="sprawdzacz-poÅ¼yczeÅ„"><a class="header" href="#sprawdzacz-poÅ¼yczeÅ„">Sprawdzacz poÅ¼yczeÅ„</a></h3>
<p>Kompilator Rust posiada <em>sprawdzacz poÅ¼yczeÅ„</em>, ktÃ³ry porÃ³wnuje zasiÄ™gi, aby okreÅ›liÄ‡, czy wszystkie poÅ¼yczki sÄ… waÅ¼ne. Listing 10-17 przedstawia ten sam kod co Listing 10-16, ale z adnotacjami pokazujÄ…cymi czasy Å¼ycia zmiennych.</p>
<listing number="10-17" caption="Adnotacje czasÃ³w Å¼ycia `r` i `x`, nazwane odpowiednio `&#39;a` i `&#39;b`">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {r}");   //          |
}                         // ---------+</code></pre>
</listing>
<p>Tutaj oznaczyliÅ›my czas Å¼ycia <code>r</code> jako <code>'a</code>, a czas Å¼ycia <code>x</code> jako <code>'b</code>. Jak widaÄ‡, wewnÄ™trzny blok <code>'b</code> jest znacznie mniejszy niÅ¼ zewnÄ™trzny blok czasu Å¼ycia <code>'a</code>. W czasie kompilacji Rust porÃ³wnuje rozmiar tych dwÃ³ch czasÃ³w Å¼ycia i widzi, Å¼e <code>r</code> ma czas Å¼ycia <code>'a</code>, ale odnosi siÄ™ do pamiÄ™ci z czasem Å¼ycia <code>'b</code>. Program jest odrzucany, poniewaÅ¼ <code>'b</code> jest krÃ³tsze niÅ¼ <code>'a</code>: podmiot referencji nie Å¼yje tak dÅ‚ugo, jak sama referencja.</p>
<p>Listing 10-18 naprawia kod, tak aby nie miaÅ‚ wiszÄ…cej referencji i kompilowaÅ‚ siÄ™ bez Å¼adnych bÅ‚Ä™dÃ³w.</p>
<listing number="10-18" caption="PrawidÅ‚owa referencja, poniewaÅ¼ dane majÄ… dÅ‚uÅ¼szy czas Å¼ycia niÅ¼ referencja">
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!("r: {r}");   //   |       |
                          // --+       |
}                         // ----------+</code></pre>
</listing>
<p>Tutaj <code>x</code> ma czas Å¼ycia <code>'b</code>, ktÃ³ry w tym przypadku jest wiÄ™kszy niÅ¼ <code>'a</code>. Oznacza to, Å¼e <code>r</code> moÅ¼e odwoÅ‚ywaÄ‡ siÄ™ do <code>x</code>, poniewaÅ¼ Rust wie, Å¼e referencja w <code>r</code> zawsze bÄ™dzie waÅ¼na, dopÃ³ki <code>x</code> jest waÅ¼ne.</p>
<p>Teraz, gdy wiesz, gdzie znajdujÄ… siÄ™ czasy Å¼ycia referencji i jak Rust analizuje czasy Å¼ycia, aby zapewniÄ‡, Å¼e referencje zawsze bÄ™dÄ… waÅ¼ne, przejdÅºmy do ogÃ³lnych czasÃ³w Å¼ycia w parametrach funkcji i wartoÅ›ciach zwracanych.</p>
<h3 id="ogÃ³lne-czasy-Å¼ycia-w-funkcjach"><a class="header" href="#ogÃ³lne-czasy-Å¼ycia-w-funkcjach">OgÃ³lne czasy Å¼ycia w funkcjach</a></h3>
<p>Napiszemy funkcjÄ™, ktÃ³ra zwraca dÅ‚uÅ¼szy z dwÃ³ch wycinkÃ³w ciÄ…gÃ³w znakÃ³w. Funkcja ta przyjmie dwa wycinki ciÄ…gÃ³w znakÃ³w i zwrÃ³ci pojedynczy wycinek ciÄ…gu znakÃ³w. Po zaimplementowaniu funkcji <code>longest</code>, kod z Listingu 10-19 powinien wypisaÄ‡ <code>The longest string is abcd</code>.</p>
<listing number="10-19" file-name="src/main.rs" caption="Funkcja `main` wywoÅ‚ujÄ…ca funkcjÄ™ `longest` w celu znalezienia dÅ‚uÅ¼szego z dwÃ³ch wycinkÃ³w ciÄ…gÃ³w znakÃ³w">
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {result}");
}</code></pre>
</listing>
<p>ZauwaÅ¼, Å¼e chcemy, aby funkcja przyjmowaÅ‚a wycinki ciÄ…gÃ³w znakÃ³w, ktÃ³re sÄ… referencjami, a nie ciÄ…gami znakÃ³w, poniewaÅ¼ nie chcemy, aby funkcja <code>longest</code> przejmowaÅ‚a wÅ‚asnoÅ›Ä‡ swoich parametrÃ³w. WiÄ™cej informacji na temat tego, dlaczego parametry uÅ¼yte w Listingu 10-19 sÄ… tymi, ktÃ³rych chcemy, znajduje siÄ™ w sekcji <a href="#string-slices-as-parameters">â€Wycinki ciÄ…gÃ³w znakÃ³w jako parametryâ€</a><!-- ignore --> w Rozdziale 4.</p>
<p>JeÅ›li sprÃ³bujemy zaimplementowaÄ‡ funkcjÄ™ <code>longest</code> tak, jak pokazano w Listingu 10-20, nie skompiluje siÄ™ ona.</p>
<listing number="10-20" file-name="src/main.rs" caption="Implementacja funkcji `longest`, ktÃ³ra zwraca dÅ‚uÅ¼szy z dwÃ³ch wycinkÃ³w ciÄ…gÃ³w znakÃ³w, ale jeszcze siÄ™ nie kompiluje">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() { x } else { y }
}</code></pre>
</listing>
<p>Zamiast tego otrzymujemy nastÄ™pujÄ…cy bÅ‚Ä…d, ktÃ³ry dotyczy czasÃ³w Å¼ycia:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>Tekst pomocy ujawnia, Å¼e typ zwracany wymaga parametru ogÃ³lnego czasu Å¼ycia, poniewaÅ¼ Rust nie moÅ¼e okreÅ›liÄ‡, czy zwracana referencja odnosi siÄ™ do <code>x</code> czy do <code>y</code>. Tak naprawdÄ™ my teÅ¼ tego nie wiemy, poniewaÅ¼ blok <code>if</code> w ciele tej funkcji zwraca referencjÄ™ do <code>x</code>, a blok <code>else</code> zwraca referencjÄ™ do <code>y</code>!</p>
<p>Kiedy definiujemy tÄ™ funkcjÄ™, nie znamy konkretnych wartoÅ›ci, ktÃ³re zostanÄ… do niej przekazane, wiÄ™c nie wiemy, czy wykona siÄ™ przypadek <code>if</code> czy <code>else</code>. Nie znamy rÃ³wnieÅ¼ konkretnych czasÃ³w Å¼ycia referencji, ktÃ³re zostanÄ… przekazane, wiÄ™c nie moÅ¼emy spojrzeÄ‡ na zasiÄ™gi, jak to zrobiliÅ›my w Listingach 10-17 i 10-18, aby okreÅ›liÄ‡, czy zwracana referencja bÄ™dzie zawsze waÅ¼na. Sprawdzacz poÅ¼yczeÅ„ rÃ³wnieÅ¼ nie moÅ¼e tego ustaliÄ‡, poniewaÅ¼ nie wie, jak czasy Å¼ycia <code>x</code> i <code>y</code> odnoszÄ… siÄ™ do czasu Å¼ycia wartoÅ›ci zwracanej. Aby naprawiÄ‡ ten bÅ‚Ä…d, dodamy ogÃ³lne parametry czasÃ³w Å¼ycia, ktÃ³re zdefiniujÄ… relacjÄ™ miÄ™dzy referencjami, aby sprawdzacz poÅ¼yczeÅ„ mÃ³gÅ‚ przeprowadziÄ‡ swojÄ… analizÄ™.</p>
<h3 id="skÅ‚adnia-adnotacji-czasÃ³w-Å¼ycia"><a class="header" href="#skÅ‚adnia-adnotacji-czasÃ³w-Å¼ycia">SkÅ‚adnia adnotacji czasÃ³w Å¼ycia</a></h3>
<p>Adnotacje czasÃ³w Å¼ycia nie zmieniajÄ… dÅ‚ugoÅ›ci Å¼ycia Å¼adnych referencji. Raczej opisujÄ… one relacje miÄ™dzy czasami Å¼ycia wielu referencji, nie wpÅ‚ywajÄ…c na same czasy Å¼ycia. Tak jak funkcje mogÄ… przyjmowaÄ‡ dowolny typ, gdy sygnatura okreÅ›la ogÃ³lny parametr typu, tak samo funkcje mogÄ… przyjmowaÄ‡ referencje z dowolnym czasem Å¼ycia, okreÅ›lajÄ…c ogÃ³lny parametr czasu Å¼ycia.</p>
<p>Adnotacje czasÃ³w Å¼ycia majÄ… nieco nietypowÄ… skÅ‚adniÄ™: nazwy parametrÃ³w czasu Å¼ycia muszÄ… zaczynaÄ‡ siÄ™ od apostrofu (<code>'</code>) i zazwyczaj sÄ… maÅ‚ymi literami i bardzo krÃ³tkie, podobnie jak typy ogÃ³lne. WiÄ™kszoÅ›Ä‡ ludzi uÅ¼ywa nazwy <code>'a</code> dla pierwszej adnotacji czasu Å¼ycia. Adnotacje parametrÃ³w czasu Å¼ycia umieszczamy po <code>&amp;</code> referencji, uÅ¼ywajÄ…c spacji do oddzielenia adnotacji od typu referencji.</p>
<p>Oto kilka przykÅ‚adÃ³w â€“ referencja do <code>i32</code> bez parametru czasu Å¼ycia, referencja do <code>i32</code> z parametrem czasu Å¼ycia o nazwie <code>'a</code>, oraz zmienna referencja do <code>i32</code>, ktÃ³ra rÃ³wnieÅ¼ ma czas Å¼ycia <code>'a</code>:</p>
<pre><code class="language-rust ignore">&amp;i32        // referencja
&amp;'a i32     // referencja z jawnym czasem Å¼ycia
&amp;'a mut i32 // zmienna referencja z jawnym czasem Å¼ycia</code></pre>
<p>Jedna adnotacja czasu Å¼ycia sama w sobie nie ma wiÄ™kszego znaczenia, poniewaÅ¼ adnotacje majÄ… na celu poinformowanie Rust, jak ogÃ³lne parametry czasu Å¼ycia wielu referencji odnoszÄ… siÄ™ do siebie. Przyjrzyjmy siÄ™, jak adnotacje czasu Å¼ycia odnoszÄ… siÄ™ do siebie w kontekÅ›cie funkcji <code>longest</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="lifetime-annotations-in-function-signatures"></a></p>
<h3 id="w-sygnaturach-funkcji"><a class="header" href="#w-sygnaturach-funkcji">W sygnaturach funkcji</a></h3>
<p>Aby uÅ¼ywaÄ‡ adnotacji czasÃ³w Å¼ycia w sygnaturach funkcji, musimy zadeklarowaÄ‡ ogÃ³lne parametry czasÃ³w Å¼ycia w nawiasach kÄ…towych miÄ™dzy nazwÄ… funkcji a listÄ… parametrÃ³w, tak jak robiliÅ›my to z ogÃ³lnymi parametrami typÃ³w.</p>
<p>Chcemy, aby sygnatura wyraÅ¼aÅ‚a nastÄ™pujÄ…ce ograniczenie: zwracana referencja bÄ™dzie waÅ¼na tak dÅ‚ugo, jak dÅ‚ugo oba parametry sÄ… waÅ¼ne. Jest to relacja miÄ™dzy czasami Å¼ycia parametrÃ³w a wartoÅ›ciÄ… zwracanÄ…. Nazwiemy czas Å¼ycia <code>'a</code>, a nastÄ™pnie dodamy go do kaÅ¼dej referencji, jak pokazano w Listingu 10-21.</p>
<listing number="10-21" file-name="src/main.rs" caption="Definicja funkcji `longest` okreÅ›lajÄ…ca, Å¼e wszystkie referencje w sygnaturze muszÄ… mieÄ‡ ten sam czas Å¼ycia `&#39;a`">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() { x } else { y }
}</code></pre>
</listing>
<p>Ten kod powinien siÄ™ skompilowaÄ‡ i daÄ‡ poÅ¼Ä…dany rezultat, gdy uÅ¼yjemy go z funkcjÄ… <code>main</code> z Listingu 10-19.</p>
<p>Sygnatura funkcji informuje teraz Rust, Å¼e dla pewnego czasu Å¼ycia <code>'a</code>, funkcja przyjmuje dwa parametry, z ktÃ³rych oba sÄ… wycinkami ciÄ…gÃ³w znakÃ³w, ktÃ³re Å¼yjÄ… co najmniej tak dÅ‚ugo, jak czas Å¼ycia <code>'a</code>. Sygnatura funkcji informuje rÃ³wnieÅ¼ Rust, Å¼e wycinek ciÄ…gu znakÃ³w zwrÃ³cony z funkcji bÄ™dzie Å¼yÅ‚ co najmniej tak dÅ‚ugo, jak czas Å¼ycia <code>'a</code>. W praktyce oznacza to, Å¼e czas Å¼ycia referencji zwrÃ³conej przez funkcjÄ™ <code>longest</code> jest taki sam, jak krÃ³tszy z czasÃ³w Å¼ycia wartoÅ›ci, do ktÃ³rych odwoÅ‚ujÄ… siÄ™ argumenty funkcji. Te relacje to to, czego chcemy, aby Rust uÅ¼ywaÅ‚ podczas analizy tego kodu.</p>
<p>PamiÄ™taj, Å¼e kiedy okreÅ›lamy parametry czasu Å¼ycia w sygnaturze tej funkcji, nie zmieniamy czasÃ³w Å¼ycia Å¼adnych wartoÅ›ci przekazanych ani zwracanych. Raczej okreÅ›lamy, Å¼e sprawdzacz poÅ¼yczeÅ„ powinien odrzuciÄ‡ wszelkie wartoÅ›ci, ktÃ³re nie przestrzegajÄ… tych ograniczeÅ„. ZauwaÅ¼, Å¼e funkcja <code>longest</code> nie musi dokÅ‚adnie wiedzieÄ‡, jak dÅ‚ugo bÄ™dÄ… Å¼yÅ‚y <code>x</code> i <code>y</code>, tylko Å¼e pewien zasiÄ™g moÅ¼e zostaÄ‡ podstawiony za <code>'a</code>, ktÃ³ry speÅ‚ni tÄ™ sygnaturÄ™.</p>
<p>Podczas adnotowania czasÃ³w Å¼ycia w funkcjach, adnotacje umieszcza siÄ™ w sygnaturze funkcji, a nie w jej ciele. Adnotacje czasÃ³w Å¼ycia stajÄ… siÄ™ czÄ™Å›ciÄ… kontraktu funkcji, podobnie jak typy w sygnaturze. Posiadanie sygnatur funkcji zawierajÄ…cych kontrakt czasÃ³w Å¼ycia oznacza, Å¼e analiza wykonywana przez kompilator Rust moÅ¼e byÄ‡ prostsza. JeÅ›li wystÄ…pi problem z adnotacjÄ… funkcji lub sposobem jej wywoÅ‚ania, bÅ‚Ä™dy kompilatora mogÄ… wskazaÄ‡ precyzyjniej na czÄ™Å›Ä‡ naszego kodu i ograniczenia. Gdyby kompilator Rust wyciÄ…gaÅ‚ wiÄ™cej wnioskÃ³w na temat tego, jakie relacje czasÃ³w Å¼ycia zamierzaliÅ›my, kompilator mÃ³gÅ‚by wskazaÄ‡ tylko na uÅ¼ycie naszego kodu wiele krokÃ³w od przyczyny problemu.</p>
<p>Kiedy przekazujemy konkretne referencje do <code>longest</code>, konkretny czas Å¼ycia, ktÃ³ry jest podstawiany za <code>'a</code>, to czÄ™Å›Ä‡ zasiÄ™gu <code>x</code>, ktÃ³ra nakÅ‚ada siÄ™ na zasiÄ™g <code>y</code>. Innymi sÅ‚owy, ogÃ³lny czas Å¼ycia <code>'a</code> przyjmie konkretny czas Å¼ycia, ktÃ³ry jest rÃ³wny krÃ³tszemu z czasÃ³w Å¼ycia <code>x</code> i <code>y</code>. PoniewaÅ¼ oznaczyliÅ›my zwracanÄ… referencjÄ™ tym samym parametrem czasu Å¼ycia <code>'a</code>, zwracana referencja bÄ™dzie rÃ³wnieÅ¼ waÅ¼na przez czas trwania krÃ³tszego z czasÃ³w Å¼ycia <code>x</code> i <code>y</code>.</p>
<p>Przyjrzyjmy siÄ™, jak adnotacje czasÃ³w Å¼ycia ograniczajÄ… funkcjÄ™ <code>longest</code> poprzez przekazywanie referencji, ktÃ³re majÄ… rÃ³Å¼ne konkretne czasy Å¼ycia. Listing 10-22 to prosty przykÅ‚ad.</p>
<listing number="10-22" file-name="src/main.rs" caption="UÅ¼ywanie funkcji `longest` z referencjami do wartoÅ›ci `String`, ktÃ³re majÄ… rÃ³Å¼ne konkretne czasy Å¼ycia">
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {result}");
    }
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() { x } else { y }
</span><span class="boring">}</span></code></pre>
</listing>
<p>W tym przykÅ‚adzie <code>string1</code> jest waÅ¼ne do koÅ„ca zewnÄ™trznego zasiÄ™gu, <code>string2</code> jest waÅ¼ne do koÅ„ca wewnÄ™trznego zasiÄ™gu, a <code>result</code> odwoÅ‚uje siÄ™ do czegoÅ›, co jest waÅ¼ne do koÅ„ca wewnÄ™trznego zasiÄ™gu. Uruchom ten kod, a zobaczysz, Å¼e sprawdzacz poÅ¼yczeÅ„ zatwierdza; skompiluje siÄ™ i wypisze <code>The longest string is long string is long</code>.</p>
<p>NastÄ™pnie sprÃ³bujmy przykÅ‚adu, ktÃ³ry pokazuje, Å¼e czas Å¼ycia referencji w <code>result</code> musi byÄ‡ krÃ³tszym czasem Å¼ycia z dwÃ³ch argumentÃ³w. Przeniesiemy deklaracjÄ™ zmiennej <code>result</code> poza zasiÄ™g wewnÄ™trzny, ale pozostawimy przypisanie wartoÅ›ci do zmiennej <code>result</code> wewnÄ…trz zasiÄ™gu z <code>string2</code>. NastÄ™pnie przeniesiemy <code>println!</code>, ktÃ³re uÅ¼ywa <code>result</code>, poza zasiÄ™g wewnÄ™trzny, po zakoÅ„czeniu zasiÄ™gu wewnÄ™trznego. Kod z Listingu 10-23 nie skompiluje siÄ™.</p>
<listing number="10-23" file-name="src/main.rs" caption="PrÃ³ba uÅ¼ycia `result` po tym, jak `string2` wyszÅ‚o poza zasiÄ™g">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {result}");
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() { x } else { y }
</span><span class="boring">}</span></code></pre>
</listing>
<p>Kiedy prÃ³bujemy skompilowaÄ‡ ten kod, otrzymujemy nastÄ™pujÄ…cy bÅ‚Ä…d:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
5 |         let string2 = String::from("xyz");
  |             ------- binding `string2` declared here
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!("The longest string is {result}");
  |                                      ------ borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>BÅ‚Ä…d pokazuje, Å¼e aby <code>result</code> byÅ‚o waÅ¼ne dla instrukcji <code>println!</code>, <code>string2</code> musiaÅ‚oby byÄ‡ waÅ¼ne do koÅ„ca zasiÄ™gu zewnÄ™trznego. Rust wie o tym, poniewaÅ¼ oznaczyliÅ›my czasy Å¼ycia parametrÃ³w funkcji i wartoÅ›ci zwracanych, uÅ¼ywajÄ…c tego samego parametru czasu Å¼ycia <code>'a</code>.</p>
<p>Jako ludzie, moÅ¼emy spojrzeÄ‡ na ten kod i zobaczyÄ‡, Å¼e <code>string1</code> jest dÅ‚uÅ¼sze niÅ¼ <code>string2</code>, a zatem <code>result</code> bÄ™dzie zawieraÄ‡ referencjÄ™ do <code>string1</code>. PoniewaÅ¼ <code>string1</code> nie wyszÅ‚o jeszcze poza zasiÄ™g, referencja do <code>string1</code> bÄ™dzie nadal waÅ¼na dla instrukcji <code>println!</code>. Jednak kompilator nie widzi, Å¼e referencja jest waÅ¼na w tym przypadku. PowiedzieliÅ›my Rust, Å¼e czas Å¼ycia referencji zwrÃ³conej przez funkcjÄ™ <code>longest</code> jest taki sam, jak krÃ³tszy z czasÃ³w Å¼ycia referencji przekazanych. Dlatego sprawdzacz poÅ¼yczeÅ„ nie zezwala na kod z Listingu 10-23, poniewaÅ¼ moÅ¼e on zawieraÄ‡ nieprawidÅ‚owÄ… referencjÄ™.</p>
<p>SprÃ³buj zaprojektowaÄ‡ wiÄ™cej eksperymentÃ³w, ktÃ³re zmieniajÄ… wartoÅ›ci i czasy Å¼ycia referencji przekazywanych do funkcji <code>longest</code> oraz sposÃ³b uÅ¼ycia zwrÃ³conej referencji. Postaw hipotezy, czy Twoje eksperymenty przejdÄ… sprawdzacz poÅ¼yczeÅ„, zanim skompilujesz; nastÄ™pnie sprawdÅº, czy masz racjÄ™!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="thinking-in-terms-of-lifetimes"></a></p>
<h3 id="relacje"><a class="header" href="#relacje">Relacje</a></h3>
<p>SposÃ³b, w jaki musisz okreÅ›liÄ‡ parametry czasu Å¼ycia, zaleÅ¼y od tego, co robi twoja funkcja. Na przykÅ‚ad, gdybyÅ›my zmienili implementacjÄ™ funkcji <code>longest</code> tak, aby zawsze zwracaÅ‚a pierwszy parametr zamiast najdÅ‚uÅ¼szego wycinka ciÄ…gu znakÃ³w, nie musielibyÅ›my okreÅ›laÄ‡ czasu Å¼ycia dla parametru <code>y</code>. PoniÅ¼szy kod skompiluje siÄ™:</p>
<listing file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "efghijklmnopqrstuvwxyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}</code></pre>
</listing>
<p>OkreÅ›liliÅ›my parametr czasu Å¼ycia <code>'a</code> dla parametru <code>x</code> i typu zwracanego, ale nie dla parametru <code>y</code>, poniewaÅ¼ czas Å¼ycia <code>y</code> nie ma Å¼adnego zwiÄ…zku z czasem Å¼ycia <code>x</code> ani wartoÅ›ciÄ… zwracanÄ….</p>
<p>Podczas zwracania referencji z funkcji, parametr czasu Å¼ycia dla typu zwracanego musi odpowiadaÄ‡ parametrowi czasu Å¼ycia jednego z parametrÃ³w. JeÅ›li zwracana referencja <em>nie</em> odnosi siÄ™ do jednego z parametrÃ³w, musi odnosiÄ‡ siÄ™ do wartoÅ›ci utworzonej wewnÄ…trz tej funkcji. ByÅ‚aby to jednak wiszÄ…ca referencja, poniewaÅ¼ wartoÅ›Ä‡ wyjdzie poza zasiÄ™g na koÅ„cu funkcji. RozwaÅ¼ tÄ™ prÃ³bÄ™ implementacji funkcji <code>longest</code>, ktÃ³ra siÄ™ nie skompiluje:</p>
<listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from("really long string");
    result.as_str()
}</code></pre>
</listing>
<p>Tutaj, mimo Å¼e okreÅ›liliÅ›my parametr czasu Å¼ycia <code>'a</code> dla typu zwracanego, ta implementacja nie skompiluje siÄ™, poniewaÅ¼ czas Å¼ycia wartoÅ›ci zwracanej nie jest w ogÃ³le powiÄ…zany z czasem Å¼ycia parametrÃ³w. Oto komunikat o bÅ‚Ä™dzie, ktÃ³ry otrzymujemy:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `result`
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `result` is borrowed here

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>Problem polega na tym, Å¼e <code>result</code> wychodzi poza zasiÄ™g i zostaje oczyszczone na koÅ„cu funkcji <code>longest</code>. PrÃ³bujemy rÃ³wnieÅ¼ zwrÃ³ciÄ‡ referencjÄ™ do <code>result</code> z funkcji. Nie ma sposobu, abyÅ›my mogli okreÅ›liÄ‡ parametry czasu Å¼ycia, ktÃ³re zmieniÅ‚yby wiszÄ…cÄ… referencjÄ™, a Rust nie pozwoli nam na utworzenie wiszÄ…cej referencji. W tym przypadku najlepszym rozwiÄ…zaniem byÅ‚oby zwrÃ³cenie wÅ‚asnego typu danych zamiast referencji, tak aby funkcja wywoÅ‚ujÄ…ca byÅ‚a odpowiedzialna za oczyszczenie wartoÅ›ci.</p>
<p>Ostatecznie skÅ‚adnia czasÃ³w Å¼ycia sÅ‚uÅ¼y do Å‚Ä…czenia czasÃ³w Å¼ycia rÃ³Å¼nych parametrÃ³w i wartoÅ›ci zwracanych funkcji. Po ich poÅ‚Ä…czeniu Rust ma wystarczajÄ…ce informacje, aby zezwalaÄ‡ na operacje bezpieczne dla pamiÄ™ci i odrzucaÄ‡ operacje, ktÃ³re mogÅ‚yby stworzyÄ‡ wiszÄ…ce wskaÅºniki lub w inny sposÃ³b naruszyÄ‡ bezpieczeÅ„stwo pamiÄ™ci.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="lifetime-annotations-in-struct-definitions"></a></p>
<h3 id="w-definicjach-struktur-1"><a class="header" href="#w-definicjach-struktur-1">W definicjach struktur</a></h3>
<p>Dotychczasowe struktury, ktÃ³re zdefiniowaliÅ›my, zawsze przechowywaÅ‚y typy posiadane. MoÅ¼emy zdefiniowaÄ‡ struktury, ktÃ³re przechowujÄ… referencje, ale w takim przypadku musielibyÅ›my dodaÄ‡ adnotacjÄ™ czasu Å¼ycia do kaÅ¼dej referencji w definicji struktury. Listing 10-24 przedstawia strukturÄ™ o nazwie <code>ImportantExcerpt</code>, ktÃ³ra przechowuje wycinek ciÄ…gu znakÃ³w.</p>
<listing number="10-24" file-name="src/main.rs" caption="Struktura, ktÃ³ra przechowuje referencjÄ™, wymagajÄ…ca adnotacji czasu Å¼ycia">
<pre class="playground"><code class="language-rust edition2024">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}</code></pre>
</listing>
<p>Ta struktura ma jedno pole <code>part</code>, ktÃ³re przechowuje wycinek ciÄ…gu znakÃ³w, czyli referencjÄ™. Podobnie jak w przypadku ogÃ³lnych typÃ³w danych, nazwÄ™ ogÃ³lnego parametru czasu Å¼ycia deklarujemy w nawiasach kÄ…towych po nazwie struktury, abyÅ›my mogli uÅ¼yÄ‡ parametru czasu Å¼ycia w ciele definicji struktury. Ta adnotacja oznacza, Å¼e instancja <code>ImportantExcerpt</code> nie moÅ¼e przeÅ¼yÄ‡ referencji, ktÃ³rÄ… przechowuje w swoim polu <code>part</code>.</p>
<p>Funkcja <code>main</code> tworzy tutaj instancjÄ™ struktury <code>ImportantExcerpt</code>, ktÃ³ra przechowuje referencjÄ™ do pierwszego zdania <code>String</code> bÄ™dÄ…cego wÅ‚asnoÅ›ciÄ… zmiennej <code>novel</code>. Dane w <code>novel</code> istniejÄ… przed utworzeniem instancji <code>ImportantExcerpt</code>. Ponadto <code>novel</code> nie wychodzi poza zasiÄ™g, dopÃ³ki <code>ImportantExcerpt</code> nie wyjdzie poza zasiÄ™g, wiÄ™c referencja w instancji <code>ImportantExcerpt</code> jest waÅ¼na.</p>
<h3 id="elizja-czasÃ³w-Å¼ycia"><a class="header" href="#elizja-czasÃ³w-Å¼ycia">Elizja czasÃ³w Å¼ycia</a></h3>
<p>DowiedziaÅ‚eÅ› siÄ™, Å¼e kaÅ¼da referencja ma czas Å¼ycia i Å¼e musisz okreÅ›liÄ‡ parametry czasu Å¼ycia dla funkcji lub struktur, ktÃ³re uÅ¼ywajÄ… referencji. Jednak w Listingu 4-9 mieliÅ›my funkcjÄ™, ponownie pokazanÄ… w Listingu 10-25, ktÃ³ra kompilowaÅ‚a siÄ™ bez adnotacji czasÃ³w Å¼ycia.</p>
<listing number="10-25" file-name="src/lib.rs" caption="Funkcja, ktÃ³rÄ… zdefiniowaliÅ›my w Listingu 4-9, skompilowaÅ‚a siÄ™ bez adnotacji czasÃ³w Å¼ycia, mimo Å¼e parametr i typ zwracany sÄ… referencjami">
<pre class="playground"><code class="language-rust edition2024">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from("hello world");
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of `String`s
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = "hello world";
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of string literals
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre>
</listing>
<p>Powodem, dla ktÃ³rego ta funkcja kompiluje siÄ™ bez adnotacji czasÃ³w Å¼ycia, jest historia: we wczesnych wersjach (przed 1.0) Rust, ten kod by siÄ™ nie skompilowaÅ‚, poniewaÅ¼ kaÅ¼da referencja wymagaÅ‚a jawnego czasu Å¼ycia. W tamtym czasie sygnatura funkcji byÅ‚aby napisana tak:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>Po napisaniu duÅ¼ej iloÅ›ci kodu w Rust, zespÃ³Å‚ Rust odkryÅ‚, Å¼e programiÅ›ci Rust wpisywali te same adnotacje czasÃ³w Å¼ycia wielokrotnie w konkretnych sytuacjach. Sytuacje te byÅ‚y przewidywalne i postÄ™powaÅ‚y zgodnie z kilkoma deterministycznymi wzorcami. Deweloperzy zaprogramowali te wzorce w kodzie kompilatora, aby sprawdzacz poÅ¼yczeÅ„ mÃ³gÅ‚ wnioskowaÄ‡ o czasach Å¼ycia w tych sytuacjach i nie potrzebowaÅ‚ jawnych adnotacji.</p>
<p>Ten kawaÅ‚ek historii Rust jest istotny, poniewaÅ¼ moÅ¼liwe jest, Å¼e pojawi siÄ™ wiÄ™cej deterministycznych wzorcÃ³w i zostanie dodanych do kompilatora. W przyszÅ‚oÅ›ci moÅ¼e byÄ‡ wymagane jeszcze mniej adnotacji czasÃ³w Å¼ycia.</p>
<p>Wzorce zaprogramowane w analizie referencji przez Rust nazywane sÄ… <em>zasadami elizji czasÃ³w Å¼ycia</em>. Nie sÄ… to zasady, ktÃ³rymi programiÅ›ci majÄ… siÄ™ kierowaÄ‡; to zbiÃ³r konkretnych przypadkÃ³w, ktÃ³re kompilator weÅºmie pod uwagÄ™, a jeÅ›li twÃ³j kod pasuje do tych przypadkÃ³w, nie musisz jawnie pisaÄ‡ czasÃ³w Å¼ycia.</p>
<p>Zasady elizji nie zapewniajÄ… peÅ‚nego wnioskowania. JeÅ›li po zastosowaniu zasad nadal istnieje niejasnoÅ›Ä‡ co do czasÃ³w Å¼ycia referencji, kompilator nie zgadnie, jakie powinny byÄ‡ czasy Å¼ycia pozostaÅ‚ych referencji. Zamiast zgadywaÄ‡, kompilator wyÅ›wietli bÅ‚Ä…d, ktÃ³ry moÅ¼na rozwiÄ…zaÄ‡, dodajÄ…c adnotacje czasÃ³w Å¼ycia.</p>
<p>Czasy Å¼ycia na parametrach funkcji lub metod nazywane sÄ… <em>czasami Å¼ycia wejÅ›ciowymi</em>, a czasy Å¼ycia na wartoÅ›ciach zwracanych nazywane sÄ… <em>czasami Å¼ycia wyjÅ›ciowymi</em>.</p>
<p>Kompilator uÅ¼ywa trzech zasad, aby ustaliÄ‡ czasy Å¼ycia referencji, gdy nie ma jawnych adnotacji. Pierwsza zasada dotyczy czasÃ³w Å¼ycia wejÅ›ciowych, a druga i trzecia zasada dotyczÄ… czasÃ³w Å¼ycia wyjÅ›ciowych. JeÅ›li kompilator dojdzie do koÅ„ca trzech zasad, a nadal istniejÄ… referencje, dla ktÃ³rych nie moÅ¼e ustaliÄ‡ czasÃ³w Å¼ycia, kompilator zatrzyma siÄ™ z bÅ‚Ä™dem. Zasady te majÄ… zastosowanie zarÃ³wno do definicji <code>fn</code>, jak i blokÃ³w <code>impl</code>.</p>
<p>Pierwsza zasada mÃ³wi, Å¼e kompilator przypisuje parametr czasu Å¼ycia kaÅ¼demu parametrowi, ktÃ³ry jest referencjÄ…. Innymi sÅ‚owy, funkcja z jednym parametrem otrzymuje jeden parametr czasu Å¼ycia: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>; funkcja z dwoma parametrami otrzymuje dwa oddzielne parametry czasu Å¼ycia: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>; i tak dalej.</p>
<p>Druga zasada mÃ³wi, Å¼e jeÅ›li istnieje dokÅ‚adnie jeden parametr czasu Å¼ycia wejÅ›ciowego, to ten czas Å¼ycia jest przypisywany do wszystkich parametrÃ³w czasu Å¼ycia wyjÅ›ciowego: <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
<p>Trzecia zasada mÃ³wi, Å¼e jeÅ›li istnieje wiele parametrÃ³w czasu Å¼ycia wejÅ›ciowego, ale jeden z nich to <code>&amp;self</code> lub <code>&amp;mut self</code>, poniewaÅ¼ jest to metoda, czas Å¼ycia <code>self</code> jest przypisywany do wszystkich parametrÃ³w czasu Å¼ycia wyjÅ›ciowego. Ta trzecia zasada sprawia, Å¼e metody sÄ… znacznie przyjemniejsze w czytaniu i pisaniu, poniewaÅ¼ potrzeba mniej symboli.</p>
<p>Udawajmy, Å¼e jesteÅ›my kompilatorem. Zastosujemy te zasady, aby ustaliÄ‡ czasy Å¼ycia referencji w sygnaturze funkcji <code>first_word</code> z Listingu 10-25. Sygnatura zaczyna siÄ™ bez Å¼adnych czasÃ³w Å¼ycia przypisanych do referencji:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {</code></pre>
<p>NastÄ™pnie kompilator stosuje pierwszÄ… zasadÄ™, ktÃ³ra okreÅ›la, Å¼e kaÅ¼dy parametr otrzymuje swÃ³j wÅ‚asny czas Å¼ycia. Nazwiemy go jak zwykle <code>'a</code>, wiÄ™c sygnatura wyglÄ…da teraz tak:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {</code></pre>
<p>Druga zasada ma zastosowanie, poniewaÅ¼ istnieje dokÅ‚adnie jeden czas Å¼ycia wejÅ›ciowego. Druga zasada okreÅ›la, Å¼e czas Å¼ycia jednego parametru wejÅ›ciowego jest przypisywany do czasu Å¼ycia wyjÅ›ciowego, wiÄ™c sygnatura wyglÄ…da teraz tak:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>Teraz wszystkie referencje w sygnaturze tej funkcji majÄ… czasy Å¼ycia, a kompilator moÅ¼e kontynuowaÄ‡ swojÄ… analizÄ™ bez potrzeby, aby programista adnotowaÅ‚ czasy Å¼ycia w sygnaturze tej funkcji.</p>
<p>Przyjrzyjmy siÄ™ innemu przykÅ‚adowi, tym razem uÅ¼ywajÄ…c funkcji <code>longest</code>, ktÃ³ra nie miaÅ‚a parametrÃ³w czasu Å¼ycia, kiedy zaczÄ™liÅ›my z niÄ… pracowaÄ‡ w Listingu 10-20:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {</code></pre>
<p>Zastosujmy pierwszÄ… zasadÄ™: kaÅ¼dy parametr otrzymuje swÃ³j wÅ‚asny czas Å¼ycia. Tym razem mamy dwa parametry zamiast jednego, wiÄ™c mamy dwa czasy Å¼ycia:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {</code></pre>
<p>Widzisz, Å¼e druga zasada nie ma zastosowania, poniewaÅ¼ istnieje wiÄ™cej niÅ¼ jeden czas Å¼ycia wejÅ›ciowego. Trzecia zasada rÃ³wnieÅ¼ nie ma zastosowania, poniewaÅ¼ <code>longest</code> jest funkcjÄ…, a nie metodÄ…, wiÄ™c Å¼aden z parametrÃ³w nie jest <code>self</code>. Po przejÅ›ciu przez wszystkie trzy zasady, nadal nie ustaliliÅ›my, jaki jest czas Å¼ycia typu zwracanego. Dlatego otrzymaliÅ›my bÅ‚Ä…d podczas prÃ³by kompilacji kodu z Listingu 10-20: kompilator przeanalizowaÅ‚ zasady elizji czasÃ³w Å¼ycia, ale nadal nie byÅ‚ w stanie ustaliÄ‡ wszystkich czasÃ³w Å¼ycia referencji w sygnaturze.</p>
<p>PoniewaÅ¼ trzecia zasada dotyczy tak naprawdÄ™ tylko sygnatur metod, przyjrzyjmy siÄ™ teraz czasom Å¼ycia w tym kontekÅ›cie, aby zobaczyÄ‡, dlaczego trzecia zasada oznacza, Å¼e nie musimy zbyt czÄ™sto adnotowaÄ‡ czasÃ³w Å¼ycia w sygnaturach metod.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="lifetime-annotations-in-method-definitions"></a></p>
<h3 id="w-definicjach-metod-1"><a class="header" href="#w-definicjach-metod-1">W definicjach metod</a></h3>
<p>Kiedy implementujemy metody w strukturze z czasami Å¼ycia, uÅ¼ywamy tej samej skÅ‚adni co w przypadku ogÃ³lnych parametrÃ³w typÃ³w, jak pokazano w Listingu 10-11. Gdzie deklarujemy i uÅ¼ywamy parametrÃ³w czasu Å¼ycia, zaleÅ¼y od tego, czy sÄ… one zwiÄ…zane z polami struktury, czy z parametrami metody i wartoÅ›ciami zwracanymi.</p>
<p>Nazwy czasÃ³w Å¼ycia dla pÃ³l struktury zawsze muszÄ… byÄ‡ deklarowane po sÅ‚owie kluczowym <code>impl</code>, a nastÄ™pnie uÅ¼ywane po nazwie struktury, poniewaÅ¼ te czasy Å¼ycia sÄ… czÄ™Å›ciÄ… typu struktury.</p>
<p>W sygnaturach metod w bloku <code>impl</code>, referencje mogÄ… byÄ‡ powiÄ…zane z czasem Å¼ycia referencji w polach struktury, lub mogÄ… byÄ‡ niezaleÅ¼ne. Ponadto, zasady elizji czasÃ³w Å¼ycia czÄ™sto powodujÄ…, Å¼e adnotacje czasÃ³w Å¼ycia nie sÄ… konieczne w sygnaturach metod. Przyjrzyjmy siÄ™ kilku przykÅ‚adom, uÅ¼ywajÄ…c struktury <code>ImportantExcerpt</code>, ktÃ³rÄ… zdefiniowaliÅ›my w Listingu 10-24.</p>
<p>Najpierw uÅ¼yjemy metody o nazwie <code>level</code>, ktÃ³rej jedynym parametrem jest referencja do <code>self</code>, a zwracana wartoÅ›Ä‡ to <code>i32</code>, ktÃ³ra nie jest referencjÄ… do niczego:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!("Attention please: {announcement}");
</span><span class="boring">        self.part
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from("Call me Ishmael. Some years ago...");
</span><span class="boring">    let first_sentence = novel.split('.').next().unwrap();
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre>
<p>Deklaracja parametru czasu Å¼ycia po <code>impl</code> i jego uÅ¼ycie po nazwie typu sÄ… wymagane, ale ze wzglÄ™du na pierwszÄ… zasadÄ™ elizji, nie musimy adnotowaÄ‡ czasu Å¼ycia referencji do <code>self</code>.</p>
<p>Oto przykÅ‚ad, w ktÃ³rym ma zastosowanie trzecia zasada elizji czasu Å¼ycia:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn level(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!("Attention please: {announcement}");
        self.part
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from("Call me Ishmael. Some years ago...");
</span><span class="boring">    let first_sentence = novel.split('.').next().unwrap();
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre>
<p>IstniejÄ… dwa wejÅ›ciowe czasy Å¼ycia, wiÄ™c Rust stosuje pierwszÄ… zasadÄ™ elizji czasu Å¼ycia i nadaje zarÃ³wno <code>&amp;self</code>, jak i <code>announcement</code> ich wÅ‚asne czasy Å¼ycia. NastÄ™pnie, poniewaÅ¼ jeden z parametrÃ³w to <code>&amp;self</code>, typ zwracany otrzymuje czas Å¼ycia <code>&amp;self</code>, a wszystkie czasy Å¼ycia zostaÅ‚y uwzglÄ™dnione.</p>
<h3 id="statyczny-czas-Å¼ycia"><a class="header" href="#statyczny-czas-Å¼ycia">Statyczny czas Å¼ycia</a></h3>
<p>Jeden specjalny czas Å¼ycia, o ktÃ³rym musimy porozmawiaÄ‡, to <code>'static</code>, ktÃ³ry oznacza, Å¼e dotkniÄ™ta referencja <em>moÅ¼e</em> Å¼yÄ‡ przez caÅ‚y czas trwania programu. Wszystkie literaÅ‚y ciÄ…gÃ³w znakÃ³w majÄ… czas Å¼ycia <code>'static</code>, ktÃ³ry moÅ¼emy adnotowaÄ‡ w nastÄ™pujÄ…cy sposÃ³b:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = "I have a static lifetime.";
<span class="boring">}</span></code></pre>
<p>Tekst tego ciÄ…gu znakÃ³w jest przechowywany bezpoÅ›rednio w pliku binarnym programu, ktÃ³ry jest zawsze dostÄ™pny. Dlatego czas Å¼ycia wszystkich literaÅ‚Ã³w ciÄ…gÃ³w znakÃ³w jest <code>'static</code>.</p>
<p>MoÅ¼esz zobaczyÄ‡ sugestie w komunikatach o bÅ‚Ä™dach, aby uÅ¼yÄ‡ czasu Å¼ycia <code>'static</code>. Ale zanim okreÅ›lisz <code>'static</code> jako czas Å¼ycia dla referencji, zastanÃ³w siÄ™, czy referencja, ktÃ³rÄ… masz, faktycznie Å¼yje przez caÅ‚y czas trwania twojego programu i czy tego chcesz. Przez wiÄ™kszoÅ›Ä‡ czasu komunikat o bÅ‚Ä™dzie sugerujÄ…cy czas Å¼ycia <code>'static</code> wynika z prÃ³by utworzenia wiszÄ…cej referencji lub niezgodnoÅ›ci dostÄ™pnych czasÃ³w Å¼ycia. W takich przypadkach rozwiÄ…zaniem jest naprawienie tych problemÃ³w, a nie okreÅ›lanie czasu Å¼ycia <code>'static</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="generic-type-parameters-trait-bounds-and-lifetimes-together"></a></p>
<h2 id="ogÃ³lne-parametry-typÃ³w-ograniczenia-cech-i-czasy-Å¼ycia"><a class="header" href="#ogÃ³lne-parametry-typÃ³w-ograniczenia-cech-i-czasy-Å¼ycia">OgÃ³lne parametry typÃ³w, ograniczenia cech i czasy Å¼ycia</a></h2>
<p>Przyjrzyjmy siÄ™ krÃ³tko skÅ‚adni okreÅ›lania ogÃ³lnych parametrÃ³w typÃ³w, ograniczeÅ„ cech i czasÃ³w Å¼ycia w jednej funkcji!</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest_with_an_announcement(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        "Today is someone's birthday!",
</span><span class="boring">    );
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!("Announcement! {ann}");
    if x.len() &gt; y.len() { x } else { y }
}</code></pre>
<p>To funkcja <code>longest</code> z Listingu 10-21, ktÃ³ra zwraca dÅ‚uÅ¼szy z dwÃ³ch wycinkÃ³w ciÄ…gÃ³w znakÃ³w. Ale teraz ma dodatkowy parametr o nazwie <code>ann</code> typu ogÃ³lnego <code>T</code>, ktÃ³ry moÅ¼e byÄ‡ wypeÅ‚niony dowolnym typem implementujÄ…cym cechÄ™ <code>Display</code>, zgodnie z klauzulÄ… <code>where</code>. Ten dodatkowy parametr zostanie wypisany za pomocÄ… <code>{}</code>, dlatego konieczne jest ograniczenie cechy <code>Display</code>. PoniewaÅ¼ czasy Å¼ycia sÄ… rodzajem generykÃ³w, deklaracje parametru czasu Å¼ycia <code>'a</code> i ogÃ³lnego parametru typu <code>T</code> znajdujÄ… siÄ™ na tej samej liÅ›cie w nawiasach kÄ…towych po nazwie funkcji.</p>
<h2 id="podsumowanie-9"><a class="header" href="#podsumowanie-9">Podsumowanie</a></h2>
<p>W tym rozdziale omÃ³wiliÅ›my wiele zagadnieÅ„! Teraz, gdy znasz ogÃ³lne parametry typÃ³w, cechy i ograniczenia cech oraz ogÃ³lne parametry czasÃ³w Å¼ycia, jesteÅ› gotowy do pisania kodu bez powtÃ³rzeÅ„, ktÃ³ry dziaÅ‚a w wielu rÃ³Å¼nych sytuacjach. OgÃ³lne parametry typÃ³w pozwalajÄ… zastosowaÄ‡ kod do rÃ³Å¼nych typÃ³w. Cechy i ograniczenia cech zapewniajÄ…, Å¼e mimo iÅ¼ typy sÄ… ogÃ³lne, bÄ™dÄ… miaÅ‚y zachowanie, ktÃ³rego kod potrzebuje. NauczyÅ‚eÅ› siÄ™, jak uÅ¼ywaÄ‡ adnotacji czasÃ³w Å¼ycia, aby zapewniÄ‡, Å¼e ten elastyczny kod nie bÄ™dzie miaÅ‚ Å¼adnych wiszÄ…cych referencji. I caÅ‚a ta analiza odbywa siÄ™ w czasie kompilacji, co nie wpÅ‚ywa na wydajnoÅ›Ä‡ w czasie wykonania!</p>
<p>Wierz lub nie, ale jest znacznie wiÄ™cej do nauczenia siÄ™ na tematy, ktÃ³re omÃ³wiliÅ›my w tym rozdziale: RozdziaÅ‚ 18 omawia obiekty cech, ktÃ³re sÄ… innym sposobem uÅ¼ywania cech. IstniejÄ… rÃ³wnieÅ¼ bardziej zÅ‚oÅ¼one scenariusze zwiÄ…zane z adnotacjami czasÃ³w Å¼ycia, ktÃ³re bÄ™dÄ… ci potrzebne tylko w bardzo zaawansowanych przypadkach; w ich przypadku powinieneÅ› przeczytaÄ‡ <a href="../reference/trait-bounds.html">Rust Reference</a>. Ale nastÄ™pnie dowiesz siÄ™, jak pisaÄ‡ testy w Rust, aby upewniÄ‡ siÄ™, Å¼e twÃ³j kod dziaÅ‚a tak, jak powinien.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pisanie-automatycznych-testÃ³w"><a class="header" href="#pisanie-automatycznych-testÃ³w">Pisanie automatycznych testÃ³w</a></h1>
<p>W swoim eseju â€Skromny programistaâ€ z 1972 roku, Edsger W. Dijkstra powiedziaÅ‚, Å¼e â€testowanie programu moÅ¼e byÄ‡ bardzo efektywnym sposobem na wykazanie obecnoÅ›ci bÅ‚Ä™dÃ³w, ale jest beznadziejnie niewystarczajÄ…ce do wykazania ich brakuâ€. To nie znaczy, Å¼e nie powinniÅ›my prÃ³bowaÄ‡ testowaÄ‡ jak najwiÄ™cej!</p>
<p><em>PoprawnoÅ›Ä‡</em> w naszych programach to zakres, w jakim nasz kod robi to, co zamierzamy. Rust zostaÅ‚ zaprojektowany z duÅ¼Ä… troskÄ… o poprawnoÅ›Ä‡ programÃ³w, ale poprawnoÅ›Ä‡ jest zÅ‚oÅ¼ona i nieÅ‚atwa do udowodnienia. System typÃ³w Rust bierze na siebie duÅ¼Ä… czÄ™Å›Ä‡ tego ciÄ™Å¼aru, ale system typÃ³w nie jest w stanie wyÅ‚apaÄ‡ wszystkiego. W zwiÄ…zku z tym Rust zawiera wsparcie dla pisania automatycznych testÃ³w oprogramowania.</p>
<p>Powiedzmy, Å¼e piszemy funkcjÄ™ <code>add_two</code>, ktÃ³ra dodaje 2 do dowolnej liczby przekazanej do niej. Sygnatura tej funkcji akceptuje liczbÄ™ caÅ‚kowitÄ… jako parametr i zwraca liczbÄ™ caÅ‚kowitÄ… jako wynik. Kiedy implementujemy i kompilujemy tÄ™ funkcjÄ™, Rust wykonuje wszystkie sprawdzanie typÃ³w i sprawdzanie poÅ¼yczeÅ„, o ktÃ³rych uczyÅ‚eÅ› siÄ™ do tej pory, aby zapewniÄ‡, Å¼e na przykÅ‚ad nie przekazujemy wartoÅ›ci <code>String</code> ani nieprawidÅ‚owej referencji do tej funkcji. Ale Rust <em>nie</em> jest w stanie sprawdziÄ‡, czy ta funkcja zrobi dokÅ‚adnie to, co zamierzamy, czyli zwrÃ³ci parametr plus 2, a nie na przykÅ‚ad parametr plus 10 lub parametr minus 50! WÅ‚aÅ›nie tutaj wchodzÄ… testy.</p>
<p>MoÅ¼emy pisaÄ‡ testy, ktÃ³re potwierdzajÄ…, na przykÅ‚ad, Å¼e gdy przekazujemy <code>3</code> do funkcji <code>add_two</code>, zwrÃ³cona wartoÅ›Ä‡ to <code>5</code>. MoÅ¼emy uruchamiaÄ‡ te testy za kaÅ¼dym razem, gdy wprowadzamy zmiany w naszym kodzie, aby upewniÄ‡ siÄ™, Å¼e istniejÄ…ce prawidÅ‚owe zachowanie nie ulegÅ‚o zmianie.</p>
<p>Testowanie to zÅ‚oÅ¼ona umiejÄ™tnoÅ›Ä‡: ChociaÅ¼ w jednym rozdziale nie moÅ¼emy omÃ³wiÄ‡ kaÅ¼dego szczegÃ³Å‚u dotyczÄ…cego tego, jak pisaÄ‡ dobre testy, w tym rozdziale omÃ³wimy mechanikÄ™ funkcji testowych Rust. Porozmawiamy o dostÄ™pnych adnotacjach i makrach podczas pisania testÃ³w, domyÅ›lnym zachowaniu i opcjach dostÄ™pnych do uruchamiania testÃ³w oraz o tym, jak organizowaÄ‡ testy w testy jednostkowe i testy integracyjne.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="jak-pisaÄ‡-testy-1"><a href="#jak-pisaÄ‡-testy-1" class="header">Jak pisaÄ‡ testy</a></h1>
<h2 id="jak-pisaÄ‡-testy"><a class="header" href="#jak-pisaÄ‡-testy">Jak pisaÄ‡ testy</a></h2>
<p><em>Testy</em> to funkcje Rusta, ktÃ³re weryfikujÄ…, czy kod poza testami dziaÅ‚a zgodnie
z oczekiwaniami. CiaÅ‚a funkcji testowych zazwyczaj wykonujÄ… trzy dziaÅ‚ania:</p>
<ul>
<li>Przygotowanie potrzebnych danych lub stanu.</li>
<li>Uruchomienie kodu, ktÃ³ry chcesz przetestowaÄ‡.</li>
<li>Sprawdzenie, czy wyniki sÄ… zgodne z oczekiwaniami.</li>
</ul>
<p>Przyjrzyjmy siÄ™ funkcjom, ktÃ³re Rust dostarcza specjalnie do pisania testÃ³w
wykonujÄ…cych te dziaÅ‚ania, w tym atrybutowi <code>test</code>, kilku makrom i atrybutowi
<code>should_panic</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="the-anatomy-of-a-test-function"></a></p>
<h3 id="struktura-funkcji-testowych"><a class="header" href="#struktura-funkcji-testowych">Struktura funkcji testowych</a></h3>
<p>NajproÅ›ciej rzecz ujmujÄ…c, test w Rust to funkcja opatrzona atrybutem <code>test</code>.
Atrybuty to metadane dotyczÄ…ce fragmentÃ³w kodu Rust; jednym z przykÅ‚adÃ³w jest
atrybut <code>derive</code>, ktÃ³rego uÅ¼ywaliÅ›my ze strukturami w Rozdziale 5. Aby
zmieniÄ‡ funkcjÄ™ w funkcjÄ™ testowÄ…, dodaj <code>#[test]</code> w linii przed <code>fn</code>. Kiedy
uruchamiasz testy za pomocÄ… polecenia <code>cargo test</code>, Rust buduje binarny
runner testÃ³w, ktÃ³ry uruchamia adnotowane funkcje i raportuje, czy kaÅ¼da
funkcja testowa przeszÅ‚a, czy nie powiodÅ‚a siÄ™.</p>
<p>IlekroÄ‡ tworzymy nowy projekt biblioteczny za pomocÄ… Cargo, automatycznie
generowany jest dla nas moduÅ‚ testowy z funkcjÄ… testowÄ…. ModuÅ‚ ten
udostÄ™pnia szablon do pisania testÃ³w, dziÄ™ki czemu nie musisz za kaÅ¼dym
razem, gdy zaczynasz nowy projekt, szukaÄ‡ dokÅ‚adnej struktury i skÅ‚adni. MoÅ¼esz
dodaÄ‡ tyle dodatkowych funkcji testowych i moduÅ‚Ã³w testowych, ile tylko
chcesz!</p>
<p>Przeanalizujemy niektÃ³re aspekty dziaÅ‚ania testÃ³w, eksperymentujÄ…c z
szablonowym testem, zanim faktycznie przetestujemy jakikolwiek kod. NastÄ™pnie
napiszemy kilka rzeczywistych testÃ³w, ktÃ³re wywoÅ‚ajÄ… napisany przez nas kod i
sprawdzÄ…, czy jego zachowanie jest prawidÅ‚owe.</p>
<p>StwÃ³rzmy nowy projekt biblioteczny o nazwie <code>adder</code>, ktÃ³ry bÄ™dzie dodawaÅ‚
dwie liczby:</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>ZawartoÅ›Ä‡ pliku <em>src/lib.rs</em> w Twojej bibliotece <code>adder</code> powinna wyglÄ…daÄ‡ jak
Listing 11-1.</p>
<figure class="listing" id="listing-11-1">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new listing-11-01 --lib --name adder
cd listing-11-01
echo "$ cargo test" > output.txt
RUSTFLAGS="-A unused_variables -A dead_code" RUST_TEST_THREADS=1 cargo test >> output.txt 2>&1
git diff output.txt # commit any relevant changes; discard irrelevant ones
cd ../../..
-->
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<figcaption><a href="#listing-11-1">Listing 11-1</a>: Kod wygenerowany automatycznie przez <code>cargo new</code></figcaption>
</figure>
<p>Plik zaczyna siÄ™ od przykÅ‚adowej funkcji <code>add</code>, abyÅ›my mieli coÅ› do
testowania.</p>
<p>Na razie skupmy siÄ™ wyÅ‚Ä…cznie na funkcji <code>it_works</code>. ZwrÃ³Ä‡ uwagÄ™ na adnotacjÄ™
<code>#[test]</code>: Ten atrybut wskazuje, Å¼e jest to funkcja testowa, wiÄ™c
program uruchamiajÄ…cy testy wie, aby traktowaÄ‡ tÄ™ funkcjÄ™ jako test. MoÅ¼emy
rÃ³wnieÅ¼ mieÄ‡ funkcje nietestowe w module <code>tests</code>, aby pomÃ³c w
konfigurowaniu typowych scenariuszy lub wykonywaniu typowych operacji, wiÄ™c
zawsze musimy wskazywaÄ‡, ktÃ³re funkcje sÄ… testami.</p>
<p>PrzykÅ‚adowe ciaÅ‚o funkcji uÅ¼ywa makra <code>assert_eq!</code>, aby sprawdziÄ‡, czy
<code>result</code>, ktÃ³re zawiera wynik wywoÅ‚ania <code>add</code> z argumentami 2 i 2, jest rÃ³wne
4. To twierdzenie sÅ‚uÅ¼y jako przykÅ‚ad formatu typowego testu. Uruchommy je,
aby zobaczyÄ‡, Å¼e ten test przechodzi.</p>
<p>Polecenie <code>cargo test</code> uruchamia wszystkie testy w naszym projekcie, jak
pokazano w Listingu 11-2.</p>
<figure class="listing" id="listing-11-2">
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (target/debug/deps/adder-01ad14159ff659ab)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<figcaption><a href="#listing-11-2">Listing 11-2</a>: Wynik uruchomienia automatycznie wygenerowanego testu</figcaption>
</figure>
<p>Cargo skompilowaÅ‚ i uruchomiÅ‚ test. Widzimy liniÄ™ <code>running 1 test</code>. NastÄ™pna
linia pokazuje nazwÄ™ wygenerowanej funkcji testowej, nazwanej
<code>tests::it_works</code>, oraz Å¼e wynik uruchomienia tego testu to <code>ok</code>. OgÃ³lne
podsumowanie <code>test result: ok.</code> oznacza, Å¼e wszystkie testy przeszÅ‚y, a czÄ™Å›Ä‡
<code>1 passed; 0 failed</code> sumuje liczbÄ™ testÃ³w, ktÃ³re przeszÅ‚y lub nie powiodÅ‚y siÄ™.</p>
<p>MoÅ¼na oznaczyÄ‡ test jako zignorowany, aby nie byÅ‚ uruchamiany w konkretnej
instancji; omÃ³wimy to w sekcji <a href="#ignoring-tests-unless-specifically-requested">â€Ignorowanie testÃ³w, chyba Å¼e sÄ…
specjalnie Å¼Ä…daneâ€</a><!-- ignore --> pÃ³Åºniej w tym rozdziale. PoniewaÅ¼
tego tutaj nie zrobiliÅ›my, podsumowanie pokazuje <code>0 ignored</code>. MoÅ¼emy rÃ³wnieÅ¼
przekazaÄ‡ argument do polecenia <code>cargo test</code>, aby uruchomiÄ‡ tylko te testy,
ktÃ³rych nazwa pasuje do ciÄ…gu znakÃ³w; nazywa siÄ™ to <em>filtrowaniem</em>,
i omÃ³wimy to w sekcji <a href="#running-a-subset-of-tests-by-name">â€Uruchamianie podzbioru testÃ³w wedÅ‚ug
nazwyâ€</a><!-- ignore -->. Tutaj nie filtrowaliÅ›my uruchamianych testÃ³w,
wiÄ™c na koÅ„cu podsumowania wyÅ›wietla siÄ™ <code>0 filtered out</code>.</p>
<p>Statystyka <code>0 measured</code> dotyczy testÃ³w wydajnoÅ›ciowych, ktÃ³re mierzÄ…
wydajnoÅ›Ä‡. Testy wydajnoÅ›ciowe, w chwili pisania tego tekstu, sÄ… dostÄ™pne tylko
w nightly Rust. WiÄ™cej informacji znajdziesz w <a href="../unstable-book/library-features/test.html">dokumentacji testÃ³w
wydajnoÅ›ciowych</a>.</p>
<p>NastÄ™pna czÄ™Å›Ä‡ danych wyjÅ›ciowych testu, zaczynajÄ…ca siÄ™ od <code>Doc-tests adder</code>,
dotyczy wynikÃ³w wszelkich testÃ³w dokumentacyjnych. Nie mamy jeszcze Å¼adnych
testÃ³w dokumentacyjnych, ale Rust moÅ¼e kompilowaÄ‡ wszelkie przykÅ‚ady kodu,
ktÃ³re pojawiajÄ… siÄ™ w naszej dokumentacji API. Ta funkcja pomaga utrzymaÄ‡
dokumentacjÄ™ i kod w synchronizacji! OmÃ³wimy, jak pisaÄ‡ testy dokumentacyjne w
sekcji <a href="#documentation-comments-as-tests">â€Komentarze dokumentacyjne jako testyâ€</a><!-- ignore -->
RozdziaÅ‚u 14. Na razie zignorujemy dane wyjÅ›ciowe <code>Doc-tests</code>.</p>
<p>Zacznijmy dostosowywaÄ‡ test do naszych wÅ‚asnych potrzeb. Najpierw zmieÅ„ nazwÄ™
funkcji <code>it_works</code> na innÄ…, takÄ… jak <code>exploration</code>, w ten sposÃ³b:</p>
<p><span class="filename">Nazwa pliku: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>NastÄ™pnie ponownie uruchom <code>cargo test</code>. Wynik pokazuje teraz <code>exploration</code>
zamiast <code>it_works</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Teraz dodamy kolejny test, ale tym razem stworzymy test, ktÃ³ry zawiedzie! Testy
zawodzÄ…, gdy coÅ› w funkcji testowej panikuje. KaÅ¼dy test jest uruchamiany w
nowym wÄ…tku, a gdy gÅ‚Ã³wny wÄ…tek widzi, Å¼e wÄ…tek testowy umarÅ‚, test jest
oznaczany jako nieudany. W Rozdziale 9 rozmawialiÅ›my o tym, Å¼e najprostszym
sposobem na panikÄ™ jest wywoÅ‚anie makra <code>panic!</code>. WprowadÅº nowy test jako
funkcjÄ™ o nazwie <code>another</code>, tak aby TwÃ³j plik <em>src/lib.rs</em> wyglÄ…daÅ‚ jak Listing
11-3.</p>
<figure class="listing" id="listing-11-3">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust panics noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    fn another() {
        panic!("Make this test fail");
    }
}</code></pre>
<figcaption><a href="#listing-11-3">Listing 11-3</a>: Dodawanie drugiego testu, ktÃ³ry zakoÅ„czy siÄ™ niepowodzeniem, poniewaÅ¼ wywoÅ‚ujemy makro <code>panic!</code></figcaption>
</figure>
<p>Uruchom testy ponownie za pomocÄ… <code>cargo test</code>. Wynik powinien wyglÄ…daÄ‡ jak
Listing 11-4, ktÃ³ry pokazuje, Å¼e nasz test <code>exploration</code> przeszedÅ‚, a <code>another</code>
zakoÅ„czyÅ‚ siÄ™ niepowodzeniem.</p>
<figure class="listing" id="listing-11-4">
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----

thread 'tests::another' panicked at src/lib.rs:17:9:
Make this test fail
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<figcaption><a href="#listing-11-4">Listing 11-4</a>: Wyniki testÃ³w, gdy jeden test przechodzi, a jeden koÅ„czy siÄ™ niepowodzeniem</figcaption>
</figure>
<!-- manual-regeneration
rg panicked listings/ch11-writing-automated-tests/listing-11-03/output.txt
check the line number of the panic matches the line number in the following paragraph
 -->
<p>Zamiast <code>ok</code>, linia <code>test tests::another</code> pokazuje <code>FAILED</code>. PojawiajÄ… siÄ™
dwie nowe sekcje miÄ™dzy indywidualnymi wynikami a podsumowaniem: Pierwsza
wyÅ›wietla szczegÃ³Å‚owy powÃ³d kaÅ¼dego niepowodzenia testu. W tym przypadku
dostajemy szczegÃ³Å‚y, Å¼e <code>tests::another</code> zawiÃ³dÅ‚, poniewaÅ¼ spanikowaÅ‚ z
wiadomoÅ›ciÄ… <code>Make this test fail</code> w linii 17 w pliku <em>src/lib.rs</em>. NastÄ™pna
sekcja zawiera tylko nazwy wszystkich nieudanych testÃ³w, co jest przydatne,
gdy jest duÅ¼o testÃ³w i duÅ¼o szczegÃ³Å‚owych danych wyjÅ›ciowych nieudanych
testÃ³w. MoÅ¼emy uÅ¼yÄ‡ nazwy nieudanego testu, aby uruchomiÄ‡ tylko ten test,
aby Å‚atwiej go debugowaÄ‡; wiÄ™cej na temat sposobÃ³w uruchamiania testÃ³w
opowiemy w sekcji <a href="#controlling-how-tests-are-run">â€Kontrolowanie sposobu uruchamiania
testÃ³wâ€</a><!-- ignore -->.</p>
<p>Na koniec wyÅ›wietla siÄ™ linia podsumowujÄ…ca: OgÃ³lnie, nasz wynik testÃ³w to
<code>FAILED</code>. Jeden test przeszedÅ‚, a jeden zawiÃ³dÅ‚.</p>
<p>Teraz, gdy widziaÅ‚eÅ›, jak wyglÄ…dajÄ… wyniki testÃ³w w rÃ³Å¼nych scenariuszach,
przyjrzyjmy siÄ™ innym makrom niÅ¼ <code>panic!</code>, ktÃ³re sÄ… przydatne w testach.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="checking-results-with-the-assert-macro"></a></p>
<h3 id="sprawdzanie-wynikÃ³w-za-pomocÄ…-makra-assert"><a class="header" href="#sprawdzanie-wynikÃ³w-za-pomocÄ…-makra-assert">Sprawdzanie wynikÃ³w za pomocÄ… makra <code>assert!</code></a></h3>
<p>Makro <code>assert!</code>, dostarczane przez standardowÄ… bibliotekÄ™, jest przydatne,
gdy chcesz upewniÄ‡ siÄ™, Å¼e jakiÅ› warunek w teÅ›cie ocenia siÄ™ jako <code>true</code>.
Podajemy makru <code>assert!</code> argument, ktÃ³ry ocenia siÄ™ do wartoÅ›ci boolowskiej.
JeÅ›li wartoÅ›Ä‡ jest <code>true</code>, nic siÄ™ nie dzieje i test przechodzi. JeÅ›li wartoÅ›Ä‡
jest <code>false</code>, makro <code>assert!</code> wywoÅ‚uje <code>panic!</code>, aby spowodowaÄ‡ niepowodzenie
testu. UÅ¼ycie makra <code>assert!</code> pomaga nam sprawdziÄ‡, czy nasz kod dziaÅ‚a w
sposÃ³b, w jaki zamierzamy.</p>
<p>W Rozdziale 5, Listing 5-15, uÅ¼yliÅ›my struktury <code>Rectangle</code> i metody
<code>can_hold</code>, ktÃ³re sÄ… powtÃ³rzone tutaj w Listingu 11-5. UmieÅ›Ä‡my ten kod w
pliku <em>src/lib.rs</em>, a nastÄ™pnie napiszmy dla niego kilka testÃ³w za pomocÄ…
makra <code>assert!</code>.</p>
<figure class="listing" id="listing-11-5">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}</code></pre>
<figcaption><a href="#listing-11-5">Listing 11-5</a>: Struktura <code>Rectangle</code> i jej metoda <code>can_hold</code> z RozdziaÅ‚u 5</figcaption>
</figure>
<p>Metoda <code>can_hold</code> zwraca wartoÅ›Ä‡ boolowskÄ…, co oznacza, Å¼e jest idealnym
przypadkiem uÅ¼ycia dla makra <code>assert!</code>. W Listingu 11-6 piszemy test, ktÃ³ry
wykorzystuje metodÄ™ <code>can_hold</code>, tworzÄ…c instancjÄ™ <code>Rectangle</code> o szerokoÅ›ci 8
i wysokoÅ›ci 7 i twierdzÄ…c, Å¼e moÅ¼e ona pomieÅ›ciÄ‡ innÄ… instancjÄ™ <code>Rectangle</code>
o szerokoÅ›ci 5 i wysokoÅ›ci 1.</p>
<figure class="listing" id="listing-11-6">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}</code></pre>
<figcaption><a href="#listing-11-6">Listing 11-6</a>: Test dla <code>can_hold</code>, ktÃ³ry sprawdza, czy wiÄ™kszy prostokÄ…t moÅ¼e rzeczywiÅ›cie pomieÅ›ciÄ‡ mniejszy prostokÄ…t</figcaption>
</figure>
<p>ZwrÃ³Ä‡ uwagÄ™ na liniÄ™ <code>use super::*;</code> w module <code>tests</code>. ModuÅ‚ <code>tests</code> to
zwykÅ‚y moduÅ‚, ktÃ³ry podlega zwykÅ‚ym zasadom widocznoÅ›ci, ktÃ³re omÃ³wiliÅ›my w
Rozdziale 7 w sekcji <a href="#Å›cieÅ¼ki-do-odwoÅ‚ywania-siÄ™-do-elementu-w-drzewie-moduÅ‚Ã³w-1">â€ÅšcieÅ¼ki do odwoÅ‚ywania siÄ™ do elementu w drzewie
moduÅ‚Ã³wâ€</a><!-- ignore -->.
PoniewaÅ¼ moduÅ‚ <code>tests</code> jest moduÅ‚em wewnÄ™trznym, musimy wprowadziÄ‡ kod poddawany
testom z moduÅ‚u zewnÄ™trznego do zakresu moduÅ‚u wewnÄ™trznego. UÅ¼ywamy tutaj
globa, wiÄ™c wszystko, co zdefiniujemy w module zewnÄ™trznym, jest dostÄ™pne dla
tego moduÅ‚u <code>tests</code>.</p>
<p>NazwaliÅ›my nasz test <code>larger_can_hold_smaller</code> i utworzyliÅ›my dwie
instancje <code>Rectangle</code>, ktÃ³rych potrzebujemy. NastÄ™pnie wywoÅ‚aliÅ›my makro
<code>assert!</code> i przekazaliÅ›my mu wynik wywoÅ‚ania <code>larger.can_hold(&amp;smaller)</code>.
To wyraÅ¼enie powinno zwrÃ³ciÄ‡ <code>true</code>, wiÄ™c nasz test powinien przejÅ›Ä‡.
SprawdÅºmy!</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Przechodzi! Dodajmy kolejny test, tym razem sprawdzajÄ…cy, czy mniejszy
prostokÄ…t nie moÅ¼e pomieÅ›ciÄ‡ wiÄ™kszego prostokÄ…ta:</p>
<p><span class="filename">Nazwa pliku: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}</code></pre>
<p>PoniewaÅ¼ poprawny wynik funkcji <code>can_hold</code> w tym przypadku to <code>false</code>, musimy
zanegowaÄ‡ ten wynik, zanim przekaÅ¼emy go do makra <code>assert!</code>. W rezultacie nasz
test przejdzie, jeÅ›li <code>can_hold</code> zwrÃ³ci <code>false</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Dwa testy, ktÃ³re przeszÅ‚y! Zobaczmy teraz, co siÄ™ stanie z wynikami naszych
testÃ³w, gdy wprowadzimy bÅ‚Ä…d do naszego kodu. Zmienimy implementacjÄ™ metody
<code>can_hold</code>, zastÄ™pujÄ…c znak â€wiÄ™ksze niÅ¼â€ (<code>&gt;</code>) znakiem â€mniejsze niÅ¼â€ (<code>&lt;</code>),
gdy porÃ³wnuje szerokoÅ›ci:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Uruchomienie testÃ³w teraz daje nastÄ™pujÄ…ce wyniki:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----

thread 'tests::larger_can_hold_smaller' panicked at src/lib.rs:28:9:
assertion failed: larger.can_hold(&amp;smaller)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Nasze testy wykryÅ‚y bÅ‚Ä…d! PoniewaÅ¼ <code>larger.width</code> wynosi <code>8</code>, a <code>smaller.width</code>
wynosi <code>5</code>, porÃ³wnanie szerokoÅ›ci w <code>can_hold</code> zwraca teraz <code>false</code>: 8 nie jest
mniejsze niÅ¼ 5.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="testing-equality-with-the-assert_eq-and-assert_ne-macros"></a></p>
<h3 id="testowanie-rÃ³wnoÅ›ci-za-pomocÄ…-makr-assert_eq-i-assert_ne"><a class="header" href="#testowanie-rÃ³wnoÅ›ci-za-pomocÄ…-makr-assert_eq-i-assert_ne">Testowanie rÃ³wnoÅ›ci za pomocÄ… makr <code>assert_eq!</code> i <code>assert_ne!</code></a></h3>
<p>Powszechnym sposobem weryfikacji funkcjonalnoÅ›ci jest testowanie rÃ³wnoÅ›ci miÄ™dzy
wynikiem kodu poddanego testom a wartoÅ›ciÄ…, ktÃ³rÄ… kod powinien zwrÃ³ciÄ‡. MoÅ¼na
to zrobiÄ‡, uÅ¼ywajÄ…c makra <code>assert!</code> i przekazujÄ…c mu wyraÅ¼enie uÅ¼ywajÄ…ce
operatora <code>==</code>. Jest to jednak tak powszechny test, Å¼e standardowa biblioteka
dostarcza parÄ™ makr â€” <code>assert_eq!</code> i <code>assert_ne!</code> â€” aby wygodniej
wykonaÄ‡ ten test. Makra te porÃ³wnujÄ… dwa argumenty pod kÄ…tem rÃ³wnoÅ›ci lub
nierÃ³wnoÅ›ci. WyÅ›wietlajÄ… rÃ³wnieÅ¼ dwie wartoÅ›ci, jeÅ›li asercja zawiedzie, co
uÅ‚atwia zrozumienie, <em>dlaczego</em> test zawiÃ³dÅ‚; z kolei makro <code>assert!</code>
wskazuje tylko, Å¼e otrzymaÅ‚o wartoÅ›Ä‡ <code>false</code> dla wyraÅ¼enia <code>==</code>, nie
wyÅ›wietlajÄ…c wartoÅ›ci, ktÃ³re doprowadziÅ‚y do wartoÅ›ci <code>false</code>.</p>
<p>W Listingu 11-7 piszemy funkcjÄ™ o nazwie <code>add_two</code>, ktÃ³ra dodaje <code>2</code> do swego
parametru, a nastÄ™pnie testujemy tÄ™ funkcjÄ™ za pomocÄ… makra <code>assert_eq!</code>.</p>
<figure class="listing" id="listing-11-7">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub fn add_two(a: u64) -&gt; u64 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }
}</code></pre>
<figcaption><a href="#listing-11-7">Listing 11-7</a>: Testowanie funkcji <code>add_two</code> za pomocÄ… makra <code>assert_eq!</code></figcaption>
</figure>
<p>SprawdÅºmy, czy przechodzi!</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Tworzymy zmiennÄ… o nazwie <code>result</code>, ktÃ³ra przechowuje wynik wywoÅ‚ania
<code>add_two(2)</code>. NastÄ™pnie przekazujemy <code>result</code> i <code>4</code> jako argumenty do makra
<code>assert_eq!</code>. Linia wyjÅ›ciowa dla tego testu to <code>test tests::it_adds_two ... ok</code>,
a tekst <code>ok</code> wskazuje, Å¼e nasz test przeszedÅ‚!</p>
<p>WprowadÅºmy bÅ‚Ä…d do naszego kodu, aby zobaczyÄ‡, jak wyglÄ…da <code>assert_eq!</code>, gdy
zawodzi. ZmieÅ„ implementacjÄ™ funkcji <code>add_two</code>, aby zamiast tego dodawaÅ‚a <code>3</code>:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn add_two(a: u64) -&gt; u64 {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        let result = add_two(2);
</span><span class="boring">        assert_eq!(result, 4);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Uruchom testy ponownie:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----

thread 'tests::it_adds_two' panicked at src/lib.rs:12:9:
assertion `left == right` failed
  left: 5
 right: 4
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Nasz test wykryÅ‚ bÅ‚Ä…d! Test <code>tests::it_adds_two</code> nie powiÃ³dÅ‚ siÄ™, a komunikat
informuje nas, Å¼e asercja, ktÃ³ra zawiodÅ‚a, to <code>left == right</code> oraz jakie sÄ…
wartoÅ›ci <code>left</code> i <code>right</code>. Ten komunikat pomaga nam rozpoczÄ…Ä‡ debugowanie:
argument <code>left</code>, gdzie mieliÅ›my wynik wywoÅ‚ania <code>add_two(2)</code>, wynosiÅ‚ <code>5</code>, ale
argument <code>right</code> wynosiÅ‚ <code>4</code>. MoÅ¼na sobie wyobraziÄ‡, Å¼e byÅ‚oby to szczegÃ³lnie
pomocne, gdybyÅ›my mieli wiele testÃ³w.</p>
<p>ZauwaÅ¼, Å¼e w niektÃ³rych jÄ™zykach i frameworkach testowych parametry funkcji
asercji rÃ³wnoÅ›ci nazywane sÄ… <code>expected</code> i <code>actual</code>, a kolejnoÅ›Ä‡, w jakiej
okreÅ›lamy argumenty, ma znaczenie. Jednak w Rust nazywajÄ… siÄ™ <code>left</code> i
<code>right</code>, a kolejnoÅ›Ä‡, w jakiej okreÅ›lamy wartoÅ›Ä‡, ktÃ³rej oczekujemy, i
wartoÅ›Ä‡, ktÃ³rÄ… produkuje kod, nie ma znaczenia. MoglibyÅ›my napisaÄ‡ asercjÄ™
w tym teÅ›cie jako <code>assert_eq!(4, result)</code>, co spowodowaÅ‚oby ten sam komunikat
o bÅ‚Ä™dzie, ktÃ³ry wyÅ›wietla <code>assertion `left == right` failed</code>.</p>
<p>Makro <code>assert_ne!</code> przejdzie, jeÅ›li dwie podane mu wartoÅ›ci nie sÄ… sobie rÃ³wne,
a zawiedzie, jeÅ›li sÄ… rÃ³wne. To makro jest najbardziej przydatne w przypadkach,
gdy nie jesteÅ›my pewni, jaka <em>bÄ™dzie</em> wartoÅ›Ä‡, ale wiemy, jaka wartoÅ›Ä‡
zdecydowanie <em>nie powinna</em> byÄ‡. Na przykÅ‚ad, jeÅ›li testujemy funkcjÄ™, ktÃ³ra ma
gwarantowaÄ‡ zmianÄ™ jej danych wejÅ›ciowych w jakiÅ› sposÃ³b, ale sposÃ³b zmiany
danych wejÅ›ciowych zaleÅ¼y od dnia tygodnia, w ktÃ³rym uruchamiamy nasze testy,
najlepiej byÅ‚oby sprawdziÄ‡, czy wynik funkcji nie jest rÃ³wny danym
wejÅ›ciowym.</p>
<p>Pod powierzchniÄ…, makra <code>assert_eq!</code> i <code>assert_ne!</code> uÅ¼ywajÄ… odpowiednio
operatorÃ³w <code>==</code> i <code>!=</code>. Kiedy asercje zawiodÄ…, te makra wypisujÄ… swoje
argumenty za pomocÄ… formatowania debuggowania, co oznacza, Å¼e porÃ³wnywane
wartoÅ›ci muszÄ… implementowaÄ‡ cechy <code>PartialEq</code> i <code>Debug</code>. Wszystkie typy
prymitywne i wiÄ™kszoÅ›Ä‡ typÃ³w standardowej biblioteki implementujÄ… te cechy.
Dla struktur i wyliczeÅ„, ktÃ³re sam definiujesz, bÄ™dziesz musiaÅ‚ zaimplementowaÄ‡
<code>PartialEq</code>, aby sprawdziÄ‡ rÃ³wnoÅ›Ä‡ tych typÃ³w. BÄ™dziesz rÃ³wnieÅ¼ musiaÅ‚
zaimplementowaÄ‡ <code>Debug</code>, aby wyÅ›wietliÄ‡ wartoÅ›ci, gdy asercja zawiedzie.
PoniewaÅ¼ obie cechy sÄ… cechami, ktÃ³re moÅ¼na wyprowadziÄ‡, jak wspomniano w
Listingu 5-12 w Rozdziale 5, jest to zazwyczaj tak proste, jak dodanie
anotacji <code>#[derive(PartialEq, Debug)]</code> do definicji struktury lub wyliczenia.
WiÄ™cej szczegÃ³Å‚Ã³w na temat tych i innych cech, ktÃ³re moÅ¼na wyprowadziÄ‡,
znajdziesz w Dodatku C, <a href="#c---cechy-dziedziczne">â€Cechy, ktÃ³re moÅ¼na
wyprowadziÄ‡â€</a><!-- ignore -->.</p>
<h3 id="dodawanie-niestandardowych-komunikatÃ³w-o-bÅ‚Ä™dach"><a class="header" href="#dodawanie-niestandardowych-komunikatÃ³w-o-bÅ‚Ä™dach">Dodawanie niestandardowych komunikatÃ³w o bÅ‚Ä™dach</a></h3>
<p>MoÅ¼esz rÃ³wnieÅ¼ dodaÄ‡ niestandardowy komunikat do wydrukowania wraz z
komunikatem o bÅ‚Ä™dzie jako opcjonalne argumenty do makr <code>assert!</code>, <code>assert_eq!</code>
i <code>assert_ne!</code>. Wszelkie argumenty okreÅ›lone po wymaganych argumentach sÄ…
przekazywane do makra <code>format!</code> (omÃ³wionego w <a href="#concatenating-with--or-format">â€ÅÄ…czenie za pomocÄ… <code>+</code> lub
<code>format!</code>â€</a><!-- ignore --> w Rozdziale 8), wiÄ™c moÅ¼esz
przekazaÄ‡ ciÄ…g formatujÄ…cy, ktÃ³ry zawiera znaczniki <code>{}</code> i wartoÅ›ci, ktÃ³re majÄ…
byÄ‡ umieszczone w tych znacznikach. Niestandardowe komunikaty sÄ… przydatne do
dokumentowania, co oznacza asercja; gdy test zawiedzie, bÄ™dziesz miaÅ‚ lepsze
pojÄ™cie o tym, na czym polega problem z kodem.</p>
<p>Na przykÅ‚ad, powiedzmy, Å¼e mamy funkcjÄ™, ktÃ³ra wita ludzi po imieniu, i chcemy
przetestowaÄ‡, czy imiÄ™, ktÃ³re przekazujemy do funkcji, pojawia siÄ™ w danych
wyjÅ›ciowych:</p>
<p><span class="filename">Nazwa pliku: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    format!("Hello {name}!")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(result.contains("Carol"));
    }
}</code></pre>
<p>Wymagania dla tego programu nie zostaÅ‚y jeszcze uzgodnione, a my jesteÅ›my
raczej pewni, Å¼e tekst â€Helloâ€ na poczÄ…tku pozdrowienia zmieni siÄ™. PostanowiliÅ›my,
Å¼e nie chcemy aktualizowaÄ‡ testu, gdy wymagania siÄ™ zmieniÄ…, wiÄ™c zamiast
sprawdzaÄ‡ dokÅ‚adnÄ… rÃ³wnoÅ›Ä‡ z wartoÅ›ciÄ… zwrÃ³conÄ… przez funkcjÄ™ <code>greeting</code>,
bÄ™dziemy tylko sprawdzaÄ‡, czy wynik zawiera tekst parametru wejÅ›ciowego.</p>
<p>Teraz wprowadÅºmy bÅ‚Ä…d do tego kodu, zmieniajÄ…c <code>greeting</code> tak, aby wykluczaÅ‚o
<code>name</code>, aby zobaczyÄ‡, jak wyglÄ…da domyÅ›lne niepowodzenie testu:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    String::from("Hello!")
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting("Carol");
</span><span class="boring">        assert!(result.contains("Carol"));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Uruchomienie tego testu daje nastÄ™pujÄ…ce wyniki:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----

thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
assertion failed: result.contains("Carol")
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Ten wynik wskazuje tylko, Å¼e asercja nie powiodÅ‚a siÄ™ i w ktÃ³rej linii siÄ™
znajduje. Bardziej uÅ¼yteczny komunikat o bÅ‚Ä™dzie wyÅ›wietliÅ‚by wartoÅ›Ä‡ z funkcji
<code>greeting</code>. Dodajmy niestandardowy komunikat o bÅ‚Ä™dzie skÅ‚adajÄ…cy siÄ™ z ciÄ…gu
formatujÄ…cego z znacznikiem miejsca wypeÅ‚nionym rzeczywistÄ… wartoÅ›ciÄ…, ktÃ³rÄ…
otrzymaliÅ›my z funkcji <code>greeting</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from("Hello!")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(
            result.contains("Carol"),
            "Greeting did not contain name, value was `{result}`"
        );
    }
<span class="boring">}</span></code></pre>
<p>Teraz, gdy uruchomimy test, otrzymamy bardziej informacyjny komunikat o bÅ‚Ä™dzie:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----

thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
Greeting did not contain name, value was `Hello!`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>MoÅ¼emy zobaczyÄ‡ rzeczywistÄ… wartoÅ›Ä‡, ktÃ³rÄ… otrzymaliÅ›my w wynikach testu, co
pomogÅ‚oby nam debugowaÄ‡, co siÄ™ staÅ‚o, zamiast tego, czego siÄ™ spodziewaliÅ›my.</p>
<h3 id="sprawdzanie-paniki-za-pomocÄ…-should_panic"><a class="header" href="#sprawdzanie-paniki-za-pomocÄ…-should_panic">Sprawdzanie paniki za pomocÄ… <code>should_panic</code></a></h3>
<p>OprÃ³cz sprawdzania wartoÅ›ci zwracanych, waÅ¼ne jest sprawdzenie, czy nasz kod
obsÅ‚uguje warunki bÅ‚Ä™dÃ³w zgodnie z oczekiwaniami. Na przykÅ‚ad, rozwaÅ¼ typ
<code>Guess</code>, ktÃ³ry utworzyliÅ›my w Rozdziale 9, Listing 9-13. Inny kod, ktÃ³ry
uÅ¼ywa <code>Guess</code>, zaleÅ¼y od gwarancji, Å¼e instancje <code>Guess</code> bÄ™dÄ… zawieraÄ‡ tylko
wartoÅ›ci od 1 do 100. MoÅ¼emy napisaÄ‡ test, ktÃ³ry zapewni, Å¼e prÃ³ba utworzenia
instancji <code>Guess</code> z wartoÅ›ciÄ… spoza tego zakresu spowoduje panikÄ™.</p>
<p>Robimy to, dodajÄ…c atrybut <code>should_panic</code> do naszej funkcji testowej. Test
przechodzi, jeÅ›li kod wewnÄ…trz funkcji panikuje; test koÅ„czy siÄ™ niepowodzeniem,
jeÅ›li kod wewnÄ…trz funkcji nie panikuje.</p>
<p>Listing 11-8 przedstawia test, ktÃ³ry sprawdza, czy warunki bÅ‚Ä™du funkcji
<code>Guess::new</code> wystÄ™pujÄ…, gdy tego oczekujemy.</p>
<figure class="listing" id="listing-11-8">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
<figcaption><a href="#listing-11-8">Listing 11-8</a>: Testowanie, czy warunek spowoduje <code>panic!</code></figcaption>
</figure>
<p>Umieszczamy atrybut <code>#[should_panic]</code> po atrybucie <code>#[test]</code> i przed funkcjÄ…
testowÄ…, ktÃ³rej dotyczy. SpÃ³jrzmy na wynik, gdy ten test przejdzie:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>WyglÄ…da dobrze! Teraz wprowadÅºmy bÅ‚Ä…d do naszego kodu, usuwajÄ…c warunek, Å¼e
funkcja <code>new</code> spanikuje, jeÅ›li wartoÅ›Ä‡ jest wiÄ™ksza niÅ¼ 100:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Kiedy uruchomimy test w Listingu 11-8, zakoÅ„czy siÄ™ on niepowodzeniem:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected at src/lib.rs:21:8

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>W tym przypadku nie otrzymujemy zbyt pomocnego komunikatu, ale patrzÄ…c na
funkcjÄ™ testowÄ…, widzimy, Å¼e jest ona opatrzona adnotacjÄ…
<code>#[should_panic]</code>. Otrzymany bÅ‚Ä…d oznacza, Å¼e kod w funkcji testowej nie
spowodowaÅ‚ paniki.</p>
<p>Testy wykorzystujÄ…ce <code>should_panic</code> mogÄ… byÄ‡ niedokÅ‚adne. Test <code>should_panic</code>
przeszedÅ‚by nawet wtedy, gdyby test panikowaÅ‚ z innego powodu niÅ¼ ten, ktÃ³rego
siÄ™ spodziewaliÅ›my. Aby testy <code>should_panic</code> byÅ‚y bardziej precyzyjne,
moÅ¼emy dodaÄ‡ opcjonalny parametr <code>expected</code> do atrybutu <code>should_panic</code>. Test
framework zapewni, Å¼e komunikat o bÅ‚Ä™dzie bÄ™dzie zawieraÅ‚ podany tekst. Na
przykÅ‚ad, rozwaÅ¼ zmodyfikowany kod dla <code>Guess</code> w Listingu 11-9, gdzie funkcja
<code>new</code> panikuje z rÃ³Å¼nymi komunikatami w zaleÅ¼noÅ›ci od tego, czy wartoÅ›Ä‡ jest
za maÅ‚a, czy za duÅ¼a.</p>
<figure class="listing" id="listing-11-9">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
<figcaption><a href="#listing-11-9">Listing 11-9</a>: Testowanie <code>panic!</code> z komunikatem paniki zawierajÄ…cym okreÅ›lony podciÄ…g</figcaption>
</figure>
<p>Ten test przejdzie, poniewaÅ¼ wartoÅ›Ä‡, ktÃ³rÄ… umieÅ›ciliÅ›my w parametrze
<code>expected</code> atrybutu <code>should_panic</code>, jest podciÄ…giem komunikatu, z ktÃ³rym
funkcja <code>Guess::new</code> panikuje. MogliÅ›my okreÅ›liÄ‡ caÅ‚y oczekiwany komunikat
paniki, ktÃ³ry w tym przypadku brzmiaÅ‚by <code>Guess value must be less than or equal to 100, got 200</code>. To, co zdecydujesz siÄ™ okreÅ›liÄ‡, zaleÅ¼y od tego, jak
wiele z komunikatu paniki jest unikalne lub dynamiczne i jak precyzyjny chcesz,
aby byÅ‚ TwÃ³j test. W tym przypadku podciÄ…g komunikatu paniki jest wystarczajÄ…cy,
aby upewniÄ‡ siÄ™, Å¼e kod w funkcji testowej wykonuje przypadek
<code>else if value &gt; 100</code>.</p>
<p>Aby zobaczyÄ‡, co siÄ™ stanie, gdy test <code>should_panic</code> z komunikatem <code>expected</code>
zawiedzie, ponownie wprowadÅºmy bÅ‚Ä…d do naszego kodu, zamieniajÄ…c ciaÅ‚a blokÃ³w
<code>if value &lt; 1</code> i <code>else if value &gt; 100</code>:</p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = "less than or equal to 100")]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Tym razem, gdy uruchomimy test <code>should_panic</code>, zakoÅ„czy siÄ™ on niepowodzeniem:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----

thread 'tests::greater_than_100' panicked at src/lib.rs:12:13:
Guess value must be greater than or equal to 1, got 200.
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: "Guess value must be greater than or equal to 1, got 200."
 expected substring: "less than or equal to 100"

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Komunikat o bÅ‚Ä™dzie wskazuje, Å¼e ten test rzeczywiÅ›cie panikowaÅ‚, jak siÄ™
spodziewaliÅ›my, ale komunikat paniki nie zawieraÅ‚ oczekiwanego ciÄ…gu znakÃ³w
<code>less than or equal to 100</code>. Komunikat paniki, ktÃ³ry otrzymaliÅ›my w tym
przypadku, brzmiaÅ‚ <code>Guess value must be greater than or equal to 1, got 200</code>.
Teraz moÅ¼emy zaczÄ…Ä‡ szukaÄ‡ naszego bÅ‚Ä™du!</p>
<h3 id="uÅ¼ywanie-resultt-e-w-testach"><a class="header" href="#uÅ¼ywanie-resultt-e-w-testach">UÅ¼ywanie <code>Result&lt;T, E&gt;</code> w testach</a></h3>
<p>Wszystkie nasze dotychczasowe testy panikujÄ…, gdy zawiodÄ…. MoÅ¼emy rÃ³wnieÅ¼
pisaÄ‡ testy, ktÃ³re uÅ¼ywajÄ… <code>Result&lt;T, E&gt;</code>! Oto test z Listingu 11-1,
przepisany tak, aby uÅ¼ywaÅ‚ <code>Result&lt;T, E&gt;</code> i zwracaÅ‚ <code>Err</code> zamiast panikowaÄ‡:</p>
<pre><code class="language-rust noplayground"><span class="boring">pub fn add(left: u64, right: u64) -&gt; u64 {
</span><span class="boring">    left + right
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        let result = add(2, 2);

        if result == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
}</code></pre>
<p>Funkcja <code>it_works</code> ma teraz typ zwracany <code>Result&lt;(), String&gt;</code>. W ciele
funkcji, zamiast wywoÅ‚ywaÄ‡ makro <code>assert_eq!</code>, zwracamy <code>Ok(())</code>, gdy test
przejdzie, i <code>Err</code> z <code>String</code> w Å›rodku, gdy test zawiedzie.</p>
<p>Pisanie testÃ³w w taki sposÃ³b, aby zwracaÅ‚y <code>Result&lt;T, E&gt;</code>, pozwala na
uÅ¼ywanie operatora znaku zapytania w ciele testÃ³w, co moÅ¼e byÄ‡ wygodnym
sposobem pisania testÃ³w, ktÃ³re powinny zakoÅ„czyÄ‡ siÄ™ niepowodzeniem, jeÅ›li
jakakolwiek operacja w ich obrÄ™bie zwrÃ³ci wariant <code>Err</code>.</p>
<p>Nie moÅ¼esz uÅ¼ywaÄ‡ adnotacji <code>#[should_panic]</code> w testach, ktÃ³re uÅ¼ywajÄ…
<code>Result&lt;T, E&gt;</code>. Aby potwierdziÄ‡, Å¼e operacja zwraca wariant <code>Err</code>, <em>nie</em> uÅ¼ywaj
operatora znaku zapytania na wartoÅ›ci <code>Result&lt;T, E&gt;</code>. Zamiast tego uÅ¼yj
<code>assert!(value.is_err())</code>.</p>
<p>Teraz, gdy znasz kilka sposobÃ³w pisania testÃ³w, przyjrzyjmy siÄ™, co dzieje siÄ™,
gdy uruchamiamy nasze testy i zbadajmy rÃ³Å¼ne opcje, ktÃ³rych moÅ¼emy uÅ¼yÄ‡ z
<code>cargo test</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="kontrolowanie-sposobu-uruchamiania-testÃ³w-1"><a href="#kontrolowanie-sposobu-uruchamiania-testÃ³w-1" class="header">Kontrolowanie sposobu uruchamiania testÃ³w</a></h1>
<h2 id="kontrolowanie-sposobu-uruchamiania-testÃ³w"><a class="header" href="#kontrolowanie-sposobu-uruchamiania-testÃ³w">Kontrolowanie sposobu uruchamiania testÃ³w</a></h2>
<p>Tak jak <code>cargo run</code> kompiluje TwÃ³j kod, a nastÄ™pnie uruchamia wynikowy plik binarny, tak <code>cargo test</code> kompiluje TwÃ³j kod w trybie testowym i uruchamia wynikowy plik binarny testÃ³w. DomyÅ›lne zachowanie pliku binarnego wyprodukowanego przez <code>cargo test</code> to uruchamianie wszystkich testÃ³w rÃ³wnolegle i przechwytywanie danych wyjÅ›ciowych generowanych podczas przebiegÃ³w testÃ³w, co zapobiega wyÅ›wietlaniu danych wyjÅ›ciowych i uÅ‚atwia czytanie danych wyjÅ›ciowych zwiÄ…zanych z wynikami testÃ³w. MoÅ¼esz jednak okreÅ›liÄ‡ opcje wiersza poleceÅ„, aby zmieniÄ‡ to domyÅ›lne zachowanie.</p>
<p>NiektÃ³re opcje wiersza poleceÅ„ trafiajÄ… do <code>cargo test</code>, a niektÃ³re do wynikowego pliku binarnego testÃ³w. Aby rozdzieliÄ‡ te dwa typy argumentÃ³w, naleÅ¼y wymieniÄ‡ argumenty, ktÃ³re trafiajÄ… do <code>cargo test</code>, po ktÃ³rych nastÄ™puje separator <code>--</code>, a nastÄ™pnie te, ktÃ³re trafiajÄ… do pliku binarnego testÃ³w. Uruchomienie <code>cargo test --help</code> wyÅ›wietla opcje, ktÃ³rych moÅ¼na uÅ¼yÄ‡ z <code>cargo test</code>, a uruchomienie <code>cargo test -- --help</code> wyÅ›wietla opcje, ktÃ³rych moÅ¼na uÅ¼yÄ‡ po separatorze. Opcje te sÄ… rÃ³wnieÅ¼ udokumentowane w sekcji <a href="https://doc.rust-lang.org/rustc/tests/index.html">â€Testyâ€ w <em>The <code>rustc</code> Book</em></a>.</p>
<h3 id="uruchamianie-testÃ³w-rÃ³wnolegle-lub-sekwencyjnie"><a class="header" href="#uruchamianie-testÃ³w-rÃ³wnolegle-lub-sekwencyjnie">Uruchamianie testÃ³w rÃ³wnolegle lub sekwencyjnie</a></h3>
<p>Kiedy uruchamiasz wiele testÃ³w, domyÅ›lnie dziaÅ‚ajÄ… one rÃ³wnolegle, uÅ¼ywajÄ…c wÄ…tkÃ³w, co oznacza, Å¼e koÅ„czÄ… siÄ™ szybciej i otrzymujesz informacjÄ™ zwrotnÄ… wczeÅ›niej. PoniewaÅ¼ testy dziaÅ‚ajÄ… jednoczeÅ›nie, musisz upewniÄ‡ siÄ™, Å¼e Twoje testy nie zaleÅ¼Ä… od siebie nawzajem ani od Å¼adnego wspÃ³Å‚dzielonego stanu, w tym wspÃ³Å‚dzielonego Å›rodowiska, takiego jak bieÅ¼Ä…cy katalog roboczy lub zmienne Å›rodowiskowe.</p>
<p>Na przykÅ‚ad, powiedzmy, Å¼e kaÅ¼dy z twoich testÃ³w uruchamia pewien kod, ktÃ³ry tworzy plik na dysku o nazwie <em>test-output.txt</em> i zapisuje do niego pewne dane. NastÄ™pnie, kaÅ¼dy test odczytuje dane z tego pliku i twierdzi, Å¼e plik zawiera okreÅ›lonÄ… wartoÅ›Ä‡, ktÃ³ra jest rÃ³Å¼na w kaÅ¼dym teÅ›cie. PoniewaÅ¼ testy dziaÅ‚ajÄ… jednoczeÅ›nie, jeden test moÅ¼e nadpisaÄ‡ plik w czasie miÄ™dzy zapisem a odczytem pliku przez inny test. Drugi test zakoÅ„czy siÄ™ niepowodzeniem, nie dlatego, Å¼e kod jest niepoprawny, ale dlatego, Å¼e testy wzajemnie siÄ™ zakÅ‚Ã³caÅ‚y podczas dziaÅ‚ania rÃ³wnolegÅ‚ego. Jednym z rozwiÄ…zaÅ„ jest upewnienie siÄ™, Å¼e kaÅ¼dy test zapisuje do innego pliku; innym rozwiÄ…zaniem jest uruchamianie testÃ³w jeden po drugim.</p>
<p>JeÅ›li nie chcesz uruchamiaÄ‡ testÃ³w rÃ³wnolegle lub jeÅ›li chcesz mieÄ‡ bardziej precyzyjnÄ… kontrolÄ™ nad liczbÄ… uÅ¼ywanych wÄ…tkÃ³w, moÅ¼esz przekazaÄ‡ flagÄ™ <code>--test-threads</code> oraz liczbÄ™ wÄ…tkÃ³w, ktÃ³rych chcesz uÅ¼yÄ‡, do binarnego pliku testowego. SpÃ³jrz na nastÄ™pujÄ…cy przykÅ‚ad:</p>
<pre><code class="language-console">$ cargo test -- --test-threads=1
</code></pre>
<p>Ustawiamy liczbÄ™ wÄ…tkÃ³w testowych na <code>1</code>, informujÄ…c program, aby nie uÅ¼ywaÅ‚ Å¼adnego paralelizmu. Uruchamianie testÃ³w na jednym wÄ…tku zajmie wiÄ™cej czasu niÅ¼ uruchamianie ich rÃ³wnolegle, ale testy nie bÄ™dÄ… ze sobÄ… kolidowaÄ‡, jeÅ›li wspÃ³Å‚dzielÄ… stan.</p>
<h3 id="wyÅ›wietlanie-wyjÅ›cia-funkcji"><a class="header" href="#wyÅ›wietlanie-wyjÅ›cia-funkcji">WyÅ›wietlanie wyjÅ›cia funkcji</a></h3>
<p>DomyÅ›lnie, jeÅ›li test przechodzi, biblioteka testowa Rust przechwytuje wszystko, co jest wypisywane na standardowe wyjÅ›cie. Na przykÅ‚ad, jeÅ›li wywoÅ‚amy <code>println!</code> w teÅ›cie, a test przejdzie, nie zobaczymy wyjÅ›cia <code>println!</code> w terminalu; zobaczymy tylko wiersz wskazujÄ…cy, Å¼e test przeszedÅ‚. JeÅ›li test zakoÅ„czy siÄ™ niepowodzeniem, zobaczymy wszystko, co zostaÅ‚o wypisane na standardowe wyjÅ›cie, wraz z resztÄ… komunikatu o bÅ‚Ä™dzie.</p>
<p>Jako przykÅ‚ad, Listing 11-10 zawiera prostÄ… funkcjÄ™, ktÃ³ra wypisuje wartoÅ›Ä‡ swojego parametru i zwraca 10, a takÅ¼e test, ktÃ³ry przechodzi, i test, ktÃ³ry koÅ„czy siÄ™ niepowodzeniem.</p>
<listing number="11-10" file-name="src/lib.rs" caption="Testy funkcji wywoÅ‚ujÄ…cej `println!`">
<pre><code class="language-rust panics noplayground">fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!("I got the value {a}");
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(value, 10);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(value, 5);
    }
}</code></pre>
</listing>
<p>Kiedy uruchomimy te testy za pomocÄ… <code>cargo test</code>, zobaczymy nastÄ™pujÄ…ce dane wyjÅ›ciowe:</p>
<pre><code class="language-console">$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8

thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:
assertion `left == right` failed
  left: 10
 right: 5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>ZauwaÅ¼, Å¼e w tym wyjÅ›ciu nigdzie nie widzimy <code>I got the value 4</code>, ktÃ³re jest wypisywane, gdy test, ktÃ³ry przechodzi, jest uruchamiany. To wyjÅ›cie zostaÅ‚o przechwycone. WyjÅ›cie z testu, ktÃ³ry zakoÅ„czyÅ‚ siÄ™ niepowodzeniem, <code>I got the value 8</code>, pojawia siÄ™ w sekcji podsumowania testÃ³w, ktÃ³ra rÃ³wnieÅ¼ pokazuje przyczynÄ™ niepowodzenia testu.</p>
<p>JeÅ›li chcemy zobaczyÄ‡ wypisane wartoÅ›ci rÃ³wnieÅ¼ dla przechodzÄ…cych testÃ³w, moÅ¼emy nakazaÄ‡ Rustowi wyÅ›wietlanie danych wyjÅ›ciowych udanych testÃ³w za pomocÄ… <code>--show-output</code>:</p>
<pre><code class="language-console">$ cargo test -- --show-output
</code></pre>
<p>Kiedy ponownie uruchomimy testy z Listingu 11-10 z flagÄ… <code>--show-output</code>, zobaczymy nastÄ™pujÄ…ce dane wyjÅ›ciowe:</p>
<pre><code class="language-console">$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

successes:

---- tests::this_test_will_pass stdout ----
I got the value 4


successes:
    tests::this_test_will_pass

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8

thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:
assertion `left == right` failed
  left: 10
 right: 5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<h3 id="uruchamianie-podzbioru-testÃ³w-po-nazwie"><a class="header" href="#uruchamianie-podzbioru-testÃ³w-po-nazwie">Uruchamianie podzbioru testÃ³w po nazwie</a></h3>
<p>Uruchamianie peÅ‚nego zestawu testÃ³w moÅ¼e czasem zajÄ…Ä‡ duÅ¼o czasu. JeÅ›li pracujesz nad kodem w okreÅ›lonym obszarze, moÅ¼esz chcieÄ‡ uruchomiÄ‡ tylko testy dotyczÄ…ce tego kodu. MoÅ¼esz wybraÄ‡, ktÃ³re testy uruchomiÄ‡, przekazujÄ…c <code>cargo test</code> nazwÄ™ lub nazwy testÃ³w, ktÃ³re chcesz uruchomiÄ‡, jako argument.</p>
<p>Aby zademonstrowaÄ‡, jak uruchomiÄ‡ podzbiÃ³r testÃ³w, najpierw utworzymy trzy testy dla naszej funkcji <code>add_two</code>, jak pokazano w Listingu 11-11, i wybierzemy, ktÃ³re z nich uruchomiÄ‡.</p>
<listing number="11-11" file-name="src/lib.rs" caption="Trzy testy z trzema rÃ³Å¼nymi nazwami">
<pre><code class="language-rust noplayground">pub fn add_two(a: u64) -&gt; u64 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }

    #[test]
    fn add_three_and_two() {
        let result = add_two(3);
        assert_eq!(result, 5);
    }

    #[test]
    fn one_hundred() {
        let result = add_two(100);
        assert_eq!(result, 102);
    }
}</code></pre>
</listing>
<p>JeÅ›li uruchomimy testy bez przekazywania Å¼adnych argumentÃ³w, jak widzieliÅ›my wczeÅ›niej, wszystkie testy zostanÄ… uruchomione rÃ³wnolegle:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<h4 id="uruchamianie-pojedynczych-testÃ³w"><a class="header" href="#uruchamianie-pojedynczych-testÃ³w">Uruchamianie pojedynczych testÃ³w</a></h4>
<p>MoÅ¼emy przekazaÄ‡ nazwÄ™ dowolnej funkcji testowej do <code>cargo test</code>, aby uruchomiÄ‡ tylko ten test:</p>
<pre><code class="language-console">$ cargo test one_hundred
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s

</code></pre>
<p>Uruchomiono tylko test o nazwie <code>one_hundred</code>; pozostaÅ‚e dwa testy nie pasowaÅ‚y do tej nazwy. Wyniki testÃ³w informujÄ… nas, Å¼e byÅ‚o wiÄ™cej testÃ³w, ktÃ³re nie zostaÅ‚y uruchomione, wyÅ›wietlajÄ…c na koÅ„cu <code>2 filtered out</code>.</p>
<p>W ten sposÃ³b nie moÅ¼na okreÅ›laÄ‡ nazw wielu testÃ³w; uÅ¼yta zostanie tylko pierwsza wartoÅ›Ä‡ podana <code>cargo test</code>. Ale istnieje sposÃ³b na uruchamianie wielu testÃ³w.</p>
<h4 id="filtrowanie-w-celu-uruchomienia-wielu-testÃ³w"><a class="header" href="#filtrowanie-w-celu-uruchomienia-wielu-testÃ³w">Filtrowanie w celu uruchomienia wielu testÃ³w</a></h4>
<p>MoÅ¼emy okreÅ›liÄ‡ czÄ™Å›Ä‡ nazwy testu, a kaÅ¼dy test, ktÃ³rego nazwa pasuje do tej wartoÅ›ci, zostanie uruchomiony. Na przykÅ‚ad, poniewaÅ¼ nazwy dwÃ³ch naszych testÃ³w zawierajÄ… <code>add</code>, moÅ¼emy uruchomiÄ‡ te dwa, uruchamiajÄ…c <code>cargo test add</code>:</p>
<pre><code class="language-console">$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

</code></pre>
<p>To polecenie uruchomiÅ‚o wszystkie testy zawierajÄ…ce <code>add</code> w nazwie i odfiltrowaÅ‚o test o nazwie <code>one_hundred</code>. ZwrÃ³Ä‡ rÃ³wnieÅ¼ uwagÄ™, Å¼e moduÅ‚, w ktÃ³rym pojawia siÄ™ test, staje siÄ™ czÄ™Å›ciÄ… nazwy testu, wiÄ™c moÅ¼emy uruchomiÄ‡ wszystkie testy w module, filtrujÄ…c po nazwie moduÅ‚u.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="ignoring-some-tests-unless-specifically-requested"></a></p>
<h3 id="ignorowanie-testÃ³w-chyba-Å¼e-sÄ…-wyraÅºnie-Å¼Ä…dane"><a class="header" href="#ignorowanie-testÃ³w-chyba-Å¼e-sÄ…-wyraÅºnie-Å¼Ä…dane">Ignorowanie testÃ³w, chyba Å¼e sÄ… wyraÅºnie Å¼Ä…dane</a></h3>
<p>Czasami kilka konkretnych testÃ³w moÅ¼e byÄ‡ bardzo czasochÅ‚onnych w wykonaniu, wiÄ™c moÅ¼esz chcieÄ‡ je wykluczyÄ‡ podczas wiÄ™kszoÅ›ci uruchomieÅ„ <code>cargo test</code>. Zamiast wymieniaÄ‡ jako argumenty wszystkie testy, ktÃ³re chcesz uruchomiÄ‡, moÅ¼esz zamiast tego opatrzyÄ‡ czasochÅ‚onne testy atrybutem <code>ignore</code>, aby je wykluczyÄ‡, jak pokazano tutaj:</p>
<p><span class="filename">Nazwa pliku: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub fn add(left: u64, right: u64) -&gt; u64 {
</span><span class="boring">    left + right
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    #[ignore]
    fn expensive_test() {
        // code that takes an hour to run
    }
}</code></pre>
<p>Po <code>#[test]</code> dodajemy wiersz <code>#[ignore]</code> do testu, ktÃ³ry chcemy wykluczyÄ‡. Teraz, gdy uruchomimy nasze testy, <code>it_works</code> zostanie uruchomione, ale <code>expensive_test</code> nie:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::expensive_test ... ignored
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Funkcja <code>expensive_test</code> jest wymieniona jako <code>ignored</code>. JeÅ›li chcemy uruchomiÄ‡ tylko ignorowane testy, moÅ¼emy uÅ¼yÄ‡ <code>cargo test -- --ignored</code>:</p>
<pre><code class="language-console">$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>KontrolujÄ…c, ktÃ³re testy sÄ… uruchamiane, moÅ¼esz mieÄ‡ pewnoÅ›Ä‡, Å¼e wyniki <code>cargo test</code> zostanÄ… zwrÃ³cone szybko. Kiedy nadejdzie moment, w ktÃ³rym sensowne jest sprawdzenie wynikÃ³w testÃ³w <code>ignored</code> i masz czas, aby poczekaÄ‡ na wyniki, moÅ¼esz zamiast tego uruchomiÄ‡ <code>cargo test -- --ignored</code>. JeÅ›li chcesz uruchomiÄ‡ wszystkie testy, niezaleÅ¼nie od tego, czy sÄ… ignorowane, czy nie, moÅ¼esz uruchomiÄ‡ <code>cargo test -- --include-ignored</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="organizacja-testÃ³w-1"><a href="#organizacja-testÃ³w-1" class="header">Organizacja testÃ³w</a></h1>
<h2 id="organizacja-testÃ³w"><a class="header" href="#organizacja-testÃ³w">Organizacja testÃ³w</a></h2>
<p>Jak wspomniano na poczÄ…tku rozdziaÅ‚u, testowanie jest zÅ‚oÅ¼onÄ… dyscyplinÄ…, a rÃ³Å¼ni ludzie uÅ¼ywajÄ… rÃ³Å¼nej terminologii i organizacji. SpoÅ‚ecznoÅ›Ä‡ Rust rozwaÅ¼a testy w kategoriach dwÃ³ch gÅ‚Ã³wnych kategorii: testÃ³w jednostkowych i testÃ³w integracyjnych. <em>Testy jednostkowe</em> sÄ… maÅ‚e i bardziej skoncentrowane, testujÄ… jeden moduÅ‚ w izolacji, i mogÄ… testowaÄ‡ interfejsy prywatne. <em>Testy integracyjne</em> sÄ… caÅ‚kowicie zewnÄ™trzne w stosunku do Twojej biblioteki i uÅ¼ywajÄ… Twojego kodu w taki sam sposÃ³b, jak kaÅ¼dy inny kod zewnÄ™trzny, uÅ¼ywajÄ…c tylko publicznego interfejsu i potencjalnie testujÄ…c wiele moduÅ‚Ã³w na test.</p>
<p>Pisanie obu rodzajÃ³w testÃ³w jest waÅ¼ne, aby upewniÄ‡ siÄ™, Å¼e czÄ™Å›ci twojej biblioteki dziaÅ‚ajÄ… tak, jak tego oczekujesz, zarÃ³wno oddzielnie, jak i razem.</p>
<h3 id="testy-jednostkowe"><a class="header" href="#testy-jednostkowe">Testy jednostkowe</a></h3>
<p>Celem testÃ³w jednostkowych jest przetestowanie kaÅ¼dej jednostki kodu w izolacji od reszty kodu, aby szybko zlokalizowaÄ‡, gdzie kod dziaÅ‚a, a gdzie nie, zgodnie z oczekiwaniami. Testy jednostkowe umieszcza siÄ™ w katalogu <em>src</em> w kaÅ¼dym pliku z kodem, ktÃ³ry testujÄ…. KonwencjÄ… jest tworzenie w kaÅ¼dym pliku moduÅ‚u o nazwie <code>tests</code>, ktÃ³ry zawiera funkcje testowe i oznaczanie moduÅ‚u atrybutem <code>cfg(test)</code>.</p>
<h4 id="moduÅ‚-tests-i-cfgtest"><a class="header" href="#moduÅ‚-tests-i-cfgtest">ModuÅ‚ <code>tests</code> i <code>#[cfg(test)]</code></a></h4>
<p>Adnotacja <code>#[cfg(test)]</code> na module <code>tests</code> informuje Rust, aby kompilowaÅ‚ i uruchamiaÅ‚ kod testowy tylko wtedy, gdy uruchamiasz <code>cargo test</code>, a nie gdy uruchamiasz <code>cargo build</code>. To oszczÄ™dza czas kompilacji, gdy chcesz tylko zbudowaÄ‡ bibliotekÄ™, i oszczÄ™dza miejsce w wynikowym skompilowanym artefakcie, poniewaÅ¼ testy nie sÄ… wÅ‚Ä…czone. Zobaczysz, Å¼e poniewaÅ¼ testy integracyjne znajdujÄ… siÄ™ w innym katalogu, nie potrzebujÄ… adnotacji <code>#[cfg(test)]</code>. JednakÅ¼e, poniewaÅ¼ testy jednostkowe znajdujÄ… siÄ™ w tych samych plikach co kod, bÄ™dziesz uÅ¼ywaÅ‚ <code>#[cfg(test)]</code> do okreÅ›lenia, Å¼e nie powinny byÄ‡ one uwzglÄ™dniane w skompilowanym wyniku.</p>
<p>PamiÄ™taj, Å¼e kiedy generowaliÅ›my nowy projekt <code>adder</code> w pierwszej sekcji tego rozdziaÅ‚u, Cargo wygenerowaÅ‚ dla nas ten kod:</p>
<p><span class="filename">Nazwa pliku: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>Na automatycznie wygenerowanym module <code>tests</code> atrybut <code>cfg</code> oznacza <em>konfiguracjÄ™</em> i informuje Rust, Å¼e nastÄ™pny element powinien byÄ‡ uwzglÄ™dniony tylko przy okreÅ›lonej opcji konfiguracji. W tym przypadku opcjÄ… konfiguracji jest <code>test</code>, ktÃ³ra jest dostarczana przez Rust do kompilowania i uruchamiania testÃ³w. UÅ¼ywajÄ…c atrybutu <code>cfg</code>, Cargo kompiluje nasz kod testowy tylko wtedy, gdy aktywnie uruchamiamy testy za pomocÄ… <code>cargo test</code>. Dotyczy to wszelkich funkcji pomocniczych, ktÃ³re mogÄ… znajdowaÄ‡ siÄ™ w tym module, oprÃ³cz funkcji oznaczonych <code>#[test]</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="testing-private-functions"></a></p>
<h4 id="testy-funkcji-prywatnych"><a class="header" href="#testy-funkcji-prywatnych">Testy funkcji prywatnych</a></h4>
<p>Istnieje debata w Å›rodowisku testowym na temat tego, czy funkcje prywatne powinny byÄ‡ testowane bezpoÅ›rednio, a inne jÄ™zyki utrudniajÄ… lub uniemoÅ¼liwiajÄ… testowanie funkcji prywatnych. NiezaleÅ¼nie od tego, ktÃ³rej ideologii testowania przestrzegasz, zasady prywatnoÅ›ci Rust pozwalajÄ… testowaÄ‡ funkcje prywatne. RozwaÅ¼ kod w Listingu 11-12 z prywatnÄ… funkcjÄ… <code>internal_adder</code>.</p>
<listing number="11-12" file-name="src/lib.rs" caption="Testowanie funkcji prywatnej">
<pre><code class="language-rust noplayground">pub fn add_two(a: u64) -&gt; u64 {
    internal_adder(a, 2)
}

fn internal_adder(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        let result = internal_adder(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
</listing>
<p>ZauwaÅ¼, Å¼e funkcja <code>internal_adder</code> nie jest oznaczona jako <code>pub</code>. Testy to po prostu kod Rust, a moduÅ‚ <code>tests</code> to tylko kolejny moduÅ‚. Jak omÃ³wiliÅ›my w sekcji <a href="#Å›cieÅ¼ki-do-odwoÅ‚ywania-siÄ™-do-elementu-w-drzewie-moduÅ‚Ã³w-1">â€ÅšcieÅ¼ki do odwoÅ‚ywania siÄ™ do elementu w drzewie moduÅ‚Ã³wâ€</a><!-- ignore -->, elementy w podmoduÅ‚ach mogÄ… uÅ¼ywaÄ‡ elementÃ³w w swoich moduÅ‚ach nadrzÄ™dnych. W tym teÅ›cie wprowadzamy wszystkie elementy naleÅ¼Ä…ce do rodzica moduÅ‚u <code>tests</code> do zasiÄ™gu za pomocÄ… <code>use super::*</code>, a nastÄ™pnie test moÅ¼e wywoÅ‚aÄ‡ <code>internal_adder</code>. JeÅ›li nie uwaÅ¼asz, Å¼e funkcje prywatne powinny byÄ‡ testowane, w Rust nie ma niczego, co by CiÄ™ do tego zmuszaÅ‚o.</p>
<h3 id="testy-integracyjne"><a class="header" href="#testy-integracyjne">Testy integracyjne</a></h3>
<p>W Rust testy integracyjne sÄ… caÅ‚kowicie zewnÄ™trzne w stosunku do twojej biblioteki. UÅ¼ywajÄ… one twojej biblioteki w taki sam sposÃ³b, jak kaÅ¼dy inny kod, co oznacza, Å¼e mogÄ… wywoÅ‚ywaÄ‡ tylko funkcje, ktÃ³re sÄ… czÄ™Å›ciÄ… publicznego API twojej biblioteki. Ich celem jest sprawdzenie, czy wiele czÄ™Å›ci twojej biblioteki dziaÅ‚a poprawnie razem. Jednostki kodu, ktÃ³re dziaÅ‚ajÄ… poprawnie samodzielnie, mogÄ… mieÄ‡ problemy po zintegrowaniu, dlatego pokrycie testowe zintegrowanego kodu jest rÃ³wnieÅ¼ waÅ¼ne. Aby utworzyÄ‡ testy integracyjne, najpierw potrzebujesz katalogu <em>tests</em>.</p>
<h4 id="katalog-tests"><a class="header" href="#katalog-tests">Katalog <em>tests</em></a></h4>
<p>Tworzymy katalog <em>tests</em> na najwyÅ¼szym poziomie naszego katalogu projektu, obok <em>src</em>. Cargo wie, Å¼e powinien szukaÄ‡ plikÃ³w testÃ³w integracyjnych w tym katalogu. MoÅ¼emy nastÄ™pnie tworzyÄ‡ dowolnÄ… liczbÄ™ plikÃ³w testowych, a Cargo skompiluje kaÅ¼dy z tych plikÃ³w jako oddzielnÄ… skrzynkÄ™.</p>
<p>UtwÃ³rzmy test integracyjny. Z kodem z Listingu 11-12, ktÃ³ry nadal znajduje siÄ™ w pliku <em>src/lib.rs</em>, utwÃ³rz katalog <em>tests</em> i stwÃ³rz nowy plik o nazwie <em>tests/integration_test.rs</em>. Struktura katalogÃ³w powinna wyglÄ…daÄ‡ nastÄ™pujÄ…co:</p>
<pre><code class="language-text">adder
â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src
â”‚Â Â  â””â”€â”€ lib.rs
â””â”€â”€ tests
    â””â”€â”€ integration_test.rs
</code></pre>
<p>WprowadÅº kod z Listingu 11-13 do pliku <em>tests/integration_test.rs</em>.</p>
<listing number="11-13" file-name="tests/integration_test.rs" caption="Test integracyjny funkcji ze skrzynki `adder`">
<pre><code class="language-rust ignore">use adder::add_two;

#[test]
fn it_adds_two() {
    let result = add_two(2);
    assert_eq!(result, 4);
}</code></pre>
</listing>
<p>KaÅ¼dy plik w katalogu <em>tests</em> jest oddzielnÄ… skrzynkÄ…, wiÄ™c musimy wprowadziÄ‡ naszÄ… bibliotekÄ™ do zasiÄ™gu kaÅ¼dej skrzynki testowej. Z tego powodu na poczÄ…tku kodu dodajemy <code>use adder::add_two;</code>, czego nie potrzebowaliÅ›my w testach jednostkowych.</p>
<p>Nie musimy adnotowaÄ‡ Å¼adnego kodu w <em>tests/integration_test.rs</em> atrybutem <code>#[cfg(test)]</code>. Cargo traktuje katalog <em>tests</em> w specjalny sposÃ³b i kompiluje pliki w tym katalogu tylko wtedy, gdy uruchamiamy <code>cargo test</code>. Uruchom <code>cargo test</code> teraz:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests src/lib.rs (target/debug/deps/adder-1082c4b063a8fbe6)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Trzy sekcje wynikÃ³w obejmujÄ… testy jednostkowe, testy integracyjne i testy dokumentacji. ZauwaÅ¼, Å¼e jeÅ›li jakikolwiek test w sekcji zakoÅ„czy siÄ™ niepowodzeniem, nastÄ™pne sekcje nie zostanÄ… uruchomione. Na przykÅ‚ad, jeÅ›li test jednostkowy zakoÅ„czy siÄ™ niepowodzeniem, nie bÄ™dzie Å¼adnych danych wyjÅ›ciowych dla testÃ³w integracyjnych i dokumentacji, poniewaÅ¼ te testy zostanÄ… uruchomione tylko wtedy, gdy wszystkie testy jednostkowe przejdÄ….</p>
<p>Pierwsza sekcja dla testÃ³w jednostkowych jest taka sama, jak widzieliÅ›my wczeÅ›niej: jeden wiersz dla kaÅ¼dego testu jednostkowego (jeden o nazwie <code>internal</code>, ktÃ³ry dodaliÅ›my w Listingu 11-12), a nastÄ™pnie wiersz podsumowania dla testÃ³w jednostkowych.</p>
<p>Sekcja testÃ³w integracyjnych zaczyna siÄ™ od wiersza <code>Running tests/integration_test.rs</code>. NastÄ™pnie, dla kaÅ¼dej funkcji testowej w tym teÅ›cie integracyjnym znajduje siÄ™ wiersz i wiersz podsumowania wynikÃ³w testu integracyjnego tuÅ¼ przed sekcjÄ… <code>Doc-tests adder</code>.</p>
<p>KaÅ¼dy plik testÃ³w integracyjnych ma swojÄ… wÅ‚asnÄ… sekcjÄ™, wiÄ™c jeÅ›li dodamy wiÄ™cej plikÃ³w do katalogu <em>tests</em>, bÄ™dzie wiÄ™cej sekcji testÃ³w integracyjnych.</p>
<p>Nadal moÅ¼emy uruchomiÄ‡ konkretnÄ… funkcjÄ™ testowÄ… integracji, okreÅ›lajÄ…c nazwÄ™ funkcji testowej jako argument dla <code>cargo test</code>. Aby uruchomiÄ‡ wszystkie testy w konkretnym pliku testowym integracji, uÅ¼yj argumentu <code>--test</code> <code>cargo test</code>, po ktÃ³rym nastÄ™puje nazwa pliku:</p>
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.64s
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>To polecenie uruchamia tylko testy z pliku <em>tests/integration_test.rs</em>.</p>
<h4 id="podmoduÅ‚y-w-testach-integracyjnych"><a class="header" href="#podmoduÅ‚y-w-testach-integracyjnych">PodmoduÅ‚y w testach integracyjnych</a></h4>
<p>W miarÄ™ dodawania kolejnych testÃ³w integracyjnych, moÅ¼esz chcieÄ‡ utworzyÄ‡ wiÄ™cej plikÃ³w w katalogu <em>tests</em>, aby pomÃ³c w ich organizacji; na przykÅ‚ad, moÅ¼esz grupowaÄ‡ funkcje testowe wedÅ‚ug testowanej przez nie funkcjonalnoÅ›ci. Jak wspomniano wczeÅ›niej, kaÅ¼dy plik w katalogu <em>tests</em> jest kompilowany jako oddzielna skrzynka, co jest przydatne do tworzenia oddzielnych zasiÄ™gÃ³w, aby dokÅ‚adniej naÅ›ladowaÄ‡ sposÃ³b, w jaki uÅ¼ytkownicy koÅ„cowi bÄ™dÄ… uÅ¼ywaÄ‡ Twojej skrzynki. Oznacza to jednak, Å¼e pliki w katalogu <em>tests</em> nie majÄ… tego samego zachowania, co pliki w <em>src</em>, o czym dowiedziaÅ‚eÅ› siÄ™ w Rozdziale 7, dotyczÄ…cym sposobu dzielenia kodu na moduÅ‚y i pliki.</p>
<p>RÃ³Å¼ne zachowanie plikÃ³w z katalogu <em>tests</em> jest najbardziej zauwaÅ¼alne, gdy masz zestaw funkcji pomocniczych do uÅ¼ycia w wielu plikach testÃ³w integracyjnych i prÃ³bujesz postÄ™powaÄ‡ zgodnie z instrukcjami w sekcji <a href="#dzielenie-moduÅ‚Ã³w-na-rÃ³Å¼ne-pliki-1">â€Dzielenie moduÅ‚Ã³w na rÃ³Å¼ne plikiâ€</a><!-- ignore --> w Rozdziale 7, aby wyodrÄ™bniÄ‡ je do wspÃ³lnego moduÅ‚u. Na przykÅ‚ad, jeÅ›li utworzymy <em>tests/common.rs</em> i umieÅ›cimy w nim funkcjÄ™ o nazwie <code>setup</code>, moÅ¼emy dodaÄ‡ do <code>setup</code> kod, ktÃ³ry chcemy wywoÅ‚aÄ‡ z wielu funkcji testowych w wielu plikach testowych:</p>
<p><span class="filename">Nazwa pliku: tests/common.rs</span></p>
<pre><code class="language-rust noplayground">pub fn setup() {
    // setup code specific to your library's tests would go here
}</code></pre>
<p>Kiedy ponownie uruchomimy testy, zobaczymy nowÄ… sekcjÄ™ w wynikach testÃ³w dla pliku <em>common.rs</em>, mimo Å¼e ten plik nie zawiera Å¼adnych funkcji testowych ani nie wywoÅ‚aliÅ›my funkcji <code>setup</code> z Å¼adnego miejsca:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.89s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Pojawienie siÄ™ <code>common</code> w wynikach testÃ³w z wyÅ›wietlonym <code>running 0 tests</code> nie byÅ‚o tym, czego chcieliÅ›my. ChcieliÅ›my tylko udostÄ™pniÄ‡ kod innym plikom testÃ³w integracyjnych. Aby uniknÄ…Ä‡ pojawiania siÄ™ <code>common</code> w wynikach testÃ³w, zamiast tworzenia <em>tests/common.rs</em>, utworzymy <em>tests/common/mod.rs</em>. Katalog projektu wyglÄ…da teraz tak:</p>
<pre><code class="language-text">â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src
â”‚Â Â  â””â”€â”€ lib.rs
â””â”€â”€ tests
    â”œâ”€â”€ common
    â”‚Â Â  â””â”€â”€ mod.rs
    â””â”€â”€ integration_test.rs
</code></pre>
<p>Jest to starsza konwencja nazewnictwa, ktÃ³rÄ… Rust rÃ³wnieÅ¼ rozumie i o ktÃ³rej wspomnieliÅ›my w sekcji <a href="#alternate-file-paths">â€Alternatywne Å›cieÅ¼ki plikÃ³wâ€</a><!-- ignore --> w Rozdziale 7. Nazwanie pliku w ten sposÃ³b informuje Rust, aby nie traktowaÅ‚ moduÅ‚u <code>common</code> jako pliku testÃ³w integracyjnych. Kiedy przeniesiemy kod funkcji <code>setup</code> do <em>tests/common/mod.rs</em> i usuniemy plik <em>tests/common.rs</em>, sekcja w wynikach testÃ³w przestanie siÄ™ pojawiaÄ‡. Pliki w podkatalogach katalogu <em>tests</em> nie sÄ… kompilowane jako oddzielne skrzynki ani nie majÄ… sekcji w wynikach testÃ³w.</p>
<p>Po utworzeniu <em>tests/common/mod.rs</em> moÅ¼emy go uÅ¼ywaÄ‡ z dowolnego pliku testÃ³w integracyjnych jako moduÅ‚u. Oto przykÅ‚ad wywoÅ‚ania funkcji <code>setup</code> z testu <code>it_adds_two</code> w <em>tests/integration_test.rs</em>:</p>
<p><span class="filename">Nazwa pliku: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder::add_two;

mod common;

#[test]
fn it_adds_two() {
    common::setup();

    let result = add_two(2);
    assert_eq!(result, 4);
}</code></pre>
<p>ZauwaÅ¼, Å¼e deklaracja <code>mod common;</code> jest taka sama jak deklaracja moduÅ‚u, ktÃ³rÄ… zademonstrowaliÅ›my w Listingu 7-21. NastÄ™pnie w funkcji testowej moÅ¼emy wywoÅ‚aÄ‡ funkcjÄ™ <code>common::setup()</code>.</p>
<h4 id="testy-integracyjne-dla-binarnych-skrzynek"><a class="header" href="#testy-integracyjne-dla-binarnych-skrzynek">Testy integracyjne dla binarnych skrzynek</a></h4>
<p>JeÅ›li nasz projekt jest binarnÄ… skrzynkÄ…, ktÃ³ra zawiera tylko plik <em>src/main.rs</em> i nie ma pliku <em>src/lib.rs</em>, nie moÅ¼emy tworzyÄ‡ testÃ³w integracyjnych w katalogu <em>tests</em> i wprowadzaÄ‡ funkcji zdefiniowanych w pliku <em>src/main.rs</em> do zasiÄ™gu za pomocÄ… instrukcji <code>use</code>. Tylko skrzynki biblioteczne udostÄ™pniajÄ… funkcje, ktÃ³rych mogÄ… uÅ¼ywaÄ‡ inne skrzynki; skrzynki binarne sÄ… przeznaczone do samodzielnego uruchamiania.</p>
<p>Jest to jeden z powodÃ³w, dla ktÃ³rych projekty Rust, ktÃ³re udostÄ™pniajÄ… plik binarny, majÄ… prosty plik <em>src/main.rs</em>, ktÃ³ry wywoÅ‚uje logikÄ™ znajdujÄ…cÄ… siÄ™ w pliku <em>src/lib.rs</em>. KorzystajÄ…c z tej struktury, testy integracyjne <em>mogÄ…</em> testowaÄ‡ skrzynkÄ™ bibliotecznÄ… za pomocÄ… <code>use</code>, aby udostÄ™pniÄ‡ waÅ¼nÄ… funkcjonalnoÅ›Ä‡. JeÅ›li waÅ¼na funkcjonalnoÅ›Ä‡ dziaÅ‚a, maÅ‚a iloÅ›Ä‡ kodu w pliku <em>src/main.rs</em> rÃ³wnieÅ¼ bÄ™dzie dziaÅ‚aÄ‡, a ta maÅ‚a iloÅ›Ä‡ kodu nie musi byÄ‡ testowana.</p>
<h2 id="podsumowanie-10"><a class="header" href="#podsumowanie-10">Podsumowanie</a></h2>
<p>Funkcje testowe Rust zapewniajÄ… sposÃ³b na okreÅ›lenie, jak kod powinien dziaÅ‚aÄ‡, aby zapewniÄ‡, Å¼e bÄ™dzie on nadal dziaÅ‚aÅ‚ zgodnie z oczekiwaniami, nawet po wprowadzeniu zmian. Testy jednostkowe sprawdzajÄ… rÃ³Å¼ne czÄ™Å›ci biblioteki oddzielnie i mogÄ… testowaÄ‡ prywatne szczegÃ³Å‚y implementacji. Testy integracyjne sprawdzajÄ…, czy wiele czÄ™Å›ci biblioteki dziaÅ‚a poprawnie razem, i uÅ¼ywajÄ… publicznego API biblioteki do testowania kodu w taki sam sposÃ³b, w jaki bÄ™dzie go uÅ¼ywaÅ‚ kod zewnÄ™trzny. Mimo Å¼e system typÃ³w i zasady wÅ‚asnoÅ›ci Rust pomagajÄ… zapobiegaÄ‡ niektÃ³rym rodzajom bÅ‚Ä™dÃ³w, testy sÄ… nadal waÅ¼ne, aby zmniejszyÄ‡ liczbÄ™ bÅ‚Ä™dÃ³w logicznych zwiÄ…zanych z oczekiwanym zachowaniem kodu.</p>
<p>PoÅ‚Ä…czmy wiedzÄ™ zdobytÄ… w tym i poprzednich rozdziaÅ‚ach, aby popracowaÄ‡ nad projektem!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="projekt-io-budowa-programu-wiersza-poleceÅ„"><a class="header" href="#projekt-io-budowa-programu-wiersza-poleceÅ„">Projekt I/O: Budowa programu wiersza poleceÅ„</a></h1>
<p>Ten rozdziaÅ‚ to podsumowanie wielu umiejÄ™tnoÅ›ci, ktÃ³rych nauczyÅ‚eÅ› siÄ™ do tej pory, oraz eksploracja kilku dodatkowych funkcji biblioteki standardowej. Zbudujemy narzÄ™dzie wiersza poleceÅ„, ktÃ³re bÄ™dzie wspÃ³Å‚pracowaÄ‡ z plikowym i wierszowym wejÅ›ciem/wyjÅ›ciem, aby przeÄ‡wiczyÄ‡ niektÃ³re pojÄ™cia Rust, ktÃ³re masz juÅ¼ opanowane.</p>
<p>SzybkoÅ›Ä‡, bezpieczeÅ„stwo, pojedynczy plik binarny i wsparcie miÄ™dzyplatformowe Rust sprawiajÄ…, Å¼e jest to idealny jÄ™zyk do tworzenia narzÄ™dzi wiersza poleceÅ„. Dlatego w naszym projekcie stworzymy wÅ‚asnÄ… wersjÄ™ klasycznego narzÄ™dzia wyszukiwania wiersza poleceÅ„ <code>grep</code> (<strong>g</strong>lobally search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint). W najprostszym przypadku <code>grep</code> wyszukuje w okreÅ›lonym pliku okreÅ›lony ciÄ…g znakÃ³w. Aby to zrobiÄ‡, <code>grep</code> przyjmuje jako argumenty Å›cieÅ¼kÄ™ do pliku i ciÄ…g znakÃ³w. NastÄ™pnie odczytuje plik, znajduje w nim wiersze zawierajÄ…ce argument ciÄ…gu znakÃ³w i wypisuje te wiersze.</p>
<p>Po drodze pokaÅ¼emy, jak sprawiÄ‡, by nasze narzÄ™dzie wiersza poleceÅ„ korzystaÅ‚o z funkcji terminala, ktÃ³rych uÅ¼ywa wiele innych narzÄ™dzi wiersza poleceÅ„. Odczytamy wartoÅ›Ä‡ zmiennej Å›rodowiskowej, aby umoÅ¼liwiÄ‡ uÅ¼ytkownikowi skonfigurowanie zachowania naszego narzÄ™dzia. BÄ™dziemy rÃ³wnieÅ¼ wypisywaÄ‡ komunikaty o bÅ‚Ä™dach do standardowego strumienia bÅ‚Ä™dÃ³w konsoli (<code>stderr</code>) zamiast standardowego wyjÅ›cia (<code>stdout</code>), aby na przykÅ‚ad uÅ¼ytkownik mÃ³gÅ‚ przekierowaÄ‡ udane dane wyjÅ›ciowe do pliku, nadal widzÄ…c komunikaty o bÅ‚Ä™dach na ekranie.</p>
<p>Jeden z czÅ‚onkÃ³w spoÅ‚ecznoÅ›ci Rust, Andrew Gallant, stworzyÅ‚ juÅ¼ w peÅ‚ni funkcjonalnÄ…, bardzo szybkÄ… wersjÄ™ <code>grep</code>, nazwanÄ… <code>ripgrep</code>. W porÃ³wnaniu, nasza wersja bÄ™dzie raczej prosta, ale ten rozdziaÅ‚ da ci podstawowÄ… wiedzÄ™, ktÃ³rej potrzebujesz, aby zrozumieÄ‡ rzeczywisty projekt, taki jak <code>ripgrep</code>.</p>
<p>Nasz projekt <code>grep</code> poÅ‚Ä…czy wiele pojÄ™Ä‡, ktÃ³rych nauczyÅ‚eÅ› siÄ™ do tej pory:</p>
<ul>
<li>Organizowanie kodu (<a href="#pakiety-kapsuÅ‚y-crate-i-moduÅ‚y">RozdziaÅ‚ 7</a><!-- ignore -->)</li>
<li>UÅ¼ywanie wektorÃ³w i ciÄ…gÃ³w znakÃ³w (<a href="#wspÃ³lne-kolekcje">RozdziaÅ‚ 8</a><!-- ignore -->)</li>
<li>ObsÅ‚uga bÅ‚Ä™dÃ³w (<a href="#obsÅ‚uga-bÅ‚Ä™dÃ³w">RozdziaÅ‚ 9</a><!-- ignore -->)</li>
<li>UÅ¼ywanie cech i czasÃ³w Å¼ycia tam, gdzie jest to stosowne (<a href="#typy-generyczne-cechy-i-czasy-Å¼ycia">RozdziaÅ‚ 10</a><!-- ignore -->)</li>
<li>Pisanie testÃ³w (<a href="#pisanie-automatycznych-testÃ³w">RozdziaÅ‚ 11</a><!-- ignore -->)</li>
</ul>
<p>Ponadto pokrÃ³tce przedstawimy domkniÄ™cia, iteratory i obiekty cech, ktÃ³re <a href="#funkcjonalne-cechy-jÄ™zyka-iteratory-i-domkniÄ™cia">RozdziaÅ‚ 13</a><!-- ignore --> i <a href="#cechy-programowania-zorientowanego-obiektowo">RozdziaÅ‚ 18</a><!-- ignore --> omÃ³wiÄ… szczegÃ³Å‚owo.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="akceptowanie-argumentÃ³w-wiersza-poleceÅ„-1"><a href="#akceptowanie-argumentÃ³w-wiersza-poleceÅ„-1" class="header">Akceptowanie argumentÃ³w wiersza poleceÅ„</a></h1>
<h2 id="akceptowanie-argumentÃ³w-wiersza-poleceÅ„"><a class="header" href="#akceptowanie-argumentÃ³w-wiersza-poleceÅ„">Akceptowanie argumentÃ³w wiersza poleceÅ„</a></h2>
<p>UtwÃ³rzmy nowy projekt, jak zawsze, za pomocÄ… <code>cargo new</code>. Nasz projekt nazwiemy <code>minigrep</code>, aby odrÃ³Å¼niÄ‡ go od narzÄ™dzia <code>grep</code>, ktÃ³re moÅ¼esz juÅ¼ mieÄ‡ w swoim systemie:</p>
<pre><code class="language-console">$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>Pierwszym zadaniem jest sprawienie, aby <code>minigrep</code> akceptowaÅ‚ dwa argumenty wiersza poleceÅ„: Å›cieÅ¼kÄ™ do pliku i ciÄ…g znakÃ³w do wyszukania. Oznacza to, Å¼e chcemy mÃ³c uruchamiaÄ‡ nasz program za pomocÄ… <code>cargo run</code>, dwÃ³ch myÅ›lnikÃ³w wskazujÄ…cych, Å¼e nastÄ™pujÄ…ce argumenty sÄ… przeznaczone dla naszego programu, a nie dla <code>cargo</code>, ciÄ…gu znakÃ³w do wyszukania i Å›cieÅ¼ki do pliku, w ktÃ³rym ma siÄ™ odbywaÄ‡ wyszukiwanie, w nastÄ™pujÄ…cy sposÃ³b:</p>
<pre><code class="language-console">$ cargo run -- searchstring example-filename.txt
</code></pre>
<p>Obecnie program wygenerowany przez <code>cargo new</code> nie moÅ¼e przetwarzaÄ‡ podanych mu argumentÃ³w. IstniejÄ…ce biblioteki na <a href="https://crates.io/">crates.io</a><!-- ignore --> mogÄ… pomÃ³c w pisaniu programu, ktÃ³ry akceptuje argumenty wiersza poleceÅ„, ale poniewaÅ¼ dopiero uczysz siÄ™ tej koncepcji, zaimplementujmy tÄ™ funkcjonalnoÅ›Ä‡ samodzielnie.</p>
<h3 id="odczytywanie-wartoÅ›ci-argumentÃ³w"><a class="header" href="#odczytywanie-wartoÅ›ci-argumentÃ³w">Odczytywanie wartoÅ›ci argumentÃ³w</a></h3>
<p>Aby <code>minigrep</code> mÃ³gÅ‚ odczytywaÄ‡ wartoÅ›ci argumentÃ³w wiersza poleceÅ„, ktÃ³re do niego przekazujemy, bÄ™dziemy potrzebowaÄ‡ funkcji <code>std::env::args</code> udostÄ™pnionej w standardowej bibliotece Rust. Funkcja ta zwraca iterator argumentÃ³w wiersza poleceÅ„ przekazanych do <code>minigrep</code>. WyczerpujÄ…co omÃ³wimy iteratory w <a href="#funkcjonalne-cechy-jÄ™zyka-iteratory-i-domkniÄ™cia">Rozdziale 13</a><!-- ignore -->. Na razie musisz znaÄ‡ tylko dwa szczegÃ³Å‚y dotyczÄ…ce iteratorÃ³w: iteratory produkujÄ… seriÄ™ wartoÅ›ci, a metodÄ™ <code>collect</code> moÅ¼emy wywoÅ‚aÄ‡ na iteratorze, aby zamieniÄ‡ go w kolekcjÄ™, takÄ… jak wektor, ktÃ³ra zawiera wszystkie elementy produkowane przez iterator.</p>
<p>Kod z Listingu 12-1 pozwala programowi <code>minigrep</code> odczytaÄ‡ wszelkie argumenty wiersza poleceÅ„, ktÃ³re do niego przekazano, a nastÄ™pnie zebraÄ‡ wartoÅ›ci w wektor.</p>
<listing number="12-1" file-name="src/main.rs" caption="Zbieranie argumentÃ³w wiersza poleceÅ„ w wektor i ich wypisywanie">
<pre class="playground"><code class="language-rust edition2024">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    dbg!(args);
}</code></pre>
</listing>
<p>Najpierw wprowadzamy moduÅ‚ <code>std::env</code> do zasiÄ™gu za pomocÄ… instrukcji <code>use</code>, abyÅ›my mogli uÅ¼ywaÄ‡ jego funkcji <code>args</code>. ZauwaÅ¼, Å¼e funkcja <code>std::env::args</code> jest zagnieÅ¼dÅ¼ona na dwÃ³ch poziomach moduÅ‚Ã³w. Jak omÃ³wiliÅ›my w <a href="#creating-idiomatic-use-paths">Rozdziale 7</a><!-- ignore -->, w przypadkach, gdy poÅ¼Ä…dana funkcja jest zagnieÅ¼dÅ¼ona w wiÄ™cej niÅ¼ jednym module, zdecydowaliÅ›my siÄ™ wprowadziÄ‡ moduÅ‚ nadrzÄ™dny do zasiÄ™gu, a nie funkcjÄ™. DziÄ™ki temu moÅ¼emy Å‚atwo uÅ¼ywaÄ‡ innych funkcji z <code>std::env</code>. Jest to rÃ³wnieÅ¼ mniej dwuznaczne niÅ¼ dodawanie <code>use std::env::args</code>, a nastÄ™pnie wywoÅ‚ywanie funkcji tylko za pomocÄ… <code>args</code>, poniewaÅ¼ <code>args</code> moÅ¼na by Å‚atwo pomyliÄ‡ z funkcjÄ… zdefiniowanÄ… w bieÅ¼Ä…cym module.</p>
<p>W pierwszym wierszu <code>main</code> wywoÅ‚ujemy <code>env::args</code> i natychmiast uÅ¼ywamy <code>collect</code>, aby zamieniÄ‡ iterator w wektor zawierajÄ…cy wszystkie wartoÅ›ci wyprodukowane przez iterator. MoÅ¼emy uÅ¼yÄ‡ funkcji <code>collect</code> do tworzenia wielu rodzajÃ³w kolekcji, wiÄ™c jawnie adnotujemy typ <code>args</code>, aby okreÅ›liÄ‡, Å¼e chcemy wektora ciÄ…gÃ³w znakÃ³w. ChociaÅ¼ w Rust bardzo rzadko trzeba adnotowaÄ‡ typy, <code>collect</code> jest jednÄ… z funkcji, ktÃ³rÄ… czÄ™sto trzeba adnotowaÄ‡, poniewaÅ¼ Rust nie jest w stanie wywnioskowaÄ‡, jakiego rodzaju kolekcjÄ™ chcemy.</p>
<p>Na koniec wypisujemy wektor za pomocÄ… makra debugowania. SprÃ³bujmy uruchomiÄ‡ kod najpierw bez argumentÃ³w, a nastÄ™pnie z dwoma argumentami:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[src/main.rs:5:5] args = [
    "target/debug/minigrep",
]
</code></pre>
<pre><code class="language-console">$ cargo run -- needle haystack
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep needle haystack`
[src/main.rs:5:5] args = [
    "target/debug/minigrep",
    "needle",
    "haystack",
]
</code></pre>
<p>ZauwaÅ¼, Å¼e pierwszÄ… wartoÅ›ciÄ… w wektorze jest <code>"target/debug/minigrep"</code>, co jest nazwÄ… naszego pliku binarnego. Odpowiada to zachowaniu listy argumentÃ³w w C, pozwalajÄ…c programom uÅ¼ywaÄ‡ nazwy, za pomocÄ… ktÃ³rej zostaÅ‚y wywoÅ‚ane, w swoim wykonaniu. CzÄ™sto wygodnie jest mieÄ‡ dostÄ™p do nazwy programu w przypadku, gdy chcesz jÄ… wypisaÄ‡ w komunikatach lub zmieniÄ‡ zachowanie programu na podstawie aliasu wiersza poleceÅ„, ktÃ³ry zostaÅ‚ uÅ¼yty do wywoÅ‚ania programu. Ale dla celÃ³w tego rozdziaÅ‚u zignorujemy to i zapiszemy tylko dwa argumenty, ktÃ³rych potrzebujemy.</p>
<h3 id="zapisywanie-wartoÅ›ci-argumentÃ³w-w-zmiennych"><a class="header" href="#zapisywanie-wartoÅ›ci-argumentÃ³w-w-zmiennych">Zapisywanie wartoÅ›ci argumentÃ³w w zmiennych</a></h3>
<p>Program jest obecnie w stanie uzyskaÄ‡ dostÄ™p do wartoÅ›ci okreÅ›lonych jako argumenty wiersza poleceÅ„. Teraz musimy zapisaÄ‡ wartoÅ›ci tych dwÃ³ch argumentÃ³w w zmiennych, abyÅ›my mogli uÅ¼ywaÄ‡ ich w pozostaÅ‚ej czÄ™Å›ci programu. Robimy to w Listingu 12-2.</p>
<listing number="12-2" file-name="src/main.rs" caption="Tworzenie zmiennych do przechowywania argumentu zapytania i argumentu Å›cieÅ¼ki pliku">
<pre><code class="language-rust should_panic noplayground">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let file_path = &amp;args[2];

    println!("Searching for {query}");
    println!("In file {file_path}");
}</code></pre>
</listing>
<p>Jak widzieliÅ›my, wypisujÄ…c wektor, nazwa programu zajmuje pierwszÄ… wartoÅ›Ä‡ w wektorze pod <code>args[0]</code>, wiÄ™c zaczynamy argumenty od indeksu 1. Pierwszym argumentem, ktÃ³ry przyjmuje <code>minigrep</code>, jest ciÄ…g znakÃ³w, ktÃ³rego szukamy, wiÄ™c umieszczamy referencjÄ™ do pierwszego argumentu w zmiennej <code>query</code>. Drugim argumentem bÄ™dzie Å›cieÅ¼ka do pliku, wiÄ™c umieszczamy referencjÄ™ do drugiego argumentu w zmiennej <code>file_path</code>.</p>
<p>Tymczasowo wypisujemy wartoÅ›ci tych zmiennych, aby udowodniÄ‡, Å¼e kod dziaÅ‚a zgodnie z naszym zamierzeniem. Uruchommy ten program ponownie z argumentami <code>test</code> i <code>sample.txt</code>:</p>
<pre><code class="language-console">$ cargo run -- test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
</code></pre>
<p>Åšwietnie, program dziaÅ‚a! Potrzebne nam wartoÅ›ci argumentÃ³w sÄ… zapisywane w odpowiednich zmiennych. PÃ³Åºniej dodamy obsÅ‚ugÄ™ bÅ‚Ä™dÃ³w, aby poradziÄ‡ sobie z pewnymi potencjalnie bÅ‚Ä™dnymi sytuacjami, takimi jak brak argumentÃ³w podanych przez uÅ¼ytkownika; na razie zignorujemy tÄ™ sytuacjÄ™ i zajmiemy siÄ™ dodaniem moÅ¼liwoÅ›ci odczytu plikÃ³w.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="odczytywanie-pliku-1"><a href="#odczytywanie-pliku-1" class="header">Odczytywanie pliku</a></h1>
<h2 id="odczytywanie-pliku"><a class="header" href="#odczytywanie-pliku">Odczytywanie pliku</a></h2>
<p>Teraz dodamy funkcjonalnoÅ›Ä‡ do odczytywania pliku okreÅ›lonego w argumencie <code>file_path</code>. Najpierw potrzebujemy przykÅ‚adowego pliku do przetestowania: uÅ¼yjemy pliku z niewielkÄ… iloÅ›ciÄ… tekstu na wielu liniach z kilkoma powtÃ³rzonymi sÅ‚owami. Listing 12-3 zawiera wiersz Emily Dickinson, ktÃ³ry bÄ™dzie dobrze dziaÅ‚aÅ‚! UtwÃ³rz plik o nazwie <em>poem.txt</em> w katalogu gÅ‚Ã³wnym projektu i wprowadÅº wiersz â€Iâ€™m Nobody! Who are you?â€</p>
<listing number="12-3" file-name="poem.txt" caption="Wiersz Emily Dickinson stanowi dobry przypadek testowy.">
<pre><code class="language-text">I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
</listing>
<p>Gdy tekst jest juÅ¼ na miejscu, edytuj <em>src/main.rs</em> i dodaj kod do odczytywania pliku, jak pokazano w Listingu 12-4.</p>
<listing number="12-4" file-name="src/main.rs" caption="Odczytywanie zawartoÅ›ci pliku okreÅ›lonego przez drugi argument">
<pre><code class="language-rust should_panic noplayground">use std::env;
use std::fs;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let query = &amp;args[1];
</span><span class="boring">    let file_path = &amp;args[2];
</span><span class="boring">
</span><span class="boring">    println!("Searching for {query}");
</span>    println!("In file {file_path}");

    let contents = fs::read_to_string(file_path)
        .expect("Should have been able to read the file");

    println!("With text:\n{contents}");
}</code></pre>
</listing>
<p>Najpierw wprowadzamy do zasiÄ™gu odpowiedniÄ… czÄ™Å›Ä‡ biblioteki standardowej za pomocÄ… instrukcji <code>use</code>: Potrzebujemy <code>std::fs</code> do obsÅ‚ugi plikÃ³w.</p>
<p>W <code>main</code> nowa instrukcja <code>fs::read_to_string</code> przyjmuje <code>file_path</code>, otwiera ten plik i zwraca wartoÅ›Ä‡ typu <code>std::io::Result&lt;String&gt;</code>, ktÃ³ra zawiera zawartoÅ›Ä‡ pliku.</p>
<p>NastÄ™pnie ponownie dodajemy tymczasowÄ… instrukcjÄ™ <code>println!</code>, ktÃ³ra wypisuje wartoÅ›Ä‡ <code>contents</code> po odczytaniu pliku, abyÅ›my mogli sprawdziÄ‡, czy program dziaÅ‚a do tej pory.</p>
<p>Uruchommy ten kod z dowolnym ciÄ…giem znakÃ³w jako pierwszym argumentem wiersza poleceÅ„ (poniewaÅ¼ nie zaimplementowaliÅ›my jeszcze czÄ™Å›ci wyszukiwania) i plikiem <em>poem.txt</em> jako drugim argumentem:</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>Åšwietnie! Kod odczytaÅ‚, a nastÄ™pnie wypisaÅ‚ zawartoÅ›Ä‡ pliku. Ale kod ma kilka wad. W tej chwili funkcja <code>main</code> peÅ‚ni wiele rÃ³l: parsuje argumenty i odczytuje pliki. W miarÄ™ rozrostu programu, liczba oddzielnych zadaÅ„ obsÅ‚ugiwanych przez funkcjÄ™ <code>main</code> bÄ™dzie wzrastaÄ‡. W miarÄ™ zwiÄ™kszania odpowiedzialnoÅ›ci funkcji, staje siÄ™ ona trudniejsza do zrozumienia, trudniejsza do testowania i trudniejsza do zmiany bez uszkodzenia jednej z jej czÄ™Å›ci. Najlepiej jest rozdzieliÄ‡ funkcjonalnoÅ›Ä‡ tak, aby kaÅ¼da funkcja byÅ‚a odpowiedzialna tylko za jedno zadanie.</p>
<p>Ten problem wiÄ…Å¼e siÄ™ rÃ³wnieÅ¼ z drugim problemem: chociaÅ¼ <code>query</code> i <code>file_path</code> sÄ… zmiennymi konfiguracyjnymi naszego programu, zmienne takie jak <code>contents</code> sÄ… uÅ¼ywane do wykonywania logiki programu. Im dÅ‚uÅ¼szy staje siÄ™ <code>main</code>, tym wiÄ™cej zmiennych bÄ™dziemy musieli wprowadziÄ‡ do zasiÄ™gu; im wiÄ™cej zmiennych mamy w zasiÄ™gu, tym trudniej bÄ™dzie Å›ledziÄ‡ cel kaÅ¼dej z nich. Najlepiej jest zgrupowaÄ‡ zmienne konfiguracyjne w jednÄ… strukturÄ™, aby ich cel byÅ‚ jasny.</p>
<p>Trzeci problem polega na tym, Å¼e uÅ¼yliÅ›my <code>expect</code> do wypisania komunikatu o bÅ‚Ä™dzie, gdy odczyt pliku siÄ™ nie powiedzie, ale komunikat o bÅ‚Ä™dzie wypisuje tylko <code>Should have been able to read the file</code>. Odczyt pliku moÅ¼e zakoÅ„czyÄ‡ siÄ™ niepowodzeniem na wiele sposobÃ³w: na przykÅ‚ad, plik moÅ¼e brakowaÄ‡, lub moÅ¼emy nie mieÄ‡ uprawnieÅ„ do jego otwarcia. W tej chwili, niezaleÅ¼nie od sytuacji, wypisywalibyÅ›my ten sam komunikat o bÅ‚Ä™dzie dla wszystkiego, co nie daÅ‚oby uÅ¼ytkownikowi Å¼adnych informacji!</p>
<p>Po czwarte, uÅ¼ywamy <code>expect</code> do obsÅ‚ugi bÅ‚Ä™du, a jeÅ›li uÅ¼ytkownik uruchomi nasz program bez okreÅ›lenia wystarczajÄ…cej liczby argumentÃ³w, otrzyma bÅ‚Ä…d <code>index out of bounds</code> z Rust, ktÃ³ry nie wyjaÅ›nia jasno problemu. Najlepiej byÅ‚oby, gdyby caÅ‚y kod obsÅ‚ugi bÅ‚Ä™dÃ³w znajdowaÅ‚ siÄ™ w jednym miejscu, tak aby przyszli konserwatorzy mieli tylko jedno miejsce do konsultowania kodu, jeÅ›li logika obsÅ‚ugi bÅ‚Ä™dÃ³w wymagaÅ‚a zmiany. Posiadanie caÅ‚ego kodu obsÅ‚ugi bÅ‚Ä™dÃ³w w jednym miejscu zapewni rÃ³wnieÅ¼, Å¼e bÄ™dziemy wypisywaÄ‡ komunikaty, ktÃ³re bÄ™dÄ… zrozumiaÅ‚e dla naszych uÅ¼ytkownikÃ³w koÅ„cowych.</p>
<p>Zajmiemy siÄ™ tymi czterema problemami, refaktoryzujÄ…c nasz projekt.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="refaktoryzacja-w-celu-poprawy-moduÅ‚owoÅ›ci-i-obsÅ‚ugi-bÅ‚Ä™dÃ³w-1"><a href="#refaktoryzacja-w-celu-poprawy-moduÅ‚owoÅ›ci-i-obsÅ‚ugi-bÅ‚Ä™dÃ³w-1" class="header">Refaktoryzacja w celu poprawy moduÅ‚owoÅ›ci i obsÅ‚ugi bÅ‚Ä™dÃ³w</a></h1>
<h2 id="refaktoryzacja-w-celu-poprawy-moduÅ‚owoÅ›ci-i-obsÅ‚ugi-bÅ‚Ä™dÃ³w"><a class="header" href="#refaktoryzacja-w-celu-poprawy-moduÅ‚owoÅ›ci-i-obsÅ‚ugi-bÅ‚Ä™dÃ³w">Refaktoryzacja w celu poprawy moduÅ‚owoÅ›ci i obsÅ‚ugi bÅ‚Ä™dÃ³w</a></h2>
<p>Aby ulepszyÄ‡ nasz program, naprawimy cztery problemy zwiÄ…zane ze strukturÄ…
programu i sposobem obsÅ‚ugi potencjalnych bÅ‚Ä™dÃ³w. Po pierwsze, nasza funkcja
<code>main</code> wykonuje teraz dwa zadania: parsuje argumenty i odczytuje pliki. W
miarÄ™ rozwoju programu liczba oddzielnych zadaÅ„, ktÃ³re obsÅ‚uguje funkcja
<code>main</code>, bÄ™dzie rosÅ‚a. Gdy funkcja zyskuje nowe obowiÄ…zki, staje siÄ™ trudniejsza
do zrozumienia, trudniejsza do testowania i trudniejsza do zmiany bez
uszkodzenia jednej z jej czÄ™Å›ci. Najlepiej jest oddzieliÄ‡ funkcjonalnoÅ›Ä‡,
tak aby kaÅ¼da funkcja byÅ‚a odpowiedzialna za jedno zadanie.</p>
<p>Ten problem wiÄ…Å¼e siÄ™ rÃ³wnieÅ¼ z drugim problemem: chociaÅ¼ <code>query</code> i
<code>file_path</code> sÄ… zmiennymi konfiguracyjnymi naszego programu, zmienne takie jak
<code>contents</code> sÄ… uÅ¼ywane do wykonywania logiki programu. Im dÅ‚uÅ¼szy staje siÄ™
<code>main</code>, tym wiÄ™cej zmiennych bÄ™dziemy musieli wprowadziÄ‡ do zakresu; im wiÄ™cej
zmiennych mamy w zakresie, tym trudniej bÄ™dzie Å›ledziÄ‡ cel kaÅ¼dej z nich.
Najlepiej jest pogrupowaÄ‡ zmienne konfiguracyjne w jednÄ… strukturÄ™, aby ich cel
byÅ‚ jasny.</p>
<p>Trzeci problem polega na tym, Å¼e uÅ¼yliÅ›my <code>expect</code> do wyÅ›wietlenia
komunikatu o bÅ‚Ä™dzie, gdy odczyt pliku nie powiÃ³dÅ‚ siÄ™, ale komunikat o
bÅ‚Ä™dzie po prostu wyÅ›wietla <code>Should have been able to read the file</code>. Odczyt
pliku moÅ¼e zakoÅ„czyÄ‡ siÄ™ niepowodzeniem na wiele sposobÃ³w: na przykÅ‚ad plik
moÅ¼e brakowaÄ‡ lub moÅ¼emy nie mieÄ‡ uprawnieÅ„ do jego otwarcia. Obecnie,
niezaleÅ¼nie od sytuacji, wyÅ›wietlalibyÅ›my ten sam komunikat o bÅ‚Ä™dzie dla
wszystkiego, co nie dostarczyÅ‚oby uÅ¼ytkownikowi Å¼adnych informacji!</p>
<p>Po czwarte, uÅ¼ywamy <code>expect</code> do obsÅ‚ugi bÅ‚Ä™du, a jeÅ›li uÅ¼ytkownik uruchomi nasz
program bez podania wystarczajÄ…cej liczby argumentÃ³w, otrzyma bÅ‚Ä…d <code>index out of bounds</code> z Rusta, ktÃ³ry nie wyjaÅ›nia jasno problemu. ByÅ‚oby najlepiej,
gdyby caÅ‚y kod obsÅ‚ugi bÅ‚Ä™dÃ³w znajdowaÅ‚ siÄ™ w jednym miejscu, tak aby przyszli
utrzymujÄ…cy mieli tylko jedno miejsce do konsultowania kodu, jeÅ›li logika
obsÅ‚ugi bÅ‚Ä™dÃ³w wymagaÅ‚aby zmiany. Posiadanie caÅ‚ego kodu obsÅ‚ugi bÅ‚Ä™dÃ³w w
jednym miejscu zapewni rÃ³wnieÅ¼, Å¼e wyÅ›wietlamy komunikaty, ktÃ³re bÄ™dÄ…
zrozumiaÅ‚e dla naszych uÅ¼ytkownikÃ³w koÅ„cowych.</p>
<p>RozwiÄ…Å¼emy te cztery problemy, refaktoryzujÄ…c nasz projekt.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="separation-of-concerns-for-binary-projects"></a></p>
<h3 id="rozdzielanie-odpowiedzialnoÅ›ci-w-projektach-binarnych"><a class="header" href="#rozdzielanie-odpowiedzialnoÅ›ci-w-projektach-binarnych">Rozdzielanie odpowiedzialnoÅ›ci w projektach binarnych</a></h3>
<p>Problem organizacyjny polegajÄ…cy na przypisywaniu funkcji <code>main</code>
odpowiedzialnoÅ›ci za wiele zadaÅ„ jest powszechny w wielu projektach
binarnych. W rezultacie wielu programistÃ³w Rust uwaÅ¼a za przydatne
rozdzielenie rÃ³Å¼nych aspektÃ³w programu binarnego, gdy funkcja <code>main</code> staje
siÄ™ zbyt duÅ¼a. Proces ten obejmuje nastÄ™pujÄ…ce kroki:</p>
<ul>
<li>Podziel program na pliki <em>main.rs</em> i <em>lib.rs</em> i przenieÅ› logikÄ™ programu
do <em>lib.rs</em>.</li>
<li>DopÃ³ki logika parsowania wiersza poleceÅ„ jest maÅ‚a, moÅ¼e pozostaÄ‡ w
funkcji <code>main</code>.</li>
<li>Kiedy logika parsowania wiersza poleceÅ„ zaczyna siÄ™ komplikowaÄ‡, wyodrÄ™bnij
jÄ… z funkcji <code>main</code> do innych funkcji lub typÃ³w.</li>
</ul>
<p>ObowiÄ…zki, ktÃ³re pozostajÄ… w funkcji <code>main</code> po tym procesie, powinny byÄ‡
ograniczone do nastÄ™pujÄ…cych:</p>
<ul>
<li>WywoÅ‚anie logiki parsowania wiersza poleceÅ„ z wartoÅ›ciami argumentÃ³w</li>
<li>Ustawienie wszelkich innych konfiguracji</li>
<li>WywoÅ‚anie funkcji <code>run</code> w <em>lib.rs</em></li>
<li>ObsÅ‚uga bÅ‚Ä™du, jeÅ›li <code>run</code> zwrÃ³ci bÅ‚Ä…d</li>
</ul>
<p>Ten wzorzec polega na rozdzieleniu odpowiedzialnoÅ›ci: <em>main.rs</em> zajmuje siÄ™
uruchamianiem programu, a <em>lib.rs</em> obsÅ‚uguje caÅ‚Ä… logikÄ™ bieÅ¼Ä…cego zadania.
PoniewaÅ¼ nie moÅ¼na bezpoÅ›rednio testowaÄ‡ funkcji <code>main</code>, ta struktura pozwala
testowaÄ‡ caÅ‚Ä… logikÄ™ programu, przenoszÄ…c jÄ… poza funkcjÄ™ <code>main</code>. Kod,
ktÃ³ry pozostaje w funkcji <code>main</code>, bÄ™dzie wystarczajÄ…co maÅ‚y, aby zweryfikowaÄ‡
jego poprawnoÅ›Ä‡ poprzez odczytanie. PrzerÃ³bmy nasz program, postÄ™pujÄ…c
zgodnie z tym procesem.</p>
<h4 id="wyodrÄ™bnianie-parsera-argumentÃ³w"><a class="header" href="#wyodrÄ™bnianie-parsera-argumentÃ³w">WyodrÄ™bnianie parsera argumentÃ³w</a></h4>
<p>WyodrÄ™bnimy funkcjonalnoÅ›Ä‡ parsowania argumentÃ³w do funkcji, ktÃ³rÄ… wywoÅ‚a <code>main</code>.
Listing 12-5 pokazuje nowy poczÄ…tek funkcji <code>main</code>, ktÃ³ra wywoÅ‚uje nowÄ… funkcjÄ™
<code>parse_config</code>, ktÃ³rÄ… zdefiniujemy w <em>src/main.rs</em>.</p>
<figure class="listing" id="listing-12-5">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, file_path) = parse_config(&amp;args);

    // --snip--
<span class="boring">
</span><span class="boring">    println!("Searching for {query}");
</span><span class="boring">    println!("In file {file_path}");
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let file_path = &amp;args[2];

    (query, file_path)
}</code></pre>
<figcaption><a href="#listing-12-5">Listing 12-5</a>: WyodrÄ™bnianie funkcji <code>parse_config</code> z <code>main</code></figcaption>
</figure>
<p>Nadal zbieramy argumenty wiersza poleceÅ„ do wektora, ale zamiast przypisywaÄ‡
wartoÅ›Ä‡ argumentu pod indeksem 1 do zmiennej <code>query</code> i wartoÅ›Ä‡ argumentu pod
indeksem 2 do zmiennej <code>file_path</code> w funkcji <code>main</code>, przekazujemy caÅ‚y wektor
do funkcji <code>parse_config</code>. Funkcja <code>parse_config</code> zawiera nastÄ™pnie logikÄ™,
ktÃ³ra okreÅ›la, ktÃ³ry argument trafia do ktÃ³rej zmiennej i przekazuje wartoÅ›ci
z powrotem do <code>main</code>. Nadal tworzymy zmienne <code>query</code> i <code>file_path</code> w <code>main</code>,
ale <code>main</code> nie jest juÅ¼ odpowiedzialny za okreÅ›lanie, jak argumenty wiersza
poleceÅ„ i zmienne odpowiadajÄ… sobie.</p>
<p>Ta przerÃ³bka moÅ¼e wydawaÄ‡ siÄ™ przesadna dla naszego maÅ‚ego programu, ale
refaktoryzujemy jÄ… maÅ‚ymi, przyrostowymi krokami. Po dokonaniu tej zmiany,
uruchom program ponownie, aby sprawdziÄ‡, czy parsowanie argumentÃ³w nadal
dziaÅ‚a. Dobrze jest czÄ™sto sprawdzaÄ‡ postÄ™py, aby pomÃ³c zidentyfikowaÄ‡ przyczynÄ™
problemÃ³w, gdy siÄ™ pojawiÄ….</p>
<h4 id="grupowanie-wartoÅ›ci-konfiguracyjnych"><a class="header" href="#grupowanie-wartoÅ›ci-konfiguracyjnych">Grupowanie wartoÅ›ci konfiguracyjnych</a></h4>
<p>MoÅ¼emy podjÄ…Ä‡ kolejny maÅ‚y krok, aby jeszcze bardziej ulepszyÄ‡ funkcjÄ™
<code>parse_config</code>. W tej chwili zwracamy krotkÄ™, ale natychmiast rozbijamy tÄ™
krotkÄ™ ponownie na pojedyncze czÄ™Å›ci. Jest to znak, Å¼e byÄ‡ moÅ¼e nie mamy
jeszcze odpowiedniej abstrakcji.</p>
<p>Inny wskaÅºnik, ktÃ³ry pokazuje, Å¼e jest miejsce na ulepszenia, to czÄ™Å›Ä‡ <code>config</code>
w <code>parse_config</code>, co implikuje, Å¼e dwie zwracane wartoÅ›ci sÄ… powiÄ…zane i obie
sÄ… czÄ™Å›ciÄ… jednej wartoÅ›ci konfiguracyjnej. Obecnie nie przekazujemy tego
znaczenia w strukturze danych inaczej niÅ¼ poprzez grupowanie dwÃ³ch wartoÅ›ci w
krotkÄ™; zamiast tego umieÅ›cimy dwie wartoÅ›ci w jednej strukturze i nadamy
kaÅ¼demu z pÃ³l struktury znaczÄ…cÄ… nazwÄ™. Zrobienie tego uÅ‚atwi przyszÅ‚ym
utrzymujÄ…cym ten kod zrozumienie, jak rÃ³Å¼ne wartoÅ›ci sÄ… ze sobÄ… powiÄ…zane i
jaki jest ich cel.</p>
<p>Listing 12-6 pokazuje ulepszenia funkcji <code>parse_config</code>.</p>
<figure class="listing" id="listing-12-6">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    let contents = fs::read_to_string(config.file_path)
        .expect("Should have been able to read the file");

    // --snip--
<span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>}

struct Config {
    query: String,
    file_path: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let file_path = args[2].clone();

    Config { query, file_path }
}</code></pre>
<figcaption><a href="#listing-12-6">Listing 12-6</a>: Refaktoryzacja <code>parse_config</code> w celu zwrÃ³cenia instancji struktury <code>Config</code></figcaption>
</figure>
<p>DodaliÅ›my strukturÄ™ o nazwie <code>Config</code> z polami <code>query</code> i <code>file_path</code>. Sygnatura
<code>parse_config</code> wskazuje teraz, Å¼e zwraca wartoÅ›Ä‡ <code>Config</code>. W ciele <code>parse_config</code>,
gdzie wczeÅ›niej zwracaliÅ›my wycinki stringÃ³w, ktÃ³re odwoÅ‚ywaÅ‚y siÄ™ do wartoÅ›ci
<code>String</code> w <code>args</code>, teraz definiujemy <code>Config</code> tak, aby zawieraÅ‚ wÅ‚asne wartoÅ›ci
<code>String</code>. Zmienna <code>args</code> w <code>main</code> jest wÅ‚aÅ›cicielem wartoÅ›ci argumentÃ³w i tylko
pozwala funkcji <code>parse_config</code> je poÅ¼yczyÄ‡, co oznacza, Å¼e naruszylibyÅ›my zasady
poÅ¼yczania Rusta, gdyby <code>Config</code> prÃ³bowaÅ‚o przejÄ…Ä‡ wÅ‚asnoÅ›Ä‡ wartoÅ›ci w <code>args</code>.</p>
<p>Istnieje wiele sposobÃ³w zarzÄ…dzania danymi <code>String</code>; najÅ‚atwiejsza, choÄ‡
nieco nieefektywna, droga to wywoÅ‚anie metody <code>clone</code> na wartoÅ›ciach. Spowoduje
to peÅ‚nÄ… kopiÄ™ danych dla instancji <code>Config</code>, co zajmuje wiÄ™cej czasu i pamiÄ™ci
niÅ¼ przechowywanie referencji do danych ciÄ…gu znakÃ³w. Jednak klonowanie danych
rÃ³wnieÅ¼ sprawia, Å¼e nasz kod jest bardzo prosty, poniewaÅ¼ nie musimy
zarzÄ…dzaÄ‡ czasami Å¼ycia referencji; w tych okolicznoÅ›ciach, rezygnacja z
nieco wydajnoÅ›ci na rzecz prostoty jest opÅ‚acalnym kompromisem.</p>
<section class="note" aria-role="note">
<h3 id="kompromisy-zwiÄ…zane-z-uÅ¼ywaniem-clone"><a class="header" href="#kompromisy-zwiÄ…zane-z-uÅ¼ywaniem-clone">Kompromisy zwiÄ…zane z uÅ¼ywaniem <code>clone</code></a></h3>
<p>Wielu programistÃ³w Rusta ma tendencjÄ™ do unikania uÅ¼ywania <code>clone</code> do
naprawiania problemÃ³w z wÅ‚asnoÅ›ciÄ… ze wzglÄ™du na jego koszt wykonawczy.
W <a href="#funkcjonalne-cechy-jÄ™zyka-iteratory-i-domkniÄ™cia">Rozdziale 13</a><!-- ignore --> dowiesz siÄ™, jak uÅ¼ywaÄ‡ bardziej
efektywnych metod w tego typu sytuacjach. Ale na razie w porzÄ…dku jest
kopiowanie kilku ciÄ…gÃ³w znakÃ³w, aby kontynuowaÄ‡ postÄ™p, poniewaÅ¼ te kopie
zrobisz tylko raz, a Å›cieÅ¼ka pliku i ciÄ…g zapytania sÄ… bardzo maÅ‚e. Lepiej
mieÄ‡ dziaÅ‚ajÄ…cy program, ktÃ³ry jest nieco nieefektywny, niÅ¼ prÃ³bowaÄ‡
hiperoptymalizowaÄ‡ kod za pierwszym razem. W miarÄ™ zdobywania doÅ›wiadczenia
z Rustem, Å‚atwiej bÄ™dzie zaczÄ…Ä‡ od najbardziej efektywnego rozwiÄ…zania, ale na
razie, uÅ¼ywanie <code>clone</code> jest caÅ‚kowicie akceptowalne.</p>
</section>
<p>ZaktualizowaliÅ›my <code>main</code> tak, aby umieszczaÅ‚ instancjÄ™ <code>Config</code> zwrÃ³conÄ… przez
<code>parse_config</code> w zmiennej o nazwie <code>config</code>, i zaktualizowaliÅ›my kod, ktÃ³ry
wczeÅ›niej uÅ¼ywaÅ‚ oddzielnych zmiennych <code>query</code> i <code>file_path</code>, tak aby teraz
uÅ¼ywaÅ‚ pÃ³l struktury <code>Config</code>.</p>
<p>Teraz nasz kod jaÅ›niej przekazuje, Å¼e <code>query</code> i <code>file_path</code> sÄ… ze sobÄ…
powiÄ…zane i Å¼e ich celem jest konfigurowanie dziaÅ‚ania programu. KaÅ¼dy kod,
ktÃ³ry uÅ¼ywa tych wartoÅ›ci, wie, Å¼e znajdzie je w instancji <code>config</code> w polach
nazwanych zgodnie z ich przeznaczeniem.</p>
<h4 id="tworzenie-konstruktora-dla-config"><a class="header" href="#tworzenie-konstruktora-dla-config">Tworzenie konstruktora dla <code>Config</code></a></h4>
<p>Do tej pory wyodrÄ™bniliÅ›my logikÄ™ odpowiedzialnÄ… za parsowanie argumentÃ³w
wiersza poleceÅ„ z <code>main</code> i umieÅ›ciliÅ›my jÄ… w funkcji <code>parse_config</code>. DziÄ™ki
temu zauwaÅ¼yliÅ›my, Å¼e wartoÅ›ci <code>query</code> i <code>file_path</code> byÅ‚y ze sobÄ… powiÄ…zane,
i ten zwiÄ…zek powinien byÄ‡ przekazany w naszym kodzie. NastÄ™pnie dodaliÅ›my
strukturÄ™ <code>Config</code>, aby nazwaÄ‡ powiÄ…zane przeznaczenie <code>query</code> i <code>file_path</code>
oraz mÃ³c zwracaÄ‡ nazwy wartoÅ›ci jako nazwy pÃ³l struktury z funkcji
<code>parse_config</code>.</p>
<p>Skoro teraz celem funkcji <code>parse_config</code> jest stworzenie instancji <code>Config</code>,
moÅ¼emy zmieniÄ‡ <code>parse_config</code> z prostej funkcji na funkcjÄ™ o nazwie <code>new</code>,
ktÃ³ra jest skojarzona ze strukturÄ… <code>Config</code>. Ta zmiana sprawi, Å¼e kod bÄ™dzie
bardziej idiomatyczny. MoÅ¼emy tworzyÄ‡ instancje typÃ³w w standardowej bibliotece,
takich jak <code>String</code>, wywoÅ‚ujÄ…c <code>String::new</code>. Podobnie, zmieniajÄ…c
<code>parse_config</code> na funkcjÄ™ <code>new</code> skojarzonÄ… z <code>Config</code>, bÄ™dziemy mogli tworzyÄ‡
instancje <code>Config</code>, wywoÅ‚ujÄ…c <code>Config::new</code>. Listing 12-7 pokazuje zmiany, ktÃ³re
musimy wprowadziÄ‡.</p>
<figure class="listing" id="listing-12-7">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>
    // --snip--
}

// --snip--

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let file_path = args[2].clone();

        Config { query, file_path }
    }
}</code></pre>
<figcaption><a href="#listing-12-7">Listing 12-7</a>: Zmiana <code>parse_config</code> na <code>Config::new</code></figcaption>
</figure>
<p>ZaktualizowaliÅ›my <code>main</code>, gdzie wywoÅ‚ywaliÅ›my <code>parse_config</code>, aby zamiast tego
wywoÅ‚ywaÄ‡ <code>Config::new</code>. ZmieniliÅ›my nazwÄ™ <code>parse_config</code> na <code>new</code> i przenieÅ›liÅ›my
jÄ… do bloku <code>impl</code>, co wiÄ…Å¼e funkcjÄ™ <code>new</code> z <code>Config</code>. SprÃ³buj ponownie
skompilowaÄ‡ ten kod, aby upewniÄ‡ siÄ™, Å¼e dziaÅ‚a.</p>
<h3 id="naprawa-obsÅ‚ugi-bÅ‚Ä™dÃ³w"><a class="header" href="#naprawa-obsÅ‚ugi-bÅ‚Ä™dÃ³w">Naprawa obsÅ‚ugi bÅ‚Ä™dÃ³w</a></h3>
<p>Teraz zajmiemy siÄ™ naprawÄ… obsÅ‚ugi bÅ‚Ä™dÃ³w. Przypomnijmy, Å¼e prÃ³ba uzyskania
dostÄ™pu do wartoÅ›ci w wektorze <code>args</code> pod indeksem 1 lub 2 spowoduje panikÄ™
programu, jeÅ›li wektor zawiera mniej niÅ¼ trzy elementy. SprÃ³buj uruchomiÄ‡
program bez Å¼adnych argumentÃ³w; bÄ™dzie to wyglÄ…daÅ‚o tak:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`

thread 'main' panicked at src/main.rs:27:21:
index out of bounds: the len is 1 but the index is 1
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Linia <code>index out of bounds: the len is 1 but the index is 1</code> to komunikat o
bÅ‚Ä™dzie przeznaczony dla programistÃ³w. Nie pomoÅ¼e on naszym uÅ¼ytkownikom
koÅ„cowym zrozumieÄ‡, co powinni zrobiÄ‡ zamiast tego. Naprawmy to teraz.</p>
<h4 id="ulepszanie-komunikatu-o-bÅ‚Ä™dzie"><a class="header" href="#ulepszanie-komunikatu-o-bÅ‚Ä™dzie">Ulepszanie komunikatu o bÅ‚Ä™dzie</a></h4>
<p>W Listingu 12-8 dodajemy w funkcji <code>new</code> sprawdzenie, czy wycinek jest
wystarczajÄ…co dÅ‚ugi, zanim uzyska dostÄ™p do indeksu 1 i 2. JeÅ›li wycinek nie
jest wystarczajÄ…co dÅ‚ugi, program panikuje i wyÅ›wietla lepszy komunikat o bÅ‚Ä™dzie.</p>
<figure class="listing" id="listing-12-8">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // --snip--
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!("not enough arguments");
        }
        // --snip--
<span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { query, file_path }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-12-8">Listing 12-8</a>: Dodawanie sprawdzenia liczby argumentÃ³w</figcaption>
</figure>
<p>Ten kod jest podobny do <a href="#creating-custom-types-for-validation">funkcji <code>Guess::new</code>, ktÃ³rÄ… napisaliÅ›my w Listingu
9-13</a><!-- ignore -->, gdzie wywoÅ‚aliÅ›my <code>panic!</code>, gdy
argument <code>value</code> byÅ‚ poza zakresem prawidÅ‚owych wartoÅ›ci. Zamiast sprawdzaÄ‡
zakres wartoÅ›ci tutaj, sprawdzamy, czy dÅ‚ugoÅ›Ä‡ <code>args</code> wynosi co najmniej <code>3</code>,
a reszta funkcji moÅ¼e dziaÅ‚aÄ‡, zakÅ‚adajÄ…c, Å¼e ten warunek zostaÅ‚ speÅ‚niony.
JeÅ›li <code>args</code> ma mniej niÅ¼ trzy elementy, ten warunek bÄ™dzie <code>true</code> i wywoÅ‚amy
makro <code>panic!</code>, aby natychmiast zakoÅ„czyÄ‡ program.</p>
<p>Z tymi dodatkowymi kilkoma liniami kodu w <code>new</code>, uruchommy program ponownie bez
Å¼adnych argumentÃ³w, aby zobaczyÄ‡, jak teraz wyglÄ…da bÅ‚Ä…d:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`

thread 'main' panicked at src/main.rs:26:13:
not enough arguments
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Ten wynik jest lepszy: mamy teraz rozsÄ…dny komunikat o bÅ‚Ä™dzie. Mamy jednak
takÅ¼e zbÄ™dne informacje, ktÃ³rych nie chcemy przekazywaÄ‡ naszym uÅ¼ytkownikom.
ByÄ‡ moÅ¼e technika, ktÃ³rej uÅ¼yliÅ›my w Listingu 9-13, nie jest tutaj najlepsza:
wywoÅ‚anie <code>panic!</code> jest bardziej odpowiednie dla problemu programistycznego niÅ¼
problemu z uÅ¼yciem, <a href="#guidelines-for-error-handling">jak omÃ³wiono w Rozdziale
9</a><!-- ignore -->. Zamiast tego, uÅ¼yjemy innej
techniki, o ktÃ³rej dowiedziaÅ‚eÅ› siÄ™ w Rozdziale 9 â€“ <a href="#bÅ‚Ä™dy-odzyskiwalne-za-pomocÄ…-result-1">zwracania
<code>Result</code></a><!-- ignore -->, ktÃ³ry wskazuje na sukces lub bÅ‚Ä…d.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="returning-a-result-from-new-instead-of-calling-panic"></a></p>
<h4 id="zwracanie-result-zamiast-wywoÅ‚ywania-panic"><a class="header" href="#zwracanie-result-zamiast-wywoÅ‚ywania-panic">Zwracanie <code>Result</code> zamiast wywoÅ‚ywania <code>panic!</code></a></h4>
<p>Zamiast tego moÅ¼emy zwrÃ³ciÄ‡ wartoÅ›Ä‡ <code>Result</code>, ktÃ³ra bÄ™dzie zawieraÅ‚a instancjÄ™
<code>Config</code> w przypadku sukcesu i bÄ™dzie opisywaÄ‡ problem w przypadku bÅ‚Ä™du.
Zmienimy rÃ³wnieÅ¼ nazwÄ™ funkcji z <code>new</code> na <code>build</code>, poniewaÅ¼ wielu
programistÃ³w oczekuje, Å¼e funkcje <code>new</code> nigdy nie zawiodÄ…. Kiedy <code>Config::build</code>
komunikuje siÄ™ z <code>main</code>, moÅ¼emy uÅ¼yÄ‡ typu <code>Result</code>, aby zasygnalizowaÄ‡,
Å¼e wystÄ…piÅ‚ problem. NastÄ™pnie moÅ¼emy zmieniÄ‡ <code>main</code>, aby przeksztaÅ‚ciÄ‡
wariant <code>Err</code> w bardziej praktyczny bÅ‚Ä…d dla naszych uÅ¼ytkownikÃ³w, bez
otaczajÄ…cego tekstu o <code>thread 'main'</code> i <code>RUST_BACKTRACE</code>, ktÃ³re powoduje
wywoÅ‚anie <code>panic!</code>.</p>
<p>Listing 12-9 pokazuje zmiany, ktÃ³re musimy wprowadziÄ‡ w wartoÅ›ci zwracanej
funkcji, ktÃ³rÄ… teraz nazywamy <code>Config::build</code>, oraz w ciele funkcji
potrzebnym do zwrÃ³cenia <code>Result</code>. ZauwaÅ¼, Å¼e to siÄ™ nie skompiluje, dopÃ³ki nie
zaktualizujemy rÃ³wnieÅ¼ <code>main</code>, co zrobimy w nastÄ™pnym listingu.</p>
<figure class="listing" id="listing-12-9">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        Ok(Config { query, file_path })
    }
}</code></pre>
<figcaption><a href="#listing-12-9">Listing 12-9</a>: Zwracanie <code>Result</code> z <code>Config::build</code></figcaption>
</figure>
<p>Nasza funkcja <code>build</code> zwraca <code>Result</code> z instancjÄ… <code>Config</code> w przypadku
pomyÅ›lnoÅ›ci i literaÅ‚em ciÄ…gu znakÃ³w w przypadku bÅ‚Ä™du. Nasze wartoÅ›ci bÅ‚Ä™dÃ³w
bÄ™dÄ… zawsze literaÅ‚ami ciÄ…gu znakÃ³w, ktÃ³re majÄ… czas Å¼ycia <code>'static</code>.</p>
<p>DokonaliÅ›my dwÃ³ch zmian w ciele funkcji: zamiast wywoÅ‚ywaÄ‡ <code>panic!</code> gdy
uÅ¼ytkownik nie przekaÅ¼e wystarczajÄ…cej liczby argumentÃ³w, teraz zwracamy
wartoÅ›Ä‡ <code>Err</code>, a wartoÅ›Ä‡ zwracanÄ… <code>Config</code> opakowaliÅ›my w <code>Ok</code>. Te zmiany
sprawiajÄ…, Å¼e funkcja jest zgodna z nowym podpisem typu.</p>
<p>Zwracanie wartoÅ›ci <code>Err</code> z <code>Config::build</code> pozwala funkcji <code>main</code> obsÅ‚uÅ¼yÄ‡
wartoÅ›Ä‡ <code>Result</code> zwrÃ³conÄ… z funkcji <code>build</code> i czysto zakoÅ„czyÄ‡ proces w
przypadku bÅ‚Ä™du.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="calling-confignew-and-handling-errors"></a></p>
<h4 id="wywoÅ‚ywanie-configbuild-i-obsÅ‚uga-bÅ‚Ä™dÃ³w"><a class="header" href="#wywoÅ‚ywanie-configbuild-i-obsÅ‚uga-bÅ‚Ä™dÃ³w">WywoÅ‚ywanie <code>Config::build</code> i obsÅ‚uga bÅ‚Ä™dÃ³w</a></h4>
<p>Aby obsÅ‚uÅ¼yÄ‡ przypadek bÅ‚Ä™du i wyÅ›wietliÄ‡ komunikat zrozumiaÅ‚y dla uÅ¼ytkownika,
musimy zaktualizowaÄ‡ <code>main</code> w celu obsÅ‚ugi <code>Result</code> zwracanego przez
<code>Config::build</code>, jak pokazano w Listingu 12-10. Przejmiemy rÃ³wnieÅ¼
odpowiedzialnoÅ›Ä‡ za zakoÅ„czenie narzÄ™dzia wiersza poleceÅ„ z niezerowym kodem
bÅ‚Ä™du zamiast <code>panic!</code> i zaimplementujemy to rÄ™cznie. Niezerowy status
wyjÅ›cia jest konwencjÄ… sygnalizujÄ…cÄ… procesowi, ktÃ³ry wywoÅ‚aÅ‚ nasz program, Å¼e
program zakoÅ„czyÅ‚ dziaÅ‚anie ze stanem bÅ‚Ä™du.</p>
<figure class="listing" id="listing-12-10">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-12-10">Listing 12-10</a>: WyjÅ›cie z kodem bÅ‚Ä™du, jeÅ›li budowanie <code>Config</code> zawiedzie</figcaption>
</figure>
<p>W tym listingu uÅ¼yliÅ›my metody, ktÃ³rej jeszcze szczegÃ³Å‚owo nie omÃ³wiliÅ›my:
<code>unwrap_or_else</code>, ktÃ³ra jest zdefiniowana w <code>Result&lt;T, E&gt;</code> przez standardowÄ…
bibliotekÄ™. UÅ¼ycie <code>unwrap_or_else</code> pozwala nam zdefiniowaÄ‡ niestandardowÄ…,
nie-<code>panic!</code> obsÅ‚ugÄ™ bÅ‚Ä™dÃ³w. JeÅ›li <code>Result</code> jest wartoÅ›ciÄ… <code>Ok</code>, zachowanie
tej metody jest podobne do <code>unwrap</code>: zwraca wewnÄ™trznÄ… wartoÅ›Ä‡, ktÃ³rÄ… opakowuje
<code>Ok</code>. Jednak jeÅ›li wartoÅ›Ä‡ jest wartoÅ›ciÄ… <code>Err</code>, ta metoda wywoÅ‚uje kod w
zamkniÄ™ciu, ktÃ³re jest anonimowÄ… funkcjÄ…, ktÃ³rÄ… definiujemy i przekazujemy jako
argument do <code>unwrap_or_else</code>. ZamkniÄ™cia omÃ³wimy bardziej szczegÃ³Å‚owo w
<a href="#funkcjonalne-cechy-jÄ™zyka-iteratory-i-domkniÄ™cia">Rozdziale 13</a><!-- ignore -->. Na razie wystarczy wiedzieÄ‡, Å¼e
<code>unwrap_or_else</code> przekaÅ¼e wewnÄ™trznÄ… wartoÅ›Ä‡ <code>Err</code>, ktÃ³ra w tym przypadku jest
statycznym ciÄ…giem znakÃ³w <code>"not enough arguments"</code>, ktÃ³ry dodaliÅ›my w Listingu
12-9, do naszego zamkniÄ™cia w argumencie <code>err</code>, ktÃ³ry pojawia siÄ™ miÄ™dzy
pionowymi kreskami. Kod w zamkniÄ™ciu moÅ¼e nastÄ™pnie uÅ¼yÄ‡ wartoÅ›ci <code>err</code>, gdy
bÄ™dzie dziaÅ‚aÅ‚.</p>
<p>DodaliÅ›my nowÄ… liniÄ™ <code>use</code>, aby wprowadziÄ‡ <code>process</code> ze standardowej biblioteki
do zakresu. Kod w zamkniÄ™ciu, ktÃ³ry zostanie uruchomiony w przypadku bÅ‚Ä™du,
skÅ‚ada siÄ™ tylko z dwÃ³ch linii: wyÅ›wietlamy <code>err</code>, a nastÄ™pnie wywoÅ‚ujemy
<code>process::exit</code>. Funkcja <code>process::exit</code> natychmiast zatrzyma program i zwrÃ³ci
liczbÄ™, ktÃ³ra zostaÅ‚a przekazana jako kod statusu wyjÅ›cia. Jest to podobne do
obsÅ‚ugi opartej na <code>panic!</code>, ktÃ³rej uÅ¼yliÅ›my w Listingu 12-8, ale nie
otrzymujemy juÅ¼ wszystkich dodatkowych danych wyjÅ›ciowych. SprÃ³bujmy:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>Åšwietnie! Ten wynik jest znacznie bardziej przyjazny dla naszych uÅ¼ytkownikÃ³w.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="extracting-logic-from-the-main-function"></a></p>
<h3 id="wyodrÄ™bnianie-logiki-z-funkcji-main"><a class="header" href="#wyodrÄ™bnianie-logiki-z-funkcji-main">WyodrÄ™bnianie logiki z funkcji <code>main</code></a></h3>
<p>Teraz, gdy zakoÅ„czyliÅ›my refaktoryzacjÄ™ parsowania konfiguracji, zajmijmy siÄ™
logikÄ… programu. Jak stwierdziliÅ›my w sekcji <a href="#separation-of-concerns-for-binary-projects">â€Rozdzielanie odpowiedzialnoÅ›ci w
projektach binarnychâ€</a><!--
ignore -->, wyodrÄ™bnimy funkcjÄ™ o nazwie <code>run</code>, ktÃ³ra bÄ™dzie zawieraÅ‚a caÅ‚Ä…
logikÄ™ znajdujÄ…cÄ… siÄ™ obecnie w funkcji <code>main</code>, niezwiÄ…zanÄ… z konfigurowaniem
ani obsÅ‚ugÄ… bÅ‚Ä™dÃ³w. Po zakoÅ„czeniu funkcja <code>main</code> bÄ™dzie zwiÄ™zÅ‚a i Å‚atwa do
weryfikacji poprzez inspekcjÄ™, a my bÄ™dziemy mogli pisaÄ‡ testy dla caÅ‚ej
pPozostaÅ‚ej logiki.</p>
<p>Listing 12-11 pokazuje niewielkÄ…, przyrostowÄ… poprawÄ™ w wyodrÄ™bnianiu funkcji
<code>run</code>.</p>
<figure class="listing" id="listing-12-11">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.file_path)
        .expect("Should have been able to read the file");

    println!("With text:\n{contents}");
}

// --snip--
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-12-11">Listing 12-11</a>: WyodrÄ™bnianie funkcji <code>run</code> zawierajÄ…cej resztÄ™ logiki programu</figcaption>
</figure>
<p>Funkcja <code>run</code> zawiera teraz caÅ‚Ä… pozostaÅ‚Ä… logikÄ™ z <code>main</code>, poczynajÄ…c od
æ¨‘odczytu pliku. Funkcja <code>run</code> przyjmuje instancjÄ™ <code>Config</code> jako argument.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="returning-errors-from-the-run-function"></a></p>
<h4 id="zwracanie-bÅ‚Ä™dÃ³w-z-funkcji-run"><a class="header" href="#zwracanie-bÅ‚Ä™dÃ³w-z-funkcji-run">Zwracanie bÅ‚Ä™dÃ³w z funkcji <code>run</code></a></h4>
<p>Po oddzieleniu pozostaÅ‚ej logiki programu do funkcji <code>run</code>, moÅ¼emy poprawiÄ‡
obsÅ‚ugÄ™ bÅ‚Ä™dÃ³w, tak jak to zrobiliÅ›my z <code>Config::build</code> w Listingu 12-9.
Zamiast pozwalaÄ‡ programowi na panikÄ™ poprzez wywoÅ‚anie <code>expect</code>, funkcja
<code>run</code> bÄ™dzie zwracaÄ‡ <code>Result&lt;T, E&gt;</code>, gdy coÅ› pÃ³jdzie nie tak. Pozwoli to nam
dalej skonsolidowaÄ‡ logikÄ™ obsÅ‚ugi bÅ‚Ä™dÃ³w w <code>main</code> w sposÃ³b przyjazny dla
uÅ¼ytkownika. Listing 12-12 pokazuje zmiany, ktÃ³re musimy wprowadziÄ‡ w sygnaturze
i ciele <code>run</code>.</p>
<figure class="listing" id="listing-12-12">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// --snip--

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    println!("With text:\n{contents}");

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-12-12">Listing 12-12</a>: Zmiana funkcji <code>run</code> na zwracajÄ…cÄ… <code>Result</code></figcaption>
</figure>
<p>WprowadziliÅ›my tu trzy istotne zmiany. Po pierwsze, zmieniliÅ›my typ zwracany
funkcji <code>run</code> na <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>. Ta funkcja wczeÅ›niej zwracaÅ‚a
typ jednostkowy <code>()</code>, i zachowujemy to jako wartoÅ›Ä‡ zwracanÄ… w przypadku <code>Ok</code>.</p>
<p>Jako typ bÅ‚Ä™du uÅ¼yliÅ›my obiektu cechy <code>Box&lt;dyn Error&gt;</code> (i wprowadziliÅ›my
<code>std::error::Error</code> do zakresu za pomocÄ… instrukcji <code>use</code> na gÃ³rze). Obiekty
cech omÃ³wimy w <a href="#cechy-programowania-zorientowanego-obiektowo">Rozdziale 18</a><!-- ignore -->. Na razie wystarczy wiedzieÄ‡,
Å¼e <code>Box&lt;dyn Error&gt;</code> oznacza, Å¼e funkcja zwrÃ³ci typ, ktÃ³ry implementuje cechÄ™
<code>Error</code>, ale nie musimy okreÅ›laÄ‡, jaki konkretny typ bÄ™dzie miaÅ‚a wartoÅ›Ä‡
zwracana. Daje nam to elastycznoÅ›Ä‡ w zwracaniu wartoÅ›ci bÅ‚Ä™dÃ³w, ktÃ³re mogÄ… byÄ‡
rÃ³Å¼nych typÃ³w w rÃ³Å¼nych przypadkach bÅ‚Ä™dÃ³w. SÅ‚owo kluczowe <code>dyn</code> to skrÃ³t od
<em>dynamiczny</em>.</p>
<p>Po drugie, usunÄ™liÅ›my wywoÅ‚anie <code>expect</code> na rzecz operatora <code>?</code>, o czym
mÃ³wiliÅ›my w <a href="#a-shortcut-for-propagating-errors-the--operator">Rozdziale 9</a><!-- ignore -->. Zamiast panikowaÄ‡
w przypadku bÅ‚Ä™du, <code>?</code> zwrÃ³ci wartoÅ›Ä‡ bÅ‚Ä™du z bieÅ¼Ä…cej funkcji, aby wywoÅ‚ujÄ…cy
mÃ³gÅ‚ jÄ… obsÅ‚uÅ¼yÄ‡.</p>
<p>Po trzecie, funkcja <code>run</code> zwraca teraz wartoÅ›Ä‡ <code>Ok</code> w przypadku sukcesu.
ZadeklarowaliÅ›my typ sukcesu funkcji <code>run</code> jako <code>()</code> w sygnaturze, co oznacza,
Å¼e musimy opakowaÄ‡ wartoÅ›Ä‡ typu jednostkowego w wartoÅ›Ä‡ <code>Ok</code>. Ta skÅ‚adnia
<code>Ok(())</code> moÅ¼e na poczÄ…tku wydawaÄ‡ siÄ™ nieco dziwna. Ale uÅ¼ycie <code>()</code> w ten sposÃ³b
jest idiomatycznym sposobem wskazania, Å¼e wywoÅ‚ujemy <code>run</code> tylko dla jego
efektÃ³w ubocznych; nie zwraca on wartoÅ›ci, ktÃ³rej potrzebujemy.</p>
<p>Kiedy uruchomisz ten kod, skompiluje siÄ™, ale wyÅ›wietli ostrzeÅ¼enie:</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
19 |     let _ = run(config);
   |     +++++++

warning: `minigrep` (bin "minigrep") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>Rust informuje nas, Å¼e nasz kod zignorowaÅ‚ wartoÅ›Ä‡ <code>Result</code> i Å¼e wartoÅ›Ä‡
<code>Result</code> moÅ¼e wskazywaÄ‡ na wystÄ…pienie bÅ‚Ä™du. Ale nie sprawdzamy, czy wystÄ…piÅ‚
bÅ‚Ä…d, a kompilator przypomina nam, Å¼e prawdopodobnie zamierzaliÅ›my umieÅ›ciÄ‡
tutaj jakiÅ› kod do obsÅ‚ugi bÅ‚Ä™dÃ³w! Naprawmy ten problem teraz.</p>
<h4 id="obsÅ‚uga-bÅ‚Ä™dÃ³w-zwracanych-przez-run-w-main"><a class="header" href="#obsÅ‚uga-bÅ‚Ä™dÃ³w-zwracanych-przez-run-w-main">ObsÅ‚uga bÅ‚Ä™dÃ³w zwracanych przez <code>run</code> w <code>main</code></a></h4>
<p>Sprawdzimy bÅ‚Ä™dy i obsÅ‚uÅ¼ymy je za pomocÄ… techniki podobnej do tej, ktÃ³rej
uÅ¼yliÅ›my z <code>Config::build</code> w Listingu 12-10, ale z niewielkÄ… rÃ³Å¼nicÄ…:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    if let Err(e) = run(config) {
        println!("Application error: {e}");
        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>UÅ¼ywamy <code>if let</code> zamiast <code>unwrap_or_else</code>, aby sprawdziÄ‡, czy <code>run</code> zwraca
wartoÅ›Ä‡ <code>Err</code>, i aby wywoÅ‚aÄ‡ <code>process::exit(1)</code>, jeÅ›li tak. Funkcja <code>run</code> nie
zwraca wartoÅ›ci, ktÃ³rÄ… chcemy <code>unwrap</code> w taki sam sposÃ³b, w jaki
<code>Config::build</code> zwraca instancjÄ™ <code>Config</code>. PoniewaÅ¼ <code>run</code> zwraca <code>()</code> w
przypadku sukcesu, zaleÅ¼y nam tylko na wykryciu bÅ‚Ä™du, wiÄ™c nie potrzebujemy
<code>unwrap_or_else</code>, aby zwrÃ³ciÄ‡ rozpakowanÄ… wartoÅ›Ä‡, ktÃ³ra byÅ‚aby tylko <code>()</code>.</p>
<p>CiaÅ‚a funkcji <code>if let</code> i <code>unwrap_or_else</code> sÄ… w obu przypadkach takie same:
wyÅ›wietlamy bÅ‚Ä…d i wychodzimy.</p>
<h3 id="podziaÅ‚-kodu-na-bibliotekÄ™-typu-crate"><a class="header" href="#podziaÅ‚-kodu-na-bibliotekÄ™-typu-crate">PodziaÅ‚ kodu na bibliotekÄ™ typu â€œcrateâ€</a></h3>
<p>Nasz projekt <code>minigrep</code> wyglÄ…da do tej pory dobrze! Teraz podzielimy plik
<em>src/main.rs</em> i umieÅ›cimy czÄ™Å›Ä‡ kodu w pliku <em>src/lib.rs</em>. W ten sposÃ³b moÅ¼emy
testowaÄ‡ kod i mieÄ‡ plik <em>src/main.rs</em> z mniejszÄ… odpowiedzialnoÅ›ciÄ….</p>
<p>Zdefiniujmy kod odpowiedzialny za wyszukiwanie tekstu w <em>src/lib.rs</em> zamiast w
<em>src/main.rs</em>, co pozwoli nam (lub kaÅ¼demu innemu, kto uÅ¼ywa naszej biblioteki
<code>minigrep</code>) wywoÅ‚aÄ‡ funkcjÄ™ wyszukiwania z wiÄ™kszej liczby kontekstÃ³w niÅ¼ nasz
plik binarny <code>minigrep</code>.</p>
<p>Najpierw zdefiniujmy sygnaturÄ™ funkcji <code>search</code> w <em>src/lib.rs</em>, jak pokazano w
Listingu 12-13, z ciaÅ‚em, ktÃ³re wywoÅ‚uje makro <code>unimplemented!</code>. WyjaÅ›nimy
sygnaturÄ™ bardziej szczegÃ³Å‚owo, gdy wypeÅ‚nimy implementacjÄ™.</p>
<figure class="listing" id="listing-12-13">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    unimplemented!();
}</code></pre>
<figcaption><a href="#listing-12-13">Listing 12-13</a>: Definiowanie funkcji <code>search</code> w <em>src/lib.rs</em></figcaption>
</figure>
<p>UÅ¼yliÅ›my sÅ‚owa kluczowego <code>pub</code> w definicji funkcji, aby oznaczyÄ‡ <code>search</code> jako
czÄ™Å›Ä‡ publicznego API naszego pakietu bibliotecznego. Mamy teraz pakiet
biblioteczny, ktÃ³rego moÅ¼emy uÅ¼ywaÄ‡ z naszego pakietu binarnego i ktÃ³ry moÅ¼emy
testowaÄ‡!</p>
<p>Teraz musimy wprowadziÄ‡ kod zdefiniowany w <em>src/lib.rs</em> do zakresu pakietu
binarnego w <em>src/main.rs</em> i wywoÅ‚aÄ‡ go, jak pokazano w Listingu 12-14.</p>
<figure class="listing" id="listing-12-14">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>// --snip--
use minigrep::search;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        println!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!("{line}");
    }

    Ok(())
}</code></pre>
<figcaption><a href="#listing-12-14">Listing 12-14</a>: UÅ¼ycie funkcji <code>search</code> z biblioteki <code>minigrep</code> w <em>src/main.rs</em></figcaption>
</figure>
<p>Dodajemy liniÄ™ <code>use minigrep::search</code>, aby wprowadziÄ‡ funkcjÄ™ <code>search</code> z
pakietu bibliotecznego do zakresu pakietu binarnego. NastÄ™pnie, w funkcji <code>run</code>,
zamiast wypisywaÄ‡ zawartoÅ›Ä‡ pliku, wywoÅ‚ujemy funkcjÄ™ <code>search</code> i przekazujemy
wartoÅ›Ä‡ <code>config.query</code> oraz <code>contents</code> jako argumenty. NastÄ™pnie <code>run</code> uÅ¼yje
pÄ™tli <code>for</code> do wypisania kaÅ¼dej linii zwrÃ³conej przez <code>search</code>, ktÃ³ra
dopasowaÅ‚a zapytanie. To rÃ³wnieÅ¼ dobry moment na usuniÄ™cie wywoÅ‚aÅ„
<code>println!</code> w funkcji <code>main</code>, ktÃ³re wyÅ›wietlaÅ‚y zapytanie i Å›cieÅ¼kÄ™ pliku, tak
aby nasz program wyÅ›wietlaÅ‚ tylko wyniki wyszukiwania (jeÅ›li nie wystÄ…piÅ‚y
bÅ‚Ä™dy).</p>
<p>ZauwaÅ¼, Å¼e funkcja wyszukiwania bÄ™dzie zbieraÄ‡ wszystkie wyniki do zwracanego
wektora, zanim rozpocznie siÄ™ jakiekolwiek drukowanie. Ta implementacja moÅ¼e
byÄ‡ powolna w wyÅ›wietlaniu wynikÃ³w podczas wyszukiwania w duÅ¼ych plikach,
poniewaÅ¼ wyniki nie sÄ… drukowane w miarÄ™ ich znajdowania; omÃ³wimy moÅ¼liwy
sposÃ³b rozwiÄ…zania tego problemu za pomocÄ… iteratorÃ³w w Rozdziale 13.</p>
<p>Uff! To byÅ‚a ciÄ™Å¼ka praca, ale przygotowaliÅ›my siÄ™ na przyszÅ‚oÅ›Ä‡. Teraz o wiele
Å‚atwiej jest obsÅ‚ugiwaÄ‡ bÅ‚Ä™dy, a kod uczyniliÅ›my bardziej moduÅ‚owym.
Prawie caÅ‚a nasza praca bÄ™dzie wykonywana w <em>src/lib.rs</em> od teraz.</p>
<p>Wykorzystajmy tÄ™ nowo odkrytÄ… moduÅ‚owoÅ›Ä‡, robiÄ…c coÅ›, co byÅ‚oby trudne ze
starym kodem, ale jest Å‚atwe z nowym: napiszemy kilka testÃ³w!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dodawanie-funkcjonalnoÅ›ci-z-wykorzystaniem-programowania-sterowanego-testami-1"><a href="#dodawanie-funkcjonalnoÅ›ci-z-wykorzystaniem-programowania-sterowanego-testami-1" class="header">Dodawanie funkcjonalnoÅ›ci z wykorzystaniem programowania sterowanego testami</a></h1>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="developing-the-librarys-functionality-with-test-driven-development"></a></p>
<h2 id="dodawanie-funkcjonalnoÅ›ci-z-wykorzystaniem-programowania-sterowanego-testami"><a class="header" href="#dodawanie-funkcjonalnoÅ›ci-z-wykorzystaniem-programowania-sterowanego-testami">Dodawanie funkcjonalnoÅ›ci z wykorzystaniem programowania sterowanego testami</a></h2>
<p>Teraz, gdy logika wyszukiwania znajduje siÄ™ w pliku <em>src/lib.rs</em> oddzielnie od funkcji <code>main</code>, znacznie Å‚atwiej jest pisaÄ‡ testy dla podstawowej funkcjonalnoÅ›ci naszego kodu. MoÅ¼emy wywoÅ‚ywaÄ‡ funkcje bezpoÅ›rednio z rÃ³Å¼nymi argumentami i sprawdzaÄ‡ wartoÅ›ci zwracane bez koniecznoÅ›ci wywoÅ‚ywania naszego pliku binarnego z wiersza poleceÅ„.</p>
<p>W tej sekcji dodamy logikÄ™ wyszukiwania do programu <code>minigrep</code> przy uÅ¼yciu procesu programowania sterowanego testami (TDD) zgodnie z nastÄ™pujÄ…cymi krokami:</p>
<ol>
<li>Napisz test, ktÃ³ry zawodzi, i uruchom go, aby upewniÄ‡ siÄ™, Å¼e zawodzi z oczekiwanej przyczyny.</li>
<li>Napisz lub zmodyfikuj wystarczajÄ…co duÅ¼o kodu, aby nowy test przeszedÅ‚.</li>
<li>Zrefaktoruj kod, ktÃ³ry wÅ‚aÅ›nie dodaÅ‚eÅ› lub zmieniÅ‚eÅ›, i upewnij siÄ™, Å¼e testy nadal przechodzÄ….</li>
<li>PowtÃ³rz od kroku 1!</li>
</ol>
<p>ChociaÅ¼ jest to tylko jeden z wielu sposobÃ³w pisania oprogramowania, TDD moÅ¼e pomÃ³c w kierowaniu projektem kodu. Pisanie testu przed napisaniem kodu, ktÃ³ry sprawia, Å¼e test przechodzi, pomaga utrzymaÄ‡ wysokie pokrycie testami przez caÅ‚y proces.</p>
<p>BÄ™dziemy testowaÄ‡ implementacjÄ™ funkcjonalnoÅ›ci, ktÃ³ra faktycznie bÄ™dzie wyszukiwaÄ‡ ciÄ…g zapytania w zawartoÅ›ci pliku i generowaÄ‡ listÄ™ pasujÄ…cych wierszy. TÄ™ funkcjonalnoÅ›Ä‡ dodamy w funkcji nazwanej <code>search</code>.</p>
<h3 id="pisanie-nieudanego-testu"><a class="header" href="#pisanie-nieudanego-testu">Pisanie nieudanego testu</a></h3>
<p>W pliku <em>src/lib.rs</em> dodamy moduÅ‚ <code>tests</code> z funkcjÄ… testowÄ…, tak jak to zrobiliÅ›my w <a href="#the-anatomy-of-a-test-function">Rozdziale 11</a><!-- ignore -->. Funkcja testowa okreÅ›la zachowanie, jakie chcemy, aby funkcja <code>search</code> miaÅ‚a: BÄ™dzie przyjmowaÄ‡ zapytanie i tekst do przeszukania, i bÄ™dzie zwracaÄ‡ tylko te wiersze z tekstu, ktÃ³re zawierajÄ… zapytanie. Listing 12-15 pokazuje ten test.</p>
<listing number="12-15" file-name="src/lib.rs" caption="Tworzenie nieudanego testu dla funkcji `search` dla funkcjonalnoÅ›ci, ktÃ³rÄ… chcielibyÅ›my mieÄ‡">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    unimplemented!();
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }
}</code></pre>
</listing>
<p>Ten test wyszukuje ciÄ…g <code>"duct"</code>. Tekst, ktÃ³ry przeszukujemy, ma trzy wiersze, z ktÃ³rych tylko jeden zawiera <code>"duct"</code> (zauwaÅ¼, Å¼e ukoÅ›nik wsteczny po otwierajÄ…cym cudzysÅ‚owie podwÃ³jnym informuje Rusta, aby nie umieszczaÅ‚ znaku nowej linii na poczÄ…tku zawartoÅ›ci tego literaÅ‚u ciÄ…gu znakÃ³w). Twierdzimy, Å¼e wartoÅ›Ä‡ zwrÃ³cona przez funkcjÄ™ <code>search</code> zawiera tylko oczekiwany wiersz.</p>
<p>JeÅ›li uruchomimy ten test, obecnie siÄ™ nie powiedzie, poniewaÅ¼ makro <code>unimplemented!</code> panikuje z komunikatem â€not implementedâ€. Zgodnie z zasadami TDD, zrobimy maÅ‚y krok, dodajÄ…c wystarczajÄ…co duÅ¼o kodu, aby test nie panikowaÅ‚ podczas wywoÅ‚ywania funkcji, definiujÄ…c funkcjÄ™ <code>search</code> tak, aby zawsze zwracaÅ‚a pusty wektor, jak pokazano w Listing 12-16. NastÄ™pnie test powinien siÄ™ skompilowaÄ‡ i zakoÅ„czyÄ‡ niepowodzeniem, poniewaÅ¼ pusty wektor nie pasuje do wektora zawierajÄ…cego wiersz <code>"safe, fast, productive."</code>.</p>
<listing number="12-16" file-name="src/lib.rs" caption="Definiowanie wystarczajÄ…cej czÄ™Å›ci funkcji `search`, aby jej wywoÅ‚anie nie panikowaÅ‚o">
<pre><code class="language-rust noplayground">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</listing>
<p>Teraz omÃ³wmy, dlaczego musimy zdefiniowaÄ‡ jawnÄ… Å¼ywotnoÅ›Ä‡ <code>'a</code> w sygnaturze <code>search</code> i uÅ¼yÄ‡ tej Å¼ywotnoÅ›ci z argumentem <code>contents</code> i wartoÅ›ciÄ… zwracanÄ…. Przypomnij sobie z <a href="#walidacja-referencji-za-pomocÄ…-czasÃ³w-Å¼ycia-1">RozdziaÅ‚u 10</a><!-- ignore -->, Å¼e parametry Å¼ywotnoÅ›ci okreÅ›lajÄ…, ktÃ³ra Å¼ywotnoÅ›Ä‡ argumentu jest poÅ‚Ä…czona z Å¼ywotnoÅ›ciÄ… wartoÅ›ci zwracanej. W tym przypadku wskazujemy, Å¼e zwrÃ³cony wektor powinien zawieraÄ‡ wycinki ciÄ…gÃ³w znakÃ³w, ktÃ³re odwoÅ‚ujÄ… siÄ™ do wycinkÃ³w argumentu <code>contents</code> (a nie argumentu <code>query</code>).</p>
<p>Innymi sÅ‚owy, mÃ³wimy Rustowi, Å¼e dane zwrÃ³cone przez funkcjÄ™ <code>search</code> bÄ™dÄ… Å¼yÅ‚y tak dÅ‚ugo, jak dane przekazane do funkcji <code>search</code> w argumencie <code>contents</code>. To jest waÅ¼ne! Dane, do ktÃ³rych odwoÅ‚uje siÄ™ wycinek, muszÄ… byÄ‡ waÅ¼ne, aby referencja byÅ‚a waÅ¼na; jeÅ›li kompilator zaÅ‚oÅ¼y, Å¼e tworzymy wycinki ciÄ…gÃ³w znakÃ³w z <code>query</code> zamiast z <code>contents</code>, to jego sprawdzanie bezpieczeÅ„stwa bÄ™dzie nieprawidÅ‚owe.</p>
<p>JeÅ›li zapomnimy o adnotacjach Å¼ywotnoÅ›ci i sprÃ³bujemy skompilowaÄ‡ tÄ™ funkcjÄ™, otrzymamy nastÄ™pujÄ…cy bÅ‚Ä…d:</p>
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
 --&gt; src/lib.rs:1:51
  |
1 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
  |                      ----            ----         ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`
help: consider introducing a named lifetime parameter
  |
1 | pub fn search&lt;'a&gt;(query: &amp;'a str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
  |              ++++         ++                 ++              ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` (lib) due to 1 previous error
</code></pre>
<p>Rust nie moÅ¼e wiedzieÄ‡, ktÃ³ry z dwÃ³ch parametrÃ³w jest nam potrzebny do wyjÅ›cia, wiÄ™c musimy mu to jawnie powiedzieÄ‡. ZauwaÅ¼, Å¼e tekst pomocy sugeruje okreÅ›lenie tego samego parametru czasu Å¼ycia dla wszystkich parametrÃ³w i typu wyjÅ›ciowego, co jest nieprawidÅ‚owe! PoniewaÅ¼ <code>contents</code> jest parametrem, ktÃ³ry zawiera caÅ‚y nasz tekst i chcemy zwrÃ³ciÄ‡ pasujÄ…ce fragmenty tego tekstu, wiemy, Å¼e <code>contents</code> jest jedynym parametrem, ktÃ³ry powinien byÄ‡ poÅ‚Ä…czony z wartoÅ›ciÄ… zwracanÄ… za pomocÄ… skÅ‚adni czasu Å¼ycia.</p>
<p>Inne jÄ™zyki programowania nie wymagajÄ… Å‚Ä…czenia argumentÃ³w z wartoÅ›ciami zwracanymi w sygnaturze, ale ta praktyka z czasem stanie siÄ™ Å‚atwiejsza. MoÅ¼esz porÃ³wnaÄ‡ ten przykÅ‚ad z przykÅ‚adami w sekcji <a href="#validating-references-with-lifetimes">â€Walidowanie referencji za pomocÄ… Å¼ywotnoÅ›ciâ€</a><!-- ignore --> w Rozdziale 10.</p>
<h3 id="pisanie-kodu-aby-test-przeszedÅ‚"><a class="header" href="#pisanie-kodu-aby-test-przeszedÅ‚">Pisanie kodu, aby test przeszedÅ‚</a></h3>
<p>Obecnie nasz test zawodzi, poniewaÅ¼ zawsze zwracamy pusty wektor. Aby to naprawiÄ‡ i zaimplementowaÄ‡ <code>search</code>, nasz program musi wykonaÄ‡ nastÄ™pujÄ…ce kroki:</p>
<ol>
<li>Iteruj przez kaÅ¼dy wiersz zawartoÅ›ci.</li>
<li>SprawdÅº, czy wiersz zawiera nasz ciÄ…g zapytania.</li>
<li>JeÅ›li tak, dodaj go do listy wartoÅ›ci, ktÃ³re zwracamy.</li>
<li>JeÅ›li nie, nie rÃ³b nic.</li>
<li>ZwrÃ³Ä‡ listÄ™ pasujÄ…cych wynikÃ³w.</li>
</ol>
<p>PrzejdÅºmy przez kaÅ¼dy krok, zaczynajÄ…c od iteracji przez wiersze.</p>
<h4 id="iterowanie-przez-wiersze-za-pomocÄ…-metody-lines"><a class="header" href="#iterowanie-przez-wiersze-za-pomocÄ…-metody-lines">Iterowanie przez wiersze za pomocÄ… metody <code>lines</code></a></h4>
<p>Rust ma przydatnÄ… metodÄ™ do obsÅ‚ugi iteracji po ciÄ…gach znakÃ³w wiersz po wierszu, wygodnie nazwanÄ… <code>lines</code>, ktÃ³ra dziaÅ‚a tak, jak pokazano w Listing 12-17. ZauwaÅ¼, Å¼e to jeszcze siÄ™ nie skompiluje.</p>
<listing number="12-17" file-name="src/lib.rs" caption="Iterowanie przez kaÅ¼dy wiersz w `contents`">
<pre><code class="language-rust ignore does_not_compile">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // do something with line
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</listing>
<p>Metoda <code>lines</code> zwraca iterator. DogÅ‚Ä™bnie omÃ³wimy iteratory w <a href="#przetwarzanie-serii-elementÃ³w-za-pomocÄ…-iteratorÃ³w-1">Rozdziale 13</a><!-- ignore -->. Ale przypomnij sobie, Å¼e widziaÅ‚eÅ› ten sposÃ³b uÅ¼ywania iteratora w <a href="#looping-through-a-collection-with-for">Listing 3-5</a><!-- ignore -->, gdzie uÅ¼ywaliÅ›my pÄ™tli <code>for</code> z iteratorem, aby wykonaÄ‡ kod na kaÅ¼dym elemencie w kolekcji.</p>
<h4 id="wyszukiwanie-zapytania-w-kaÅ¼dym-wierszu"><a class="header" href="#wyszukiwanie-zapytania-w-kaÅ¼dym-wierszu">Wyszukiwanie zapytania w kaÅ¼dym wierszu</a></h4>
<p>NastÄ™pnie sprawdzimy, czy bieÅ¼Ä…cy wiersz zawiera nasz ciÄ…g zapytania. Na szczÄ™Å›cie ciÄ…gi znakÃ³w majÄ… przydatnÄ… metodÄ™ o nazwie <code>contains</code>, ktÃ³ra to dla nas robi! Dodaj wywoÅ‚anie metody <code>contains</code> w funkcji <code>search</code>, jak pokazano w Listing 12-18. ZauwaÅ¼, Å¼e to nadal siÄ™ nie skompiluje.</p>
<listing number="12-18" file-name="src/lib.rs" caption="Dodawanie funkcjonalnoÅ›ci, aby sprawdziÄ‡, czy wiersz zawiera ciÄ…g znakÃ³w z `query`">
<pre><code class="language-rust ignore does_not_compile">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</listing>
<p>W tej chwili budujemy funkcjonalnoÅ›Ä‡. Aby kod siÄ™ skompilowaÅ‚, musimy zwrÃ³ciÄ‡ wartoÅ›Ä‡ z ciaÅ‚a, zgodnie z tym, co wskazaliÅ›my w sygnaturze funkcji.</p>
<h4 id="przechowywanie-pasujÄ…cych-wierszy"><a class="header" href="#przechowywanie-pasujÄ…cych-wierszy">Przechowywanie pasujÄ…cych wierszy</a></h4>
<p>Aby zakoÅ„czyÄ‡ tÄ™ funkcjÄ™, potrzebujemy sposobu na przechowywanie pasujÄ…cych wierszy, ktÃ³re chcemy zwrÃ³ciÄ‡. W tym celu moÅ¼emy stworzyÄ‡ modyfikowalny wektor przed pÄ™tlÄ… <code>for</code> i wywoÅ‚aÄ‡ metodÄ™ <code>push</code>, aby zapisaÄ‡ <code>line</code> w wektorze. Po pÄ™tli <code>for</code> zwracamy wektor, jak pokazano w Listing 12-19.</p>
<listing number="12-19" file-name="src/lib.rs" caption="Przechowywanie pasujÄ…cych wierszy, abyÅ›my mogli je zwrÃ³ciÄ‡">
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</listing>
<p>Teraz funkcja <code>search</code> powinna zwracaÄ‡ tylko wiersze zawierajÄ…ce <code>query</code>, a nasz test powinien przejÅ›Ä‡. Uruchommy test:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Nasz test przeszedÅ‚, wiÄ™c wiemy, Å¼e dziaÅ‚a!</p>
<p>W tym momencie moglibyÅ›my rozwaÅ¼yÄ‡ moÅ¼liwoÅ›ci refaktoryzacji implementacji funkcji wyszukiwania, jednoczeÅ›nie utrzymujÄ…c testy przechodzÄ…ce, aby zachowaÄ‡ tÄ™ samÄ… funkcjonalnoÅ›Ä‡. Kod w funkcji wyszukiwania nie jest zbyt zÅ‚y, ale nie wykorzystuje niektÃ³rych przydatnych funkcji iteratorÃ³w. WrÃ³cimy do tego przykÅ‚adu w <a href="#przetwarzanie-serii-elementÃ³w-za-pomocÄ…-iteratorÃ³w-1">Rozdziale 13</a><!-- ignore -->, gdzie szczegÃ³Å‚owo omÃ³wimy iteratory i przyjrzymy siÄ™, jak go ulepszyÄ‡.</p>
<p>Teraz caÅ‚y program powinien dziaÅ‚aÄ‡! WyprÃ³bujmy go najpierw ze sÅ‚owem, ktÃ³re powinno zwrÃ³ciÄ‡ dokÅ‚adnie jeden wiersz z wiersza Emily Dickinson: <em>frog</em>.</p>
<pre><code class="language-console">$ cargo run -- frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>Åšwietnie! Teraz sprÃ³bujmy sÅ‚owa, ktÃ³re bÄ™dzie pasowaÄ‡ do wielu wierszy, na przykÅ‚ad <em>body</em>:</p>
<pre><code class="language-console">$ cargo run -- body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>I na koniec, upewnijmy siÄ™, Å¼e nie otrzymujemy Å¼adnych wierszy, gdy szukamy sÅ‚owa, ktÃ³rego nie ma w wierszu, na przykÅ‚ad <em>monomorfization</em>:</p>
<pre><code class="language-console">$ cargo run -- monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>Doskonale! ZbudowaliÅ›my naszÄ… mini wersjÄ™ klasycznego narzÄ™dzia i wiele nauczyliÅ›my siÄ™ o tym, jak strukturyzowaÄ‡ aplikacje. NauczyliÅ›my siÄ™ rÃ³wnieÅ¼ trochÄ™ o wejÅ›ciu i wyjÅ›ciu plikowym, Å¼ywotnoÅ›ci, testowaniu i parsowaniu wiersza poleceÅ„.</p>
<p>Aby zakoÅ„czyÄ‡ ten projekt, krÃ³tko zademonstrujemy, jak pracowaÄ‡ ze zmiennymi Å›rodowiskowymi i jak drukowaÄ‡ do standardowego strumienia bÅ‚Ä™dÃ³w, co jest przydatne podczas pisania programÃ³w wiersza poleceÅ„.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="praca-ze-zmiennymi-Å›rodowiskowymi-1"><a href="#praca-ze-zmiennymi-Å›rodowiskowymi-1" class="header">Praca ze zmiennymi Å›rodowiskowymi</a></h1>
<h2 id="praca-ze-zmiennymi-Å›rodowiskowymi"><a class="header" href="#praca-ze-zmiennymi-Å›rodowiskowymi">Praca ze zmiennymi Å›rodowiskowymi</a></h2>
<p>Udoskonalimy plik binarny <code>minigrep</code>, dodajÄ…c dodatkowÄ… funkcjÄ™: opcjÄ™ wyszukiwania bez uwzglÄ™dniania wielkoÅ›ci liter, ktÃ³rÄ… uÅ¼ytkownik moÅ¼e wÅ‚Ä…czyÄ‡ za pomocÄ… zmiennej Å›rodowiskowej. MoglibyÅ›my uczyniÄ‡ tÄ™ funkcjÄ™ opcjÄ… wiersza poleceÅ„ i wymagaÄ‡ od uÅ¼ytkownikÃ³w wprowadzania jej za kaÅ¼dym razem, gdy chcÄ… jÄ… zastosowaÄ‡, ale zamiast tego, tworzÄ…c zmiennÄ… Å›rodowiskowÄ…, pozwalamy naszym uÅ¼ytkownikom ustawiÄ‡ zmiennÄ… Å›rodowiskowÄ… raz i mieÄ‡ wszystkie ich wyszukiwania bez uwzglÄ™dniania wielkoÅ›ci liter w tej sesji terminala.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="writing-a-failing-test-for-the-case-insensitive-search-function"></a></p>
<h3 id="pisanie-nieudanego-testu-dla-wyszukiwania-bez-uwzglÄ™dniania-wielkoÅ›ci-liter"><a class="header" href="#pisanie-nieudanego-testu-dla-wyszukiwania-bez-uwzglÄ™dniania-wielkoÅ›ci-liter">Pisanie nieudanego testu dla wyszukiwania bez uwzglÄ™dniania wielkoÅ›ci liter</a></h3>
<p>Najpierw dodajemy nowÄ… funkcjÄ™ <code>search_case_insensitive</code> do biblioteki <code>minigrep</code>, ktÃ³ra zostanie wywoÅ‚ana, gdy zmienna Å›rodowiskowa bÄ™dzie miaÅ‚a wartoÅ›Ä‡. BÄ™dziemy kontynuowaÄ‡ proces TDD, wiÄ™c pierwszym krokiem ponownie jest napisanie nieudanego testu. Dodamy nowy test dla nowej funkcji <code>search_case_insensitive</code> i zmienimy nazwÄ™ naszego starego testu z <code>one_result</code> na <code>case_sensitive</code>, aby wyjaÅ›niÄ‡ rÃ³Å¼nice miÄ™dzy dwoma testami, jak pokazano w Listing 12-20.</p>
<listing number="12-20" file-name="src/lib.rs" caption="Dodawanie nowego nieudanego testu dla funkcji bez uwzglÄ™dniania wielkoÅ›ci liter, ktÃ³rÄ… zamierzamy dodaÄ‡">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Duct tape.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }

    #[test]
    fn case_insensitive() {
        let query = "rUsT";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Trust me.";

        assert_eq!(
            vec!["Rust:", "Trust me."],
            search_case_insensitive(query, contents)
        );
    }
}</code></pre>
</listing>
<p>ZauwaÅ¼, Å¼e zmodyfikowaliÅ›my rÃ³wnieÅ¼ <code>contents</code> starego testu. DodaliÅ›my nowy wiersz z tekstem <code>"Duct tape."</code> z wielkÄ… literÄ… <em>D</em>, ktÃ³ry nie powinien pasowaÄ‡ do zapytania <code>"duct"</code> podczas wyszukiwania z uwzglÄ™dnieniem wielkoÅ›ci liter. Zmiana starego testu w ten sposÃ³b pomaga upewniÄ‡ siÄ™, Å¼e nie uszkodzimy przypadkowo funkcjonalnoÅ›ci wyszukiwania z uwzglÄ™dnieniem wielkoÅ›ci liter, ktÃ³rÄ… juÅ¼ zaimplementowaliÅ›my. Ten test powinien teraz przejÅ›Ä‡ i powinien nadal przechodziÄ‡ podczas pracy nad wyszukiwaniem bez uwzglÄ™dniania wielkoÅ›ci liter.</p>
<p>Nowy test dla wyszukiwania bez uwzglÄ™dniania wielkoÅ›ci liter (case-<em>insensitive</em>) uÅ¼ywa <code>"rUsT"</code> jako zapytania. W funkcji <code>search_case_insensitive</code>, ktÃ³rÄ… zaraz dodamy, zapytanie <code>"rUsT"</code> powinno pasowaÄ‡ do wiersza zawierajÄ…cego <code>"Rust:"</code> z wielkÄ… literÄ… <em>R</em> oraz do wiersza <code>"Trust me."</code> mimo Å¼e oba majÄ… innÄ… wielkoÅ›Ä‡ liter niÅ¼ zapytanie. To jest nasz test, ktÃ³ry zakoÅ„czy siÄ™ niepowodzeniem, poniewaÅ¼ nie zdefiniowaliÅ›my jeszcze funkcji <code>search_case_insensitive</code>. MoÅ¼esz dodaÄ‡ szkieletowÄ… implementacjÄ™, ktÃ³ra zawsze zwraca pusty wektor, podobnie jak zrobiliÅ›my to dla funkcji <code>search</code> w Listing 12-16, aby zobaczyÄ‡, jak test siÄ™ kompiluje i koÅ„czy niepowodzeniem.</p>
<h3 id="implementowanie-funkcji-search_case_insensitive"><a class="header" href="#implementowanie-funkcji-search_case_insensitive">Implementowanie funkcji <code>search_case_insensitive</code></a></h3>
<p>Funkcja <code>search_case_insensitive</code>, pokazana w Listing 12-21, bÄ™dzie prawie taka sama jak funkcja <code>search</code>. JedynÄ… rÃ³Å¼nicÄ… jest to, Å¼e zmienimy <code>query</code> i kaÅ¼dy <code>line</code> na maÅ‚e litery, tak aby niezaleÅ¼nie od wielkoÅ›ci liter w argumentach wejÅ›ciowych, miaÅ‚y one tÄ™ samÄ… wielkoÅ›Ä‡ liter, gdy sprawdzamy, czy wiersz zawiera zapytanie.</p>
<listing number="12-21" file-name="src/lib.rs" caption="Definiowanie funkcji `search_case_insensitive`, ktÃ³ra zamienia zapytanie i wiersz na maÅ‚e litery przed ich porÃ³wnaniem">
<pre><code class="language-rust noplayground"><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search_case_insensitive&lt;'a&gt;(
    query: &amp;str,
    contents: &amp;'a str,
) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</listing>
<p>Najpierw zmieniamy ciÄ…g znakÃ³w <code>query</code> na maÅ‚e litery i przechowujemy go w nowej zmiennej o tej samej nazwie, zasÅ‚aniajÄ…c oryginalny <code>query</code>. WywoÅ‚anie <code>to_lowercase</code> na zapytaniu jest konieczne, aby niezaleÅ¼nie od tego, czy zapytanie uÅ¼ytkownika to <code>"rust"</code>, <code>"RUST"</code>, <code>"Rust"</code>, czy <code>"rUsT"</code>, traktowaÄ‡ zapytanie tak, jakby byÅ‚o <code>"rust"</code> i ignorowaÄ‡ wielkoÅ›Ä‡ liter. ChociaÅ¼ <code>to_lowercase</code> poradzi sobie z podstawowym Unicode, nie bÄ™dzie w 100 procentach dokÅ‚adne. GdybyÅ›my pisali prawdziwÄ… aplikacjÄ™, chcielibyÅ›my wÅ‚oÅ¼yÄ‡ w to wiÄ™cej pracy, ale ta sekcja dotyczy zmiennych Å›rodowiskowych, a nie Unicode, wiÄ™c na tym poprzestaniemy.</p>
<p>ZauwaÅ¼, Å¼e <code>query</code> jest teraz <code>String</code>, a nie wycinkiem ciÄ…gu znakÃ³w, poniewaÅ¼ wywoÅ‚anie <code>to_lowercase</code> tworzy nowe dane, zamiast odwoÅ‚ywaÄ‡ siÄ™ do istniejÄ…cych. Na przykÅ‚ad, jeÅ›li zapytanie to <code>"rUsT"</code>: ten wycinek ciÄ…gu znakÃ³w nie zawiera maÅ‚ych liter <code>u</code> ani <code>t</code>, ktÃ³rych moglibyÅ›my uÅ¼yÄ‡, wiÄ™c musimy zaalokowaÄ‡ nowy <code>String</code> zawierajÄ…cy <code>"rust"</code>. Kiedy teraz przekazujemy <code>query</code> jako argument do metody <code>contains</code>, musimy dodaÄ‡ ampersand, poniewaÅ¼ sygnatura <code>contains</code> jest zdefiniowana tak, aby przyjmowaÅ‚a wycinek ciÄ…gu znakÃ³w.</p>
<p>NastÄ™pnie dodajemy wywoÅ‚anie <code>to_lowercase</code> na kaÅ¼dym <code>line</code>, aby zmieniÄ‡ wszystkie znaki na maÅ‚e litery. Teraz, gdy przekonwertowaliÅ›my <code>line</code> i <code>query</code> na maÅ‚e litery, znajdziemy dopasowania niezaleÅ¼nie od wielkoÅ›ci liter w zapytaniu.</p>
<p>SprawdÅºmy, czy ta implementacja przechodzi testy:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.33s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 2 tests
test tests::case_insensitive ... ok
test tests::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Åšwietnie! Testy przeszÅ‚y. Teraz wywoÅ‚ajmy nowÄ… funkcjÄ™ <code>search_case_insensitive</code> z funkcji <code>run</code>. Najpierw dodamy opcjÄ™ konfiguracji do struktury <code>Config</code>, aby przeÅ‚Ä…czaÄ‡ siÄ™ miÄ™dzy wyszukiwaniem z uwzglÄ™dnianiem wielkoÅ›ci liter a wyszukiwaniem bez uwzglÄ™dniania wielkoÅ›ci liter. Dodanie tego pola spowoduje bÅ‚Ä™dy kompilacji, poniewaÅ¼ nigdzie jeszcze nie inicjalizujemy tego pola:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::{search, search_case_insensitive};
</span><span class="boring">
</span><span class="boring">// --snip--
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        println!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Config {
    pub query: String,
    pub file_path: String,
    pub ignore_case: bool,
}
<span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<p>DodaliÅ›my pole <code>ignore_case</code>, ktÃ³re przechowuje wartoÅ›Ä‡ typu boolean. NastÄ™pnie funkcja <code>run</code> musi sprawdziÄ‡ wartoÅ›Ä‡ pola <code>ignore_case</code> i na tej podstawie zdecydowaÄ‡, czy wywoÅ‚aÄ‡ funkcjÄ™ <code>search</code>, czy funkcjÄ™ <code>search_case_insensitive</code>, jak pokazano w Listing 12-22. To jeszcze siÄ™ nie skompiluje.</p>
<listing number="12-22" file-name="src/main.rs" caption="WywoÅ‚ywanie `search` lub `search_case_insensitive` w zaleÅ¼noÅ›ci od wartoÅ›ci w `config.ignore_case`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>use minigrep::{search, search_case_insensitive};

// --snip--

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        println!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    let results = if config.ignore_case {
        search_case_insensitive(&amp;config.query, &amp;contents)
    } else {
        search(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!("{line}");
    }

    Ok(())
}</code></pre>
</listing>
<p>Na koniec musimy sprawdziÄ‡ zmiennÄ… Å›rodowiskowÄ…. Funkcje do pracy ze zmiennymi Å›rodowiskowymi znajdujÄ… siÄ™ w module <code>env</code> w standardowej bibliotece, ktÃ³ry jest juÅ¼ w zakresie na poczÄ…tku pliku <em>src/main.rs</em>. UÅ¼yjemy funkcji <code>var</code> z moduÅ‚u <code>env</code>, aby sprawdziÄ‡, czy jakakolwiek wartoÅ›Ä‡ zostaÅ‚a ustawiona dla zmiennej Å›rodowiskowej o nazwie <code>IGNORE_CASE</code>, jak pokazano w Listing 12-23.</p>
<listing number="12-23" file-name="src/main.rs" caption="Sprawdzanie dowolnej wartoÅ›ci w zmiennej Å›rodowiskowej o nazwie `IGNORE_CASE`">
<pre><code class="language-rust ignore noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::{search, search_case_insensitive};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        println!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
</listing>
<p>Tutaj tworzymy nowÄ… zmiennÄ… <code>ignore_case</code>. Aby ustawiÄ‡ jej wartoÅ›Ä‡, wywoÅ‚ujemy funkcjÄ™ <code>env::var</code> i przekazujemy jej nazwÄ™ zmiennej Å›rodowiskowej <code>IGNORE_CASE</code>. Funkcja <code>env::var</code> zwraca <code>Result</code>, ktÃ³ry bÄ™dzie wariantem <code>Ok</code> zawierajÄ…cym wartoÅ›Ä‡ zmiennej Å›rodowiskowej, jeÅ›li zmienna Å›rodowiskowa jest ustawiona na jakÄ…kolwiek wartoÅ›Ä‡. ZwrÃ³ci wariant <code>Err</code>, jeÅ›li zmienna Å›rodowiskowa nie jest ustawiona.</p>
<p>UÅ¼ywamy metody <code>is_ok</code> na <code>Result</code>, aby sprawdziÄ‡, czy zmienna Å›rodowiskowa jest ustawiona, co oznacza, Å¼e program powinien przeprowadziÄ‡ wyszukiwanie bez uwzglÄ™dniania wielkoÅ›ci liter. JeÅ›li zmienna Å›rodowiskowa <code>IGNORE_CASE</code> nie jest ustawiona na nic, <code>is_ok</code> zwrÃ³ci <code>false</code>, a program przeprowadzi wyszukiwanie z uwzglÄ™dnieniem wielkoÅ›ci liter. Nie obchodzi nas <em>wartoÅ›Ä‡</em> zmiennej Å›rodowiskowej, tylko to, czy jest ustawiona, czy nie, wiÄ™c sprawdzamy <code>is_ok</code> zamiast uÅ¼ywaÄ‡ <code>unwrap</code>, <code>expect</code> lub innych metod, ktÃ³re widzieliÅ›my na <code>Result</code>.</p>
<p>Przekazujemy wartoÅ›Ä‡ zmiennej <code>ignore_case</code> do instancji <code>Config</code>, aby funkcja <code>run</code> mogÅ‚a odczytaÄ‡ tÄ™ wartoÅ›Ä‡ i zdecydowaÄ‡, czy wywoÅ‚aÄ‡ <code>search_case_insensitive</code>, czy <code>search</code>, jak zaimplementowaliÅ›my w Listing 12-22.</p>
<p>WyprÃ³bujmy to! Najpierw uruchomimy nasz program bez ustawionej zmiennej Å›rodowiskowej i z zapytaniem <code>to</code>, ktÃ³re powinno pasowaÄ‡ do kaÅ¼dego wiersza zawierajÄ…cego sÅ‚owo <em>to</em> pisanego maÅ‚ymi literami:</p>
<pre><code class="language-console">$ cargo run -- to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>WyglÄ…da na to, Å¼e to nadal dziaÅ‚a! Teraz uruchommy program z <code>IGNORE_CASE</code> ustawionym na <code>1</code>, ale z tym samym zapytaniem <code>to</code>:</p>
<pre><code class="language-console">$ IGNORE_CASE=1 cargo run -- to poem.txt
</code></pre>
<p>JeÅ›li uÅ¼ywasz PowerShell, musisz ustawiÄ‡ zmiennÄ… Å›rodowiskowÄ… i uruchomiÄ‡ program jako osobne polecenia:</p>
<pre><code class="language-console">PS&gt; $Env:IGNORE_CASE=1; cargo run -- to poem.txt
</code></pre>
<p>Spowoduje to, Å¼e <code>IGNORE_CASE</code> bÄ™dzie obowiÄ…zywaÄ‡ przez resztÄ™ sesji powÅ‚oki. MoÅ¼na go usunÄ…Ä‡ za pomocÄ… polecenia <code>Remove-Item</code>:</p>
<pre><code class="language-console">PS&gt; Remove-Item Env:IGNORE_CASE
</code></pre>
<p>PpowinniÅ›my otrzymaÄ‡ wiersze, ktÃ³re zawierajÄ… <em>to</em> z ewentualnymi duÅ¼ymi literami:</p>
<!-- manual-regeneration
cd listings/ch12-an-io-project/listing-12-23
IGNORE_CASE=1 cargo run -- to poem.txt
can't extract because of the environment variable
-->
<pre><code class="language-console">Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Doskonale, dostaliÅ›my teÅ¼ linie zawierajÄ…ce <em>To</em>! Nasz program <code>minigrep</code> moÅ¼e teraz przeprowadzaÄ‡ wyszukiwanie bez uwzglÄ™dniania wielkoÅ›ci liter, sterowane zmiennÄ… Å›rodowiskowÄ…. Teraz wiesz, jak zarzÄ…dzaÄ‡ opcjami ustawionymi za pomocÄ… argumentÃ³w wiersza poleceÅ„ lub zmiennych Å›rodowiskowych.</p>
<p>NiektÃ³re programy pozwalajÄ… na uÅ¼ycie argumentÃ³w <em>i</em> zmiennych Å›rodowiskowych dla tej samej konfiguracji. W takich przypadkach programy decydujÄ…, ktÃ³re z nich majÄ… pierwszeÅ„stwo. W ramach samodzielnego Ä‡wiczenia sprÃ³buj kontrolowaÄ‡ czuÅ‚oÅ›Ä‡ na wielkoÅ›Ä‡ liter za pomocÄ… argumentu wiersza poleceÅ„ lub zmiennej Å›rodowiskowej. Zdecyduj, czy argument wiersza poleceÅ„, czy zmienna Å›rodowiskowa powinna mieÄ‡ pierwszeÅ„stwo, jeÅ›li program jest uruchamiany z jednym ustawionym na uwzglÄ™dnianie wielkoÅ›ci liter, a drugim na ignorowanie wielkoÅ›ci liter.</p>
<p>ModuÅ‚ <code>std::env</code> zawiera wiele innych przydatnych funkcji do obsÅ‚ugi zmiennych Å›rodowiskowych: zajrzyj do jego dokumentacji, aby zobaczyÄ‡, co jest dostÄ™pne.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="przekierowywanie-bÅ‚Ä™dÃ³w-do-standardowego-strumienia-bÅ‚Ä™dÃ³w-1"><a href="#przekierowywanie-bÅ‚Ä™dÃ³w-do-standardowego-strumienia-bÅ‚Ä™dÃ³w-1" class="header">Przekierowywanie bÅ‚Ä™dÃ³w do standardowego strumienia bÅ‚Ä™dÃ³w</a></h1>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="writing-error-messages-to-standard-error-instead-of-standard-output"></a></p>
<h2 id="przekierowywanie-bÅ‚Ä™dÃ³w-do-standardowego-strumienia-bÅ‚Ä™dÃ³w"><a class="header" href="#przekierowywanie-bÅ‚Ä™dÃ³w-do-standardowego-strumienia-bÅ‚Ä™dÃ³w">Przekierowywanie bÅ‚Ä™dÃ³w do standardowego strumienia bÅ‚Ä™dÃ³w</a></h2>
<p>W tej chwili wszystkie nasze dane wyjÅ›ciowe zapisujemy do terminala za pomocÄ… makra <code>println!</code>. W wiÄ™kszoÅ›ci terminali istniejÄ… dwa rodzaje danych wyjÅ›ciowych: <em>standardowe wyjÅ›cie</em> (<code>stdout</code>) dla ogÃ³lnych informacji i <em>standardowy bÅ‚Ä…d</em> (<code>stderr</code>) dla komunikatÃ³w o bÅ‚Ä™dach. To rozrÃ³Å¼nienie umoÅ¼liwia uÅ¼ytkownikom skierowanie pomyÅ›lnych danych wyjÅ›ciowych programu do pliku, ale nadal wyÅ›wietlanie komunikatÃ³w o bÅ‚Ä™dach na ekranie.</p>
<p>Makro <code>println!</code> jest w stanie drukowaÄ‡ tylko na standardowe wyjÅ›cie, wiÄ™c musimy uÅ¼yÄ‡ czegoÅ› innego do drukowania na standardowy bÅ‚Ä…d.</p>
<h3 id="sprawdzanie-gdzie-sÄ…-zapisywane-bÅ‚Ä™dy"><a class="header" href="#sprawdzanie-gdzie-sÄ…-zapisywane-bÅ‚Ä™dy">Sprawdzanie, gdzie sÄ… zapisywane bÅ‚Ä™dy</a></h3>
<p>Najpierw zaobserwujmy, jak zawartoÅ›Ä‡ drukowana przez <code>minigrep</code> jest obecnie zapisywana na standardowe wyjÅ›cie, w tym wszelkie komunikaty o bÅ‚Ä™dach, ktÃ³re chcielibyÅ›my zamiast tego zapisaÄ‡ na standardowy strumieÅ„ bÅ‚Ä™dÃ³w. Zrobimy to, przekierowujÄ…c standardowy strumieÅ„ wyjÅ›ciowy do pliku, celowo powodujÄ…c bÅ‚Ä…d. Nie bÄ™dziemy przekierowywaÄ‡ standardowego strumienia bÅ‚Ä™dÃ³w, wiÄ™c wszelka zawartoÅ›Ä‡ wysÅ‚ana na standardowy strumieÅ„ bÅ‚Ä™dÃ³w bÄ™dzie nadal wyÅ›wietlana na ekranie.</p>
<p>Oczekuje siÄ™, Å¼e programy wiersza poleceÅ„ wysyÅ‚ajÄ… komunikaty o bÅ‚Ä™dach do standardowego strumienia bÅ‚Ä™dÃ³w, abyÅ›my mogli nadal widzieÄ‡ komunikaty o bÅ‚Ä™dach na ekranie, nawet jeÅ›li przekierujemy standardowy strumieÅ„ wyjÅ›ciowy do pliku. Nasz program nie zachowuje siÄ™ obecnie poprawnie: zaraz zobaczymy, Å¼e zapisuje komunikaty o bÅ‚Ä™dach do pliku!</p>
<p>Aby zademonstrowaÄ‡ to zachowanie, uruchomimy program z <code>&gt;</code> i Å›cieÅ¼kÄ… pliku <em>output.txt</em>, do ktÃ³rej chcemy przekierowaÄ‡ standardowy strumieÅ„ wyjÅ›ciowy. Nie bÄ™dziemy przekazywaÄ‡ Å¼adnych argumentÃ³w, co powinno spowodowaÄ‡ bÅ‚Ä…d:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
</code></pre>
<p>SkÅ‚adnia <code>&gt;</code> informuje powÅ‚okÄ™, aby zapisaÅ‚a zawartoÅ›Ä‡ standardowego wyjÅ›cia do <em>output.txt</em> zamiast na ekran. Nie zobaczyliÅ›my komunikatu o bÅ‚Ä™dzie, ktÃ³rego siÄ™ spodziewaliÅ›my, na ekranie, wiÄ™c musi on trafiÄ‡ do pliku. Oto co zawiera <em>output.txt</em>:</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<p>Tak, nasz komunikat o bÅ‚Ä™dzie jest drukowany na standardowe wyjÅ›cie. DuÅ¼o bardziej uÅ¼yteczne jest drukowanie takich komunikatÃ³w o bÅ‚Ä™dach na standardowy strumieÅ„ bÅ‚Ä™dÃ³w, tak aby do pliku trafiaÅ‚y tylko dane z pomyÅ›lnego uruchomienia. Zmienimy to.</p>
<h3 id="drukowanie-bÅ‚Ä™dÃ³w-na-standardowy-strumieÅ„-bÅ‚Ä™dÃ³w"><a class="header" href="#drukowanie-bÅ‚Ä™dÃ³w-na-standardowy-strumieÅ„-bÅ‚Ä™dÃ³w">Drukowanie bÅ‚Ä™dÃ³w na standardowy strumieÅ„ bÅ‚Ä™dÃ³w</a></h3>
<p>UÅ¼yjemy kodu z Listing 12-24, aby zmieniÄ‡ sposÃ³b drukowania komunikatÃ³w o bÅ‚Ä™dach. DziÄ™ki refaktoryzacji, ktÃ³rÄ… przeprowadziliÅ›my wczeÅ›niej w tym rozdziale, caÅ‚y kod drukujÄ…cy komunikaty o bÅ‚Ä™dach znajduje siÄ™ w jednej funkcji, <code>main</code>. Standardowa biblioteka dostarcza makro <code>eprintln!</code>, ktÃ³re drukuje na standardowy strumieÅ„ bÅ‚Ä™dÃ³w, wiÄ™c zmieÅ„my dwa miejsca, w ktÃ³rych wywoÅ‚ywaliÅ›my <code>println!</code> do drukowania bÅ‚Ä™dÃ³w, aby zamiast tego uÅ¼yÄ‡ <code>eprintln!</code>.</p>
<listing number="12-24" file-name="src/main.rs" caption="Zapisywanie komunikatÃ³w o bÅ‚Ä™dach na standardowy strumieÅ„ bÅ‚Ä™dÃ³w zamiast na standardowe wyjÅ›cie za pomocÄ… `eprintln!`">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::{search, search_case_insensitive};
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    if let Err(e) = run(config) {
        eprintln!("Application error: {e}");
        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var("IGNORE_CASE").is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
</listing>
<p>Uruchommy teraz program ponownie w ten sam sposÃ³b, bez Å¼adnych argumentÃ³w i przekierowujÄ…c standardowe wyjÅ›cie za pomocÄ… <code>&gt;</code>:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<p>Teraz widzimy bÅ‚Ä…d na ekranie, a plik <em>output.txt</em> jest pusty, co jest zachowaniem, ktÃ³rego oczekujemy od programÃ³w wiersza poleceÅ„.</p>
<p>Uruchommy program ponownie z argumentami, ktÃ³re nie powodujÄ… bÅ‚Ä™du, ale nadal przekierowujÄ… standardowe wyjÅ›cie do pliku, w nastÄ™pujÄ…cy sposÃ³b:</p>
<pre><code class="language-console">$ cargo run -- to poem.txt &gt; output.txt
</code></pre>
<p>Nie zobaczymy Å¼adnych danych wyjÅ›ciowych w terminalu, a plik <em>output.txt</em> bÄ™dzie zawieraÅ‚ nasze wyniki:</p>
<p><span class="filename">Nazwa pliku: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>To pokazuje, Å¼e teraz uÅ¼ywamy standardowego wyjÅ›cia dla pomyÅ›lnych wynikÃ³w i standardowego strumienia bÅ‚Ä™dÃ³w dla komunikatÃ³w o bÅ‚Ä™dach, stosownie do potrzeb.</p>
<h2 id="podsumowanie-11"><a class="header" href="#podsumowanie-11">Podsumowanie</a></h2>
<p>Ten rozdziaÅ‚ podsumowaÅ‚ niektÃ³re z gÅ‚Ã³wnych pojÄ™Ä‡, ktÃ³re poznaÅ‚eÅ› do tej pory, i omÃ³wiÅ‚, jak wykonywaÄ‡ typowe operacje wejÅ›cia/wyjÅ›cia w Rust. KorzystajÄ…c z argumentÃ³w wiersza poleceÅ„, plikÃ³w, zmiennych Å›rodowiskowych i makra <code>eprintln!</code> do drukowania bÅ‚Ä™dÃ³w, jesteÅ› teraz przygotowany do pisania aplikacji wiersza poleceÅ„. W poÅ‚Ä…czeniu z koncepcjami z poprzednich rozdziaÅ‚Ã³w, TwÃ³j kod bÄ™dzie dobrze zorganizowany, skutecznie przechowywaÅ‚ dane w odpowiednich strukturach danych, Å‚adnie obsÅ‚ugiwaÅ‚ bÅ‚Ä™dy i bÄ™dzie dobrze przetestowany.</p>
<p>NastÄ™pnie zbadamy niektÃ³re funkcje Rusta, ktÃ³re zostaÅ‚y zainspirowane jÄ™zykami funkcyjnymi: domkniÄ™cia i iteratory.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="funkcjonalne-cechy-jÄ™zyka-iteratory-i-domkniÄ™cia"><a class="header" href="#funkcjonalne-cechy-jÄ™zyka-iteratory-i-domkniÄ™cia">Funkcjonalne cechy jÄ™zyka: Iteratory i domkniÄ™cia</a></h1>
<p>Projekt Rusta czerpie inspiracjÄ™ z wielu istniejÄ…cych jÄ™zykÃ³w i technik, a jednym z istotnych wpÅ‚ywÃ³w jest <em>programowanie funkcyjne</em>. Programowanie w stylu funkcyjnym czÄ™sto obejmuje uÅ¼ywanie funkcji jako wartoÅ›ci, przekazywanie ich w argumentach, zwracanie ich z innych funkcji, przypisywanie ich do zmiennych do pÃ³Åºniejszego wykonania i tak dalej.</p>
<p>W tym rozdziale nie bÄ™dziemy debatowaÄ‡ nad tym, czym jest lub nie jest programowanie funkcyjne, ale zamiast tego omÃ³wimy niektÃ³re cechy Rusta, ktÃ³re sÄ… podobne do cech w wielu jÄ™zykach czÄ™sto okreÅ›lanych jako funkcyjne.</p>
<p>Bardziej szczegÃ³Å‚owo omÃ³wimy:</p>
<ul>
<li><em>DomkniÄ™cia</em>, konstrukcje podobne do funkcji, ktÃ³re moÅ¼na przechowywaÄ‡ w zmiennej</li>
<li><em>Iteratory</em>, sposÃ³b przetwarzania serii elementÃ³w</li>
<li>Jak uÅ¼ywaÄ‡ domkniÄ™Ä‡ i iteratorÃ³w do ulepszenia projektu I/O z RozdziaÅ‚u 12</li>
<li>WydajnoÅ›Ä‡ domkniÄ™Ä‡ i iteratorÃ³w (spoiler: sÄ… szybsze, niÅ¼ mogÅ‚oby siÄ™ wydawaÄ‡!)</li>
</ul>
<p>OmÃ³wiliÅ›my juÅ¼ inne cechy Rusta, takie jak dopasowywanie wzorcÃ³w i wyliczenia, ktÃ³re rÃ³wnieÅ¼ sÄ… inspirowane stylem funkcyjnym. PoniewaÅ¼ opanowanie domkniÄ™Ä‡ i iteratorÃ³w jest waÅ¼nÄ… czÄ™Å›ciÄ… pisania szybkiego, idiomatycznego kodu w Rust, poÅ›wiÄ™cimy im caÅ‚y ten rozdziaÅ‚.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="domkniÄ™cia-1"><a href="#domkniÄ™cia-1" class="header">DomkniÄ™cia</a></h1>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="closures-anonymous-functions-that-can-capture-their-environment"></a>
<a id="closures-anonymous-functions-that-capture-their-environment"></a></p>
<h2 id="domkniÄ™cia"><a class="header" href="#domkniÄ™cia">DomkniÄ™cia</a></h2>
<p>DomkniÄ™cia w Rust to anonimowe funkcje, ktÃ³re moÅ¼na zapisaÄ‡ w zmiennej lub przekazaÄ‡ jako argumenty do innych funkcji. MoÅ¼na utworzyÄ‡ domkniÄ™cie w jednym miejscu, a nastÄ™pnie wywoÅ‚aÄ‡ je w innym, aby je oceniÄ‡ w innym kontekÅ›cie. W przeciwieÅ„stwie do funkcji, domkniÄ™cia mogÄ… przechwytywaÄ‡ wartoÅ›ci ze Å›rodowiska, w ktÃ³rym sÄ… zdefiniowane. Zdemonstrujemy, jak te cechy domkniÄ™Ä‡ pozwalajÄ… na ponowne uÅ¼ycie kodu i dostosowanie zachowania.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-an-abstraction-of-behavior-with-closures"></a>
<a id="refactoring-using-functions"></a>
<a id="refactoring-with-closures-to-store-code"></a>
<a id="capturing-the-environment-with-closures"></a></p>
<h3 id="przechwytywanie-Å›rodowiska"><a class="header" href="#przechwytywanie-Å›rodowiska">Przechwytywanie Å›rodowiska</a></h3>
<p>Najpierw zbadamy, jak moÅ¼emy uÅ¼ywaÄ‡ domkniÄ™Ä‡ do przechwytywania wartoÅ›ci ze Å›rodowiska, w ktÃ³rym sÄ… zdefiniowane, do pÃ³Åºniejszego uÅ¼ycia. Oto scenariusz: Co jakiÅ› czas nasza firma produkujÄ…ca koszulki rozdaje ekskluzywnÄ… koszulkÄ™ z limitowanej edycji osobie z naszej listy mailingowej w ramach promocji. Osoby z listy mailingowej mogÄ… opcjonalnie dodaÄ‡ swÃ³j ulubiony kolor do swojego profilu. JeÅ›li osoba wybrana do darmowej koszulki ma ustawiony ulubiony kolor, otrzymuje koszulkÄ™ w tym kolorze. JeÅ›li osoba nie okreÅ›liÅ‚a ulubionego koloru, otrzymuje koszulkÄ™ w kolorze, ktÃ³rego firma ma obecnie najwiÄ™cej.</p>
<p>Istnieje wiele sposobÃ³w na zaimplementowanie tego. W tym przykÅ‚adzie uÅ¼yjemy wyliczenia <code>ShirtColor</code>, ktÃ³re ma warianty <code>Red</code> i <code>Blue</code> (dla uproszczenia ograniczamy liczbÄ™ dostÄ™pnych kolorÃ³w). Reprezentujemy stan magazynowy firmy za pomocÄ… struktury <code>Inventory</code>, ktÃ³ra ma pole <code>shirts</code> zawierajÄ…ce <code>Vec&lt;ShirtColor&gt;</code> reprezentujÄ…ce kolory koszulek aktualnie w magazynie. Metoda <code>giveaway</code> zdefiniowana dla <code>Inventory</code> pobiera opcjonalne preferencje koloru koszulki zwyciÄ™zcy darmowej koszulki i zwraca kolor koszulki, ktÃ³rÄ… osoba otrzyma. Ta konfiguracja jest pokazana w Listing 13-1.</p>
<listing number="13-1" file-name="src/main.rs" caption="Sytuacja z rozdawaniem koszulek przez firmÄ™">
<pre><code class="language-rust noplayground">#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec&lt;ShirtColor&gt;,
}

impl Inventory {
    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&amp;self) -&gt; ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &amp;self.shirts {
            match color {
                ShirtColor::Red =&gt; num_red += 1,
                ShirtColor::Blue =&gt; num_blue += 1,
            }
        }
        if num_red &gt; num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        "UÅ¼ytkownik z preferencjÄ… {:?} dostaje {:?}",
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        "UÅ¼ytkownik z preferencjÄ… {:?} dostaje {:?}",
        user_pref2, giveaway2
    );
}</code></pre>
</listing>
<p><code>store</code> zdefiniowany w <code>main</code> ma dwie niebieskie i jednÄ… czerwonÄ… koszulkÄ™ do rozdania w ramach tej limitowanej promocji. WywoÅ‚ujemy metodÄ™ <code>giveaway</code> dla uÅ¼ytkownika preferujÄ…cego czerwonÄ… koszulkÄ™ i dla uÅ¼ytkownika bez Å¼adnych preferencji.</p>
<p>Ponownie, ten kod mÃ³gÅ‚by byÄ‡ zaimplementowany na wiele sposobÃ³w, a tutaj, aby skupiÄ‡ siÄ™ na domkniÄ™ciach, trzymaliÅ›my siÄ™ pojÄ™Ä‡, ktÃ³re juÅ¼ znasz, z wyjÄ…tkiem ciaÅ‚a metody <code>giveaway</code>, ktÃ³ra uÅ¼ywa domkniÄ™cia. W metodzie <code>giveaway</code> otrzymujemy preferencjÄ™ uÅ¼ytkownika jako parametr typu <code>Option&lt;ShirtColor&gt;</code> i wywoÅ‚ujemy metodÄ™ <code>unwrap_or_else</code> na <code>user_preference</code>. Metoda <a href="../std/option/enum.Option.html#method.unwrap_or_else"><code>unwrap_or_else</code> w <code>Option&lt;T&gt;</code></a><!-- ignore --> jest zdefiniowana przez standardowÄ… bibliotekÄ™. Przyjmuje jeden argument: domkniÄ™cie bez Å¼adnych argumentÃ³w, ktÃ³re zwraca wartoÅ›Ä‡ <code>T</code> (tego samego typu co przechowywany w wariancie <code>Some</code> <code>Option&lt;T&gt;</code>, w tym przypadku <code>ShirtColor</code>). JeÅ›li <code>Option&lt;T&gt;</code> jest wariantem <code>Some</code>, <code>unwrap_or_else</code> zwraca wartoÅ›Ä‡ z <code>Some</code>. JeÅ›li <code>Option&lt;T&gt;</code> jest wariantem <code>None</code>, <code>unwrap_or_else</code> wywoÅ‚uje domkniÄ™cie i zwraca wartoÅ›Ä‡ zwrÃ³conÄ… przez domkniÄ™cie.</p>
<p>OkreÅ›lamy wyraÅ¼enie domkniÄ™cia <code>|| self.most_stocked()</code> jako argument dla <code>unwrap_or_else</code>. Jest to domkniÄ™cie, ktÃ³re samo nie przyjmuje parametrÃ³w (gdyby domkniÄ™cie miaÅ‚o parametry, pojawiÅ‚yby siÄ™ one miÄ™dzy dwoma pionowymi kreskami). CiaÅ‚o domkniÄ™cia wywoÅ‚uje <code>self.most_stocked()</code>. Definiujemy tutaj domkniÄ™cie, a implementacja <code>unwrap_or_else</code> oceni domkniÄ™cie pÃ³Åºniej, jeÅ›li wynik bÄ™dzie potrzebny.</p>
<p>Uruchomienie tego kodu wyÅ›wietli nastÄ™pujÄ…ce informacje:</p>
<pre><code class="language-console">$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
UÅ¼ytkownik z preferencjÄ… Some(Red) dostaje Red
UÅ¼ytkownik z preferencjÄ… None dostaje Blue
</code></pre>
<p>Jednym interesujÄ…cym aspektem jest to, Å¼e przekazaliÅ›my domkniÄ™cie, ktÃ³re wywoÅ‚uje <code>self.most_stocked()</code> na bieÅ¼Ä…cej instancji <code>Inventory</code>. Standardowa biblioteka nie musiaÅ‚a wiedzieÄ‡ nic o typach <code>Inventory</code> ani <code>ShirtColor</code>, ktÃ³re zdefiniowaliÅ›my, ani o logice, ktÃ³rej chcemy uÅ¼yÄ‡ w tym scenariuszu. DomkniÄ™cie przechwytuje niezmiennÄ… referencjÄ™ do instancji <code>self</code> <code>Inventory</code> i przekazuje jÄ… z okreÅ›lonym przez nas kodem do metody <code>unwrap_or_else</code>. Funkcje natomiast nie sÄ… w stanie przechwytywaÄ‡ swojego Å›rodowiska w ten sposÃ³b.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="closure-type-inference-and-annotation"></a></p>
<h3 id="wywnioskowanie-i-adnotowanie-typÃ³w-domkniÄ™Ä‡"><a class="header" href="#wywnioskowanie-i-adnotowanie-typÃ³w-domkniÄ™Ä‡">Wywnioskowanie i adnotowanie typÃ³w domkniÄ™Ä‡</a></h3>
<p>Istnieje wiÄ™cej rÃ³Å¼nic miÄ™dzy funkcjami a domkniÄ™ciami. DomkniÄ™cia zazwyczaj nie wymagajÄ… adnotowania typÃ³w parametrÃ³w ani wartoÅ›ci zwracanej, tak jak funkcje <code>fn</code>. Adnotacje typÃ³w sÄ… wymagane w funkcjach, poniewaÅ¼ typy sÄ… czÄ™Å›ciÄ… jawnego interfejsu udostÄ™pnianego uÅ¼ytkownikom. Sztywne definiowanie tego interfejsu jest waÅ¼ne dla zapewnienia, Å¼e wszyscy zgadzajÄ… siÄ™ co do tego, jakich typÃ³w wartoÅ›ci funkcja uÅ¼ywa i zwraca. DomkniÄ™cia natomiast nie sÄ… uÅ¼ywane w takim udostÄ™pnionym interfejsie: sÄ… przechowywane w zmiennych i uÅ¼ywane bez nazywania ich i udostÄ™pniania uÅ¼ytkownikom naszej biblioteki.</p>
<p>DomkniÄ™cia sÄ… zazwyczaj krÃ³tkie i istotne tylko w wÄ…skim kontekÅ›cie, a nie w dowolnym scenariuszu. W tych ograniczonych kontekstach kompilator moÅ¼e wywnioskowaÄ‡ typy parametrÃ³w i typ zwracany, podobnie jak jest w stanie wywnioskowaÄ‡ typy wiÄ™kszoÅ›ci zmiennych (istniejÄ… rzadkie przypadki, w ktÃ³rych kompilator rÃ³wnieÅ¼ potrzebuje adnotacji typÃ³w domkniÄ™Ä‡).</p>
<p>Podobnie jak w przypadku zmiennych, moÅ¼emy dodaÄ‡ adnotacje typÃ³w, jeÅ›li chcemy zwiÄ™kszyÄ‡ jawnoÅ›Ä‡ i klarownoÅ›Ä‡ kosztem wiÄ™kszej szczegÃ³Å‚owoÅ›ci, niÅ¼ jest to Å›ciÅ›le konieczne. Adnotowanie typÃ³w dla domkniÄ™cia wyglÄ…daÅ‚oby jak definicja pokazana w Listing 13-2. W tym przykÅ‚adzie definiujemy domkniÄ™cie i przechowujemy je w zmiennej, zamiast definiowaÄ‡ domkniÄ™cie w miejscu, w ktÃ³rym przekazujemy je jako argument, jak to zrobiliÅ›my w Listing 13-1.</p>
<listing number="13-2" file-name="src/main.rs" caption="Dodawanie opcjonalnych adnotacji typÃ³w parametrÃ³w i wartoÅ›ci zwracanych w domkniÄ™ciu">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!("obliczanie powoli...");
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!("DziÅ›, zrÃ³b {} pompek!", expensive_closure(intensity));
</span><span class="boring">        println!("NastÄ™pnie, zrÃ³b {} brzuszkÃ³w!", expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!("ZrÃ³b sobie dziÅ› przerwÄ™! PamiÄ™taj o nawodnieniu!");
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                "DziÅ›, biegnij przez {} minut!",
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}</span></code></pre>
</listing>
<p>Po dodaniu adnotacji typÃ³w skÅ‚adnia domkniÄ™Ä‡ wyglÄ…da bardziej podobnie do skÅ‚adni funkcji. Tutaj definiujemy funkcjÄ™, ktÃ³ra dodaje 1 do swojego parametru, i domkniÄ™cie, ktÃ³re ma takie samo zachowanie, dla porÃ³wnania. DodaliÅ›my kilka spacji, aby wyrÃ³wnaÄ‡ odpowiednie czÄ™Å›ci. Pokazuje to, jak skÅ‚adnia domkniÄ™cia jest podobna do skÅ‚adni funkcji, z wyjÄ…tkiem uÅ¼ycia pionowych kresek i iloÅ›ci skÅ‚adni, ktÃ³ra jest opcjonalna:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;</code></pre>
<p>Pierwsza linia pokazuje definicjÄ™ funkcji, a druga definicjÄ™ domkniÄ™cia z peÅ‚nymi adnotacjami. W trzeciej linii usuwamy adnotacje typÃ³w z definicji domkniÄ™cia. W czwartej linii usuwamy nawiasy klamrowe, ktÃ³re sÄ… opcjonalne, poniewaÅ¼ ciaÅ‚o domkniÄ™cia ma tylko jedno wyraÅ¼enie. Wszystkie te definicje sÄ… poprawne i bÄ™dÄ… dawaÄ‡ to samo zachowanie po ich wywoÅ‚aniu. Linie <code>add_one_v3</code> i <code>add_one_v4</code> wymagajÄ… oceny domkniÄ™Ä‡, aby mogÅ‚y siÄ™ skompilowaÄ‡, poniewaÅ¼ typy zostanÄ… wywnioskowane z ich uÅ¼ycia. Jest to podobne do <code>let v = Vec::new();</code>, ktÃ³re wymaga albo adnotacji typÃ³w, albo wartoÅ›ci jakiegoÅ› typu do wstawienia do <code>Vec</code>, aby Rust mÃ³gÅ‚ wywnioskowaÄ‡ typ.</p>
<p>Dla definicji domkniÄ™Ä‡ kompilator wywnioskuje jeden konkretny typ dla kaÅ¼dego z ich parametrÃ³w i dla ich wartoÅ›ci zwracanej. Na przykÅ‚ad, Listing 13-3 pokazuje definicjÄ™ krÃ³tkiego domkniÄ™cia, ktÃ³re po prostu zwraca wartoÅ›Ä‡, ktÃ³rÄ… otrzymuje jako parametr. To domkniÄ™cie nie jest zbyt uÅ¼yteczne, z wyjÄ…tkiem celÃ³w tego przykÅ‚adu. ZauwaÅ¼, Å¼e nie dodaliÅ›my Å¼adnych adnotacji typÃ³w do definicji. PoniewaÅ¼ nie ma adnotacji typÃ³w, moÅ¼emy wywoÅ‚aÄ‡ domkniÄ™cie z dowolnym typem, co zrobiliÅ›my tutaj z <code>String</code> za pierwszym razem. JeÅ›li nastÄ™pnie sprÃ³bujemy wywoÅ‚aÄ‡ <code>example_closure</code> z liczbÄ… caÅ‚kowitÄ…, otrzymamy bÅ‚Ä…d.</p>
<listing number="13-3" file-name="src/main.rs" caption="PrÃ³ba wywoÅ‚ania domkniÄ™cia, ktÃ³rego typy sÄ… wywnioskowane, z dwoma rÃ³Å¼nymi typami">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5);
<span class="boring">}</span></code></pre>
</listing>
<p>Kompilator daje nam nastÄ™pujÄ…cy bÅ‚Ä…d:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |             --------------- ^ expected `String`, found integer
  |             |
  |             arguments to this function are incorrect
  |
note: expected because the closure was earlier called with an argument of type `String`
 --&gt; src/main.rs:4:29
  |
4 |     let s = example_closure(String::from("hello"));
  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of type `String`
  |             |
  |             in this closure call
note: closure parameter defined here
 --&gt; src/main.rs:2:28
  |
2 |     let example_closure = |x| x;
  |                            ^
help: try using a conversion method
  |
5 |     let n = example_closure(5.to_string());
  |                              ++++++++++++

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` (bin "closure-example") due to 1 previous error
</code></pre>
<p>Za pierwszym razem, gdy wywoÅ‚ujemy <code>example_closure</code> z wartoÅ›ciÄ… <code>String</code>, kompilator wywnioskowuje typ <code>x</code> i typ zwracany domkniÄ™cia jako <code>String</code>. Te typy sÄ… nastÄ™pnie zablokowane w domkniÄ™ciu w <code>example_closure</code>, i otrzymujemy bÅ‚Ä…d typu, gdy nastÄ™pnym razem prÃ³bujemy uÅ¼yÄ‡ innego typu z tym samym domkniÄ™ciem.</p>
<h3 id="przechwytywanie-referencji-lub-przenoszenie-wÅ‚asnoÅ›ci"><a class="header" href="#przechwytywanie-referencji-lub-przenoszenie-wÅ‚asnoÅ›ci">Przechwytywanie referencji lub przenoszenie wÅ‚asnoÅ›ci</a></h3>
<p>DomkniÄ™cia mogÄ… przechwytywaÄ‡ wartoÅ›ci ze swojego Å›rodowiska na trzy sposoby, ktÃ³re bezpoÅ›rednio odpowiadajÄ… trzem sposobom, w jakie funkcja moÅ¼e przyjÄ…Ä‡ parametr: poÅ¼yczanie niezmienne, poÅ¼yczanie zmienne i przejmowanie wÅ‚asnoÅ›ci. DomkniÄ™cie zdecyduje, ktÃ³rego z nich uÅ¼yÄ‡, w zaleÅ¼noÅ›ci od tego, co ciaÅ‚o funkcji robi z przechwyconymi wartoÅ›ciami.</p>
<p>W Listing 13-4 definiujemy domkniÄ™cie, ktÃ³re przechwytuje niezmiennÄ… referencjÄ™ do wektora o nazwie <code>list</code>, poniewaÅ¼ potrzebuje jedynie niezmiennej referencji, aby wydrukowaÄ‡ wartoÅ›Ä‡.</p>
<listing number="13-4" file-name="src/main.rs" caption="Definiowanie i wywoÅ‚ywanie domkniÄ™cia, ktÃ³re przechwytuje niezmiennÄ… referencjÄ™">
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let list = vec![1, 2, 3];
    println!("Przed zdefiniowaniem domkniÄ™cia: {list:?}");

    let only_borrows = || println!("Z domkniÄ™cia: {list:?}");

    println!("Przed wywoÅ‚aniem domkniÄ™cia: {list:?}");
    only_borrows();
    println!("Po wywoÅ‚aniu domkniÄ™cia: {list:?}");
}</code></pre>
</listing>
<p>Ten przykÅ‚ad ilustruje rÃ³wnieÅ¼, Å¼e zmienna moÅ¼e byÄ‡ zwiÄ…zana z definicjÄ… domkniÄ™cia, a pÃ³Åºniej moÅ¼emy wywoÅ‚aÄ‡ domkniÄ™cie, uÅ¼ywajÄ…c nazwy zmiennej i nawiasÃ³w, tak jakby nazwa zmiennej byÅ‚a nazwÄ… funkcji.</p>
<p>PoniewaÅ¼ moÅ¼emy mieÄ‡ jednoczeÅ›nie wiele niezmiennych referencji do <code>list</code>, <code>list</code> jest nadal dostÄ™pny z kodu przed definicjÄ… domkniÄ™cia, po definicji domkniÄ™cia, ale przed wywoÅ‚aniem domkniÄ™cia, i po wywoÅ‚aniu domkniÄ™cia. Ten kod kompiluje siÄ™, uruchamia i drukuje:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Przed zdefiniowaniem domkniÄ™cia: [1, 2, 3]
Przed wywoÅ‚aniem domkniÄ™cia: [1, 2, 3]
Z domkniÄ™cia: [1, 2, 3]
Po wywoÅ‚aniu domkniÄ™cia: [1, 2, 3]
</code></pre>
<p>NastÄ™pnie, w Listing 13-5, zmieniamy ciaÅ‚o domkniÄ™cia tak, aby dodawaÅ‚o element do wektora <code>list</code>. DomkniÄ™cie teraz przechwytuje zmiennÄ… referencjÄ™.</p>
<listing number="13-5" file-name="src/main.rs" caption="Definiowanie i wywoÅ‚ywanie domkniÄ™cia, ktÃ³re przechwytuje zmiennÄ… referencjÄ™">
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut list = vec![1, 2, 3];
    println!("Przed zdefiniowaniem domkniÄ™cia: {list:?}");

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("Po wywoÅ‚aniu domkniÄ™cia: {list:?}");
}</code></pre>
</listing>
<p>Ten kod kompiluje siÄ™, uruchamia i drukuje:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Przed zdefiniowaniem domkniÄ™cia: [1, 2, 3]
Po wywoÅ‚aniu domkniÄ™cia: [1, 2, 3, 7]
</code></pre>
<p>ZauwaÅ¼, Å¼e nie ma juÅ¼ <code>println!</code> miÄ™dzy definicjÄ… a wywoÅ‚aniem domkniÄ™cia <code>borrows_mutably</code>: Kiedy <code>borrows_mutably</code> jest zdefiniowane, przechwytuje zmiennÄ… referencjÄ™ do <code>list</code>. Nie uÅ¼ywamy domkniÄ™cia ponownie po jego wywoÅ‚aniu, wiÄ™c zmienna poÅ¼yczka siÄ™ koÅ„czy. MiÄ™dzy definicjÄ… domkniÄ™cia a wywoÅ‚aniem domkniÄ™cia, niezmienna poÅ¼yczka do wydrukowania nie jest dozwolona, poniewaÅ¼ Å¼adne inne poÅ¼yczki nie sÄ… dozwolone, gdy istnieje zmienna poÅ¼yczka. SprÃ³buj dodaÄ‡ tam <code>println!</code>, aby zobaczyÄ‡, jaki komunikat o bÅ‚Ä™dzie otrzymasz!</p>
<p>JeÅ›li chcesz wymusiÄ‡ na domkniÄ™ciu przejÄ™cie wÅ‚asnoÅ›ci wartoÅ›ci, ktÃ³rych uÅ¼ywa w Å›rodowisku, mimo Å¼e ciaÅ‚o domkniÄ™cia nie potrzebuje Å›ciÅ›le wÅ‚asnoÅ›ci, moÅ¼esz uÅ¼yÄ‡ sÅ‚owa kluczowego <code>move</code> przed listÄ… parametrÃ³w.</p>
<p>Ta technika jest najbardziej uÅ¼yteczna, gdy przekazujemy domkniÄ™cie do nowego wÄ…tku, aby przenieÅ›Ä‡ dane, tak aby nowy wÄ…tek byÅ‚ ich wÅ‚aÅ›cicielem. SzczegÃ³Å‚owo omÃ³wimy wÄ…tki i dlaczego warto ich uÅ¼ywaÄ‡ w Rozdziale 16, kiedy bÄ™dziemy mÃ³wiÄ‡ o wspÃ³Å‚bieÅ¼noÅ›ci, ale na razie przyjrzyjmy siÄ™ krÃ³tko tworzeniu nowego wÄ…tku za pomocÄ… domkniÄ™cia, ktÃ³re wymaga sÅ‚owa kluczowego <code>move</code>. Listing 13-6 pokazuje Listing 13-4 zmodyfikowany tak, aby drukowaÅ‚ wektor w nowym wÄ…tku, a nie w wÄ…tku gÅ‚Ã³wnym.</p>
<listing number="13-6" file-name="src/main.rs" caption="UÅ¼ywanie `move` do wymuszenia na domkniÄ™ciu dla wÄ…tku przejÄ™cia wÅ‚asnoÅ›ci `list`">
<pre class="playground"><code class="language-rust edition2024">use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("Przed zdefiniowaniem domkniÄ™cia: {list:?}");

    thread::spawn(move || println!("Z wÄ…tku: {list:?}"))
        .join()
        .unwrap();
}</code></pre>
</listing>
<p>Tworzymy nowy wÄ…tek, przekazujÄ…c mu domkniÄ™cie do uruchomienia jako argument. CiaÅ‚o domkniÄ™cia wypisuje listÄ™. W Listing 13-4 domkniÄ™cie przechwytywaÅ‚o <code>list</code> tylko za pomocÄ… niezmiennej referencji, poniewaÅ¼ to jest minimalny dostÄ™p do <code>list</code> potrzebny do jego wydrukowania. W tym przykÅ‚adzie, mimo Å¼e ciaÅ‚o domkniÄ™cia nadal potrzebuje tylko niezmiennej referencji, musimy okreÅ›liÄ‡, Å¼e <code>list</code> powinno zostaÄ‡ przeniesione do domkniÄ™cia, umieszczajÄ…c sÅ‚owo kluczowe <code>move</code> na poczÄ…tku definicji domkniÄ™cia. Gdyby wÄ…tek gÅ‚Ã³wny wykonywaÅ‚ wiÄ™cej operacji przed wywoÅ‚aniem <code>join</code> na nowym wÄ…tku, nowy wÄ…tek mÃ³gÅ‚by zakoÅ„czyÄ‡ siÄ™ przed zakoÅ„czeniem reszty wÄ…tku gÅ‚Ã³wnego, lub wÄ…tek gÅ‚Ã³wny mÃ³gÅ‚by zakoÅ„czyÄ‡ siÄ™ pierwszy. Gdyby wÄ…tek gÅ‚Ã³wny zachowaÅ‚ wÅ‚asnoÅ›Ä‡ <code>list</code>, ale zakoÅ„czyÅ‚ siÄ™ przed nowym wÄ…tkiem i upuÅ›ciÅ‚ <code>list</code>, niezmienna referencja w wÄ…tku byÅ‚aby niewaÅ¼na. Dlatego kompilator wymaga przeniesienia <code>list</code> do domkniÄ™cia przekazanego nowemu wÄ…tkowi, aby referencja byÅ‚a waÅ¼na. SprÃ³buj usunÄ…Ä‡ sÅ‚owo kluczowe <code>move</code> lub uÅ¼yÄ‡ <code>list</code> w wÄ…tku gÅ‚Ã³wnym po zdefiniowaniu domkniÄ™cia, aby zobaczyÄ‡, jakie bÅ‚Ä™dy kompilatora otrzymasz!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a>
<a id="limitations-of-the-cacher-implementation"></a>
<a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a>
<a id="moving-captured-values-out-of-closures-and-the-fn-traits"></a></p>
<h3 id="przenoszenie-przechwyconych-wartoÅ›ci-poza-domkniÄ™cia"><a class="header" href="#przenoszenie-przechwyconych-wartoÅ›ci-poza-domkniÄ™cia">Przenoszenie przechwyconych wartoÅ›ci poza domkniÄ™cia</a></h3>
<p>Gdy domkniÄ™cie przechwyci referencjÄ™ lub wÅ‚asnoÅ›Ä‡ wartoÅ›ci ze Å›rodowiska, w ktÃ³rym jest zdefiniowane (wpÅ‚ywajÄ…c tym samym na to, co, jeÅ›li w ogÃ³le, jest przenoszone <em>do</em> domkniÄ™cia), kod w ciele domkniÄ™cia okreÅ›la, co dzieje siÄ™ z referencjami lub wartoÅ›ciami, gdy domkniÄ™cie jest pÃ³Åºniej oceniane (wpÅ‚ywajÄ…c tym samym na to, co, jeÅ›li w ogÃ³le, jest przenoszone <em>z</em> domkniÄ™cia).</p>
<p>CiaÅ‚o domkniÄ™cia moÅ¼e wykonaÄ‡ dowolne z nastÄ™pujÄ…cych czynnoÅ›ci: przenieÅ›Ä‡ przechwyconÄ… wartoÅ›Ä‡ poza domkniÄ™cie, zmutowaÄ‡ przechwyconÄ… wartoÅ›Ä‡, ani nie przenieÅ›Ä‡, ani nie zmutowaÄ‡ wartoÅ›ci, lub w ogÃ³le nic nie przechwyciÄ‡ ze Å›rodowiska.</p>
<p>SposÃ³b, w jaki domkniÄ™cie przechwytuje i obsÅ‚uguje wartoÅ›ci ze Å›rodowiska, wpÅ‚ywa na to, ktÃ³re cechy domkniÄ™cie implementuje, a cechy to sposÃ³b, w jaki funkcje i struktury mogÄ… okreÅ›laÄ‡, jakich rodzajÃ³w domkniÄ™Ä‡ mogÄ… uÅ¼ywaÄ‡. DomkniÄ™cia automatycznie zaimplementujÄ… jednÄ…, dwie lub wszystkie trzy z tych cech <code>Fn</code>, w sposÃ³b addytywny, w zaleÅ¼noÅ›ci od tego, jak ciaÅ‚o domkniÄ™cia obsÅ‚uguje wartoÅ›ci:</p>
<ul>
<li><code>FnOnce</code> dotyczy domkniÄ™Ä‡, ktÃ³re moÅ¼na wywoÅ‚aÄ‡ raz. Wszystkie domkniÄ™cia implementujÄ… co najmniej tÄ™ cechÄ™, poniewaÅ¼ wszystkie domkniÄ™cia moÅ¼na wywoÅ‚aÄ‡. DomkniÄ™cie, ktÃ³re przenosi przechwycone wartoÅ›ci ze swojego ciaÅ‚a, zaimplementuje tylko <code>FnOnce</code> i Å¼adnych innych cech <code>Fn</code>, poniewaÅ¼ moÅ¼na je wywoÅ‚aÄ‡ tylko raz.</li>
<li><code>FnMut</code> dotyczy domkniÄ™Ä‡, ktÃ³re nie przenoszÄ… przechwyconych wartoÅ›ci ze swojego ciaÅ‚a, ale mogÄ… mutowaÄ‡ przechwycone wartoÅ›ci. Te domkniÄ™cia moÅ¼na wywoÅ‚aÄ‡ wiÄ™cej niÅ¼ raz.</li>
<li><code>Fn</code> dotyczy domkniÄ™Ä‡, ktÃ³re nie przenoszÄ… przechwyconych wartoÅ›ci ze swojego ciaÅ‚a i nie mutujÄ… przechwyconych wartoÅ›ci, a takÅ¼e domkniÄ™Ä‡, ktÃ³re nic nie przechwytujÄ… ze swojego Å›rodowiska. Te domkniÄ™cia moÅ¼na wywoÅ‚aÄ‡ wiÄ™cej niÅ¼ raz bez mutowania ich Å›rodowiska, co jest waÅ¼ne w przypadkach takich jak wielokrotne wywoÅ‚ywanie domkniÄ™cia wspÃ³Å‚bieÅ¼nie.</li>
</ul>
<p>Przyjrzyjmy siÄ™ definicji metody <code>unwrap_or_else</code> na <code>Option&lt;T&gt;</code>, ktÃ³rej uÅ¼yliÅ›my w Listing 13-1:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}</code></pre>
<p>PamiÄ™taj, Å¼e <code>T</code> to typ ogÃ³lny reprezentujÄ…cy typ wartoÅ›ci w wariancie <code>Some</code> <code>Option</code>. Ten typ <code>T</code> jest rÃ³wnieÅ¼ typem zwracanym przez funkcjÄ™ <code>unwrap_or_else</code>: kod, ktÃ³ry wywoÅ‚uje <code>unwrap_or_else</code> na <code>Option&lt;String&gt;</code>, na przykÅ‚ad, otrzyma <code>String</code>.</p>
<p>NastÄ™pnie, zauwaÅ¼, Å¼e funkcja <code>unwrap_or_else</code> ma dodatkowy generyczny parametr typu <code>F</code>. Typ <code>F</code> to typ parametru o nazwie <code>f</code>, czyli domkniÄ™cia, ktÃ³re dostarczamy podczas wywoÅ‚ywania <code>unwrap_or_else</code>.</p>
<p>Ograniczenie cechy okreÅ›lone dla typu generycznego <code>F</code> to <code>FnOnce() -&gt; T</code>, co oznacza, Å¼e <code>F</code> musi byÄ‡ wywoÅ‚ywalne raz, nie przyjmowaÄ‡ Å¼adnych argumentÃ³w i zwracaÄ‡ <code>T</code>. UÅ¼ycie <code>FnOnce</code> w ograniczeniu cechy wyraÅ¼a ograniczenie, Å¼e <code>unwrap_or_else</code> nie wywoÅ‚a <code>f</code> wiÄ™cej niÅ¼ raz. W ciele <code>unwrap_or_else</code> widzimy, Å¼e jeÅ›li <code>Option</code> jest <code>Some</code>, <code>f</code> nie zostanie wywoÅ‚ane. JeÅ›li <code>Option</code> jest <code>None</code>, <code>f</code> zostanie wywoÅ‚ane raz. PoniewaÅ¼ wszystkie domkniÄ™cia implementujÄ… <code>FnOnce</code>, <code>unwrap_or_else</code> akceptuje wszystkie trzy rodzaje domkniÄ™Ä‡ i jest tak elastyczne, jak to tylko moÅ¼liwe.</p>
<blockquote>
<p>Uwaga: JeÅ›li to, co chcemy zrobiÄ‡, nie wymaga przechwytywania wartoÅ›ci ze Å›rodowiska, moÅ¼emy uÅ¼yÄ‡ nazwy funkcji zamiast domkniÄ™cia tam, gdzie potrzebujemy czegoÅ›, co implementuje jednÄ… z cech <code>Fn</code>. Na przykÅ‚ad, na wartoÅ›ci <code>Option&lt;Vec&lt;T&gt;&gt;</code> moglibyÅ›my wywoÅ‚aÄ‡ <code>unwrap_or_else(Vec::new)</code>, aby otrzymaÄ‡ nowy, pusty wektor, jeÅ›li wartoÅ›Ä‡ to <code>None</code>. Kompilator automatycznie implementuje dowolnÄ… z cech <code>Fn</code>, ktÃ³ra jest odpowiednia dla definicji funkcji.</p>
</blockquote>
<p>Teraz przyjrzyjmy siÄ™ metodzie <code>sort_by_key</code> ze standardowej biblioteki, zdefiniowanej dla wycinkÃ³w, aby zobaczyÄ‡, jak rÃ³Å¼ni siÄ™ ona od <code>unwrap_or_else</code> i dlaczego <code>sort_by_key</code> uÅ¼ywa <code>FnMut</code> zamiast <code>FnOnce</code> dla ograniczenia cechy. DomkniÄ™cie otrzymuje jeden argument w postaci referencji do bieÅ¼Ä…cego elementu w rozpatrywanym wycinku i zwraca wartoÅ›Ä‡ typu <code>K</code>, ktÃ³rÄ… moÅ¼na posortowaÄ‡. Ta funkcja jest przydatna, gdy chcesz posortowaÄ‡ wycinek wedÅ‚ug okreÅ›lonego atrybutu kaÅ¼dego elementu. W Listing 13-7 mamy listÄ™ instancji <code>Rectangle</code> i uÅ¼ywamy <code>sort_by_key</code> do uporzÄ…dkowania ich wedÅ‚ug atrybutu <code>width</code> od najmniejszego do najwiÄ™kszego.</p>
<listing number="13-7" file-name="src/main.rs" caption="UÅ¼ywanie `sort_by_key` do porzÄ…dkowania prostokÄ…tÃ³w wedÅ‚ug szerokoÅ›ci">
<pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!("{list:#?}");
}</code></pre>
</listing>
<p>Ten kod drukuje:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
</code></pre>
<p>Powodem, dla ktÃ³rego <code>sort_by_key</code> jest zdefiniowany tak, aby przyjmowaÄ‡ domkniÄ™cie <code>FnMut</code>, jest to, Å¼e wywoÅ‚uje ono domkniÄ™cie wielokrotnie: raz dla kaÅ¼dego elementu w wycinku. DomkniÄ™cie <code>|r| r.width</code> nie przechwytuje, nie mutuje ani nie przenosi niczego ze swojego Å›rodowiska, wiÄ™c speÅ‚nia wymagania ograniczenia cechy.</p>
<p>Natomiast Listing 13-8 przedstawia przykÅ‚ad domkniÄ™cia, ktÃ³re implementuje tylko cechÄ™ <code>FnOnce</code>, poniewaÅ¼ przenosi wartoÅ›Ä‡ ze Å›rodowiska. Kompilator nie pozwoli nam uÅ¼yÄ‡ tego domkniÄ™cia z <code>sort_by_key</code>.</p>
<listing number="13-8" file-name="src/main.rs" caption="PrÃ³ba uÅ¼ycia domkniÄ™cia `FnOnce` z `sort_by_key`">
<pre><code class="language-rust ignore does_not_compile">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from("closure called");

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!("{list:#?}");
}</code></pre>
</listing>
<p>To jest wymyÅ›lny, skomplikowany sposÃ³b (ktÃ³ry nie dziaÅ‚a) na prÃ³bÄ™ zliczenia, ile razy <code>sort_by_key</code> wywoÅ‚uje domkniÄ™cie podczas sortowania <code>list</code>. Ten kod prÃ³buje to zrobiÄ‡, wpychajÄ…c <code>value</code> â€“ <code>String</code> ze Å›rodowiska domkniÄ™cia â€“ do wektora <code>sort_operations</code>. DomkniÄ™cie przechwytuje <code>value</code>, a nastÄ™pnie przenosi <code>value</code> poza domkniÄ™cie, przekazujÄ…c wÅ‚asnoÅ›Ä‡ <code>value</code> do wektora <code>sort_operations</code>. To domkniÄ™cie moÅ¼na wywoÅ‚aÄ‡ raz; prÃ³ba wywoÅ‚ania go po raz drugi nie zadziaÅ‚a, poniewaÅ¼ <code>value</code> nie byÅ‚oby juÅ¼ w Å›rodowisku, aby ponownie wpychaÄ‡ je do <code>sort_operations</code>! Dlatego to domkniÄ™cie implementuje tylko <code>FnOnce</code>. Kiedy prÃ³bujemy skompilowaÄ‡ ten kod, otrzymujemy nastÄ™pujÄ…cy bÅ‚Ä…d, Å¼e <code>value</code> nie moÅ¼e zostaÄ‡ przeniesione poza domkniÄ™cie, poniewaÅ¼ domkniÄ™cie musi implementowaÄ‡ <code>FnMut</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:18:30
   |
15 |     let value = String::from("closure called");
   |         -----   ------------------------------ move occurs because `value` has type `String`, which does not implement the `Copy` trait
   |         |
   |         captured outer variable
16 |
17 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
18 |         sort_operations.push(value);
   |                              ^^^^^ `value` is moved here
   |
help: consider cloning the value if the performance cost is acceptable
   |
18 |         sort_operations.push(value.clone());
   |                                   ++++++++

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` (bin "rectangles") due to 1 previous error
</code></pre>
<p>BÅ‚Ä…d wskazuje na liniÄ™ w ciele domkniÄ™cia, ktÃ³ra przenosi <code>value</code> poza Å›rodowisko. Aby to naprawiÄ‡, musimy zmieniÄ‡ ciaÅ‚o domkniÄ™cia tak, aby nie przenosiÅ‚o wartoÅ›ci poza Å›rodowisko. Utrzymywanie licznika w Å›rodowisku i inkrementowanie jego wartoÅ›ci w ciele domkniÄ™cia jest prostszym sposobem na zliczanie, ile razy domkniÄ™cie jest wywoÅ‚ywane. DomkniÄ™cie w Listing 13-9 dziaÅ‚a z <code>sort_by_key</code>, poniewaÅ¼ przechwytuje tylko zmiennÄ… referencjÄ™ do licznika <code>num_sort_operations</code> i dlatego moÅ¼e byÄ‡ wywoÅ‚ywane wiÄ™cej niÅ¼ raz.</p>
<listing number="13-9" file-name="src/main.rs" caption="UÅ¼ywanie domkniÄ™cia `FnMut` z `sort_by_key` jest dozwolone.">
<pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!("{list:#?}, posortowane w {num_sort_operations} operacjach");
}</code></pre>
</listing>
<p>Cechy <code>Fn</code> sÄ… waÅ¼ne podczas definiowania lub uÅ¼ywania funkcji lub typÃ³w, ktÃ³re wykorzystujÄ… domkniÄ™cia. W nastÄ™pnej sekcji omÃ³wimy iteratory. Wiele metod iteratora przyjmuje argumenty domkniÄ™cia, wiÄ™c pamiÄ™taj o tych szczegÃ³Å‚ach domkniÄ™Ä‡, kontynuujÄ…c!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="przetwarzanie-serii-elementÃ³w-za-pomocÄ…-iteratorÃ³w-1"><a href="#przetwarzanie-serii-elementÃ³w-za-pomocÄ…-iteratorÃ³w-1" class="header">Przetwarzanie serii elementÃ³w za pomocÄ… iteratorÃ³w</a></h1>
<h2 id="przetwarzanie-serii-elementÃ³w-za-pomocÄ…-iteratorÃ³w"><a class="header" href="#przetwarzanie-serii-elementÃ³w-za-pomocÄ…-iteratorÃ³w">Przetwarzanie serii elementÃ³w za pomocÄ… iteratorÃ³w</a></h2>
<p>Wzorzec iteratora pozwala na wykonywanie okreÅ›lonego zadania na sekwencji elementÃ³w po kolei. Iterator jest odpowiedzialny za logikÄ™ iterowania po kaÅ¼dym elemencie i okreÅ›lanie, kiedy sekwencja siÄ™ zakoÅ„czyÅ‚a. Kiedy uÅ¼ywasz iteratorÃ³w, nie musisz samodzielnie ponownie implementowaÄ‡ tej logiki.</p>
<p>W Rust iteratory sÄ… <em>lenistwe</em>, co oznacza, Å¼e nie majÄ… Å¼adnego efektu, dopÃ³ki nie wywoÅ‚asz metod, ktÃ³re zuÅ¼ywajÄ… iterator. Na przykÅ‚ad, kod w Listing 13-10 tworzy iterator po elementach w wektorze <code>v1</code>, wywoÅ‚ujÄ…c metodÄ™ <code>iter</code> zdefiniowanÄ… dla <code>Vec&lt;T&gt;</code>. Sam ten kod nie robi nic uÅ¼ytecznego.</p>
<listing number="13-10" file-name="src/main.rs" caption="Tworzenie iteratora">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
<span class="boring">}</span></code></pre>
</listing>
<p>Iterator jest przechowywany w zmiennej <code>v1_iter</code>. Po utworzeniu iteratora moÅ¼emy go uÅ¼ywaÄ‡ na rÃ³Å¼ne sposoby. W Listing 3-5 iterowaliÅ›my po tablicy za pomocÄ… pÄ™tli <code>for</code>, aby wykonaÄ‡ jakiÅ› kod na kaÅ¼dym z jej elementÃ³w. Pod spodem, to niejawnie utworzyÅ‚o, a nastÄ™pnie zuÅ¼yÅ‚o iterator, ale pomijaliÅ›my dokÅ‚adne dziaÅ‚anie tego mechanizmu aÅ¼ do teraz.</p>
<p>W przykÅ‚adzie z Listing 13-11 oddzielamy tworzenie iteratora od uÅ¼ywania iteratora w pÄ™tli <code>for</code>. Kiedy pÄ™tla <code>for</code> jest wywoÅ‚ywana z uÅ¼yciem iteratora w <code>v1_iter</code>, kaÅ¼dy element iteratora jest uÅ¼ywany w jednej iteracji pÄ™tli, ktÃ³ra wypisuje kaÅ¼dÄ… wartoÅ›Ä‡.</p>
<listing number="13-11" file-name="src/main.rs" caption="UÅ¼ywanie iteratora w pÄ™tli `for`">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!("Otrzymano: {val}");
    }
<span class="boring">}</span></code></pre>
</listing>
<p>W jÄ™zykach, ktÃ³re nie majÄ… iteratorÃ³w dostarczanych przez ich standardowe biblioteki, prawdopodobnie napisaÅ‚byÅ› tÄ™ samÄ… funkcjonalnoÅ›Ä‡, rozpoczynajÄ…c zmiennÄ… od indeksu 0, uÅ¼ywajÄ…c tej zmiennej do indeksowania wektora w celu uzyskania wartoÅ›ci i zwiÄ™kszajÄ…c wartoÅ›Ä‡ zmiennej w pÄ™tli, dopÃ³ki nie osiÄ…gnÄ™Å‚aby caÅ‚kowitej liczby elementÃ³w w wektorze.</p>
<p>Iteratory obsÅ‚ugujÄ… caÅ‚Ä… tÄ™ logikÄ™ za Ciebie, zmniejszajÄ…c iloÅ›Ä‡ powtarzajÄ…cego siÄ™ kodu, ktÃ³ry mÃ³gÅ‚byÅ› potencjalnie zepsuÄ‡. Iteratory dajÄ… wiÄ™kszÄ… elastycznoÅ›Ä‡ w uÅ¼ywaniu tej samej logiki z wieloma rÃ³Å¼nymi rodzajami sekwencji, a nie tylko ze strukturami danych, do ktÃ³rych moÅ¼na indeksowaÄ‡, takimi jak wektory. Przyjrzyjmy siÄ™, jak to robiÄ… iteratory.</p>
<h3 id="cecha-iterator-i-metoda-next"><a class="header" href="#cecha-iterator-i-metoda-next">Cecha <code>Iterator</code> i metoda <code>next</code></a></h3>
<p>Wszystkie iteratory implementujÄ… cechÄ™ o nazwie <code>Iterator</code>, ktÃ³ra jest zdefiniowana w standardowej bibliotece. Definicja cechy wyglÄ…da nastÄ™pujÄ…co:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // metody z domyÅ›lnymi implementacjami pominiÄ™te
}
<span class="boring">}</span></code></pre>
<p>ZauwaÅ¼, Å¼e ta definicja uÅ¼ywa nowej skÅ‚adni: <code>type Item</code> i <code>Self::Item</code>, ktÃ³re definiujÄ… typ skojarzony z tÄ… cechÄ…. SzczegÃ³Å‚owo omÃ³wimy typy skojarzone w Rozdziale 20. Na razie wystarczy wiedzieÄ‡, Å¼e ten kod mÃ³wi, Å¼e implementacja cechy <code>Iterator</code> wymaga rÃ³wnieÅ¼ zdefiniowania typu <code>Item</code>, a ten typ <code>Item</code> jest uÅ¼ywany w typie zwracanym przez metodÄ™ <code>next</code>. Innymi sÅ‚owy, typ <code>Item</code> bÄ™dzie typem zwracanym przez iterator.</p>
<p>Cecha <code>Iterator</code> wymaga od implementatorÃ³w zdefiniowania tylko jednej metody: metody <code>next</code>, ktÃ³ra zwraca po jednym elemencie iteratora na raz, opakowanym w <code>Some</code>, a po zakoÅ„czeniu iteracji zwraca <code>None</code>.</p>
<p>MoÅ¼emy wywoÅ‚ywaÄ‡ metodÄ™ <code>next</code> bezpoÅ›rednio na iteratorach; Listing 13-12 pokazuje, jakie wartoÅ›ci sÄ… zwracane z wielokrotnych wywoÅ‚aÅ„ <code>next</code> na iteratorze utworzonym z wektora.</p>
<listing number="13-12" file-name="src/lib.rs" caption="WywoÅ‚ywanie metody `next` na iteratorze">
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">}</span></code></pre>
</listing>
<p>ZauwaÅ¼, Å¼e musieliÅ›my uczyniÄ‡ <code>v1_iter</code> zmiennym: wywoÅ‚anie metody <code>next</code> na iteratorze zmienia wewnÄ™trzny stan, ktÃ³rego iterator uÅ¼ywa do Å›ledzenia swojej pozycji w sekwencji. Innymi sÅ‚owy, ten kod <em>zuÅ¼ywa</em>, czyli wykorzystuje, iterator. KaÅ¼de wywoÅ‚anie <code>next</code> pobiera element z iteratora. Nie musieliÅ›my uczyniÄ‡ <code>v1_iter</code> zmiennym, gdy uÅ¼ywaliÅ›my pÄ™tli <code>for</code>, poniewaÅ¼ pÄ™tla przejmowaÅ‚a wÅ‚asnoÅ›Ä‡ <code>v1_iter</code> i czyniÅ‚a go zmiennym za kulisami.</p>
<p>ZauwaÅ¼ rÃ³wnieÅ¼, Å¼e wartoÅ›ci, ktÃ³re otrzymujemy z wywoÅ‚aÅ„ <code>next</code>, to niezmienne referencje do wartoÅ›ci w wektorze. Metoda <code>iter</code> produkuje iterator po niezmiennych referencjach. JeÅ›li chcemy stworzyÄ‡ iterator, ktÃ³ry przejmuje wÅ‚asnoÅ›Ä‡ <code>v1</code> i zwraca posiadane wartoÅ›ci, moÅ¼emy zamiast <code>iter</code> wywoÅ‚aÄ‡ <code>into_iter</code>. Podobnie, jeÅ›li chcemy iterowaÄ‡ po zmiennych referencjach, moÅ¼emy zamiast <code>iter</code> wywoÅ‚aÄ‡ <code>iter_mut</code>.</p>
<h3 id="metody-ktÃ³re-zuÅ¼ywajÄ…-iterator"><a class="header" href="#metody-ktÃ³re-zuÅ¼ywajÄ…-iterator">Metody, ktÃ³re zuÅ¼ywajÄ… iterator</a></h3>
<p>Cecha <code>Iterator</code> ma szereg rÃ³Å¼nych metod z domyÅ›lnymi implementacjami dostarczonymi przez standardowÄ… bibliotekÄ™; o tych metodach moÅ¼esz dowiedzieÄ‡ siÄ™, przeglÄ…dajÄ…c dokumentacjÄ™ API standardowej biblioteki dla cechy <code>Iterator</code>. NiektÃ³re z tych metod wywoÅ‚ujÄ… metodÄ™ <code>next</code> w swojej definicji, dlatego jesteÅ› zobowiÄ…zany do zaimplementowania metody <code>next</code> przy implementacji cechy <code>Iterator</code>.</p>
<p>Metody, ktÃ³re wywoÅ‚ujÄ… <code>next</code>, nazywane sÄ… <em>konsumujÄ…cymi adapterami</em>, poniewaÅ¼ ich wywoÅ‚anie zuÅ¼ywa iterator. Jednym z przykÅ‚adÃ³w jest metoda <code>sum</code>, ktÃ³ra przejmuje wÅ‚asnoÅ›Ä‡ iteratora i iteruje przez elementy, wielokrotnie wywoÅ‚ujÄ…c <code>next</code>, zuÅ¼ywajÄ…c tym samym iterator. Podczas iteracji dodaje kaÅ¼dy element do bieÅ¼Ä…cej sumy i zwraca sumÄ™ po zakoÅ„czeniu iteracji. Listing 13-13 zawiera test ilustrujÄ…cy uÅ¼ycie metody <code>sum</code>.</p>
<listing number="13-13" file-name="src/lib.rs" caption="WywoÅ‚ywanie metody `sum` w celu uzyskania sumy wszystkich elementÃ³w w iteratorze">
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">}</span></code></pre>
</listing>
<p>Nie moÅ¼emy uÅ¼yÄ‡ <code>v1_iter</code> po wywoÅ‚aniu <code>sum</code>, poniewaÅ¼ <code>sum</code> przejmuje wÅ‚asnoÅ›Ä‡ iteratora, na ktÃ³rym jest wywoÅ‚ywana.</p>
<h3 id="metody-ktÃ³re-produkujÄ…-inne-iteratory"><a class="header" href="#metody-ktÃ³re-produkujÄ…-inne-iteratory">Metody, ktÃ³re produkujÄ… inne iteratory</a></h3>
<p><em>Adaptery iteratora</em> to metody zdefiniowane na cesze <code>Iterator</code>, ktÃ³re nie zuÅ¼ywajÄ… iteratora. Zamiast tego produkujÄ… one inne iteratory, zmieniajÄ…c jakiÅ› aspekt oryginalnego iteratora.</p>
<p>Listing 13-14 pokazuje przykÅ‚ad wywoÅ‚ania metody adaptera iteratora <code>map</code>, ktÃ³ra przyjmuje domkniÄ™cie do wywoÅ‚ania na kaÅ¼dym elemencie w trakcie iteracji. Metoda <code>map</code> zwraca nowy iterator, ktÃ³ry produkuje zmodyfikowane elementy. DomkniÄ™cie tutaj tworzy nowy iterator, w ktÃ³rym kaÅ¼dy element z wektora zostanie zwiÄ™kszony o 1.</p>
<listing number="13-14" file-name="src/main.rs" caption="WywoÅ‚anie adaptera iteratora `map` w celu utworzenia nowego iteratora">
<pre class="playground"><code class="language-rust not_desired_behavior edition2024"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}</span></code></pre>
</listing>
<p>Jednak ten kod generuje ostrzeÅ¼enie:</p>
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: iterators are lazy and do nothing unless consumed
  = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
  |
4 |     let _ = v1.iter().map(|x| x + 1);
  |     +++++++

warning: `iterators` (bin "iterators") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<p>Kod w Listing 13-14 nic nie robi; okreÅ›lone przez nas domkniÄ™cie nigdy nie jest wywoÅ‚ywane. OstrzeÅ¼enie przypomina nam, dlaczego: adaptery iteratorÃ³w sÄ… leniwe, i musimy tutaj skonsumowaÄ‡ iterator.</p>
<p>Aby naprawiÄ‡ to ostrzeÅ¼enie i skonsumowaÄ‡ iterator, uÅ¼yjemy metody <code>collect</code>, ktÃ³rej uÅ¼yliÅ›my z <code>env::args</code> w Listing 12-1. Ta metoda zuÅ¼ywa iterator i zbiera wynikowe wartoÅ›ci do typu danych kolekcji.</p>
<p>W Listing 13-15 zbieramy wyniki iteracji po iteratorze zwrÃ³conym z wywoÅ‚ania <code>map</code> do wektora. Ten wektor bÄ™dzie zawieraÅ‚ kaÅ¼dy element z oryginalnego wektora, zwiÄ™kszony o 1.</p>
<listing number="13-15" file-name="src/main.rs" caption="WywoÅ‚ywanie metody `map` w celu utworzenia nowego iteratora, a nastÄ™pnie wywoÅ‚ywanie metody `collect` w celu zuÅ¼ycia nowego iteratora i utworzenia wektora">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}</span></code></pre>
</listing>
<p>PoniewaÅ¼ <code>map</code> przyjmuje domkniÄ™cie, moÅ¼emy okreÅ›liÄ‡ dowolnÄ… operacjÄ™, ktÃ³rÄ… chcemy wykonaÄ‡ na kaÅ¼dym elemencie. Jest to doskonaÅ‚y przykÅ‚ad tego, jak domkniÄ™cia pozwalajÄ… dostosowaÄ‡ pewne zachowanie, jednoczeÅ›nie ponownie wykorzystujÄ…c zachowanie iteracji, ktÃ³re zapewnia cecha <code>Iterator</code>.</p>
<p>MoÅ¼na Å‚Ä…czyÄ‡ wiele wywoÅ‚aÅ„ adapterÃ³w iteratora, aby wykonywaÄ‡ zÅ‚oÅ¼one dziaÅ‚ania w czytelny sposÃ³b. PoniewaÅ¼ jednak wszystkie iteratory sÄ… leniwe, naleÅ¼y wywoÅ‚aÄ‡ jednÄ… z metod adaptera konsumujÄ…cego, aby uzyskaÄ‡ wyniki z wywoÅ‚aÅ„ adapterÃ³w iteratora.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="using-closures-that-capture-their-environment"></a></p>
<h3 id="domkniÄ™cia-ktÃ³re-przechwytujÄ…-swoje-Å›rodowisko"><a class="header" href="#domkniÄ™cia-ktÃ³re-przechwytujÄ…-swoje-Å›rodowisko">DomkniÄ™cia, ktÃ³re przechwytujÄ… swoje Å›rodowisko</a></h3>
<p>Wiele adapterÃ³w iteratora przyjmuje domkniÄ™cia jako argumenty, a czÄ™sto domkniÄ™cia, ktÃ³re bÄ™dziemy okreÅ›laÄ‡ jako argumenty dla adapterÃ³w iteratora, bÄ™dÄ… domkniÄ™ciami, ktÃ³re przechwytujÄ… ich Å›rodowisko.</p>
<p>W tym przykÅ‚adzie uÅ¼yjemy metody <code>filter</code>, ktÃ³ra przyjmuje domkniÄ™cie. DomkniÄ™cie pobiera element z iteratora i zwraca <code>bool</code>. JeÅ›li domkniÄ™cie zwraca <code>true</code>, wartoÅ›Ä‡ zostanie wÅ‚Ä…czona do iteracji wyprodukowanej przez <code>filter</code>. JeÅ›li domkniÄ™cie zwraca <code>false</code>, wartoÅ›Ä‡ nie zostanie wÅ‚Ä…czona.</p>
<p>W Listing 13-16 uÅ¼ywamy <code>filter</code> z domkniÄ™ciem, ktÃ³re przechwytuje zmiennÄ… <code>shoe_size</code> ze swojego Å›rodowiska, aby iterowaÄ‡ po kolekcji instancji struktury <code>Shoe</code>. ZwrÃ³ci tylko buty o okreÅ›lonym rozmiarze.</p>
<listing number="13-16" file-name="src/lib.rs" caption="UÅ¼ycie metody `filter` z domkniÄ™ciem, ktÃ³re przechwytuje `shoe_size`">
<pre><code class="language-rust noplayground">#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from("sneaker"),
            },
            Shoe {
                size: 13,
                style: String::from("sandal"),
            },
            Shoe {
                size: 10,
                style: String::from("boot"),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from("sneaker")
                },
                Shoe {
                    size: 10,
                    style: String::from("boot")
                },
            ]
        );
    }
}</code></pre>
</listing>
<p>Funkcja <code>shoes_in_size</code> przejmuje wÅ‚asnoÅ›Ä‡ wektora butÃ³w i rozmiaru buta jako parametry. Zwraca wektor zawierajÄ…cy tylko buty o okreÅ›lonym rozmiarze.</p>
<p>W ciele <code>shoes_in_size</code> wywoÅ‚ujemy <code>into_iter</code>, aby stworzyÄ‡ iterator, ktÃ³ry przejmuje wÅ‚asnoÅ›Ä‡ wektora. NastÄ™pnie wywoÅ‚ujemy <code>filter</code>, aby dostosowaÄ‡ ten iterator do nowego iteratora, ktÃ³ry zawiera tylko elementy, dla ktÃ³rych domkniÄ™cie zwraca <code>true</code>.</p>
<p>DomkniÄ™cie przechwytuje parametr <code>shoe_size</code> ze Å›rodowiska i porÃ³wnuje wartoÅ›Ä‡ z rozmiarem kaÅ¼dego buta, zachowujÄ…c tylko buty o okreÅ›lonym rozmiarze. Na koniec wywoÅ‚anie <code>collect</code> zbiera wartoÅ›ci zwrÃ³cone przez dostosowany iterator do wektora, ktÃ³ry jest zwracany przez funkcjÄ™.</p>
<p>Test pokazuje, Å¼e po wywoÅ‚aniu <code>shoes_in_size</code> otrzymujemy z powrotem tylko buty, ktÃ³re majÄ… ten sam rozmiar, co okreÅ›lona przez nas wartoÅ›Ä‡.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="udoskonalanie-naszego-projektu-io-1"><a href="#udoskonalanie-naszego-projektu-io-1" class="header">Udoskonalanie naszego projektu I/O</a></h1>
<h2 id="udoskonalanie-naszego-projektu-io"><a class="header" href="#udoskonalanie-naszego-projektu-io">Udoskonalanie naszego projektu I/O</a></h2>
<p>DziÄ™ki tej nowej wiedzy o iteratorach moÅ¼emy ulepszyÄ‡ projekt I/O z RozdziaÅ‚u 12, wykorzystujÄ…c iteratory, aby uczyniÄ‡ kod bardziej czytelnym i zwiÄ™zÅ‚ym. Przyjrzyjmy siÄ™, jak iteratory mogÄ… ulepszyÄ‡ naszÄ… implementacjÄ™ funkcji <code>Config::build</code> i funkcji <code>search</code>.</p>
<h3 id="usuwanie-clone-za-pomocÄ…-iteratora"><a class="header" href="#usuwanie-clone-za-pomocÄ…-iteratora">Usuwanie <code>clone</code> za pomocÄ… iteratora</a></h3>
<p>W Listing 12-6 dodaliÅ›my kod, ktÃ³ry przyjmowaÅ‚ wycinek wartoÅ›ci <code>String</code> i tworzyÅ‚ instancjÄ™ struktury <code>Config</code> poprzez indeksowanie do wycinka i klonowanie wartoÅ›ci, co pozwalaÅ‚o strukturze <code>Config</code> na posiadanie tych wartoÅ›ci. W Listing 13-17 odtworzyliÅ›my implementacjÄ™ funkcji <code>Config::build</code> takÄ…, jaka byÅ‚a w Listing 12-23.</p>
<listing number="13-17" file-name="src/main.rs" caption="Reprodukcja funkcji `Config::build` z Listing 12-23">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::{search, search_case_insensitive};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        println!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
</listing>
<p>WÃ³wczas powiedzieliÅ›my, Å¼eby nie martwiÄ‡ siÄ™ nieefektywnymi wywoÅ‚aniami <code>clone</code>, poniewaÅ¼ usuniemy je w przyszÅ‚oÅ›ci. CÃ³Å¼, ten czas nadszedÅ‚!</p>
<p>PotrzebowaliÅ›my <code>clone</code> tutaj, poniewaÅ¼ mamy wycinek z elementami <code>String</code> w parametrze <code>args</code>, ale funkcja <code>build</code> nie jest wÅ‚aÅ›cicielem <code>args</code>. Aby zwrÃ³ciÄ‡ wÅ‚asnoÅ›Ä‡ instancji <code>Config</code>, musieliÅ›my sklonowaÄ‡ wartoÅ›ci z pÃ³l <code>query</code> i <code>file_path</code> <code>Config</code>, tak aby instancja <code>Config</code> mogÅ‚a posiadaÄ‡ swoje wartoÅ›ci.</p>
<p>DziÄ™ki naszej nowej wiedzy o iteratorach moÅ¼emy zmieniÄ‡ funkcjÄ™ <code>build</code>, aby przyjmowaÅ‚a wÅ‚asnoÅ›Ä‡ iteratora jako swÃ³j argument, zamiast poÅ¼yczaÄ‡ wycinek. UÅ¼yjemy funkcjonalnoÅ›ci iteratora zamiast kodu, ktÃ³ry sprawdza dÅ‚ugoÅ›Ä‡ wycinka i indeksuje do okreÅ›lonych miejsc. To wyjaÅ›ni, co robi funkcja <code>Config::build</code>, poniewaÅ¼ iterator bÄ™dzie miaÅ‚ dostÄ™p do wartoÅ›ci.</p>
<p>Gdy <code>Config::build</code> przejmie wÅ‚asnoÅ›Ä‡ iteratora i przestanie uÅ¼ywaÄ‡ operacji indeksowania, ktÃ³re poÅ¼yczajÄ…, moÅ¼emy przenieÅ›Ä‡ wartoÅ›ci <code>String</code> z iteratora do <code>Config</code> zamiast wywoÅ‚ywaÄ‡ <code>clone</code> i tworzyÄ‡ nowÄ… alokacjÄ™.</p>
<h4 id="bezpoÅ›rednie-uÅ¼ywanie-zwrÃ³conego-iteratora"><a class="header" href="#bezpoÅ›rednie-uÅ¼ywanie-zwrÃ³conego-iteratora">BezpoÅ›rednie uÅ¼ywanie zwrÃ³conego iteratora</a></h4>
<p>OtwÃ³rz plik <em>src/main.rs</em> swojego projektu I/O, ktÃ³ry powinien wyglÄ…daÄ‡ nastÄ™pujÄ…co:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::{search, search_case_insensitive};
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        eprintln!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var("IGNORE_CASE").is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<p>Najpierw zmienimy poczÄ…tek funkcji <code>main</code> z Listing 12-24 na kod z Listing 13-18, ktÃ³ry tym razem uÅ¼ywa iteratora. To nie skompiluje siÄ™, dopÃ³ki nie zaktualizujemy rÃ³wnieÅ¼ <code>Config::build</code>.</p>
<listing number="13-18" file-name="src/main.rs" caption="Przekazywanie wartoÅ›ci zwracanej przez `env::args` do `Config::build`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::{search, search_case_insensitive};
</span><span class="boring">
</span>fn main() {
    let config = Config::build(env::args()).unwrap_or_else(|err| {
        eprintln!("Problem z parsowaniem argumentÃ³w: {err}");
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        eprintln!("BÅ‚Ä…d aplikacji: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("za maÅ‚o argumentÃ³w");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var("IGNORE_CASE").is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
</listing>
<p>Funkcja <code>env::args</code> zwraca iterator! Zamiast zbieraÄ‡ wartoÅ›ci iteratora do wektora, a nastÄ™pnie przekazywaÄ‡ wycinek do <code>Config::build</code>, teraz przekazujemy wÅ‚asnoÅ›Ä‡ iteratora zwrÃ³conego przez <code>env::args</code> bezpoÅ›rednio do <code>Config::build</code>.</p>
<p>NastÄ™pnie musimy zaktualizowaÄ‡ definicjÄ™ <code>Config::build</code>. ZmieÅ„my sygnaturÄ™ <code>Config::build</code> tak, aby wyglÄ…daÅ‚a jak w Listing 13-19. To nadal siÄ™ nie skompiluje, poniewaÅ¼ musimy zaktualizowaÄ‡ ciaÅ‚o funkcji.</p>
<listing number="13-19" file-name="src/main.rs" caption="Aktualizacja sygnatury `Config::build` w celu oczekiwania iteratora">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::{search, search_case_insensitive};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let config = Config::build(env::args()).unwrap_or_else(|err| {
</span><span class="boring">        eprintln!("Problem z parsowaniem argumentÃ³w: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        eprintln!("BÅ‚Ä…d aplikacji: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("za maÅ‚o argumentÃ³w");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var("IGNORE_CASE").is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
</listing>
<p>Dokumentacja standardowej biblioteki dla funkcji <code>env::args</code> pokazuje, Å¼e typ iteratora, ktÃ³ry zwraca, to <code>std::env::Args</code>, a ten typ implementuje cechÄ™ <code>Iterator</code> i zwraca wartoÅ›ci <code>String</code>.</p>
<p>ZaktualizowaliÅ›my sygnaturÄ™ funkcji <code>Config::build</code> tak, aby parametr <code>args</code> miaÅ‚ typ generyczny z ograniczeniami cech <code>impl Iterator&lt;Item = String&gt;</code> zamiast <code>&amp;[String]</code>. To uÅ¼ycie skÅ‚adni <code>impl Trait</code>, ktÃ³rÄ… omÃ³wiliÅ›my w sekcji <a href="#traits-as-parameters">â€UÅ¼ywanie cech jako parametrÃ³wâ€</a><!-- ignore --> w Rozdziale 10, oznacza, Å¼e <code>args</code> moÅ¼e byÄ‡ dowolnym typem, ktÃ³ry implementuje cechÄ™ <code>Iterator</code> i zwraca elementy <code>String</code>.</p>
<p>PoniewaÅ¼ przejmujemy wÅ‚asnoÅ›Ä‡ <code>args</code> i bÄ™dziemy modyfikowaÄ‡ <code>args</code> poprzez iteracjÄ™ po nim, moÅ¼emy dodaÄ‡ sÅ‚owo kluczowe <code>mut</code> do specyfikacji parametru <code>args</code>, aby uczyniÄ‡ go zmiennym.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="using-iterator-trait-methods-instead-of-indexing"></a></p>
<h4 id="uÅ¼ywanie-metod-cech-iterator"><a class="header" href="#uÅ¼ywanie-metod-cech-iterator">UÅ¼ywanie metod cech <code>Iterator</code></a></h4>
<p>NastÄ™pnie poprawimy ciaÅ‚o <code>Config::build</code>. PoniewaÅ¼ <code>args</code> implementuje cechÄ™ <code>Iterator</code>, wiemy, Å¼e moÅ¼emy na nim wywoÅ‚aÄ‡ metodÄ™ <code>next</code>! Listing 13-20 aktualizuje kod z Listing 12-23, aby uÅ¼ywaÅ‚ metody <code>next</code>.</p>
<listing number="13-20" file-name="src/main.rs" caption="Zmiana ciaÅ‚a `Config::build` w celu uÅ¼ycia metod iteratora">
<pre><code class="language-rust ignore noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::{search, search_case_insensitive};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let config = Config::build(env::args()).unwrap_or_else(|err| {
</span><span class="boring">        eprintln!("Problem z parsowaniem argumentÃ³w: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        eprintln!("BÅ‚Ä…d aplikacji: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err("Nie otrzymano ciÄ…gu zapytania"),
        };

        let file_path = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err("Nie otrzymano Å›cieÅ¼ki pliku"),
        };

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
</listing>
<p>PamiÄ™taj, Å¼e pierwsza wartoÅ›Ä‡ zwracana przez <code>env::args</code> to nazwa programu. Chcemy jÄ… zignorowaÄ‡ i przejÅ›Ä‡ do nastÄ™pnej wartoÅ›ci, wiÄ™c najpierw wywoÅ‚ujemy <code>next</code> i nic nie robimy z wartoÅ›ciÄ… zwracanÄ…. NastÄ™pnie wywoÅ‚ujemy <code>next</code>, aby uzyskaÄ‡ wartoÅ›Ä‡, ktÃ³rÄ… chcemy umieÅ›ciÄ‡ w polu <code>query</code> struktury <code>Config</code>. JeÅ›li <code>next</code> zwraca <code>Some</code>, uÅ¼ywamy <code>match</code>, aby wyodrÄ™bniÄ‡ wartoÅ›Ä‡. JeÅ›li zwraca <code>None</code>, oznacza to, Å¼e nie podano wystarczajÄ…cej liczby argumentÃ³w, i zwracamy <code>Err</code>. To samo robimy dla wartoÅ›ci <code>file_path</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="making-code-clearer-with-iterator-adapters"></a></p>
<h3 id="upraszczanie-kodu-za-pomocÄ…-adapterÃ³w-iteratorÃ³w"><a class="header" href="#upraszczanie-kodu-za-pomocÄ…-adapterÃ³w-iteratorÃ³w">Upraszczanie kodu za pomocÄ… adapterÃ³w iteratorÃ³w</a></h3>
<p>MoÅ¼emy rÃ³wnieÅ¼ wykorzystaÄ‡ iteratory w funkcji <code>search</code> w naszym projekcie I/O, ktÃ³ra jest tutaj odtworzona w Listing 13-21 w takiej postaci, w jakiej byÅ‚a w Listing 12-19.</p>
<listing number="13-21" file-name="src/lib.rs" caption="Implementacja funkcji `search` z Listing 12-19">
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</listing>
<p>MoÅ¼emy napisaÄ‡ ten kod w bardziej zwiÄ™zÅ‚y sposÃ³b, uÅ¼ywajÄ…c metod adaptera iteratora. Pozwala to rÃ³wnieÅ¼ uniknÄ…Ä‡ posiadania zmiennego, poÅ›redniego wektora <code>results</code>. Styl programowania funkcyjnego preferuje minimalizowanie iloÅ›ci zmiennego stanu, aby kod byÅ‚ bardziej czytelny. UsuniÄ™cie zmiennego stanu moÅ¼e umoÅ¼liwiÄ‡ przyszÅ‚e ulepszenie, aby wyszukiwanie odbywaÅ‚o siÄ™ rÃ³wnolegle, poniewaÅ¼ nie musielibyÅ›my zarzÄ…dzaÄ‡ wspÃ³Å‚bieÅ¼nym dostÄ™pem do wektora <code>results</code>. Listing 13-22 pokazuje tÄ™ zmianÄ™.</p>
<listing number="13-22" file-name="src/lib.rs" caption="UÅ¼ywanie metod adaptera iteratora w implementacji funkcji `search`">
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
<span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</listing>
<p>PamiÄ™taj, Å¼e celem funkcji <code>search</code> jest zwrÃ³cenie wszystkich wierszy w <code>contents</code>, ktÃ³re zawierajÄ… <code>query</code>. Podobnie jak w przykÅ‚adzie <code>filter</code> w Listing 13-16, ten kod uÅ¼ywa adaptera <code>filter</code> do zachowania tylko tych wierszy, dla ktÃ³rych <code>line.contains(query)</code> zwraca <code>true</code>. NastÄ™pnie zbieramy pasujÄ…ce wiersze do innego wektora za pomocÄ… <code>collect</code>. O wiele proÅ›ciej! ZachÄ™camy do wprowadzenia tej samej zmiany, aby uÅ¼ywaÄ‡ metod iteratora rÃ³wnieÅ¼ w funkcji <code>search_case_insensitive</code>.</p>
<p>Dla dalszego ulepszenia, zwrÃ³Ä‡ iterator z funkcji <code>search</code> poprzez usuniÄ™cie wywoÅ‚ania <code>collect</code> i zmianÄ™ typu zwracanego na <code>impl Iterator&lt;Item = &amp;'a str&gt;</code>, tak aby funkcja staÅ‚a siÄ™ adapterem iteratora. ZauwaÅ¼, Å¼e bÄ™dziesz musiaÅ‚ rÃ³wnieÅ¼ zaktualizowaÄ‡ testy! Przeszukaj duÅ¼y plik za pomocÄ… narzÄ™dzia <code>minigrep</code> przed i po wprowadzeniu tej zmiany, aby zaobserwowaÄ‡ rÃ³Å¼nicÄ™ w zachowaniu. Przed tÄ… zmianÄ… program nie wyÅ›wietli Å¼adnych wynikÃ³w, dopÃ³ki nie zbierze wszystkich wynikÃ³w, ale po zmianie wyniki bÄ™dÄ… wyÅ›wietlane w miarÄ™ znajdowania kaÅ¼dej pasujÄ…cej linii, poniewaÅ¼ pÄ™tla <code>for</code> w funkcji <code>run</code> bÄ™dzie mogÅ‚a wykorzystaÄ‡ lenistwo iteratora.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="choosing-between-loops-or-iterators"></a></p>
<h3 id="wybÃ³r-miÄ™dzy-pÄ™tlami-a-iteratorami"><a class="header" href="#wybÃ³r-miÄ™dzy-pÄ™tlami-a-iteratorami">WybÃ³r miÄ™dzy pÄ™tlami a iteratorami</a></h3>
<p>NastÄ™pne logiczne pytanie brzmi, jaki styl powinieneÅ› wybraÄ‡ w swoim kodzie i dlaczego: oryginalnÄ… implementacjÄ™ z Listing 13-21, czy wersjÄ™ uÅ¼ywajÄ…cÄ… iteratorÃ³w z Listing 13-22 (zakÅ‚adajÄ…c, Å¼e zbieramy wszystkie wyniki przed ich zwrÃ³ceniem, a nie zwracamy iteratora). WiÄ™kszoÅ›Ä‡ programistÃ³w Rusta preferuje styl iteratorÃ³w. Na poczÄ…tku jest to trochÄ™ trudniejsze do opanowania, ale gdy juÅ¼ poczujesz siÄ™ z rÃ³Å¼nymi adapterami iteratorÃ³w i tym, co robiÄ…, iteratory mogÄ… byÄ‡ Å‚atwiejsze do zrozumienia. Zamiast bawiÄ‡ siÄ™ rÃ³Å¼nymi elementami pÄ™tli i budowaÄ‡ nowe wektory, kod skupia siÄ™ na ogÃ³lnym celu pÄ™tli. Abstrakcjonizuje to niektÃ³re z typowych kodÃ³w, dziÄ™ki czemu Å‚atwiej jest dostrzec koncepcje unikalne dla tego kodu, takie jak warunek filtrowania, ktÃ³ry musi speÅ‚niÄ‡ kaÅ¼dy element w iteratorze.</p>
<p>Ale czy te dwie implementacje sÄ… naprawdÄ™ rÃ³wnowaÅ¼ne? Intuicyjne zaÅ‚oÅ¼enie moÅ¼e byÄ‡ takie, Å¼e pÄ™tla niÅ¼szego poziomu bÄ™dzie szybsza. Porozmawiajmy o wydajnoÅ›ci.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wydajnoÅ›Ä‡-w-pÄ™tlach-vs-iteratorach-1"><a href="#wydajnoÅ›Ä‡-w-pÄ™tlach-vs-iteratorach-1" class="header">WydajnoÅ›Ä‡ w pÄ™tlach vs. iteratorach</a></h1>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="comparing-performance-loops-vs-iterators"></a></p>
<h2 id="wydajnoÅ›Ä‡-w-pÄ™tlach-vs-iteratorach"><a class="header" href="#wydajnoÅ›Ä‡-w-pÄ™tlach-vs-iteratorach">WydajnoÅ›Ä‡ w pÄ™tlach vs. iteratorach</a></h2>
<p>Aby zdecydowaÄ‡, czy uÅ¼yÄ‡ pÄ™tli, czy iteratorÃ³w, musisz wiedzieÄ‡, ktÃ³ra implementacja jest szybsza: wersja funkcji <code>search</code> z jawnÄ… pÄ™tlÄ… <code>for</code> czy wersja z iteratorami.</p>
<p>PrzeprowadziliÅ›my benchmark, Å‚adujÄ…c caÅ‚Ä… zawartoÅ›Ä‡ <em>PrzygÃ³d Sherlocka Holmesa</em> Sir Arthura Conana Doyleâ€™a do <code>String</code> i szukajÄ…c sÅ‚owa <em>the</em> w zawartoÅ›ci. Oto wyniki benchmarku dla wersji <code>search</code> uÅ¼ywajÄ…cej pÄ™tli <code>for</code> i wersji uÅ¼ywajÄ…cej iteratorÃ³w:</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>Obie implementacje majÄ… podobnÄ… wydajnoÅ›Ä‡! Nie bÄ™dziemy tutaj wyjaÅ›niaÄ‡ kodu benchmarku, poniewaÅ¼ nie chodzi o udowodnienie, Å¼e obie wersje sÄ… rÃ³wnowaÅ¼ne, ale o ogÃ³lne rozeznanie, jak te dwie implementacje wypadajÄ… pod wzglÄ™dem wydajnoÅ›ci.</p>
<p>Aby uzyskaÄ‡ bardziej kompleksowy benchmark, powinieneÅ› sprawdziÄ‡ uÅ¼ycie rÃ³Å¼nych tekstÃ³w o rÃ³Å¼nych rozmiarach jako <code>contents</code>, rÃ³Å¼nych sÅ‚Ã³w i sÅ‚Ã³w o rÃ³Å¼nej dÅ‚ugoÅ›ci jako <code>query</code> oraz wszelkiego rodzaju innych wariacji. Chodzi o to: iteratory, choÄ‡ sÄ… abstrakcjÄ… wysokiego poziomu, sÄ… kompilowane do mniej wiÄ™cej tego samego kodu, co gdybyÅ› sam napisaÅ‚ kod niÅ¼szego poziomu. Iteratory to jedna z <em>abstrakcji zerokosztowych</em> Rusta, co oznacza, Å¼e uÅ¼ycie abstrakcji nie narzuca Å¼adnego dodatkowego narzutu czasowego. Jest to analogiczne do tego, jak Bjarne Stroustrup, oryginalny projektant i implementator C++, definiuje zerowy narzut w swoim przemÃ³wieniu inauguracyjnym ETAPS z 2012 roku â€Foundations of C++â€:</p>
<blockquote>
<p>OgÃ³lnie rzecz biorÄ…c, implementacje C++ przestrzegajÄ… zasady zerowego narzutu: Czego nie uÅ¼ywasz, za to nie pÅ‚acisz. A dalej: Czego uÅ¼ywasz, nie mÃ³gÅ‚byÅ› napisaÄ‡ rÄ™cznie lepiej.</p>
</blockquote>
<p>W wielu przypadkach kod Rusta uÅ¼ywajÄ…cy iteratorÃ³w kompiluje siÄ™ do tego samego assemblera, co kod napisany rÄ™cznie. Stosowane sÄ… optymalizacje, takie jak rozwiniÄ™cie pÄ™tli i eliminacja sprawdzania zakresÃ³w przy dostÄ™pie do tablic, co sprawia, Å¼e wynikowy kod jest niezwykle wydajny. Teraz, gdy to wiesz, moÅ¼esz bez obaw uÅ¼ywaÄ‡ iteratorÃ³w i domkniÄ™Ä‡! SprawiajÄ…, Å¼e kod wydaje siÄ™ byÄ‡ na wyÅ¼szym poziomie, ale nie narzucajÄ… kary za wydajnoÅ›Ä‡ w czasie dziaÅ‚ania.</p>
<h2 id="podsumowanie-12"><a class="header" href="#podsumowanie-12">Podsumowanie</a></h2>
<p>DomkniÄ™cia i iteratory to cechy Rusta inspirowane ideami programowania funkcyjnego. PrzyczyniajÄ… siÄ™ one do zdolnoÅ›ci Rusta do wyraÅºnego wyraÅ¼ania idei wysokiego poziomu z niskopoziomowÄ… wydajnoÅ›ciÄ…. Implementacje domkniÄ™Ä‡ i iteratorÃ³w sÄ… takie, Å¼e wydajnoÅ›Ä‡ w czasie dziaÅ‚ania nie jest naruszana. Jest to czÄ™Å›Ä‡ celu Rusta, jakim jest dÄ…Å¼enie do zapewnienia abstrakcji zerokosztowych.</p>
<p>Teraz, gdy ulepszyliÅ›my ekspresywnoÅ›Ä‡ naszego projektu I/O, przyjrzyjmy siÄ™ kilku innym funkcjom <code>cargo</code>, ktÃ³re pomogÄ… nam udostÄ™pniÄ‡ projekt Å›wiatu.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wiÄ™cej-o-cargo-i-cratesio"><a class="header" href="#wiÄ™cej-o-cargo-i-cratesio">WiÄ™cej o Cargo i Crates.io</a></h1>
<p>Do tej pory uÅ¼ywaliÅ›my tylko najbardziej podstawowych funkcji Cargo do budowania, uruchamiania i testowania naszego kodu, ale potrafi ono znacznie wiÄ™cej. W tym rozdziale omÃ³wimy niektÃ³re z jego innych, bardziej zaawansowanych funkcji, aby pokazaÄ‡, jak:</p>
<ul>
<li>DostosowaÄ‡ kompilacjÄ™ za pomocÄ… profili wydania.</li>
<li>PublikowaÄ‡ biblioteki na <a href="https://crates.io/">crates.io</a><!-- ignore -->.</li>
<li>OrganizowaÄ‡ duÅ¼e projekty za pomocÄ… obszarÃ³w roboczych.</li>
<li>InstalowaÄ‡ pliki binarne z <a href="https://crates.io/">crates.io</a><!-- ignore -->.</li>
<li>RozszerzaÄ‡ Cargo za pomocÄ… niestandardowych poleceÅ„.</li>
</ul>
<p>Cargo potrafi jeszcze wiÄ™cej niÅ¼ funkcjonalnoÅ›Ä‡, ktÃ³rÄ… omÃ³wimy w tym rozdziale, wiÄ™c aby uzyskaÄ‡ peÅ‚ne wyjaÅ›nienie wszystkich jego funkcji, zobacz <a href="https://doc.rust-lang.org/cargo/">jego dokumentacjÄ™</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dostosowywanie-kompilacji-za-pomocÄ…-profili-wydania-1"><a href="#dostosowywanie-kompilacji-za-pomocÄ…-profili-wydania-1" class="header">Dostosowywanie kompilacji za pomocÄ… profili wydania</a></h1>
<h2 id="dostosowywanie-kompilacji-za-pomocÄ…-profili-wydania"><a class="header" href="#dostosowywanie-kompilacji-za-pomocÄ…-profili-wydania">Dostosowywanie kompilacji za pomocÄ… profili wydania</a></h2>
<p>W Rust <em>profile wydania</em> to predefiniowane, dostosowywalne profile z rÃ³Å¼nymi konfiguracjami, ktÃ³re pozwalajÄ… programistom na wiÄ™kszÄ… kontrolÄ™ nad rÃ³Å¼nymi opcjami kompilacji kodu. KaÅ¼dy profil jest konfigurowany niezaleÅ¼nie od innych.</p>
<p>Cargo ma dwa gÅ‚Ã³wne profile: profil <code>dev</code>, ktÃ³rego Cargo uÅ¼ywa podczas uruchamiania <code>cargo build</code>, oraz profil <code>release</code>, ktÃ³rego Cargo uÅ¼ywa podczas uruchamiania <code>cargo build --release</code>. Profil <code>dev</code> jest zdefiniowany z dobrymi wartoÅ›ciami domyÅ›lnymi do tworzenia oprogramowania, a profil <code>release</code> ma dobre wartoÅ›ci domyÅ›lne dla kompilacji wydania.</p>
<p>Te nazwy profili mogÄ… byÄ‡ znane z danych wyjÅ›ciowych Twoich kompilacji:</p>
<!-- manual-regeneration
anywhere, run:
cargo build
cargo build --release
and ensure output below is accurate
-->
<pre><code class="language-console">$ cargo build
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s
$ cargo build --release
    Finished `release` profile [optimized] target(s) in 0.32s
</code></pre>
<p><code>dev</code> i <code>release</code> to rÃ³Å¼ne profile uÅ¼ywane przez kompilator.</p>
<p>Cargo ma domyÅ›lne ustawienia dla kaÅ¼dego z profili, ktÃ³re sÄ… stosowane, gdy nie dodaÅ‚eÅ› jawnie Å¼adnych sekcji <code>[profile.*]</code> do pliku <em>Cargo.toml</em> projektu. DodajÄ…c sekcje <code>[profile.*]</code> dla dowolnego profilu, ktÃ³ry chcesz dostosowaÄ‡, nadpisujesz dowolny podzbiÃ³r domyÅ›lnych ustawieÅ„. Na przykÅ‚ad, oto domyÅ›lne wartoÅ›ci ustawienia <code>opt-level</code> dla profili <code>dev</code> i <code>release</code>:</p>
<p><span class="filename">Nazwa pliku: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p>Ustawienie <code>opt-level</code> kontroluje liczbÄ™ optymalizacji, ktÃ³re Rust zastosuje do Twojego kodu, w zakresie od 0 do 3. Zastosowanie wiÄ™kszej liczby optymalizacji wydÅ‚uÅ¼a czas kompilacji, wiÄ™c jeÅ›li jesteÅ› w fazie rozwoju i czÄ™sto kompilujesz swÃ³j kod, bÄ™dziesz chciaÅ‚ mniej optymalizacji, aby kompilowaÄ‡ szybciej, nawet jeÅ›li wynikowy kod bÄ™dzie dziaÅ‚aÅ‚ wolniej. DomyÅ›lny <code>opt-level</code> dla <code>dev</code> wynosi zatem <code>0</code>. Kiedy jesteÅ› gotowy do wydania swojego kodu, najlepiej poÅ›wiÄ™ciÄ‡ wiÄ™cej czasu na kompilacjÄ™. Skompilujesz w trybie wydania tylko raz, ale bÄ™dziesz uruchamiaÄ‡ skompilowany program wiele razy, wiÄ™c tryb wydania wymienia dÅ‚uÅ¼szy czas kompilacji na szybszy kod. Dlatego domyÅ›lny <code>opt-level</code> dla profilu <code>release</code> wynosi <code>3</code>.</p>
<p>MoÅ¼esz nadpisaÄ‡ domyÅ›lne ustawienie, dodajÄ…c dla niego innÄ… wartoÅ›Ä‡ w <em>Cargo.toml</em>. Na przykÅ‚ad, jeÅ›li chcemy uÅ¼yÄ‡ poziomu optymalizacji 1 w profilu deweloperskim, moÅ¼emy dodaÄ‡ te dwie linie do pliku <em>Cargo.toml</em> naszego projektu:</p>
<p><span class="filename">Nazwa pliku: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>Ten kod nadpisuje domyÅ›lne ustawienie <code>0</code>. Teraz, gdy uruchomimy <code>cargo build</code>, Cargo uÅ¼yje domyÅ›lnych ustawieÅ„ dla profilu <code>dev</code> plus nasze dostosowanie <code>opt-level</code>. PoniewaÅ¼ ustawiliÅ›my <code>opt-level</code> na <code>1</code>, Cargo zastosuje wiÄ™cej optymalizacji niÅ¼ domyÅ›lnie, ale nie tak wiele, jak w kompilacji wydania.</p>
<p>Aby uzyskaÄ‡ peÅ‚nÄ… listÄ™ opcji konfiguracji i wartoÅ›ci domyÅ›lnych dla kaÅ¼dego profilu, zobacz <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">dokumentacjÄ™ Cargo</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="publikowanie-pakietu-na-cratesio-1"><a href="#publikowanie-pakietu-na-cratesio-1" class="header">Publikowanie pakietu na Crates.io</a></h1>
<h2 id="publikowanie-pakietu-na-cratesio"><a class="header" href="#publikowanie-pakietu-na-cratesio">Publikowanie pakietu na Crates.io</a></h2>
<p>KorzystaliÅ›my juÅ¼ z pakietÃ³w z <a href="https://crates.io/">crates.io</a><!-- ignore --> jako zaleÅ¼noÅ›ci w naszych projektach, ale moÅ¼esz rÃ³wnieÅ¼ udostÄ™pniaÄ‡ swÃ³j kod innym osobom, publikujÄ…c wÅ‚asne pakiety. Rejestr pakietÃ³w <a href="https://crates.io/">crates.io</a><!-- ignore --> dystrybuuje kod ÅºrÃ³dÅ‚owy Twoich pakietÃ³w, wiÄ™c hostuje gÅ‚Ã³wnie kod open source.</p>
<p>Rust i Cargo posiadajÄ… funkcje, ktÃ³re uÅ‚atwiajÄ… innym osobom odnalezienie i uÅ¼ycie opublikowanego pakietu. NastÄ™pnie omÃ³wimy niektÃ³re z tych funkcji, a potem wyjaÅ›nimy, jak opublikowaÄ‡ pakiet.</p>
<h3 id="tworzenie-uÅ¼ytecznych-komentarzy-dokumentacji"><a class="header" href="#tworzenie-uÅ¼ytecznych-komentarzy-dokumentacji">Tworzenie uÅ¼ytecznych komentarzy dokumentacji</a></h3>
<p>DokÅ‚adne udokumentowanie Twoich pakietÃ³w pomoÅ¼e innym uÅ¼ytkownikom zrozumieÄ‡, jak i kiedy ich uÅ¼ywaÄ‡, dlatego warto poÅ›wiÄ™ciÄ‡ czas na napisanie dokumentacji. W Rozdziale 3 omÃ³wiliÅ›my, jak komentowaÄ‡ kod w Rust za pomocÄ… dwÃ³ch ukoÅ›nikÃ³w, <code>//</code>. Rust ma rÃ³wnieÅ¼ szczegÃ³lny rodzaj komentarza do dokumentacji, znany wygodnie jako <em>komentarz dokumentacji</em>, ktÃ³ry wygeneruje dokumentacjÄ™ HTML. HTML wyÅ›wietla zawartoÅ›Ä‡ komentarzy dokumentacji dla publicznych elementÃ³w API przeznaczonych dla programistÃ³w zainteresowanych sposobem <em>uÅ¼ycia</em> Twojego pakietu, w przeciwieÅ„stwie do sposobu <em>implementacji</em> Twojego pakietu.</p>
<p>Komentarze dokumentacji uÅ¼ywajÄ… trzech ukoÅ›nikÃ³w, <code>///</code>, zamiast dwÃ³ch i obsÅ‚ugujÄ… notacjÄ™ Markdown do formatowania tekstu. UmieÅ›Ä‡ komentarze dokumentacji tuÅ¼ przed elementem, ktÃ³ry dokumentujÄ…. Listing 14-1 pokazuje komentarze dokumentacji dla funkcji <code>add_one</code> w pakiecie o nazwie <code>my_crate</code>.</p>
<listing number="14-1" file-name="src/lib.rs" caption="Komentarz dokumentacji dla funkcji">
<pre><code class="language-rust ignore">/// Dodaje jeden do podanej liczby.
///
/// # PrzykÅ‚ady
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
</listing>
<p>Tutaj podajemy opis tego, co robi funkcja <code>add_one</code>, rozpoczynamy sekcjÄ™ z nagÅ‚Ã³wkiem <code>PrzykÅ‚ady</code>, a nastÄ™pnie podajemy kod, ktÃ³ry demonstruje, jak uÅ¼ywaÄ‡ funkcji <code>add_one</code>. MoÅ¼emy wygenerowaÄ‡ dokumentacjÄ™ HTML z tego komentarza dokumentacji, uruchamiajÄ…c <code>cargo doc</code>. To polecenie uruchamia narzÄ™dzie <code>rustdoc</code> dystrybuowane z Rustem i umieszcza wygenerowanÄ… dokumentacjÄ™ HTML w katalogu <em>target/doc</em>.</p>
<p>Dla wygody, uruchomienie <code>cargo doc --open</code> zbuduje HTML dla dokumentacji twojego bieÅ¼Ä…cego pakietu (a takÅ¼e dokumentacjÄ™ dla wszystkich zaleÅ¼noÅ›ci twojego pakietu) i otworzy wynik w przeglÄ…darce internetowej. PrzejdÅº do funkcji <code>add_one</code> i zobaczysz, jak tekst z komentarzy dokumentacji jest renderowany, jak pokazano na Rysunku 14-1.</p>
<img alt="Wyrenderowana dokumentacja HTML dla funkcji `add_one` pakietu `my_crate`" src="img/trpl14-01.png" class="center" />
<p><span class="caption">Rysunek 14-1: Dokumentacja HTML dla funkcji <code>add_one</code></span></p>
<h4 id="czÄ™sto-uÅ¼ywane-sekcje"><a class="header" href="#czÄ™sto-uÅ¼ywane-sekcje">CzÄ™sto uÅ¼ywane sekcje</a></h4>
<p>UÅ¼yliÅ›my nagÅ‚Ã³wka Markdown <code># PrzykÅ‚ady</code> w Listing 14-1, aby stworzyÄ‡ sekcjÄ™ w HTML z tytuÅ‚em â€PrzykÅ‚adyâ€. Oto inne sekcje, ktÃ³re autorzy pakietÃ³w czÄ™sto uÅ¼ywajÄ… w swojej dokumentacji:</p>
<ul>
<li><strong>Panics</strong>: SÄ… to scenariusze, w ktÃ³rych dokumentowana funkcja moÅ¼e wywoÅ‚aÄ‡ panikÄ™. Osoby wywoÅ‚ujÄ…ce funkcjÄ™, ktÃ³re nie chcÄ…, aby ich programy panikowaÅ‚y, powinny upewniÄ‡ siÄ™, Å¼e nie wywoÅ‚ujÄ… funkcji w tych sytuacjach.</li>
<li><strong>Errors</strong>: JeÅ›li funkcja zwraca <code>Result</code>, opisanie rodzajÃ³w bÅ‚Ä™dÃ³w, ktÃ³re mogÄ… wystÄ…piÄ‡, i warunkÃ³w, ktÃ³re mogÄ… spowodowaÄ‡ zwrÃ³cenie tych bÅ‚Ä™dÃ³w, moÅ¼e byÄ‡ pomocne dla osÃ³b wywoÅ‚ujÄ…cych, aby mogÅ‚y napisaÄ‡ kod do obsÅ‚ugi rÃ³Å¼nych rodzajÃ³w bÅ‚Ä™dÃ³w na rÃ³Å¼ne sposoby.</li>
<li><strong>Safety</strong>: JeÅ›li wywoÅ‚anie funkcji jest <code>unsafe</code> (niebezpieczne) (omawiamy niebezpieczeÅ„stwo w Rozdziale 20), powinna istnieÄ‡ sekcja wyjaÅ›niajÄ…ca, dlaczego funkcja jest niebezpieczna i omawiajÄ…ca niezmienniki, ktÃ³rych funkcja oczekuje od osÃ³b wywoÅ‚ujÄ…cych.</li>
</ul>
<p>WiÄ™kszoÅ›Ä‡ komentarzy dokumentacyjnych nie potrzebuje wszystkich tych sekcji, ale jest to dobra lista kontrolna, ktÃ³ra przypomina o aspektach Twojego kodu, ktÃ³rymi uÅ¼ytkownicy bÄ™dÄ… zainteresowani.</p>
<h4 id="komentarze-dokumentacji-jako-testy"><a class="header" href="#komentarze-dokumentacji-jako-testy">Komentarze dokumentacji jako testy</a></h4>
<p>Dodawanie blokÃ³w kodu przykÅ‚adu w komentarzach dokumentacji moÅ¼e pomÃ³c zademonstrowaÄ‡, jak uÅ¼ywaÄ‡ Twojej biblioteki i ma dodatkowy bonus: uruchomienie <code>cargo test</code> uruchomi przykÅ‚ady kodu z Twojej dokumentacji jako testy! Nic nie jest lepsze niÅ¼ dokumentacja z przykÅ‚adami. Ale nic nie jest gorsze niÅ¼ przykÅ‚ady, ktÃ³re nie dziaÅ‚ajÄ…, poniewaÅ¼ kod zmieniÅ‚ siÄ™ od czasu napisania dokumentacji. JeÅ›li uruchomimy <code>cargo test</code> z dokumentacjÄ… dla funkcji <code>add_one</code> z Listing 14-1, zobaczymy sekcjÄ™ w wynikach testÃ³w, ktÃ³ra wyglÄ…da tak:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo test
copy just the doc-tests section below
-->
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (linia 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
</code></pre>
<p>Teraz, jeÅ›li zmienimy funkcjÄ™ lub przykÅ‚ad tak, Å¼e <code>assert_eq!</code> w przykÅ‚adzie wywoÅ‚a panikÄ™, i ponownie uruchomimy <code>cargo test</code>, zobaczymy, Å¼e testy dokumentacji wykryjÄ…, Å¼e przykÅ‚ad i kod sÄ… niezsynchronizowane!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="commenting-contained-items"></a></p>
<h4 id="komentarze-do-zawartych-elementÃ³w"><a class="header" href="#komentarze-do-zawartych-elementÃ³w">Komentarze do zawartych elementÃ³w</a></h4>
<p>Styl komentarza dokumentacji <code>//!</code> dodaje dokumentacjÄ™ do elementu, ktÃ³ry <em>zawiera</em> komentarze, a nie do elementÃ³w <em>nastÄ™pujÄ…cych po</em> komentarzach. Zazwyczaj uÅ¼ywamy tych komentarzy dokumentacji wewnÄ…trz pliku gÅ‚Ã³wnego pakietu (<em>src/lib.rs</em> zgodnie z konwencjÄ…) lub wewnÄ…trz moduÅ‚u, aby udokumentowaÄ‡ pakiet lub moduÅ‚ jako caÅ‚oÅ›Ä‡.</p>
<p>Na przykÅ‚ad, aby dodaÄ‡ dokumentacjÄ™ opisujÄ…cÄ… cel pakietu <code>my_crate</code>, ktÃ³ry zawiera funkcjÄ™ <code>add_one</code>, dodajemy komentarze dokumentacji, ktÃ³re zaczynajÄ… siÄ™ od <code>//!</code> na poczÄ…tku pliku <em>src/lib.rs</em>, jak pokazano w Listing 14-2.</p>
<listing number="14-2" file-name="src/lib.rs" caption="Dokumentacja dla pakietu `my_crate` jako caÅ‚oÅ›ci">
<pre><code class="language-rust ignore">//! # MÃ³j Pakiet
//!
//! `my_crate` to zbiÃ³r narzÄ™dzi uÅ‚atwiajÄ…cych wykonywanie pewnych
//! obliczeÅ„.

/// Dodaje jeden do podanej liczby.
// --snip--
<span class="boring">///
</span><span class="boring">/// # PrzykÅ‚ady
</span><span class="boring">///
</span><span class="boring">/// ```
</span><span class="boring">/// let arg = 5;
</span><span class="boring">/// let answer = my_crate::add_one(arg);
</span><span class="boring">///
</span><span class="boring">/// assert_eq!(6, answer);
</span><span class="boring">/// ```
</span><span class="boring">pub fn add_one(x: i32) -&gt; i32 {
</span><span class="boring">    x + 1
</span><span class="boring">}</span></code></pre>
</listing>
<p>ZauwaÅ¼, Å¼e po ostatniej linii zaczynajÄ…cej siÄ™ od <code>//!</code> nie ma Å¼adnego kodu. PoniewaÅ¼ rozpoczÄ™liÅ›my komentarze od <code>//!</code> zamiast <code>///</code>, dokumentujemy element, ktÃ³ry zawiera ten komentarz, a nie element, ktÃ³ry nastÄ™puje po tym komentarzu. W tym przypadku elementem jest plik <em>src/lib.rs</em>, ktÃ³ry jest korzeniem pakietu. Te komentarze opisujÄ… caÅ‚y pakiet.</p>
<p>Kiedy uruchomimy <code>cargo doc --open</code>, te komentarze zostanÄ… wyÅ›wietlone na stronie gÅ‚Ã³wnej dokumentacji <code>my_crate</code> powyÅ¼ej listy publicznych elementÃ³w w pakiecie, jak pokazano na Rysunku 14-2.</p>
<p>Komentarze dokumentacyjne wewnÄ…trz elementÃ³w sÄ… szczegÃ³lnie przydatne do opisywania pakietÃ³w i moduÅ‚Ã³w. UÅ¼ywaj ich do wyjaÅ›niania ogÃ³lnego celu kontenera, aby pomÃ³c uÅ¼ytkownikom zrozumieÄ‡ organizacjÄ™ pakietu.</p>
<img alt="Wyrenderowana dokumentacja HTML z komentarzem dla caÅ‚ego pakietu `art`" src="img/trpl14-02.png" class="center" />
<p><span class="caption">Rysunek 14-2: Wyrenderowana dokumentacja dla <code>my_crate</code>, zawierajÄ…ca komentarz opisujÄ…cy caÅ‚y pakiet</span></p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="exporting-a-convenient-public-api-with-pub-use"></a></p>
<h3 id="eksportowanie-wygodnego-publicznego-api"><a class="header" href="#eksportowanie-wygodnego-publicznego-api">Eksportowanie wygodnego publicznego API</a></h3>
<p>Struktura publicznego API jest kluczowÄ… kwestiÄ… podczas publikowania pakietu. Osoby korzystajÄ…ce z twojego pakietu sÄ… mniej zaznajomione z jego strukturÄ… niÅ¼ ty i mogÄ… mieÄ‡ trudnoÅ›ci ze znalezieniem elementÃ³w, ktÃ³rych chcÄ… uÅ¼yÄ‡, jeÅ›li twÃ³j pakiet ma duÅ¼Ä… hierarchiÄ™ moduÅ‚Ã³w.</p>
<p>W Rozdziale 7 omÃ³wiliÅ›my, jak uczyniÄ‡ elementy publicznymi za pomocÄ… sÅ‚owa kluczowego <code>pub</code> oraz jak wprowadziÄ‡ elementy do zakresu za pomocÄ… sÅ‚owa kluczowego <code>use</code>. Jednak struktura, ktÃ³ra ma sens dla Ciebie podczas tworzenia pakietu, moÅ¼e nie byÄ‡ zbyt wygodna dla Twoich uÅ¼ytkownikÃ³w. MoÅ¼esz chcieÄ‡ zorganizowaÄ‡ swoje struktury w hierarchii zawierajÄ…cej wiele poziomÃ³w, ale wtedy osoby, ktÃ³re chcÄ… uÅ¼yÄ‡ typu zdefiniowanego gÅ‚Ä™boko w hierarchii, mogÄ… mieÄ‡ trudnoÅ›ci z odkryciem, Å¼e taki typ istnieje. MogÄ… rÃ³wnieÅ¼ byÄ‡ zirytowane koniecznoÅ›ciÄ… wpisywania <code>use my_crate::some_module::another_module::UsefulType;</code> zamiast <code>use my_crate::UsefulType;</code>.</p>
<p>DobrÄ… wiadomoÅ›ciÄ… jest to, Å¼e jeÅ›li struktura <em>nie</em> jest wygodna do uÅ¼ycia z innej biblioteki, nie musisz zmieniaÄ‡ swojej wewnÄ™trznej organizacji: zamiast tego moÅ¼esz ponownie eksportowaÄ‡ elementy, aby stworzyÄ‡ publicznÄ… strukturÄ™, ktÃ³ra rÃ³Å¼ni siÄ™ od Twojej prywatnej struktury, uÅ¼ywajÄ…c <code>pub use</code>. <em>Ponowne eksportowanie</em> pobiera publiczny element w jednym miejscu i udostÄ™pnia go publicznie w innym miejscu, tak jakby byÅ‚ zdefiniowany w tym innym miejscu.</p>
<p>Na przykÅ‚ad, powiedzmy, Å¼e stworzyliÅ›my bibliotekÄ™ o nazwie <code>art</code> do modelowania pojÄ™Ä‡ artystycznych. W tej bibliotece znajdujÄ… siÄ™ dwa moduÅ‚y: moduÅ‚ <code>kinds</code> zawierajÄ…cy dwa wyliczenia o nazwach <code>PrimaryColor</code> i <code>SecondaryColor</code> oraz moduÅ‚ <code>utils</code> zawierajÄ…cy funkcjÄ™ o nazwie <code>mix</code>, jak pokazano w Listing 14-3.</p>
<listing number="14-3" file-name="src/lib.rs" caption="Biblioteka `art` z elementami zorganizowanymi w moduÅ‚y `kinds` i `utils`">
<pre><code class="language-rust noplayground test_harness">//! # Sztuka
//!
//! Biblioteka do modelowania koncepcji artystycznych.

pub mod kinds {
    /// Kolory podstawowe wedÅ‚ug modelu kolorÃ³w RYB.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// Kolory wtÃ³rne wedÅ‚ug modelu kolorÃ³w RYB.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// ÅÄ…czy dwa kolory podstawowe w rÃ³wnych proporcjach, aby stworzyÄ‡
    /// kolor wtÃ³rny.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --snip--
<span class="boring">        unimplemented!();
</span>    }
}</code></pre>
</listing>
<p>Rysunek 14-3 pokazuje, jak wyglÄ…daÅ‚aby strona gÅ‚Ã³wna dokumentacji dla tego pakietu wygenerowana przez <code>cargo doc</code>.</p>
<img alt="Wyrenderowana dokumentacja dla pakietu `art`, ktÃ³ra zawiera listÄ™ moduÅ‚Ã³w `kinds` i `utils`" src="img/trpl14-03.png" class="center" />
<p><span class="caption">Rysunek 14-3: Strona gÅ‚Ã³wna dokumentacji dla <code>art</code>, ktÃ³ra zawiera listÄ™ moduÅ‚Ã³w <code>kinds</code> i <code>utils</code></span></p>
<p>ZauwaÅ¼, Å¼e typy <code>PrimaryColor</code> i <code>SecondaryColor</code> nie sÄ… wymienione na stronie gÅ‚Ã³wnej, podobnie jak funkcja <code>mix</code>. Musimy kliknÄ…Ä‡ <code>kinds</code> i <code>utils</code>, aby je zobaczyÄ‡.</p>
<p>Inny pakiet, ktÃ³ry zaleÅ¼y od tej biblioteki, potrzebowaÅ‚by instrukcji <code>use</code>, ktÃ³re wprowadzajÄ… elementy z <code>art</code> do zakresu, okreÅ›lajÄ…c strukturÄ™ moduÅ‚u, ktÃ³ra jest aktualnie zdefiniowana. Listing 14-4 pokazuje przykÅ‚ad pakietu, ktÃ³ry uÅ¼ywa elementÃ³w <code>PrimaryColor</code> i <code>mix</code> z pakietu <code>art</code>.</p>
<listing number="14-4" file-name="src/main.rs" caption="Pakiet uÅ¼ywajÄ…cy elementÃ³w pakietu `art` z wyeksportowanÄ… strukturÄ… wewnÄ™trznÄ…">
<pre><code class="language-rust ignore">use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}</code></pre>
</listing>
<p>Autor kodu w Listing 14-4, ktÃ³ry uÅ¼ywa pakietu <code>art</code>, musiaÅ‚ dowiedzieÄ‡ siÄ™, Å¼e <code>PrimaryColor</code> znajduje siÄ™ w module <code>kinds</code>, a <code>mix</code> w module <code>utils</code>. Struktura moduÅ‚Ã³w pakietu <code>art</code> jest bardziej istotna dla programistÃ³w pracujÄ…cych nad pakietem <code>art</code> niÅ¼ dla tych, ktÃ³rzy go uÅ¼ywajÄ…. WewnÄ™trzna struktura nie zawiera Å¼adnych uÅ¼ytecznych informacji dla kogoÅ› prÃ³bujÄ…cego zrozumieÄ‡, jak uÅ¼ywaÄ‡ pakietu <code>art</code>, ale raczej powoduje zamieszanie, poniewaÅ¼ programiÅ›ci, ktÃ³rzy go uÅ¼ywajÄ…, muszÄ… dowiedzieÄ‡ siÄ™, gdzie szukaÄ‡ i muszÄ… okreÅ›laÄ‡ nazwy moduÅ‚Ã³w w instrukcjach <code>use</code>.</p>
<p>Aby usunÄ…Ä‡ wewnÄ™trznÄ… organizacjÄ™ z publicznego API, moÅ¼emy zmodyfikowaÄ‡ kod pakietu <code>art</code> w Listing 14-3, aby dodaÄ‡ instrukcje <code>pub use</code> do ponownego eksportu elementÃ³w na najwyÅ¼szym poziomie, jak pokazano w Listing 14-5.</p>
<listing number="14-5" file-name="src/lib.rs" caption="Dodawanie instrukcji `pub use` do ponownego eksportu elementÃ³w">
<pre><code class="language-rust ignore">//! # Sztuka
//!
//! Biblioteka do modelowania koncepcji artystycznych.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --snip--
<span class="boring">    /// Kolory podstawowe wedÅ‚ug modelu kolorÃ³w RYB.
</span><span class="boring">    pub enum PrimaryColor {
</span><span class="boring">        Red,
</span><span class="boring">        Yellow,
</span><span class="boring">        Blue,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Kolory wtÃ³rne wedÅ‚ug modelu kolorÃ³w RYB.
</span><span class="boring">    pub enum SecondaryColor {
</span><span class="boring">        Orange,
</span><span class="boring">        Green,
</span><span class="boring">        Purple,
</span><span class="boring">    }
</span>}

pub mod utils {
    // --snip--
<span class="boring">    use crate::kinds::*;
</span><span class="boring">
</span><span class="boring">    /// ÅÄ…czy dwa kolory podstawowe w rÃ³wnych proporcjach, aby stworzyÄ‡
</span><span class="boring">    /// kolor wtÃ³rny.
</span><span class="boring">    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
</span><span class="boring">        SecondaryColor::Orange
</span><span class="boring">    }
</span>}</code></pre>
</listing>
<p>Dokumentacja API wygenerowana przez <code>cargo doc</code> dla tego pakietu bÄ™dzie teraz listowaÄ‡ i linkowaÄ‡ ponowne eksporty na stronie gÅ‚Ã³wnej, jak pokazano na Rysunku 14-4, uÅ‚atwiajÄ…c znalezienie typÃ³w <code>PrimaryColor</code> i <code>SecondaryColor</code> oraz funkcji <code>mix</code>.</p>
<img alt="Wyrenderowana dokumentacja dla pakietu `art` z ponownymi eksportami na stronie gÅ‚Ã³wnej" src="img/trpl14-04.png" class="center" />
<p><span class="caption">Rysunek 14-4: Strona gÅ‚Ã³wna dokumentacji dla <code>art</code>, ktÃ³ra zawiera listÄ™ ponownych eksportÃ³w</span></p>
<p>UÅ¼ytkownicy pakietu <code>art</code> nadal mogÄ… przeglÄ…daÄ‡ i uÅ¼ywaÄ‡ wewnÄ™trznej struktury z Listing 14-3, jak zademonstrowano w Listing 14-4, lub mogÄ… uÅ¼ywaÄ‡ bardziej wygodnej struktury z Listing 14-5, jak pokazano w Listing 14-6.</p>
<listing number="14-6" file-name="src/main.rs" caption="Program uÅ¼ywajÄ…cy ponownie wyeksportowanych elementÃ³w z pakietu `art`">
<pre><code class="language-rust ignore">use art::PrimaryColor;
use art::mix;

fn main() {
    // --snip--
<span class="boring">    let red = PrimaryColor::Red;
</span><span class="boring">    let yellow = PrimaryColor::Yellow;
</span><span class="boring">    mix(red, yellow);
</span>}</code></pre>
</listing>
<p>W przypadkach, gdy istnieje wiele zagnieÅ¼dÅ¼onych moduÅ‚Ã³w, ponowne eksportowanie typÃ³w na najwyÅ¼szym poziomie za pomocÄ… <code>pub use</code> moÅ¼e znacznie wpÅ‚ynÄ…Ä‡ na doÅ›wiadczenie osÃ³b korzystajÄ…cych z pakietu. Innym czÄ™stym zastosowaniem <code>pub use</code> jest ponowne eksportowanie definicji zaleÅ¼noÅ›ci w bieÅ¼Ä…cym pakiecie, aby definicje tego pakietu staÅ‚y siÄ™ czÄ™Å›ciÄ… publicznego API Twojego pakietu.</p>
<p>Tworzenie uÅ¼ytecznej struktury publicznego API to bardziej sztuka niÅ¼ nauka, a Ty moÅ¼esz iterowaÄ‡, aby znaleÅºÄ‡ API, ktÃ³re najlepiej pasuje do Twoich uÅ¼ytkownikÃ³w. WybÃ³r <code>pub use</code> daje Ci elastycznoÅ›Ä‡ w wewnÄ™trznej strukturze pakietu i oddziela tÄ™ wewnÄ™trznÄ… strukturÄ™ od tego, co prezentujesz uÅ¼ytkownikom. Przyjrzyj siÄ™ kodowi niektÃ³rych zainstalowanych pakietÃ³w, aby sprawdziÄ‡, czy ich wewnÄ™trzna struktura rÃ³Å¼ni siÄ™ od ich publicznego API.</p>
<h3 id="konfigurowanie-konta-cratesio"><a class="header" href="#konfigurowanie-konta-cratesio">Konfigurowanie konta Crates.io</a></h3>
<p>Zanim bÄ™dziesz mÃ³gÅ‚ publikowaÄ‡ jakiekolwiek pakiety, musisz utworzyÄ‡ konto na <a href="https://crates.io/">crates.io</a><!-- ignore --> i uzyskaÄ‡ token API. Aby to zrobiÄ‡, odwiedÅº stronÄ™ gÅ‚Ã³wnÄ… <a href="https://crates.io/">crates.io</a><!-- ignore --> i zaloguj siÄ™ za pomocÄ… konta GitHub. (Konto GitHub jest obecnie wymagane, ale witryna moÅ¼e w przyszÅ‚oÅ›ci obsÅ‚ugiwaÄ‡ inne sposoby tworzenia konta.) Po zalogowaniu odwiedÅº ustawienia swojego konta pod adresem <a href="https://crates.io/me/">https://crates.io/me/</a><!-- ignore --> i pobierz swÃ³j klucz API. NastÄ™pnie uruchom polecenie <code>cargo login</code> i wklej swÃ³j klucz API po wyÅ›wietleniu monitu, w nastÄ™pujÄ…cy sposÃ³b:</p>
<pre><code class="language-console">$ cargo login
abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>To polecenie poinformuje Cargo o Twoim tokenie API i zapisze go lokalnie w <em>~/.cargo/credentials.toml</em>. ZauwaÅ¼, Å¼e ten token jest tajny: nie udostÄ™pniaj go nikomu. JeÅ›li z jakiegoÅ› powodu go udostÄ™pnisz, powinieneÅ› go uniewaÅ¼niÄ‡ i wygenerowaÄ‡ nowy token na <a href="https://crates.io/">crates.io</a><!-- ignore -->.</p>
<h3 id="dodawanie-metadanych-do-nowego-pakietu"><a class="header" href="#dodawanie-metadanych-do-nowego-pakietu">Dodawanie metadanych do nowego pakietu</a></h3>
<p>Powiedzmy, Å¼e masz pakiet, ktÃ³ry chcesz opublikowaÄ‡. Przed publikacjÄ… musisz dodaÄ‡ kilka metadanych w sekcji <code>[package]</code> pliku <em>Cargo.toml</em> pakietu.</p>
<p>TwÃ³j pakiet bÄ™dzie potrzebowaÅ‚ unikalnej nazwy. Podczas pracy nad pakietem lokalnie, moÅ¼esz nazwaÄ‡ pakiet jak chcesz. Jednak nazwy pakietÃ³w na <a href="https://crates.io/">crates.io</a><!-- ignore --> sÄ… przydzielane na zasadzie â€kto pierwszy, ten lepszyâ€. Gdy nazwa pakietu zostanie zajÄ™ta, nikt inny nie moÅ¼e opublikowaÄ‡ pakietu o tej nazwie. Przed prÃ³bÄ… publikacji pakietu, wyszukaj nazwÄ™, ktÃ³rej chcesz uÅ¼yÄ‡. JeÅ›li nazwa zostaÅ‚a uÅ¼yta, bÄ™dziesz musiaÅ‚ znaleÅºÄ‡ innÄ… nazwÄ™ i edytowaÄ‡ pole <code>name</code> w pliku <em>Cargo.toml</em> w sekcji <code>[package]</code>, aby uÅ¼yÄ‡ nowej nazwy do publikacji, w nastÄ™pujÄ…cy sposÃ³b:</p>
<p><span class="filename">Nazwa pliku: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
</code></pre>
<p>Nawet jeÅ›li wybraÅ‚eÅ› unikalnÄ… nazwÄ™, kiedy uruchomisz <code>cargo publish</code>, aby opublikowaÄ‡ pakiet w tym momencie, otrzymasz ostrzeÅ¼enie, a nastÄ™pnie bÅ‚Ä…d:</p>
<!-- manual-regeneration
Create a new package with an unregistered name, making no further modifications
  to the generated package, so it is missing the description and license fields.
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Aktualizowanie indeksu crates.io
warning: manifest nie ma opisu, licencji, pliku licencyjnego, dokumentacji, strony gÅ‚Ã³wnej lub repozytorium.
Zobacz https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata aby uzyskaÄ‡ wiÄ™cej informacji.
--snip--
error: nie udaÅ‚o siÄ™ opublikowaÄ‡ w rejestrze pod adresem https://crates.io

Spowodowane przez:
  zdalny serwer odpowiedziaÅ‚ bÅ‚Ä™dem (status 400 Bad Request): brakujÄ…ce lub puste pola metadanych: description, license. Zobacz https://doc.rust-lang.org/cargo/reference/manifest.html, aby uzyskaÄ‡ wiÄ™cej informacji na temat konfiguracji tych pÃ³l
</code></pre>
<p>Prowadzi to do bÅ‚Ä™du, poniewaÅ¼ brakuje Ci pewnych kluczowych informacji: opis i licencja sÄ… wymagane, aby ludzie wiedzieli, co robi TwÃ³j pakiet i na jakich warunkach mogÄ… go uÅ¼ywaÄ‡. W <em>Cargo.toml</em> dodaj opis skÅ‚adajÄ…cy siÄ™ z jednego lub dwÃ³ch zdaÅ„, poniewaÅ¼ bÄ™dzie on wyÅ›wietlany wraz z Twoim pakietem w wynikach wyszukiwania. Dla pola <code>license</code> musisz podaÄ‡ <em>wartoÅ›Ä‡ identyfikatora licencji</em>. <a href="https://spdx.org/licenses/">Software Package Data Exchange (SPDX) Fundacji Linuksa</a> wymienia identyfikatory, ktÃ³rych moÅ¼esz uÅ¼yÄ‡ dla tej wartoÅ›ci. Na przykÅ‚ad, aby okreÅ›liÄ‡, Å¼e licencjonowaÅ‚eÅ› swÃ³j pakiet za pomocÄ… licencji MIT, dodaj identyfikator <code>MIT</code>:</p>
<p><span class="filename">Nazwa pliku: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
license = "MIT"
</code></pre>
<p>JeÅ›li chcesz uÅ¼yÄ‡ licencji, ktÃ³ra nie pojawia siÄ™ w SPDX, musisz umieÅ›ciÄ‡ tekst tej licencji w pliku, doÅ‚Ä…czyÄ‡ ten plik do swojego projektu, a nastÄ™pnie uÅ¼yÄ‡ <code>license-file</code>, aby okreÅ›liÄ‡ nazwÄ™ tego pliku zamiast uÅ¼ywania klucza <code>license</code>.</p>
<p>Porady dotyczÄ…ce wyboru odpowiedniej licencji dla Twojego projektu wykraczajÄ… poza zakres tej ksiÄ…Å¼ki. Wiele osÃ³b w spoÅ‚ecznoÅ›ci Rusta licencjonuje swoje projekty w ten sam sposÃ³b co Rust, uÅ¼ywajÄ…c podwÃ³jnej licencji <code>MIT OR Apache-2.0</code>. Ta praktyka pokazuje, Å¼e moÅ¼esz rÃ³wnieÅ¼ okreÅ›liÄ‡ wiele identyfikatorÃ³w licencji oddzielonych <code>OR</code>, aby mieÄ‡ wiele licencji dla swojego projektu.</p>
<p>Po dodaniu unikalnej nazwy, wersji, opisu i licencji, plik <em>Cargo.toml</em> dla projektu gotowego do publikacji moÅ¼e wyglÄ…daÄ‡ nastÄ™pujÄ…co:</p>
<p><span class="filename">Nazwa pliku: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2024"
description = "Ciekawa gra, w ktÃ³rej zgadujesz liczbÄ™ wybranÄ… przez komputer."
license = "MIT OR Apache-2.0"

[dependencies]
</code></pre>
<p><a href="https://doc.rust-lang.org/cargo/">Dokumentacja Cargo</a> opisuje inne metadane, ktÃ³re moÅ¼na okreÅ›liÄ‡, aby inni mogli Å‚atwiej odkryÄ‡ i uÅ¼ywaÄ‡ Twojego pakietu.</p>
<h3 id="publikowanie-na-cratesio"><a class="header" href="#publikowanie-na-cratesio">Publikowanie na Crates.io</a></h3>
<p>Teraz, gdy utworzyÅ‚eÅ› konto, zapisaÅ‚eÅ› swÃ³j token API, wybraÅ‚eÅ› nazwÄ™ dla swojego pakietu i okreÅ›liÅ‚eÅ› wymagane metadane, jesteÅ› gotowy do publikacji! Publikowanie pakietu przesyÅ‚a konkretnÄ… wersjÄ™ do <a href="https://crates.io/">crates.io</a><!-- ignore -->, aby inni mogli z niej korzystaÄ‡.</p>
<p>BÄ…dÅº ostroÅ¼ny, poniewaÅ¼ publikacja jest <em>trwaÅ‚a</em>. Wersja nigdy nie moÅ¼e zostaÄ‡ nadpisana, a kod nie moÅ¼e zostaÄ‡ usuniÄ™ty, z wyjÄ…tkiem pewnych okolicznoÅ›ci. Jednym z gÅ‚Ã³wnych celÃ³w Crates.io jest peÅ‚nienie funkcji staÅ‚ego archiwum kodu, tak aby kompilacje wszystkich projektÃ³w, ktÃ³re zaleÅ¼Ä… od pakietÃ³w z <a href="https://crates.io/">crates.io</a><!-- ignore -->, nadal dziaÅ‚aÅ‚y. Dopuszczenie usuwania wersji uniemoÅ¼liwiÅ‚oby osiÄ…gniÄ™cie tego celu. Nie ma jednak limitu liczby wersji pakietÃ³w, ktÃ³re moÅ¼esz opublikowaÄ‡.</p>
<p>Uruchom ponownie polecenie <code>cargo publish</code>. Powinno siÄ™ teraz udaÄ‡:</p>
<!-- manual-regeneration
go to some valid crate, publish a new version
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Aktualizowanie indeksu crates.io
   Pakowanie guessing_game v0.1.0 (file:///projects/guessing_game)
    Spakowano 6 plikÃ³w, 1.2KiB (895.0B skompresowanych)
   Weryfikowanie guessing_game v0.1.0 (file:///projects/guessing_game)
   Kompilowanie guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    ZakoÅ„czono `dev` profil [unoptimized + debuginfo] cel(e) w 0.19s
   PrzesyÅ‚anie guessing_game v0.1.0 (file:///projects/guessing_game)
    PrzesÅ‚ano guessing_game v0.1.0 do rejestru `crates-io`
note: oczekiwanie na dostÄ™pnoÅ›Ä‡ `guessing_game v0.1.0` w rejestrze
`crates-io`. MoÅ¼esz nacisnÄ…Ä‡ ctrl-c, aby pominÄ…Ä‡ oczekiwanie; pakiet powinien byÄ‡ dostÄ™pny wkrÃ³tce.
   Opublikowano guessing_game v0.1.0 w rejestrze `crates-io`
</code></pre>
<p>Gratulacje! UdostÄ™pniÅ‚eÅ› swÃ³j kod spoÅ‚ecznoÅ›ci Rusta, a kaÅ¼dy moÅ¼e Å‚atwo dodaÄ‡ TwÃ³j pakiet jako zaleÅ¼noÅ›Ä‡ swojego projektu.</p>
<h3 id="publikowanie-nowej-wersji-istniejÄ…cego-pakietu"><a class="header" href="#publikowanie-nowej-wersji-istniejÄ…cego-pakietu">Publikowanie nowej wersji istniejÄ…cego pakietu</a></h3>
<p>Kiedy wprowadzisz zmiany w swoim pakiecie i bÄ™dziesz gotowy do wydania nowej wersji, zmieniasz wartoÅ›Ä‡ <code>version</code> okreÅ›lonÄ… w pliku <em>Cargo.toml</em> i publikujesz ponownie. UÅ¼yj <a href="https://semver.org/">zasad Semantycznego Wersjonowania</a>, aby zdecydowaÄ‡, jaki jest odpowiedni numer nastÄ™pnej wersji, w oparciu o rodzaj wprowadzonych zmian. NastÄ™pnie uruchom <code>cargo publish</code>, aby przesÅ‚aÄ‡ nowÄ… wersjÄ™.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="removing-versions-from-cratesio-with-cargo-yank"></a>
<a id="deprecating-versions-from-cratesio-with-cargo-yank"></a></p>
<h3 id="wycofywanie-wersji-z-cratesio"><a class="header" href="#wycofywanie-wersji-z-cratesio">Wycofywanie wersji z Crates.io</a></h3>
<p>ChociaÅ¼ nie moÅ¼esz usuwaÄ‡ poprzednich wersji pakietu, moÅ¼esz uniemoÅ¼liwiÄ‡ przyszÅ‚ym projektom dodawanie ich jako nowych zaleÅ¼noÅ›ci. Jest to przydatne, gdy wersja pakietu jest zepsuta z jakiegoÅ› powodu. W takich sytuacjach Cargo obsÅ‚uguje wycofanie wersji pakietu.</p>
<p><em>Wycofanie</em> wersji zapobiega zaleÅ¼noÅ›ciom nowych projektÃ³w od tej wersji, jednoczeÅ›nie umoÅ¼liwiajÄ…c wszystkim istniejÄ…cym projektom, ktÃ³re sÄ… od niej zaleÅ¼ne, dalsze dziaÅ‚anie. Zasadniczo, wycofanie oznacza, Å¼e wszystkie projekty z plikiem <em>Cargo.lock</em> nie zostanÄ… zepsute, a Å¼adne przyszÅ‚e pliki <em>Cargo.lock</em> nie bÄ™dÄ… uÅ¼ywaÄ‡ wycofanej wersji.</p>
<p>Aby wycofaÄ‡ wersjÄ™ pakietu, w katalogu pakietu, ktÃ³ry wczeÅ›niej opublikowaÅ‚eÅ›, uruchom <code>cargo yank</code> i okreÅ›l, ktÃ³rÄ… wersjÄ™ chcesz wycofaÄ‡. Na przykÅ‚ad, jeÅ›li opublikowaliÅ›my pakiet o nazwie <code>guessing_game</code> w wersji 1.0.1 i chcemy go wycofaÄ‡, uruchomimy nastÄ™pujÄ…ce polecenie w katalogu projektu <code>guessing_game</code>:</p>
<!-- manual-regeneration:
cargo yank carol-test --version 2.1.0
cargo yank carol-test --version 2.1.0 --undo
-->
<pre><code class="language-console">$ cargo yank --vers 1.0.1
    Aktualizowanie indeksu crates.io
        WycofujÄ™ guessing_game@1.0.1
</code></pre>
<p>DodajÄ…c <code>--undo</code> do polecenia, moÅ¼esz rÃ³wnieÅ¼ cofnÄ…Ä‡ wycofanie i ponownie zezwoliÄ‡ projektom na zaleÅ¼noÅ›Ä‡ od danej wersji:</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1 --undo
    Aktualizowanie indeksu crates.io
      Przywracam guessing_game@1.0.1
</code></pre>
<p>Wycofanie <em>nie</em> usuwa Å¼adnego kodu. Nie moÅ¼e na przykÅ‚ad usunÄ…Ä‡ przypadkowo przesÅ‚anych sekretÃ³w. JeÅ›li tak siÄ™ stanie, musisz natychmiast zresetowaÄ‡ te sekrety.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="obszary-robocze-cargo-1"><a href="#obszary-robocze-cargo-1" class="header">Obszary robocze Cargo</a></h1>
<h2 id="obszary-robocze-cargo"><a class="header" href="#obszary-robocze-cargo">Obszary robocze Cargo</a></h2>
<p>W Rozdziale 12 zbudowaliÅ›my pakiet, ktÃ³ry zawieraÅ‚ binarny crate i biblioteczny crate. W miarÄ™ rozwoju projektu moÅ¼e siÄ™ okazaÄ‡, Å¼e biblioteczny crate staje siÄ™ coraz wiÄ™kszy i chcesz podzieliÄ‡ swÃ³j pakiet na wiele bibliotecznych crateâ€™Ã³w. Cargo oferuje funkcjÄ™ o nazwie <em>workspaces</em> (obszary robocze), ktÃ³ra moÅ¼e pomÃ³c w zarzÄ…dzaniu wieloma powiÄ…zanymi pakietami, ktÃ³re sÄ… rozwijane rÃ³wnoczeÅ›nie.</p>
<h3 id="tworzenie-obszaru-roboczego"><a class="header" href="#tworzenie-obszaru-roboczego">Tworzenie obszaru roboczego</a></h3>
<p><em>Obszar roboczy</em> to zestaw pakietÃ³w, ktÃ³re wspÃ³Å‚dzielÄ… ten sam plik <em>Cargo.lock</em> i katalog wyjÅ›ciowy. StwÃ³rzmy projekt z wykorzystaniem obszaru roboczego â€” uÅ¼yjemy trywialnego kodu, abyÅ›my mogli skupiÄ‡ siÄ™ na strukturze obszaru roboczego. Istnieje wiele sposobÃ³w na strukturÄ™ obszaru roboczego, wiÄ™c pokaÅ¼emy tylko jeden powszechny. BÄ™dziemy mieÄ‡ obszar roboczy zawierajÄ…cy binarny pakiet i dwie biblioteki. Binarny pakiet, ktÃ³ry zapewni gÅ‚Ã³wnÄ… funkcjonalnoÅ›Ä‡, bÄ™dzie zaleÅ¼aÅ‚ od dwÃ³ch bibliotek. Jedna biblioteka zapewni funkcjÄ™ <code>add_one</code>, a druga biblioteka funkcjÄ™ <code>add_two</code>. Te trzy pakiety bÄ™dÄ… czÄ™Å›ciÄ… tego samego obszaru roboczego. Zaczniemy od utworzenia nowego katalogu dla obszaru roboczego:</p>
<pre><code class="language-console">$ mkdir add
$ cd add
</code></pre>
<p>NastÄ™pnie, w katalogu <em>add</em>, tworzymy plik <em>Cargo.toml</em>, ktÃ³ry skonfiguruje caÅ‚y obszar roboczy. Ten plik nie bÄ™dzie miaÅ‚ sekcji <code>[package]</code>. Zamiast tego, zacznie siÄ™ od sekcji <code>[workspace]</code>, ktÃ³ra pozwoli nam dodawaÄ‡ czÅ‚onkÃ³w do obszaru roboczego. Zwracamy rÃ³wnieÅ¼ uwagÄ™ na uÅ¼ycie najnowszej i najlepszej wersji algorytmu resolvera Cargo w naszym obszarze roboczym, ustawiajÄ…c wartoÅ›Ä‡ <code>resolver</code> na <code>"3"</code>:</p>
<p><span class="filename">Nazwa pliku: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]
resolver = "3"
</code></pre>
<p>NastÄ™pnie utworzymy binarny pakiet <code>adder</code> poprzez uruchomienie <code>cargo new</code> w katalogu <em>add</em>:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-01-adder-crate/add
remove `members = ["adder"]` from Cargo.toml
rm -rf adder
cargo new adder
copy output below
-->
<pre><code class="language-console">$ cargo new adder
     Utworzono pakiet binarny (aplikacja) `adder`
      Dodawanie `adder` jako czÅ‚onka obszaru roboczego pod `file:///projects/add`
</code></pre>
<p>Uruchomienie <code>cargo new</code> wewnÄ…trz obszaru roboczego automatycznie dodaje nowo utworzony pakiet do klucza <code>members</code> w definicji <code>[workspace]</code> w pliku <em>Cargo.toml</em> obszaru roboczego, w nastÄ™pujÄ…cy sposÃ³b:</p>
<pre><code class="language-toml">[workspace]
resolver = "3"
members = ["adder"]
</code></pre>
<p>W tym momencie moÅ¼emy zbudowaÄ‡ obszar roboczy, uruchamiajÄ…c <code>cargo build</code>. Pliki w katalogu <em>add</em> powinny wyglÄ…daÄ‡ nastÄ™pujÄ…co:</p>
<pre><code class="language-text">â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ adder
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src
â”‚       â””â”€â”€ main.rs
â””â”€â”€ target
</code></pre>
<p>Obszar roboczy posiada jeden katalog <em>target</em> na najwyÅ¼szym poziomie, do ktÃ³rego zostanÄ… umieszczone skompilowane artefakty; pakiet <code>adder</code> nie ma wÅ‚asnego katalogu <em>target</em>. Nawet gdybyÅ›my uruchomili <code>cargo build</code> z wnÄ™trza katalogu <em>adder</em>, skompilowane artefakty nadal znalazÅ‚yby siÄ™ w <em>add/target</em>, a nie <em>add/adder/target</em>. Cargo strukturyzuje katalog <em>target</em> w obszarze roboczym w ten sposÃ³b, poniewaÅ¼ pakiety w obszarze roboczym majÄ… od siebie zaleÅ¼eÄ‡. Gdyby kaÅ¼dy pakiet miaÅ‚ wÅ‚asny katalog <em>target</em>, kaÅ¼dy pakiet musiaÅ‚by rekompilowaÄ‡ kaÅ¼dy z pozostaÅ‚ych pakietÃ³w w obszarze roboczym, aby umieÅ›ciÄ‡ artefakty w swoim wÅ‚asnym katalogu <em>target</em>. DziÄ™ki wspÃ³Å‚dzieleniu jednego katalogu <em>target</em> pakiety mogÄ… uniknÄ…Ä‡ niepotrzebnej ponownej kompilacji.</p>
<h3 id="tworzenie-drugiego-pakietu-w-obszarze-roboczym"><a class="header" href="#tworzenie-drugiego-pakietu-w-obszarze-roboczym">Tworzenie drugiego pakietu w obszarze roboczym</a></h3>
<p>NastÄ™pnie stwÃ³rzmy kolejny pakiet czÅ‚onkowski w obszarze roboczym i nazwijmy go <code>add_one</code>. Wygeneruj nowy pakiet biblioteczny o nazwie <code>add_one</code>:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-02-add-one/add
remove `"add_one"` from `members` list in Cargo.toml
rm -rf add_one
cargo new add_one --lib
copy output below
-->
<pre><code class="language-console">$ cargo new add_one --lib
     Utworzono bibliotekÄ™ `add_one`
      Dodawanie `add_one` jako czÅ‚onka obszaru roboczego pod `file:///projects/add`
</code></pre>
<p>Plik <em>Cargo.toml</em> na najwyÅ¼szym poziomie bÄ™dzie teraz zawieraÅ‚ Å›cieÅ¼kÄ™ <em>add_one</em> na liÅ›cie <code>members</code>:</p>
<p><span class="filename">Nazwa pliku: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]
resolver = "3"
members = ["adder", "add_one"]
</code></pre>
<p>TwÃ³j katalog <em>add</em> powinien teraz zawieraÄ‡ nastÄ™pujÄ…ce katalogi i pliki:</p>
<pre><code class="language-text">â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ add_one
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src
â”‚       â””â”€â”€ lib.rs
â”œâ”€â”€ adder
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src
â”‚       â””â”€â”€ main.rs
â””â”€â”€ target
</code></pre>
<p>W pliku <em>add_one/src/lib.rs</em> dodajmy funkcjÄ™ <code>add_one</code>:</p>
<p><span class="filename">Nazwa pliku: add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<p>Teraz pakiet <code>adder</code> z naszym plikiem binarnym moÅ¼e zaleÅ¼eÄ‡ od pakietu <code>add_one</code>, ktÃ³ry zawiera naszÄ… bibliotekÄ™. Najpierw bÄ™dziemy musieli dodaÄ‡ zaleÅ¼noÅ›Ä‡ Å›cieÅ¼kowÄ… do <code>add_one</code> do pliku <em>adder/Cargo.toml</em>.</p>
<p><span class="filename">Nazwa pliku: adder/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
add_one = { path = "../add_one" }
</code></pre>
<p>Cargo nie zakÅ‚ada, Å¼e pakiety w obszarze roboczym bÄ™dÄ… od siebie zaleÅ¼eÄ‡, wiÄ™c musimy jawnie okreÅ›liÄ‡ relacje zaleÅ¼noÅ›ci.</p>
<p>NastÄ™pnie, uÅ¼yjmy funkcji <code>add_one</code> (z pakietu <code>add_one</code>) w pakiecie <code>adder</code>. OtwÃ³rz plik <em>adder/src/main.rs</em> i zmieÅ„ funkcjÄ™ <code>main</code>, aby wywoÅ‚ywaÅ‚a funkcjÄ™ <code>add_one</code>, jak w Listing 14-7.</p>
<listing number="14-7" file-name="adder/src/main.rs" caption="UÅ¼ywanie biblioteki `add_one` z pakietu `adder`">
<pre><code class="language-rust ignore">fn main() {
    let num = 10;
    println!("Witaj, Å›wiecie! {num} plus jeden to {}!", add_one::add_one(num));
}</code></pre>
</listing>
<p>Zbudujmy obszar roboczy, uruchamiajÄ…c <code>cargo build</code> w katalogu <em>add</em> na najwyÅ¼szym poziomie!</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
   Kompilowanie add_one v0.1.0 (file:///projects/add/add_one)
   Kompilowanie adder v0.1.0 (file:///projects/add/adder)
    ZakoÅ„czono `dev` profil [unoptimized + debuginfo] cel(e) w 0.22s
</code></pre>
<p>Aby uruchomiÄ‡ binarny pakiet z katalogu <em>add</em>, moÅ¼emy okreÅ›liÄ‡, ktÃ³ry pakiet w obszarze roboczym chcemy uruchomiÄ‡, uÅ¼ywajÄ…c argumentu <code>-p</code> i nazwy pakietu z <code>cargo run</code>:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo run -p adder
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo run -p adder
    ZakoÅ„czono `dev` profil [unoptimized + debuginfo] cel(e) w 0.00s
     Uruchamianie `target/debug/adder`
Witaj, Å›wiecie! 10 plus jeden to 11!
</code></pre>
<p>To uruchamia kod z <em>adder/src/main.rs</em>, ktÃ³ry zaleÅ¼y od pakietu <code>add_one</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="depending-on-an-external-package-in-a-workspace"></a></p>
<h3 id="zaleÅ¼noÅ›Ä‡-od-zewnÄ™trznego-pakietu"><a class="header" href="#zaleÅ¼noÅ›Ä‡-od-zewnÄ™trznego-pakietu">ZaleÅ¼noÅ›Ä‡ od zewnÄ™trznego pakietu</a></h3>
<p>ZauwaÅ¼, Å¼e obszar roboczy ma tylko jeden plik <em>Cargo.lock</em> na najwyÅ¼szym poziomie, zamiast mieÄ‡ plik <em>Cargo.lock</em> w katalogu kaÅ¼dego pakietu. To zapewnia, Å¼e wszystkie pakiety uÅ¼ywajÄ… tej samej wersji wszystkich zaleÅ¼noÅ›ci. JeÅ›li dodamy pakiet <code>rand</code> do plikÃ³w <em>adder/Cargo.toml</em> i <em>add_one/Cargo.toml</em>, Cargo rozwiÄ…Å¼e oba do jednej wersji <code>rand</code> i zapisze to w jednym pliku <em>Cargo.lock</em>. Sprawienie, by wszystkie pakiety w obszarze roboczym uÅ¼ywaÅ‚y tych samych zaleÅ¼noÅ›ci, oznacza, Å¼e pakiety zawsze bÄ™dÄ… ze sobÄ… kompatybilne. Dodajmy pakiet <code>rand</code> do sekcji <code>[dependencies]</code> w pliku <em>add_one/Cargo.toml</em>, abyÅ›my mogli uÅ¼ywaÄ‡ pakietu <code>rand</code> w pakiecie <code>add_one</code>:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
-->
<p><span class="filename">Nazwa pliku: add_one/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = "0.8.5"
</code></pre>
<p>MoÅ¼emy teraz dodaÄ‡ <code>use rand;</code> do pliku <em>add_one/src/lib.rs</em>, a zbudowanie caÅ‚ego obszaru roboczego przez uruchomienie <code>cargo build</code> w katalogu <em>add</em> spowoduje zaimportowanie i skompilowanie pakietu <code>rand</code>. Otrzymamy jedno ostrzeÅ¼enie, poniewaÅ¼ nie odwoÅ‚ujemy siÄ™ do <code>rand</code>, ktÃ³re wprowadziliÅ›my do zakresu:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-03-workspace-with-external-dependency/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
    Aktualizowanie indeksu crates.io
  Pobrano rand v0.8.5
   --snip--
   Kompilowanie rand v0.8.5
   Kompilowanie add_one v0.1.0 (file:///projects/add/add_one)
warning: nieuÅ¼ywany import: `rand`
 --&gt; add_one/src/lib.rs:1:5
  |
1 | use rand;
  |     ^^^^
  |
  = note: `#[warn(unused_imports)]` domyÅ›lnie wÅ‚Ä…czone

warning: `add_one` (lib) wygenerowaÅ‚ 1 ostrzeÅ¼enie (uruchom `cargo fix --lib -p add_one`, aby zastosowaÄ‡ 1 sugestiÄ™)
   Kompilowanie adder v0.1.0 (file:///projects/add/adder)
    ZakoÅ„czono `dev` profil [unoptimized + debuginfo] cel(e) w 0.95s
</code></pre>
<p>Plik <em>Cargo.lock</em> na najwyÅ¼szym poziomie zawiera teraz informacje o zaleÅ¼noÅ›ci <code>add_one</code> od <code>rand</code>. JednakÅ¼e, mimo Å¼e <code>rand</code> jest uÅ¼ywane gdzieÅ› w obszarze roboczym, nie moÅ¼emy go uÅ¼ywaÄ‡ w innych pakietach w obszarze roboczym, chyba Å¼e dodamy <code>rand</code> rÃ³wnieÅ¼ do ich plikÃ³w <em>Cargo.toml</em>. Na przykÅ‚ad, jeÅ›li dodamy <code>use rand;</code> do pliku <em>adder/src/main.rs</em> dla pakietu <code>adder</code>, otrzymamy bÅ‚Ä…d:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-03-use-rand/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
  --snip--
   Kompilowanie adder v0.1.0 (file:///projects/add/adder)
error[E0432]: nierozwiÄ…zany import `rand`
 --&gt; adder/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ brak zewnÄ™trznego pakietu `rand`
</code></pre>
<p>Aby to naprawiÄ‡, edytuj plik <em>Cargo.toml</em> pakietu <code>adder</code> i wskaÅ¼, Å¼e <code>rand</code> jest rÃ³wnieÅ¼ jego zaleÅ¼noÅ›ciÄ…. Budowanie pakietu <code>adder</code> doda <code>rand</code> do listy zaleÅ¼noÅ›ci dla <code>adder</code> w <em>Cargo.lock</em>, ale nie zostanÄ… pobrane Å¼adne dodatkowe kopie <code>rand</code>. Cargo zapewni, Å¼e kaÅ¼dy pakiet w obszarze roboczym uÅ¼ywajÄ…cy pakietu <code>rand</code> bÄ™dzie uÅ¼ywaÅ‚ tej samej wersji, o ile okreÅ›lÄ… kompatybilne wersje <code>rand</code>, oszczÄ™dzajÄ…c nam miejsce i zapewniajÄ…c, Å¼e pakiety w obszarze roboczym bÄ™dÄ… ze sobÄ… kompatybilne.</p>
<p>JeÅ›li pakiety w obszarze roboczym okreÅ›lajÄ… niekompatybilne wersje tej samej zaleÅ¼noÅ›ci, Cargo rozwiÄ…Å¼e kaÅ¼dÄ… z nich, ale nadal bÄ™dzie staraÅ‚o siÄ™ rozwiÄ…zaÄ‡ jak najmniej wersji.</p>
<h3 id="dodawanie-testu-do-obszaru-roboczego"><a class="header" href="#dodawanie-testu-do-obszaru-roboczego">Dodawanie testu do obszaru roboczego</a></h3>
<p>Dla kolejnego ulepszenia, dodajmy test funkcji <code>add_one::add_one</code> w pakiecie <code>add_one</code>:</p>
<p><span class="filename">Nazwa pliku: add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}</code></pre>
<p>Teraz uruchom <code>cargo test</code> w katalogu <em>add</em> najwyÅ¼szego poziomu. Uruchomienie <code>cargo test</code> w tak skonstruowanym obszarze roboczym uruchomi testy dla wszystkich pakietÃ³w w obszarze roboczym:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test
copy output below; the output updating script doesn't handle subdirectories in
paths properly
-->
<pre><code class="language-console">$ cargo test
   Kompilowanie add_one v0.1.0 (file:///projects/add/add_one)
   Kompilowanie adder v0.1.0 (file:///projects/add/adder)
    ZakoÅ„czono `test` profil [unoptimized + debuginfo] cel(e) w 0.20s
     Uruchamianie unittests src/lib.rs (target/debug/deps/add_one-93c49ee75dc46543)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Uruchamianie unittests src/main.rs (target/debug/deps/adder-3a47283c568d2b6a)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Pierwsza sekcja wyjÅ›cia pokazuje, Å¼e test <code>it_works</code> w pakiecie <code>add_one</code> przeszedÅ‚. NastÄ™pna sekcja pokazuje, Å¼e w pakiecie <code>adder</code> nie znaleziono Å¼adnych testÃ³w, a nastÄ™pnie ostatnia sekcja pokazuje, Å¼e w pakiecie <code>add_one</code> nie znaleziono Å¼adnych testÃ³w dokumentacji.</p>
<p>MoÅ¼emy rÃ³wnieÅ¼ uruchomiÄ‡ testy dla jednego konkretnego pakietu w obszarze roboczym z katalogu najwyÅ¼szego poziomu, uÅ¼ywajÄ…c flagi <code>-p</code> i okreÅ›lajÄ…c nazwÄ™ pakietu, ktÃ³ry chcemy przetestowaÄ‡:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test -p add_one
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo test -p add_one
    ZakoÅ„czono `test` profil [unoptimized + debuginfo] cel(e) w 0.00s
     Uruchamianie unittests src/lib.rs (target/debug/deps/add_one-93c49ee75dc46543)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>To wyjÅ›cie pokazuje, Å¼e <code>cargo test</code> uruchomiÅ‚ tylko testy dla pakietu <code>add_one</code> i nie uruchomiÅ‚ testÃ³w pakietu <code>adder</code>.</p>
<p>JeÅ›li opublikujesz pakiety w obszarze roboczym na <a href="https://crates.io/">crates.io</a><!-- ignore -->, kaÅ¼dy pakiet w obszarze roboczym bÄ™dzie musiaÅ‚ zostaÄ‡ opublikowany osobno. Podobnie jak <code>cargo test</code>, moÅ¼emy opublikowaÄ‡ konkretny pakiet w naszym obszarze roboczym, uÅ¼ywajÄ…c flagi <code>-p</code> i okreÅ›lajÄ…c nazwÄ™ pakietu, ktÃ³ry chcemy opublikowaÄ‡.</p>
<p>Dodatkowo, sprÃ³buj dodaÄ‡ pakiet <code>add_two</code> do tego obszaru roboczego w podobny sposÃ³b jak pakiet <code>add_one</code>!</p>
<p>W miarÄ™ wzrostu projektu rozwaÅ¼ uÅ¼ycie obszaru roboczego: pozwala on na pracÄ™ z mniejszymi, Å‚atwiejszymi do zrozumienia komponentami niÅ¼ jedna duÅ¼a bryÅ‚a kodu. Ponadto, utrzymywanie pakietÃ³w w obszarze roboczym moÅ¼e uÅ‚atwiÄ‡ koordynacjÄ™ miÄ™dzy pakietami, jeÅ›li czÄ™sto sÄ… zmieniane w tym samym czasie.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="instalowanie-binariÃ³w-za-pomocÄ…-cargo-install-1"><a href="#instalowanie-binariÃ³w-za-pomocÄ…-cargo-install-1" class="header">Instalowanie binariÃ³w za pomocÄ… cargo install</a></h1>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="installing-binaries-from-cratesio-with-cargo-install"></a></p>
<h2 id="instalowanie-binariÃ³w-za-pomocÄ…-cargo-install"><a class="header" href="#instalowanie-binariÃ³w-za-pomocÄ…-cargo-install">Instalowanie binariÃ³w za pomocÄ… <code>cargo install</code></a></h2>
<p>Polecenie <code>cargo install</code> pozwala instalowaÄ‡ i uÅ¼ywaÄ‡ lokalnie binarne pakiety. Nie ma ono na celu zastÄ…pienia pakietÃ³w systemowych; ma byÄ‡ wygodnym sposobem dla programistÃ³w Rust na instalowanie narzÄ™dzi, ktÃ³re inni udostÄ™pnili na <a href="https://crates.io/">crates.io</a><!-- ignore -->. ZauwaÅ¼, Å¼e moÅ¼esz instalowaÄ‡ tylko pakiety, ktÃ³re majÄ… binarne cele. <em>Cel binarny</em> to uruchamialny program, ktÃ³ry jest tworzony, jeÅ›li pakiet ma plik <em>src/main.rs</em> lub inny plik okreÅ›lony jako binarny, w przeciwieÅ„stwie do celu bibliotecznego, ktÃ³ry nie jest uruchamialny sam w sobie, ale nadaje siÄ™ do wÅ‚Ä…czenia do innych programÃ³w. Zazwyczaj pakiety majÄ… w pliku README informacje o tym, czy dany pakiet jest bibliotekÄ…, ma cel binarny, czy jedno i drugie.</p>
<p>Wszystkie pliki binarne zainstalowane za pomocÄ… <code>cargo install</code> sÄ… przechowywane w folderze <em>bin</em> katalogu instalacyjnego. JeÅ›li zainstalowaÅ‚eÅ› Rust za pomocÄ… <em>rustup.rs</em> i nie masz Å¼adnych niestandardowych konfiguracji, ten katalog bÄ™dzie <em>$HOME/.cargo/bin</em>. Upewnij siÄ™, Å¼e ten katalog znajduje siÄ™ w Twojej zmiennej <code>$PATH</code>, aby mÃ³c uruchamiaÄ‡ programy zainstalowane za pomocÄ… <code>cargo install</code>.</p>
<p>Na przykÅ‚ad, w Rozdziale 12 wspomnieliÅ›my, Å¼e istnieje implementacja narzÄ™dzia <code>grep</code> w Rust o nazwie <code>ripgrep</code> do przeszukiwania plikÃ³w. Aby zainstalowaÄ‡ <code>ripgrep</code>, moÅ¼emy uruchomiÄ‡ nastÄ™pujÄ…ce polecenie:</p>
<!-- manual-regeneration
cargo install something you don't have, copy relevant output below
-->
<pre><code class="language-console">$ cargo install ripgrep
    Aktualizowanie indeksu crates.io
  Pobrano ripgrep v14.1.1
  Pobrano 1 pakiet (213.6 KB) w 0.40s
  Instalowanie ripgrep v14.1.1
--snip--
   Kompilowanie grep v0.3.2
    ZakoÅ„czono `release` profil [optimized + debuginfo] cel(e) w 6.73s
  Instalowanie ~/.cargo/bin/rg
   Zainstalowano pakiet `ripgrep v14.1.1` (wykonywalny `rg`)
</code></pre>
<p>Druga od koÅ„ca linia wyjÅ›cia pokazuje lokalizacjÄ™ i nazwÄ™ zainstalowanego pliku binarnego, ktÃ³rym w przypadku <code>ripgrep</code> jest <code>rg</code>. DopÃ³ki katalog instalacyjny znajduje siÄ™ w Twoim <code>$PATH</code>, jak wspomniano wczeÅ›niej, moÅ¼esz uruchomiÄ‡ <code>rg --help</code> i zaczÄ…Ä‡ uÅ¼ywaÄ‡ szybszego, bardziej â€rustyâ€ narzÄ™dzia do przeszukiwania plikÃ³w!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rozszerzanie-cargo-o-niestandardowe-polecenia-1"><a href="#rozszerzanie-cargo-o-niestandardowe-polecenia-1" class="header">Rozszerzanie Cargo o niestandardowe polecenia</a></h1>
<h2 id="rozszerzanie-cargo-o-niestandardowe-polecenia"><a class="header" href="#rozszerzanie-cargo-o-niestandardowe-polecenia">Rozszerzanie Cargo o niestandardowe polecenia</a></h2>
<p>Cargo zostaÅ‚o zaprojektowane tak, aby moÅ¼na byÅ‚o je rozszerzaÄ‡ o nowe podpolecenia bez koniecznoÅ›ci modyfikowania. JeÅ›li plik binarny w Twojej <code>$PATH</code> ma nazwÄ™ <code>cargo-coÅ›</code>, moÅ¼esz uruchomiÄ‡ go tak, jakby byÅ‚ podpoleceniem Cargo, uruchamiajÄ…c <code>cargo coÅ›</code>. Niestandardowe polecenia tego typu sÄ… rÃ³wnieÅ¼ wyÅ›wietlane po uruchomieniu <code>cargo --list</code>. MoÅ¼liwoÅ›Ä‡ uÅ¼ycia <code>cargo install</code> do instalowania rozszerzeÅ„, a nastÄ™pnie uruchamiania ich tak samo jak wbudowanych narzÄ™dzi Cargo, jest bardzo wygodnÄ… zaletÄ… projektu Cargo!</p>
<h2 id="podsumowanie-13"><a class="header" href="#podsumowanie-13">Podsumowanie</a></h2>
<p>UdostÄ™pnianie kodu za pomocÄ… Cargo i <a href="https://crates.io/">crates.io</a><!-- ignore --> jest czÄ™Å›ciÄ… tego, co sprawia, Å¼e ekosystem Rusta jest uÅ¼yteczny do wielu rÃ³Å¼nych zadaÅ„. Standardowa biblioteka Rusta jest maÅ‚a i stabilna, ale pakiety sÄ… Å‚atwe do udostÄ™pniania, uÅ¼ywania i ulepszania w innym tempie niÅ¼ jÄ™zyk. Nie krÄ™puj siÄ™ udostÄ™pniaÄ‡ kodu, ktÃ³ry jest dla Ciebie uÅ¼yteczny, na <a href="https://crates.io/">crates.io</a><!-- ignore -->; prawdopodobnie bÄ™dzie on uÅ¼yteczny rÃ³wnieÅ¼ dla kogoÅ› innego!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="inteligentne-wskaÅºniki"><a class="header" href="#inteligentne-wskaÅºniki">Inteligentne wskaÅºniki</a></h1>
<p>WskaÅºnik to ogÃ³lne pojÄ™cie dla zmiennej, ktÃ³ra zawiera adres w pamiÄ™ci. Ten adres odwoÅ‚uje siÄ™ do, czyli â€wskazuje naâ€, inne dane. NajczÄ™stszym rodzajem wskaÅºnika w Rust jest referencja, o ktÃ³rej uczyÅ‚eÅ› siÄ™ w Rozdziale 4. Referencje sÄ… wskazywane symbolem <code>&amp;</code> i poÅ¼yczajÄ… wartoÅ›Ä‡, na ktÃ³rÄ… wskazujÄ…. Nie majÄ… Å¼adnych specjalnych moÅ¼liwoÅ›ci poza odwoÅ‚ywaniem siÄ™ do danych i nie majÄ… Å¼adnych narzutÃ³w.</p>
<p><em>Inteligentne wskaÅºniki</em> natomiast to struktury danych, ktÃ³re zachowujÄ… siÄ™ jak wskaÅºnik, ale majÄ… rÃ³wnieÅ¼ dodatkowe metadane i moÅ¼liwoÅ›ci. Koncepcja inteligentnych wskaÅºnikÃ³w nie jest unikalna dla Rusta: inteligentne wskaÅºniki powstaÅ‚y w C++ i istniejÄ… rÃ³wnieÅ¼ w innych jÄ™zykach. Rust posiada rÃ³Å¼norodne inteligentne wskaÅºniki zdefiniowane w standardowej bibliotece, ktÃ³re zapewniajÄ… funkcjonalnoÅ›Ä‡ wykraczajÄ…cÄ… poza tÄ™ zapewnianÄ… przez referencje. Aby zbadaÄ‡ ogÃ³lne pojÄ™cie, przyjrzymy siÄ™ kilku rÃ³Å¼nym przykÅ‚adom inteligentnych wskaÅºnikÃ³w, w tym typowi inteligentnego wskaÅºnika z <em>licznikiem referencji</em>. Ten wskaÅºnik umoÅ¼liwia posiadanie wielu wÅ‚aÅ›cicieli danych poprzez Å›ledzenie liczby wÅ‚aÅ›cicieli i, gdy nie ma juÅ¼ wÅ‚aÅ›cicieli, oczyszczanie danych.</p>
<p>W Rust, z jego koncepcjÄ… wÅ‚asnoÅ›ci i poÅ¼yczania, istnieje dodatkowa rÃ³Å¼nica miÄ™dzy referencjami a inteligentnymi wskaÅºnikami: podczas gdy referencje tylko poÅ¼yczajÄ… dane, w wielu przypadkach inteligentne wskaÅºniki <em>posiadajÄ…</em> dane, na ktÃ³re wskazujÄ….</p>
<p>Inteligentne wskaÅºniki sÄ… zazwyczaj implementowane za pomocÄ… struktur. W przeciwieÅ„stwie do zwykÅ‚ej struktury, inteligentne wskaÅºniki implementujÄ… cechy <code>Deref</code> i <code>Drop</code>. Cecha <code>Deref</code> pozwala instancji struktury inteligentnego wskaÅºnika zachowywaÄ‡ siÄ™ jak referencja, dziÄ™ki czemu moÅ¼na pisaÄ‡ kod, ktÃ³ry dziaÅ‚a zarÃ³wno z referencjami, jak i inteligentnymi wskaÅºnikami. Cecha <code>Drop</code> pozwala dostosowaÄ‡ kod, ktÃ³ry jest uruchamiany, gdy instancja inteligentnego wskaÅºnika wychodzi poza zakres. W tym rozdziale omÃ³wimy obie te cechy i zademonstrujemy, dlaczego sÄ… one waÅ¼ne dla inteligentnych wskaÅºnikÃ³w.</p>
<p>BiorÄ…c pod uwagÄ™, Å¼e wzorzec inteligentnego wskaÅºnika jest ogÃ³lnym wzorcem projektowym czÄ™sto uÅ¼ywanym w Rust, ten rozdziaÅ‚ nie obejmie kaÅ¼dego istniejÄ…cego inteligentnego wskaÅºnika. Wiele bibliotek ma wÅ‚asne inteligentne wskaÅºniki, a nawet moÅ¼esz napisaÄ‡ wÅ‚asny. OmÃ³wimy najbardziej popularne inteligentne wskaÅºniki w standardowej bibliotece:</p>
<ul>
<li><code>Box&lt;T&gt;</code>, do alokowania wartoÅ›ci na stercie</li>
<li><code>Rc&lt;T&gt;</code>, typ zliczajÄ…cy referencje, ktÃ³ry umoÅ¼liwia wielokrotne posiadanie</li>
<li><code>Ref&lt;T&gt;</code> i <code>RefMut&lt;T&gt;</code>, dostÄ™pne przez <code>RefCell&lt;T&gt;</code>, typ, ktÃ³ry wymusza zasady poÅ¼yczania w czasie dziaÅ‚ania zamiast w czasie kompilacji</li>
</ul>
<p>Ponadto omÃ³wimy wzorzec <em>wewnÄ™trznej zmiennoÅ›ci</em>, w ktÃ³rym niezmienny typ udostÄ™pnia API do mutowania wartoÅ›ci wewnÄ™trznej. OmÃ³wimy rÃ³wnieÅ¼ cykle referencji: jak mogÄ… prowadziÄ‡ do wyciekÃ³w pamiÄ™ci i jak im zapobiegaÄ‡.</p>
<p>Zaczynajmy!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="uÅ¼ycie-boxt-do-wskazywania-na-dane-na-stercie-1"><a href="#uÅ¼ycie-boxt-do-wskazywania-na-dane-na-stercie-1" class="header">UÅ¼ycie Box&lt;T&gt; do wskazywania na dane na stercie</a></h1>
<h2 id="uÅ¼ycie-boxt-do-wskazywania-na-dane-na-stercie"><a class="header" href="#uÅ¼ycie-boxt-do-wskazywania-na-dane-na-stercie">UÅ¼ycie <code>Box&lt;T&gt;</code> do wskazywania na dane na stercie</a></h2>
<p>Najprostszym inteligentnym wskaÅºnikiem jest pudeÅ‚ko, ktÃ³rego typ zapisuje siÄ™
jako <code>Box&lt;T&gt;</code>. <em>PudeÅ‚ka</em> pozwalajÄ… przechowywaÄ‡ dane na stercie zamiast na
stosie. To, co pozostaje na stosie, to wskaÅºnik do danych na stercie.
OdwoÅ‚aj siÄ™ do RozdziaÅ‚u 4, aby zapoznaÄ‡ siÄ™ z rÃ³Å¼nicÄ… miÄ™dzy stosem a stertÄ….</p>
<p>PudeÅ‚ka nie majÄ… narzutu wydajnoÅ›ciowego, poza przechowywaniem danych na stercie
zamiast na stosie. Ale nie majÄ… teÅ¼ wielu dodatkowych moÅ¼liwoÅ›ci. BÄ™dziesz ich
uÅ¼ywaÄ‡ najczÄ™Å›ciej w nastÄ™pujÄ…cych sytuacjach:</p>
<ul>
<li>Kiedy masz typ, ktÃ³rego rozmiar nie moÅ¼e byÄ‡ znany w czasie kompilacji,
i chcesz uÅ¼yÄ‡ wartoÅ›ci tego typu w kontekÅ›cie, ktÃ³ry wymaga dokÅ‚adnego
rozmiaru</li>
<li>Kiedy masz duÅ¼Ä… iloÅ›Ä‡ danych i chcesz przenieÅ›Ä‡ wÅ‚asnoÅ›Ä‡, ale upewniÄ‡ siÄ™,
Å¼e dane nie zostanÄ… skopiowane, gdy to zrobisz</li>
<li>Kiedy chcesz byÄ‡ wÅ‚aÅ›cicielem wartoÅ›ci, a zaleÅ¼y ci tylko na tym, aby byÅ‚a to
typ, ktÃ³ry implementuje okreÅ›lonÄ… cechÄ™, zamiast byÄ‡ konkretnym typem</li>
</ul>
<p>PokaÅ¼emy pierwszÄ… sytuacjÄ™ w sekcji <a href="#enabling-recursive-types-with-boxes">â€WÅ‚Ä…czanie typÃ³w rekurencyjnych za pomocÄ…
pudeÅ‚ekâ€</a><!-- ignore -->. W drugim
przypadku przeniesienie wÅ‚asnoÅ›ci duÅ¼ej iloÅ›ci danych moÅ¼e zajÄ…Ä‡ duÅ¼o czasu,
poniewaÅ¼ dane sÄ… kopiowane na stosie. Aby poprawiÄ‡ wydajnoÅ›Ä‡ w tej sytuacji,
moÅ¼emy przechowywaÄ‡ duÅ¼Ä… iloÅ›Ä‡ danych na stercie w pudeÅ‚ku. Wtedy tylko maÅ‚a
iloÅ›Ä‡ danych wskaÅºnika jest kopiowana na stosie, podczas gdy dane, do ktÃ³rych
wskazuje, pozostajÄ… w jednym miejscu na stercie. Trzeci przypadek jest znany
jako <em>obiekt cechy</em>, a sekcja <a href="#using-trait-objects-to-abstract-over-shared-behavior">â€UÅ¼ywanie obiektÃ³w cech do abstrakcji nad
wspÃ³lnym zachowaniemâ€</a><!-- ignore --> w Rozdziale 18 jest
poÅ›wiÄ™cona temu tematowi. WiÄ™c to, czego siÄ™ tutaj nauczysz, zastosujesz
p ponownie w tej sekcji!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="using-boxt-to-store-data-on-the-heap"></a></p>
<h3 id="przechowywanie-danych-na-stercie"><a class="header" href="#przechowywanie-danych-na-stercie">Przechowywanie danych na stercie</a></h3>
<p>Zanim omÃ³wimy przypadek uÅ¼ycia <code>Box&lt;T&gt;</code> do przechowywania na stercie,
powiemy o skÅ‚adni i sposobie interakcji z wartoÅ›ciami przechowywanymi w <code>Box&lt;T&gt;</code>.</p>
<p>Listing 15-1 pokazuje, jak uÅ¼yÄ‡ pudeÅ‚ka do przechowywania wartoÅ›ci <code>i32</code> na
stercie.</p>
<figure class="listing" id="listing-15-1">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let b = Box::new(5);
    println!("b = {b}");
}</code></pre>
<figcaption><a href="#listing-15-1">Listing 15-1</a>: Przechowywanie wartoÅ›ci <code>i32</code> na stercie za pomocÄ… pudeÅ‚ka</figcaption>
</figure>
<p>Definiujemy zmiennÄ… <code>b</code> z wartoÅ›ciÄ… <code>Box</code>, ktÃ³ra wskazuje na wartoÅ›Ä‡ <code>5</code>,
alokowanÄ… na stercie. Ten program wyÅ›wietli <code>b = 5</code>; w tym przypadku moÅ¼emy
dostÄ™p do danych w pudeÅ‚ku podobnie jak wtedy, gdyby te dane znajdowaÅ‚y siÄ™ na
stercie. Podobnie jak kaÅ¼da posiadana wartoÅ›Ä‡, gdy pudeÅ‚ko wyjdzie poza
zakres, tak jak <code>b</code> na koÅ„cu <code>main</code>, zostanie zdealokowane. Dealokacja
odbywa siÄ™ zarÃ³wno dla pudeÅ‚ka (przechowywanego na stosie), jak i dla danych,
do ktÃ³rych wskazuje (przechowywanych na stercie).</p>
<p>Umieszczenie pojedynczej wartoÅ›ci na stercie nie jest zbyt uÅ¼yteczne, wiÄ™c
rzadko bÄ™dziesz uÅ¼ywaÄ‡ pudeÅ‚ek w ten sposÃ³b. Posiadanie wartoÅ›ci, takich jak
pojedyncze <code>i32</code> na stosie, gdzie sÄ… domyÅ›lnie przechowywane, jest bardziej
odpowiednie w wiÄ™kszoÅ›ci sytuacji. SpÃ³jrzmy na przypadek, w ktÃ³rym pudeÅ‚ka
pozwalajÄ… nam definiowaÄ‡ typy, ktÃ³rych nie moglibyÅ›my zdefiniowaÄ‡, gdybyÅ›my
nie mieli pudeÅ‚ek.</p>
<h3 id="wÅ‚Ä…czanie-typÃ³w-rekurencyjnych-za-pomocÄ…-pudeÅ‚ek"><a class="header" href="#wÅ‚Ä…czanie-typÃ³w-rekurencyjnych-za-pomocÄ…-pudeÅ‚ek">WÅ‚Ä…czanie typÃ³w rekurencyjnych za pomocÄ… pudeÅ‚ek</a></h3>
<p>WartoÅ›Ä‡ <em>typu rekurencyjnego</em> moÅ¼e zawieraÄ‡ innÄ… wartoÅ›Ä‡ tego samego typu jako
swojÄ… czÄ™Å›Ä‡. Typy rekurencyjne stanowiÄ… problem, poniewaÅ¼ Rust musi wiedzieÄ‡
w czasie kompilacji, ile miejsca zajmuje dany typ. Jednak zagnieÅ¼dÅ¼anie wartoÅ›ci
typÃ³w rekurencyjnych mogÅ‚oby teoretycznie trwaÄ‡ w nieskoÅ„czonoÅ›Ä‡, wiÄ™c Rust nie
moÅ¼e wiedzieÄ‡, ile miejsca potrzebuje wartoÅ›Ä‡. PoniewaÅ¼ pudeÅ‚ka majÄ… znany
rozmiar, moÅ¼emy wÅ‚Ä…czyÄ‡ typy rekurencyjne, wstawiajÄ…c pudeÅ‚ko do definicji typu
rekurencyjnego.</p>
<p>Jako przykÅ‚ad typu rekurencyjnego, przeanalizujmy listÄ™ cons. Jest to typ danych
powszechnie spotykany w jÄ™zykach programowania funkcyjnego. Typ listy cons,
ktÃ³ry zdefiniujemy, jest prosty, z wyjÄ…tkiem rekurencji; dlatego koncepcje w
przykÅ‚adzie, z ktÃ³rym bÄ™dziemy pracowaÄ‡, bÄ™dÄ… przydatne zawsze, gdy znajdziesz
siÄ™ w bardziej zÅ‚oÅ¼onych sytuacjach zwiÄ…zanych z typami rekurencyjnymi.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="more-information-about-the-cons-list"></a></p>
<h4 id="zrozumienie-listy-cons"><a class="header" href="#zrozumienie-listy-cons">Zrozumienie listy cons</a></h4>
<p><em>Lista cons</em> to struktura danych pochodzÄ…ca z jÄ™zyka programowania Lisp i jego
dialektÃ³w, skÅ‚adajÄ…ca siÄ™ z zagnieÅ¼dÅ¼onych par, i jest lispoÅ„skÄ… wersjÄ… listy
skÅ‚adajÄ…cej siÄ™ z poÅ‚Ä…czonych elementÃ³w. Jej nazwa pochodzi od funkcji <code>cons</code>
(skrÃ³t od <em>construct function</em>) w Lispie, ktÃ³ra konstruuje nowÄ… parÄ™ z dwÃ³ch
swoich argumentÃ³w. WywoÅ‚ujÄ…c <code>cons</code> na parze skÅ‚adajÄ…cej siÄ™ z wartoÅ›ci i innej
pary, moÅ¼emy konstruowaÄ‡ listy cons skÅ‚adajÄ…ce siÄ™ z rekurencyjnych par.</p>
<p>Na przykÅ‚ad, oto pseudokodowa reprezentacja listy cons zawierajÄ…cej listÄ™ <code>1, 2, 3</code>,
gdzie kaÅ¼da para jest w nawiasach:</p>
<pre><code class="language-text">(1, (2, (3, Nil)))
</code></pre>
<p>KaÅ¼dy element listy cons zawiera dwa elementy: wartoÅ›Ä‡ bieÅ¼Ä…cego elementu i
nastÄ™pnego elementu. Ostatni element listy zawiera tylko wartoÅ›Ä‡ zwanÄ… <code>Nil</code>
bez nastÄ™pnego elementu. Lista cons jest tworzona przez rekurencyjne
wywoÅ‚ywanie funkcji <code>cons</code>. Kanoniczna nazwa oznaczajÄ…ca przypadek bazowy
rekurencji to <code>Nil</code>. ZauwaÅ¼, Å¼e to nie to samo, co koncepcja â€nullâ€ lub â€nilâ€
omÃ³wiona w Rozdziale 6, ktÃ³ra oznacza nieprawidÅ‚owÄ… lub brakujÄ…cÄ… wartoÅ›Ä‡.</p>
<p>Lista cons nie jest powszechnie uÅ¼ywanÄ… strukturÄ… danych w Rust. W wiÄ™kszoÅ›ci
przypadkÃ³w, gdy masz listÄ™ elementÃ³w w Rust, <code>Vec&lt;T&gt;</code> jest lepszym wyborem. Inne,
bardziej zÅ‚oÅ¼one rekurencyjne typy danych <em>sÄ…</em> uÅ¼yteczne w rÃ³Å¼nych sytuacjach,
ale zaczynajÄ…c od listy cons w tym rozdziale, moÅ¼emy zbadaÄ‡, jak pudeÅ‚ka
pPozwalajÄ… nam definiowaÄ‡ rekurencyjny typ danych bez zbytniego rozpraszania.</p>
<p>Listing 15-2 zawiera definicjÄ™ wyliczenia dla listy cons. ZauwaÅ¼, Å¼e ten kod
jeszcze siÄ™ nie skompiluje, poniewaÅ¼ typ <code>List</code> nie ma znanego rozmiaru, co
pokaÅ¼emy.</p>
<figure class="listing" id="listing-15-2">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<figcaption><a href="#listing-15-2">Listing 15-2</a>: Pierwsza prÃ³ba zdefiniowania wyliczenia do reprezentowania struktury danych listy cons z wartoÅ›ciami <code>i32</code></figcaption>
</figure>
<section class="note" aria-role="note">
<p>Uwaga: Implementujemy listÄ™ cons, ktÃ³ra przechowuje tylko wartoÅ›ci <code>i32</code> dla
celÃ³w tego przykÅ‚adu. MoglibyÅ›my zaimplementowaÄ‡ jÄ… za pomocÄ… generykÃ³w, jak
omÃ³wiliÅ›my w Rozdziale 10, aby zdefiniowaÄ‡ typ listy cons, ktÃ³ry mÃ³gÅ‚by
przechowywaÄ‡ wartoÅ›ci dowolnego typu.</p>
</section>
<p>UÅ¼ycie typu <code>List</code> do przechowywania listy <code>1, 2, 3</code> wyglÄ…daÅ‚oby jak kod
w Listingu 15-3.</p>
<figure class="listing" id="listing-15-3">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, List),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}</code></pre>
<figcaption><a href="#listing-15-3">Listing 15-3</a>: UÅ¼ycie wyliczenia <code>List</code> do przechowywania listy <code>1, 2, 3</code></figcaption>
</figure>
<p>Pierwsza wartoÅ›Ä‡ <code>Cons</code> przechowuje <code>1</code> i innÄ… wartoÅ›Ä‡ <code>List</code>. Ta wartoÅ›Ä‡
<code>List</code> to inna wartoÅ›Ä‡ <code>Cons</code>, ktÃ³ra przechowuje <code>2</code> i innÄ… wartoÅ›Ä‡ <code>List</code>.
Ta wartoÅ›Ä‡ <code>List</code> to jeszcze jedna wartoÅ›Ä‡ <code>Cons</code>, ktÃ³ra przechowuje <code>3</code>
i wartoÅ›Ä‡ <code>List</code>, ktÃ³ra jest w koÅ„cu <code>Nil</code>, nierrekurencyjnym wariantem,
ktÃ³ry sygnalizuje koniec listy.</p>
<p>JeÅ›li sprÃ³bujemy skompilowaÄ‡ kod z Listingu 15-3, otrzymamy bÅ‚Ä…d pokazany w
Listingu 15-4.</p>
<figure class="listing" id="listing-15-4">
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +

error[E0391]: cycle detected when computing when `List` needs drop
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which immediately requires computing when `List` needs drop again
  = note: cycle used when computing whether `List` needs drop
  = note: see https://rustc-dev-guide.rust-lang.org/overview.html#queries and https://rustc-dev-guide.rust-lang.org/query.html for more information

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` (bin "cons-list") due to 2 previous errors
</code></pre>
<figcaption><a href="#listing-15-4">Listing 15-4</a>: BÅ‚Ä…d, ktÃ³ry otrzymujemy, prÃ³bujÄ…c zdefiniowaÄ‡ rekurencyjne wyliczenie</figcaption>
</figure>
<p>BÅ‚Ä…d pokazuje, Å¼e ten typ â€ma nieskoÅ„czony rozmiarâ€. Powodem jest to, Å¼e
zdefiniowaliÅ›my <code>List</code> z wariantem, ktÃ³ry jest rekurencyjny: przechowuje innÄ…
wartoÅ›Ä‡ siebie bezpoÅ›rednio. W rezultacie Rust nie potrafi okreÅ›liÄ‡, ile miejsca
potrzebuje do przechowywania wartoÅ›ci <code>List</code>. RozÅ‚Ã³Å¼my na czynniki pierwsze,
dlaczego otrzymujemy ten bÅ‚Ä…d. Najpierw przyjrzymy siÄ™, jak Rust decyduje, ile
miejsca potrzebuje do przechowywania wartoÅ›ci typu nierrekurencyjnego.</p>
<h4 id="obliczanie-rozmiaru-typu-nierrekurencyjnego"><a class="header" href="#obliczanie-rozmiaru-typu-nierrekurencyjnego">Obliczanie rozmiaru typu nierrekurencyjnego</a></h4>
<p>Przypomnijmy wyliczenie <code>Message</code>, ktÃ³re zdefiniowaliÅ›my w Listingu 6-2,
kiedy omawialiÅ›my definicje wyliczeÅ„ w Rozdziale 6:</p>
<pre class="playground"><code class="language-rust edition2024">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>Aby okreÅ›liÄ‡, ile miejsca naleÅ¼y przeznaczyÄ‡ na wartoÅ›Ä‡ <code>Message</code>, Rust
przechodzi przez kaÅ¼dy z wariantÃ³w, aby sprawdziÄ‡, ktÃ³ry wariant potrzebuje
najwiÄ™cej miejsca. Rust widzi, Å¼e <code>Message::Quit</code> nie potrzebuje miejsca,
<code>Message::Move</code> potrzebuje wystarczajÄ…co duÅ¼o miejsca na przechowanie dwÃ³ch
wartoÅ›ci <code>i32</code> i tak dalej. PoniewaÅ¼ uÅ¼ywany bÄ™dzie tylko jeden wariant,
najwiÄ™cej miejsca, jakie bÄ™dzie potrzebowaÄ‡ wartoÅ›Ä‡ <code>Message</code>, to miejsce
potrzebne na przechowanie najwiÄ™kszego z jej wariantÃ³w.</p>
<p>PorÃ³wnaj to z tym, co dzieje siÄ™, gdy Rust prÃ³buje okreÅ›liÄ‡, ile miejsca
potrzebuje rekurencyjny typ, taki jak wyliczenie <code>List</code> w Listingu 15-2.
Kompilator zaczyna od wariantu <code>Cons</code>, ktÃ³ry przechowuje wartoÅ›Ä‡ typu <code>i32</code>
i wartoÅ›Ä‡ typu <code>List</code>. Dlatego <code>Cons</code> potrzebuje tyle miejsca, ile wynosi
rozmiar <code>i32</code> plus rozmiar <code>List</code>. Aby dowiedzieÄ‡ siÄ™, ile pamiÄ™ci potrzebuje
typ <code>List</code>, kompilator patrzy na warianty, zaczynajÄ…c od wariantu <code>Cons</code>.
Wariant <code>Cons</code> przechowuje wartoÅ›Ä‡ typu <code>i32</code> i wartoÅ›Ä‡ typu <code>List</code>, i ten
proces trwa w nieskoÅ„czonoÅ›Ä‡, jak pokazano na Rysunku 15-1.</p>
<img alt="NieskoÅ„czona lista Cons: prostokÄ…t oznaczony &#39;Cons&#39; podzielony na dwa mniejsze prostokÄ…ty. Pierwszy mniejszy prostokÄ…t zawiera etykietÄ™ &#39;i32&#39;, a drugi mniejszy prostokÄ…t zawiera etykietÄ™ &#39;Cons&#39; i mniejszÄ… wersjÄ™ zewnÄ™trznego prostokÄ…ta &#39;Cons&#39;. ProstokÄ…ty &#39;Cons&#39; nadal zawierajÄ… coraz mniejsze wersje samych siebie, aÅ¼ najmniejszy, wygodnie rozmiarowy prostokÄ…t zawiera symbol nieskoÅ„czonoÅ›ci, wskazujÄ…c, Å¼e to powtÃ³rzenie trwa wiecznie." src="img/trpl15-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Rysunek 15-1: NieskoÅ„czona lista <code>List</code> skÅ‚adajÄ…ca siÄ™ z nieskoÅ„czonych wariantÃ³w <code>Cons</code></span></p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="using-boxt-to-get-a-recursive-type-with-a-known-size"></a></p>
<h4 id="uzyskiwanie-rekurencyjnego-typu-o-znanym-rozmiarze"><a class="header" href="#uzyskiwanie-rekurencyjnego-typu-o-znanym-rozmiarze">Uzyskiwanie rekurencyjnego typu o znanym rozmiarze</a></h4>
<p>PoniewaÅ¼ Rust nie jest w stanie okreÅ›liÄ‡, ile miejsca naleÅ¼y przydzieliÄ‡ dla
rekurencyjnie zdefiniowanych typÃ³w, kompilator zwraca bÅ‚Ä…d z tÄ… pomocnÄ…
sugestiÄ…:</p>
<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-->
<pre><code class="language-text">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +
</code></pre>
<p>W tej sugestii <em>poÅ›rednictwo</em> oznacza, Å¼e zamiast bezpoÅ›rednio przechowywaÄ‡
wartoÅ›Ä‡, powinniÅ›my zmieniÄ‡ strukturÄ™ danych, aby przechowywaÄ‡ wartoÅ›Ä‡
poÅ›rednio, przechowujÄ…c zamiast tego wskaÅºnik do wartoÅ›ci.</p>
<p>PoniewaÅ¼ <code>Box&lt;T&gt;</code> jest wskaÅºnikiem, Rust zawsze wie, ile miejsca potrzebuje
<code>Box&lt;T&gt;</code>: rozmiar wskaÅºnika nie zmienia siÄ™ w zaleÅ¼noÅ›ci od iloÅ›ci danych, na
ktÃ³re wskazuje. Oznacza to, Å¼e moÅ¼emy umieÅ›ciÄ‡ <code>Box&lt;T&gt;</code> w wariancie <code>Cons</code>
zamiast bezpoÅ›rednio innej wartoÅ›ci <code>List</code>. <code>Box&lt;T&gt;</code> bÄ™dzie wskazywaÄ‡ na
kolejnÄ… wartoÅ›Ä‡ <code>List</code>, ktÃ³ra bÄ™dzie znajdowaÄ‡ siÄ™ na stercie, a nie wewnÄ…trz
wariantu <code>Cons</code>. Koncepcyjnie, nadal mamy listÄ™, utworzonÄ… z list
przechowujÄ…cych inne listy, ale ta implementacja jest teraz bardziej podobna
do umieszczania elementÃ³w obok siebie, a nie wewnÄ…trz siebie.</p>
<p>MoÅ¼emy zmieniÄ‡ definicjÄ™ wyliczenia <code>List</code> w Listingu 15-2 i uÅ¼ycie <code>List</code> w
Listingu 15-3 na kod w Listingu 15-5, ktÃ³ry siÄ™ skompiluje.</p>
<figure class="listing" id="listing-15-5">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}</code></pre>
<figcaption><a href="#listing-15-5">Listing 15-5</a>: Definicja <code>List</code>, ktÃ³ra uÅ¼ywa <code>Box&lt;T&gt;</code>, aby mieÄ‡ znany rozmiar</figcaption>
</figure>
<p>Wariant <code>Cons</code> potrzebuje rozmiaru <code>i32</code> plus miejsca na przechowywanie danych
wskaznika pudeÅ‚ka. Wariant <code>Nil</code> nie przechowuje Å¼adnych wartoÅ›ci, wiÄ™c
potrzebuje mniej miejsca na stosie niÅ¼ wariant <code>Cons</code>. Wiemy teraz, Å¼e kaÅ¼da
wartoÅ›Ä‡ <code>List</code> zajmie rozmiar <code>i32</code> plus rozmiar danych wskaÅºnika pudeÅ‚ka.
UÅ¼ywajÄ…c pudeÅ‚ka, przerwaliÅ›my nieskoÅ„czony, rekurencyjny Å‚aÅ„cuch, wiÄ™c
kompilator moÅ¼e okreÅ›liÄ‡ rozmiar potrzebny do przechowywania wartoÅ›ci <code>List</code>.
Rysunek 15-2 pokazuje, jak wyglÄ…da teraz wariant <code>Cons</code>.</p>
<img alt="ProstokÄ…t oznaczony &#39;Cons&#39; podzielony na dwa mniejsze prostokÄ…ty. Pierwszy mniejszy prostokÄ…t zawiera etykietÄ™ &#39;i32&#39;, a drugi mniejszy prostokÄ…t zawiera etykietÄ™ &#39;Box&#39; z jednym wewnÄ™trznym prostokÄ…tem, ktÃ³ry zawiera etykietÄ™ &#39;usize&#39;, reprezentujÄ…cÄ… skoÅ„czony rozmiar wskaÅºnika pudeÅ‚ka." src="img/trpl15-02.svg" class="center" />
<p><span class="caption">Rysunek 15-2: <code>List</code>, ktÃ³ra nie ma nieskoÅ„czonego rozmiaru, poniewaÅ¼ <code>Cons</code> zawiera <code>Box</code></span></p>
<p>PudeÅ‚ka zapewniajÄ… jedynie poÅ›rednictwo i alokacjÄ™ na stercie; nie majÄ… Å¼adnych
innych specjalnych moÅ¼liwoÅ›ci, takich jak te, ktÃ³re zobaczymy w przypadku
innych typÃ³w inteligentnych wskaÅºnikÃ³w. Nie majÄ… rÃ³wnieÅ¼ narzutu
wydajnoÅ›ciowego, ktÃ³ry wiÄ…Å¼e siÄ™ z tymi specjalnymi moÅ¼liwoÅ›ciami, wiÄ™c mogÄ…
byÄ‡ przydatne w przypadkach, takich jak lista cons, gdzie poÅ›rednictwo jest
jedynÄ… potrzebnÄ… nam funkcjÄ…. WiÄ™cej przypadkÃ³w uÅ¼ycia pudeÅ‚ek omÃ³wimy w
Rozdziale 18.</p>
<p>Typ <code>Box&lt;T&gt;</code> jest inteligentnym wskaÅºnikiem, poniewaÅ¼ implementuje cechÄ™
<code>Deref</code>, ktÃ³ra pozwala traktowaÄ‡ wartoÅ›ci <code>Box&lt;T&gt;</code> jak referencje. Kiedy
wartoÅ›Ä‡ <code>Box&lt;T&gt;</code> wychodzi poza zakres, dane na stercie, na ktÃ³re wskazuje
pudeÅ‚ko, rÃ³wnieÅ¼ sÄ… czyszczone ze wzglÄ™du na implementacjÄ™ cechy <code>Drop</code>. Te
dwie cechy bÄ™dÄ… jeszcze waÅ¼niejsze dla funkcjonalnoÅ›ci zapewnianej przez inne
typy inteligentnych wskaÅºnikÃ³w, ktÃ³re omÃ³wimy w pozostaÅ‚ej czÄ™Å›ci tego
rozdziaÅ‚u. Przeanalizujmy te dwie cechy bardziej szczegÃ³Å‚owo.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="traktowanie-inteligentnych-wskaÅºnikÃ³w-jak-zwykÅ‚ych-referencji-1"><a href="#traktowanie-inteligentnych-wskaÅºnikÃ³w-jak-zwykÅ‚ych-referencji-1" class="header">Traktowanie inteligentnych wskaÅºnikÃ³w jak zwykÅ‚ych referencji</a></h1>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="treating-smart-pointers-like-regular-references-with-the-deref-trait"></a>
<a id="treating-smart-pointers-like-regular-references-with-deref"></a></p>
<h2 id="traktowanie-inteligentnych-wskaÅºnikÃ³w-jak-zwykÅ‚ych-referencji"><a class="header" href="#traktowanie-inteligentnych-wskaÅºnikÃ³w-jak-zwykÅ‚ych-referencji">Traktowanie inteligentnych wskaÅºnikÃ³w jak zwykÅ‚ych referencji</a></h2>
<p>Implementacja cechy <code>Deref</code> pozwala dostosowaÄ‡ zachowanie <em>operatora dereferencji</em> <code>*</code> (nie myliÄ‡ z operatorem mnoÅ¼enia ani glob). ImplementujÄ…c <code>Deref</code> w taki sposÃ³b, Å¼e inteligentny wskaÅºnik moÅ¼e byÄ‡ traktowany jak zwykÅ‚a referencja, moÅ¼esz pisaÄ‡ kod, ktÃ³ry dziaÅ‚a na referencjach i uÅ¼ywaÄ‡ tego kodu rÃ³wnieÅ¼ z inteligentnymi wskaÅºnikami.</p>
<p>Najpierw przyjrzyjmy siÄ™, jak operator dereferencji dziaÅ‚a ze zwykÅ‚ymi referencjami. NastÄ™pnie sprÃ³bujemy zdefiniowaÄ‡ niestandardowy typ, ktÃ³ry zachowuje siÄ™ jak <code>Box&lt;T&gt;</code> i zobaczymy, dlaczego operator dereferencji nie dziaÅ‚a jak referencja na naszym nowo zdefiniowanym typie. Zbadamy, jak implementacja cechy <code>Deref</code> umoÅ¼liwia inteligentnym wskaÅºnikom dziaÅ‚anie w sposÃ³b podobny do referencji. NastÄ™pnie przyjrzymy siÄ™ funkcji Rust deref coercion i temu, jak pozwala nam ona pracowaÄ‡ zarÃ³wno z referencjami, jak i inteligentnymi wskaÅºnikami.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="following-the-pointer-to-the-value-with-the-dereference-operator"></a>
<a id="following-the-pointer-to-the-value"></a></p>
<h3 id="podÄ…Å¼anie-za-referencjÄ…-do-wartoÅ›ci-za-pomocÄ…-operatora-dereferencji"><a class="header" href="#podÄ…Å¼anie-za-referencjÄ…-do-wartoÅ›ci-za-pomocÄ…-operatora-dereferencji">PodÄ…Å¼anie za referencjÄ… do wartoÅ›ci za pomocÄ… operatora dereferencji</a></h3>
<p>ZwykÅ‚a referencja jest typem wskaÅºnika, a jeden ze sposobÃ³w myÅ›lenia o wskaÅºniku to strzaÅ‚ka do wartoÅ›ci przechowywanej gdzie indziej. W Listing 15-6 tworzymy referencjÄ™ do wartoÅ›ci <code>i32</code>, a nastÄ™pnie uÅ¼ywamy operatora dereferencji, aby podÄ…Å¼yÄ‡ za referencjÄ… do wartoÅ›ci.</p>
<listing number="15-6" file-name="src/main.rs" caption="UÅ¼ywanie operatora dereferencji do podÄ…Å¼ania za referencjÄ… do wartoÅ›ci `i32`">
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre>
</listing>
<p>Zmienna <code>x</code> przechowuje wartoÅ›Ä‡ <code>i32</code> rÃ³wnÄ… <code>5</code>. Ustawiamy <code>y</code> na referencjÄ™ do <code>x</code>. MoÅ¼emy potwierdziÄ‡, Å¼e <code>x</code> jest rÃ³wne <code>5</code>. Jednak jeÅ›li chcemy sprawdziÄ‡ wartoÅ›Ä‡ w <code>y</code>, musimy uÅ¼yÄ‡ <code>*y</code>, aby podÄ…Å¼yÄ‡ za referencjÄ… do wartoÅ›ci, na ktÃ³rÄ… wskazuje (stÄ…d <em>dereferencja</em>), tak aby kompilator mÃ³gÅ‚ porÃ³wnaÄ‡ rzeczywistÄ… wartoÅ›Ä‡. Po dereferencji <code>y</code> mamy dostÄ™p do wartoÅ›ci caÅ‚kowitej, na ktÃ³rÄ… wskazuje <code>y</code>, ktÃ³rÄ… moÅ¼emy porÃ³wnaÄ‡ z <code>5</code>.</p>
<p>GdybyÅ›my sprÃ³bowali napisaÄ‡ <code>assert_eq!(5, y);</code> zamiast tego, otrzymalibyÅ›my nastÄ™pujÄ…cy bÅ‚Ä…d kompilacji:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: nie moÅ¼na porÃ³wnaÄ‡ `{integer}` z `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ brak implementacji dla `{integer} == &amp;{integer}`
  |
  = help: cecha `PartialEq&lt;&amp;{integer}&gt;` nie jest zaimplementowana dla `{integer}`
  = note: ten bÅ‚Ä…d pochodzi z makra `assert_eq` (w kompilacjach Nightly, uruchom z -Z macro-backtrace, aby uzyskaÄ‡ wiÄ™cej informacji)

For more information about this error, try `rustc --explain E0277`.
error: nie udaÅ‚o siÄ™ skompilowaÄ‡ `deref-example` (bin "deref-example") z powodu 1 poprzedniego bÅ‚Ä™du
</code></pre>
<p>PorÃ³wnywanie liczby i referencji do liczby jest niedozwolone, poniewaÅ¼ sÄ… to rÃ³Å¼ne typy. Musimy uÅ¼yÄ‡ operatora dereferencji, aby podÄ…Å¼yÄ‡ za referencjÄ… do wartoÅ›ci, na ktÃ³rÄ… wskazuje.</p>
<h3 id="uÅ¼ywanie-boxt-jak-referencji"><a class="header" href="#uÅ¼ywanie-boxt-jak-referencji">UÅ¼ywanie <code>Box&lt;T&gt;</code> jak referencji</a></h3>
<p>MoÅ¼emy przepisaÄ‡ kod z Listing 15-6, aby uÅ¼ywaÅ‚ <code>Box&lt;T&gt;</code> zamiast referencji; operator dereferencji uÅ¼yty na <code>Box&lt;T&gt;</code> w Listing 15-7 dziaÅ‚a tak samo, jak operator dereferencji uÅ¼yty na referencji w Listing 15-6.</p>
<listing number="15-7" file-name="src/main.rs" caption="UÅ¼ywanie operatora dereferencji na `Box&lt;i32&gt;`">
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre>
</listing>
<p>GÅ‚Ã³wna rÃ³Å¼nica miÄ™dzy Listing 15-7 a Listing 15-6 polega na tym, Å¼e tutaj ustawiamy <code>y</code> jako instancjÄ™ pudeÅ‚ka wskazujÄ…cego na skopiowanÄ… wartoÅ›Ä‡ <code>x</code>, a nie referencjÄ™ wskazujÄ…cÄ… na wartoÅ›Ä‡ <code>x</code>. W ostatniej asercji moÅ¼emy uÅ¼yÄ‡ operatora dereferencji, aby podÄ…Å¼yÄ‡ za wskaÅºnikiem pudeÅ‚ka w ten sam sposÃ³b, w jaki robiliÅ›my to, gdy <code>y</code> byÅ‚a referencjÄ…. NastÄ™pnie zbadamy, co jest specjalnego w <code>Box&lt;T&gt;</code>, co pozwala nam uÅ¼ywaÄ‡ operatora dereferencji, definiujÄ…c nasz wÅ‚asny typ pudeÅ‚ka.</p>
<h3 id="definiowanie-naszego-wÅ‚asnego-inteligentnego-wskaÅºnika"><a class="header" href="#definiowanie-naszego-wÅ‚asnego-inteligentnego-wskaÅºnika">Definiowanie naszego wÅ‚asnego inteligentnego wskaÅºnika</a></h3>
<p>Zbudujmy typ opakowujÄ…cy podobny do typu <code>Box&lt;T&gt;</code> dostarczanego przez standardowÄ… bibliotekÄ™, aby doÅ›wiadczyÄ‡, jak typy inteligentnych wskaÅºnikÃ³w domyÅ›lnie zachowujÄ… siÄ™ inaczej niÅ¼ referencje. NastÄ™pnie przyjrzymy siÄ™, jak dodaÄ‡ moÅ¼liwoÅ›Ä‡ uÅ¼ycia operatora dereferencji.</p>
<blockquote>
<p>Uwaga: Istnieje jedna duÅ¼a rÃ³Å¼nica miÄ™dzy typem <code>MyBox&lt;T&gt;</code>, ktÃ³ry zaraz zbudujemy, a prawdziwym <code>Box&lt;T&gt;</code>: nasza wersja nie bÄ™dzie przechowywaÄ‡ swoich danych na stercie. W tym przykÅ‚adzie skupiamy siÄ™ na <code>Deref</code>, wiÄ™c to, gdzie dane sÄ… faktycznie przechowywane, jest mniej waÅ¼ne niÅ¼ zachowanie podobne do wskaÅºnika.</p>
</blockquote>
<p>Typ <code>Box&lt;T&gt;</code> jest ostatecznie zdefiniowany jako struktura tuplowa z jednym elementem, wiÄ™c Listing 15-8 definiuje typ <code>MyBox&lt;T&gt;</code> w ten sam sposÃ³b. Zdefiniujemy rÃ³wnieÅ¼ funkcjÄ™ <code>new</code> pasujÄ…cÄ… do funkcji <code>new</code> zdefiniowanej w <code>Box&lt;T&gt;</code>.</p>
<listing number="15-8" file-name="src/main.rs" caption="Definiowanie typu `MyBox&lt;T&gt;`">
<pre class="playground"><code class="language-rust edition2024">struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
</listing>
<p>Definiujemy strukturÄ™ o nazwie <code>MyBox</code> i deklarujemy parametr generyczny <code>T</code>, poniewaÅ¼ chcemy, aby nasz typ przechowywaÅ‚ wartoÅ›ci dowolnego typu. Typ <code>MyBox</code> jest strukturÄ… tuplowÄ… z jednym elementem typu <code>T</code>. Funkcja <code>MyBox::new</code> przyjmuje jeden parametr typu <code>T</code> i zwraca instancjÄ™ <code>MyBox</code>, ktÃ³ra przechowuje przekazanÄ… wartoÅ›Ä‡.</p>
<p>SprÃ³bujmy dodaÄ‡ funkcjÄ™ <code>main</code> z Listing 15-7 do Listing 15-8 i zmieniÄ‡ jÄ… tak, aby uÅ¼ywaÅ‚a zdefiniowanego przez nas typu <code>MyBox&lt;T&gt;</code> zamiast <code>Box&lt;T&gt;</code>. Kod w Listing 15-9 nie skompiluje siÄ™, poniewaÅ¼ Rust nie wie, jak dereferencyjnie traktowaÄ‡ <code>MyBox</code>.</p>
<listing number="15-9" file-name="src/main.rs" caption="PrÃ³ba uÅ¼ycia `MyBox&lt;T&gt;` w ten sam sposÃ³b, w jaki uÅ¼yliÅ›my referencji i `Box&lt;T&gt;`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre>
</listing>
<p>Oto wynikowy bÅ‚Ä…d kompilacji:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^ nie moÅ¼na dereferencyjnie traktowaÄ‡

For more information about this error, try `rustc --explain E0614`.
error: nie udaÅ‚o siÄ™ skompilowaÄ‡ `deref-example` (bin "deref-example") z powodu 1 poprzedniego bÅ‚Ä™du
</code></pre>
<p>Nasz typ <code>MyBox&lt;T&gt;</code> nie moÅ¼e zostaÄ‡ dereferencjonowany, poniewaÅ¼ nie zaimplementowaliÅ›my tej moÅ¼liwoÅ›ci dla naszego typu. Aby umoÅ¼liwiÄ‡ dereferencjonowanie za pomocÄ… operatora <code>*</code>, implementujemy cechÄ™ <code>Deref</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="treating-a-type-like-a-reference-by-implementing-the-deref-trait"></a></p>
<h3 id="implementacja-cechy-deref"><a class="header" href="#implementacja-cechy-deref">Implementacja cechy <code>Deref</code></a></h3>
<p>Jak omÃ³wiono w sekcji <a href="#implementing-a-trait-on-a-type">â€Implementacja cechy dla typuâ€</a><!-- ignore --> w Rozdziale 10, aby zaimplementowaÄ‡ cechÄ™, musimy dostarczyÄ‡ implementacje dla wymaganych metod cechy. Cecha <code>Deref</code>, dostarczana przez standardowÄ… bibliotekÄ™, wymaga od nas zaimplementowania jednej metody o nazwie <code>deref</code>, ktÃ³ra poÅ¼ycza <code>self</code> i zwraca referencjÄ™ do wewnÄ™trznych danych. Listing 15-10 zawiera implementacjÄ™ <code>Deref</code> do dodania do definicji <code>MyBox&lt;T&gt;</code>.</p>
<listing number="15-10" file-name="src/main.rs" caption="Implementacja `Deref` dla `MyBox&lt;T&gt;`">
<pre class="playground"><code class="language-rust edition2024">use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MyBox::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}</span></code></pre>
</listing>
<p>SkÅ‚adnia <code>type Target = T;</code> definiuje typ skojarzony dla cechy <code>Deref</code>. Typy skojarzone to nieco inny sposÃ³b deklarowania parametru generycznego, ale na razie nie musisz siÄ™ nimi martwiÄ‡; omÃ³wimy je bardziej szczegÃ³Å‚owo w Rozdziale 20.</p>
<p>WypeÅ‚niamy ciaÅ‚o metody <code>deref</code> za pomocÄ… <code>&amp;self.0</code>, tak aby <code>deref</code> zwracaÅ‚o referencjÄ™ do wartoÅ›ci, do ktÃ³rej chcemy uzyskaÄ‡ dostÄ™p za pomocÄ… operatora <code>*</code>; przypomnij sobie z sekcji <a href="#creating-different-types-with-tuple-structs">â€Tworzenie rÃ³Å¼nych typÃ³w za pomocÄ… struktur tuplowychâ€</a><!-- ignore --> w Rozdziale 5, Å¼e <code>.0</code> uzyskuje dostÄ™p do pierwszej wartoÅ›ci w strukturze tuplowej. Funkcja <code>main</code> w Listing 15-9, ktÃ³ra wywoÅ‚uje <code>*</code> na wartoÅ›ci <code>MyBox&lt;T&gt;</code>, teraz siÄ™ kompiluje, a asercje przechodzÄ…!</p>
<p>Bez cechy <code>Deref</code> kompilator moÅ¼e dereferencyjnie traktowaÄ‡ tylko referencje <code>&amp;</code>. Metoda <code>deref</code> daje kompilatorowi moÅ¼liwoÅ›Ä‡ wziÄ™cia wartoÅ›ci dowolnego typu, ktÃ³ry implementuje <code>Deref</code>, i wywoÅ‚ania metody <code>deref</code>, aby uzyskaÄ‡ referencjÄ™, ktÃ³rÄ… wie, jak dereferencyjnie traktowaÄ‡.</p>
<p>Kiedy wpisaliÅ›my <code>*y</code> w Listing 15-9, za kulisami Rust faktycznie uruchomiÅ‚ ten kod:</p>
<pre><code class="language-rust ignore">*(y.deref())</code></pre>
<p>Rust zastÄ™puje operator <code>*</code> wywoÅ‚aniem metody <code>deref</code>, a nastÄ™pnie prostym dereferencjonowaniem, tak abyÅ›my nie musieli zastanawiaÄ‡ siÄ™, czy potrzebujemy wywoÅ‚ywaÄ‡ metodÄ™ <code>deref</code>, czy nie. Ta funkcja Rusta pozwala nam pisaÄ‡ kod, ktÃ³ry dziaÅ‚a identycznie, niezaleÅ¼nie od tego, czy mamy zwykÅ‚Ä… referencjÄ™, czy typ implementujÄ…cy <code>Deref</code>.</p>
<p>PowÃ³d, dla ktÃ³rego metoda <code>deref</code> zwraca referencjÄ™ do wartoÅ›ci, a zwykÅ‚a dereferencja poza nawiasami w <code>*(y.deref())</code> jest nadal konieczna, ma zwiÄ…zek z systemem wÅ‚asnoÅ›ci. Gdyby metoda <code>deref</code> zwracaÅ‚a wartoÅ›Ä‡ bezpoÅ›rednio zamiast referencji do wartoÅ›ci, wartoÅ›Ä‡ zostaÅ‚aby przeniesiona z <code>self</code>. Nie chcemy przejmowaÄ‡ wÅ‚asnoÅ›ci wewnÄ™trznej wartoÅ›ci w <code>MyBox&lt;T&gt;</code> w tym przypadku ani w wiÄ™kszoÅ›ci przypadkÃ³w, gdy uÅ¼ywamy operatora dereferencji.</p>
<p>ZauwaÅ¼, Å¼e operator <code>*</code> jest zastÄ™powany wywoÅ‚aniem metody <code>deref</code>, a nastÄ™pnie wywoÅ‚aniem operatora <code>*</code> tylko raz, za kaÅ¼dym razem, gdy uÅ¼ywamy <code>*</code> w naszym kodzie. PoniewaÅ¼ podstawianie operatora <code>*</code> nie rekursuje w nieskoÅ„czonoÅ›Ä‡, otrzymujemy dane typu <code>i32</code>, co pasuje do <code>5</code> w <code>assert_eq!</code> w Listing 15-9.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="implicit-deref-coercions-with-functions-and-methods"></a>
<a id="using-deref-coercions-in-functions-and-methods"></a></p>
<h3 id="uÅ¼ywanie-koercji-deref-w-funkcjach-i-metodach"><a class="header" href="#uÅ¼ywanie-koercji-deref-w-funkcjach-i-metodach">UÅ¼ywanie koercji Deref w funkcjach i metodach</a></h3>
<p><em>Koercja Deref</em> konwertuje referencjÄ™ do typu, ktÃ³ry implementuje cechÄ™ <code>Deref</code>, na referencjÄ™ do innego typu. Na przykÅ‚ad, koercja Deref moÅ¼e przekonwertowaÄ‡ <code>&amp;String</code> na <code>&amp;str</code>, poniewaÅ¼ <code>String</code> implementuje cechÄ™ <code>Deref</code> w taki sposÃ³b, Å¼e zwraca <code>&amp;str</code>. Koercja Deref jest udogodnieniem, ktÃ³re Rust wykonuje na argumentach funkcji i metod, i dziaÅ‚a tylko na typach, ktÃ³re implementujÄ… cechÄ™ <code>Deref</code>. Dzieje siÄ™ to automatycznie, gdy przekazujemy referencjÄ™ do wartoÅ›ci konkretnego typu jako argument do funkcji lub metody, ktÃ³ra nie pasuje do typu parametru w definicji funkcji lub metody. Sekwencja wywoÅ‚aÅ„ metody <code>deref</code> konwertuje dostarczony przez nas typ na typ, ktÃ³rego potrzebuje parametr.</p>
<p>Koercja Deref zostaÅ‚a dodana do Rusta, aby programiÅ›ci piszÄ…cy wywoÅ‚ania funkcji i metod nie musieli dodawaÄ‡ tak wielu jawnych referencji i dereferencji za pomocÄ… <code>&amp;</code> i <code>*</code>. Funkcja koercji Deref pozwala nam rÃ³wnieÅ¼ pisaÄ‡ wiÄ™cej kodu, ktÃ³ry moÅ¼e dziaÅ‚aÄ‡ zarÃ³wno z referencjami, jak i inteligentnymi wskaÅºnikami.</p>
<p>Aby zobaczyÄ‡ koercjÄ™ Deref w dziaÅ‚aniu, uÅ¼yjmy typu <code>MyBox&lt;T&gt;</code>, ktÃ³ry zdefiniowaliÅ›my w Listing 15-8, a takÅ¼e implementacji <code>Deref</code>, ktÃ³rÄ… dodaliÅ›my w Listing 15-10. Listing 15-11 pokazuje definicjÄ™ funkcji, ktÃ³ra ma parametr wycinka ciÄ…gu znakÃ³w.</p>
<listing number="15-11" file-name="src/main.rs" caption="Funkcja `hello`, ktÃ³ra ma parametr `name` typu `&amp;str`">
<pre class="playground"><code class="language-rust edition2024">fn hello(name: &amp;str) {
    println!("Witaj, {name}!");
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
</listing>
<p>MoÅ¼emy wywoÅ‚aÄ‡ funkcjÄ™ <code>hello</code> z wycinkiem ciÄ…gu znakÃ³w jako argumentem, na przykÅ‚ad <code>hello("Rust");</code>. Koercja Deref umoÅ¼liwia wywoÅ‚anie <code>hello</code> z referencjÄ… do wartoÅ›ci typu <code>MyBox&lt;String&gt;</code>, jak pokazano w Listing 15-12.</p>
<listing number="15-12" file-name="src/main.rs" caption="WywoÅ‚anie `hello` z referencjÄ… do wartoÅ›ci `MyBox&lt;String&gt;`, co dziaÅ‚a dziÄ™ki koercji dereferencyjnej">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!("Witaj, {name}!");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&amp;m);
}</code></pre>
</listing>
<p>Tutaj wywoÅ‚ujemy funkcjÄ™ <code>hello</code> z argumentem <code>&amp;m</code>, ktÃ³ry jest referencjÄ… do wartoÅ›ci <code>MyBox&lt;String&gt;</code>. PoniewaÅ¼ zaimplementowaliÅ›my cechÄ™ <code>Deref</code> dla <code>MyBox&lt;T&gt;</code> w Listing 15-10, Rust moÅ¼e przeksztaÅ‚ciÄ‡ <code>&amp;MyBox&lt;String&gt;</code> w <code>&amp;String</code> poprzez wywoÅ‚anie <code>deref</code>. Standardowa biblioteka dostarcza implementacjÄ™ <code>Deref</code> dla <code>String</code>, ktÃ³ra zwraca wycinek ciÄ…gu znakÃ³w, i jest to w dokumentacji API dla <code>Deref</code>. Rust ponownie wywoÅ‚uje <code>deref</code>, aby przeksztaÅ‚ciÄ‡ <code>&amp;String</code> w <code>&amp;str</code>, co pasuje do definicji funkcji <code>hello</code>.</p>
<p>Gdyby Rust nie implementowaÅ‚ koercji dereferencyjnej, musielibyÅ›my napisaÄ‡ kod z Listing 15-13 zamiast kodu z Listing 15-12, aby wywoÅ‚aÄ‡ <code>hello</code> z wartoÅ›ciÄ… typu <code>&amp;MyBox&lt;String&gt;</code>.</p>
<listing number="15-13" file-name="src/main.rs" caption="Kod, ktÃ³ry musielibyÅ›my napisaÄ‡, gdyby Rust nie miaÅ‚ koercji dereferencyjnej">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!("Witaj, {name}!");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&amp;(*m)[..]);
}</code></pre>
</listing>
<p><code>(*m)</code> dereferencuje <code>MyBox&lt;String&gt;</code> do <code>String</code>. NastÄ™pnie <code>&amp;</code> i <code>[..]</code> pobierajÄ… wycinek ciÄ…gu znakÃ³w z <code>String</code>, ktÃ³ry jest rÃ³wny caÅ‚emu ciÄ…gowi, aby pasowaÅ‚ do sygnatury <code>hello</code>. Ten kod bez koercji dereferencyjnych jest trudniejszy do odczytania, napisania i zrozumienia ze wszystkimi zaangaÅ¼owanymi symbolami. Koercja Deref pozwala Rustowi automatycznie obsÅ‚ugiwaÄ‡ te konwersje.</p>
<p>Kiedy cecha <code>Deref</code> jest zdefiniowana dla zaangaÅ¼owanych typÃ³w, Rust przeanalizuje typy i uÅ¼yje <code>Deref::deref</code> tyle razy, ile to konieczne, aby uzyskaÄ‡ referencjÄ™ pasujÄ…cÄ… do typu parametru. Liczba razy, jakÄ… naleÅ¼y wstawiÄ‡ <code>Deref::deref</code>, jest rozwiÄ…zywana w czasie kompilacji, wiÄ™c nie ma kary za wydajnoÅ›Ä‡ w czasie dziaÅ‚ania za korzystanie z koercji Deref!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="how-deref-coercion-interacts-with-mutability"></a></p>
<h3 id="obsÅ‚uga-koercji-deref-ze-zmiennymi-referencjami"><a class="header" href="#obsÅ‚uga-koercji-deref-ze-zmiennymi-referencjami">ObsÅ‚uga koercji Deref ze zmiennymi referencjami</a></h3>
<p>Podobnie jak uÅ¼ywasz cechy <code>Deref</code> do nadpisywania operatora <code>*</code> na niezmiennych referencjach, moÅ¼esz uÅ¼yÄ‡ cechy <code>DerefMut</code> do nadpisywania operatora <code>*</code> na zmiennych referencjach.</p>
<p>Rust wykonuje koercjÄ™ dereferencyjnÄ…, gdy znajdzie typy i implementacje cech w trzech przypadkach:</p>
<ol>
<li>Z <code>&amp;T</code> do <code>&amp;U</code>, gdy <code>T: Deref&lt;Target=U&gt;</code></li>
<li>Z <code>&amp;mut T</code> do <code>&amp;mut U</code>, gdy <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>Z <code>&amp;mut T</code> do <code>&amp;U</code>, gdy <code>T: Deref&lt;Target=U&gt;</code></li>
</ol>
<p>Pierwsze dwa przypadki sÄ… takie same, z wyjÄ…tkiem tego, Å¼e drugi implementuje zmiennoÅ›Ä‡. Pierwszy przypadek mÃ³wi, Å¼e jeÅ›li masz <code>&amp;T</code> i <code>T</code> implementuje <code>Deref</code> do pewnego typu <code>U</code>, moÅ¼esz w sposÃ³b przezroczysty uzyskaÄ‡ <code>&amp;U</code>. Drugi przypadek mÃ³wi, Å¼e ta sama koercja dereferencyjna ma miejsce dla zmiennych referencji.</p>
<p>Trzeci przypadek jest bardziej podstÄ™pny: Rust rÃ³wnieÅ¼ przeksztaÅ‚ci zmiennÄ… referencjÄ™ w niezmiennÄ…. Ale odwrotna operacja <em>nie</em> jest moÅ¼liwa: niezmienne referencje nigdy nie zostanÄ… przeksztaÅ‚cone w zmienne referencje. Ze wzglÄ™du na zasady poÅ¼yczania, jeÅ›li masz zmiennÄ… referencjÄ™, ta zmienna referencja musi byÄ‡ jedynÄ… referencjÄ… do tych danych (w przeciwnym razie program nie skompilowaÅ‚by siÄ™). Konwersja jednej zmiennej referencji na jednÄ… niezmiennÄ… referencjÄ™ nigdy nie naruszy zasad poÅ¼yczania. Konwersja niezmiennej referencji na zmiennÄ… referencjÄ™ wymagaÅ‚aby, aby poczÄ…tkowa niezmienna referencja byÅ‚a jedynÄ… niezmiennÄ… referencjÄ… do tych danych, ale zasady poÅ¼yczania tego nie gwarantujÄ…. Dlatego Rust nie moÅ¼e przyjÄ…Ä‡ zaÅ‚oÅ¼enia, Å¼e konwersja niezmiennej referencji na zmiennÄ… referencjÄ™ jest moÅ¼liwa.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="uruchamianie-kodu-podczas-czyszczenia-za-pomocÄ…-cechy-drop-1"><a href="#uruchamianie-kodu-podczas-czyszczenia-za-pomocÄ…-cechy-drop-1" class="header">Uruchamianie kodu podczas czyszczenia za pomocÄ… cechy `Drop`</a></h1>
<h2 id="uruchamianie-kodu-podczas-czyszczenia-za-pomocÄ…-cechy-drop"><a class="header" href="#uruchamianie-kodu-podczas-czyszczenia-za-pomocÄ…-cechy-drop">Uruchamianie kodu podczas czyszczenia za pomocÄ… cechy <code>Drop</code></a></h2>
<p>Druga cecha waÅ¼na dla wzorca wskaÅºnika sprytnego to <code>Drop</code>, ktÃ³ra pozwala na
dostosowanie tego, co dzieje siÄ™, gdy wartoÅ›Ä‡ ma wyjÅ›Ä‡ poza zakres. MoÅ¼esz
dostarczyÄ‡ implementacjÄ™ cechy <code>Drop</code> dla dowolnego typu, a ten kod moÅ¼e
zostaÄ‡ uÅ¼yty do zwolnienia zasobÃ³w, takich jak pliki lub poÅ‚Ä…czenia sieciowe.</p>
<p>Wprowadzamy <code>Drop</code> w kontekÅ›cie wskaÅºnikÃ³w sprytnych, poniewaÅ¼ funkcjonalnoÅ›Ä‡
cechy <code>Drop</code> jest prawie zawsze uÅ¼ywana podczas implementacji wskaÅºnika
sprytnego. Na przykÅ‚ad, gdy <code>Box&lt;T&gt;</code> zostanie usuniÄ™ty (<code>dropped</code>), zwolni
przestrzeÅ„ na stercie, na ktÃ³rÄ… wskazuje <code>Box</code>.</p>
<p>W niektÃ³rych jÄ™zykach, dla niektÃ³rych typÃ³w, programista musi wywoÅ‚aÄ‡ kod,
aby zwolniÄ‡ pamiÄ™Ä‡ lub zasoby za kaÅ¼dym razem, gdy skoÅ„czy uÅ¼ywaÄ‡ instancji
tych typÃ³w. PrzykÅ‚adami sÄ… uchwyty plikÃ³w, gniazda sieciowe i blokady. JeÅ›li
programista zapomni, system moÅ¼e zostaÄ‡ przeciÄ…Å¼ony i ulec awarii. W Rust
moÅ¼na okreÅ›liÄ‡, Å¼e dany fragment kodu ma byÄ‡ uruchamiany za kaÅ¼dym razem, gdy
wartoÅ›Ä‡ wyjdzie poza zakres, a kompilator wstawi ten kod automatycznie. W
rezultacie nie musisz martwiÄ‡ siÄ™ o umieszczanie kodu czyszczÄ…cego wszÄ™dzie w
programie, gdzie instancja okreÅ›lonego typu zostaje zakoÅ„czona â€“ nadal nie
bÄ™dziesz miaÅ‚ wyciekÃ³w zasobÃ³w!</p>
<p>Kod do uruchomienia, gdy wartoÅ›Ä‡ wyjdzie poza zakres, okreÅ›lasz, implementujÄ…c
cechÄ™ <code>Drop</code>. Cecha <code>Drop</code> wymaga zaimplementowania jednej metody o nazwie
<code>drop</code>, ktÃ³ra przyjmuje mutowalnÄ… referencjÄ™ do <code>self</code>. Aby zobaczyÄ‡, kiedy Rust
wywoÅ‚uje <code>drop</code>, zaimplementujmy na razie <code>drop</code> z instrukcjami <code>println!</code>.</p>
<p>Listing 15-14 przedstawia strukturÄ™ <code>CustomSmartPointer</code>, ktÃ³rej jedynÄ…
dostosowanÄ… funkcjonalnoÅ›ciÄ… jest to, Å¼e wypisze <code>Dropping CustomSmartPointer!</code>,
gdy instancja wyjdzie poza zakres, aby pokazaÄ‡, kiedy Rust uruchamia metodÄ™
<code>drop</code>.</p>
<listing number="15-14" file-name="src/main.rs" caption="Struktura `CustomSmartPointer` implementujÄ…ca cechÄ™ `Drop`, w ktÃ³rej umieÅ›cilibyÅ›my nasz kod czyszczÄ…cy">
<pre class="playground"><code class="language-rust edition2024">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("CustomSmartPointers created");
}</code></pre>
</listing>
<p>Cecha <code>Drop</code> jest uwzglÄ™dniona w preambule, wiÄ™c nie musimy jej importowaÄ‡.
Implementujemy cechÄ™ <code>Drop</code> dla <code>CustomSmartPointer</code> i dostarczamy implementacjÄ™
metody <code>drop</code>, ktÃ³ra wywoÅ‚uje <code>println!</code>. TreÅ›Ä‡ metody <code>drop</code> to miejsce, w
ktÃ³rym umieÅ›ciÅ‚byÅ› dowolnÄ… logikÄ™, ktÃ³rÄ… chciaÅ‚byÅ› uruchomiÄ‡, gdy instancja
twojego typu wyjdzie poza zakres. Wypisujemy tutaj tekst, aby wizualnie
zademonstrowaÄ‡, kiedy Rust wywoÅ‚a <code>drop</code>.</p>
<p>W <code>main</code> tworzymy dwie instancje <code>CustomSmartPointer</code>, a nastÄ™pnie wypisujemy
<code>CustomSmartPointers created</code>. Pod koniec <code>main</code>, nasze instancje
<code>CustomSmartPointer</code> wyjdÄ… poza zakres, a Rust wywoÅ‚a kod, ktÃ³ry umieÅ›ciliÅ›my
w metodzie <code>drop</code>, wypisujÄ…c naszÄ… koÅ„cowÄ… wiadomoÅ›Ä‡. ZauwaÅ¼, Å¼e nie musieliÅ›my
jawnie wywoÅ‚ywaÄ‡ metody <code>drop</code>.</p>
<p>Po uruchomieniu tego programu zobaczymy nastÄ™pujÄ…cy wynik:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
CustomSmartPointers created
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
</code></pre>
<p>Rust automatycznie wywoÅ‚aÅ‚ <code>drop</code> dla nas, gdy nasze instancje wyszÅ‚y poza
zakres, uruchamiajÄ…c okreÅ›lony przez nas kod. Zmienne sÄ… usuwane w odwrotnej
kolejnoÅ›ci ich tworzenia, wiÄ™c <code>d</code> zostaÅ‚o usuniÄ™te przed <code>c</code>. Celem tego
przykÅ‚adu jest zapewnienie wizualnego przewodnika po dziaÅ‚aniu metody <code>drop</code>;
zazwyczaj okreÅ›liÅ‚byÅ› kod czyszczÄ…cy, ktÃ³ry twÃ³j typ musi uruchomiÄ‡, a nie
komunikat do wypisania.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="dropping-a-value-early-with-std-mem-drop"></a></p>
<p>Niestety, wyÅ‚Ä…czenie automatycznej funkcjonalnoÅ›ci <code>drop</code> nie jest proste.
WyÅ‚Ä…czanie <code>drop</code> zazwyczaj nie jest konieczne; caÅ‚y sens cechy <code>Drop</code> polega
na tym, Å¼e jest obsÅ‚ugiwana automatycznie. Czasami jednak moÅ¼esz chcieÄ‡
posprzÄ…taÄ‡ wartoÅ›Ä‡ wczeÅ›niej. Jednym z przykÅ‚adÃ³w jest uÅ¼ycie wskaÅºnikÃ³w
sprytnych zarzÄ…dzajÄ…cych blokadami: MoÅ¼esz chcieÄ‡ wymusiÄ‡ wywoÅ‚anie metody
<code>drop</code>, ktÃ³ra zwalnia blokadÄ™, tak aby inny kod w tym samym zakresie mÃ³gÅ‚
nabyÄ‡ blokadÄ™. Rust nie pozwala na rÄ™czne wywoÅ‚anie metody <code>drop</code> cechy <code>Drop</code>;
zamiast tego musisz wywoÅ‚aÄ‡ funkcjÄ™ <code>std::mem::drop</code> dostarczonÄ… przez
bibliotekÄ™ standardowÄ…, jeÅ›li chcesz wymusiÄ‡ usuniÄ™cie wartoÅ›ci przed koÅ„cem
jej zakresu.</p>
<p>PrÃ³ba rÄ™cznego wywoÅ‚ania metody <code>drop</code> cechy <code>Drop</code> poprzez modyfikacjÄ™ funkcji
<code>main</code> z Listingu 15-14 nie zadziaÅ‚a, jak pokazano w Listingu 15-15.</p>
<listing number="15-15" file-name="src/main.rs" caption="PrÃ³ba rÄ™cznego wywoÅ‚ania metody `drop` z cechy `Drop` w celu wczesnego posprzÄ…tania">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created");
    c.drop();
    println!("CustomSmartPointer dropped before the end of main");
}</code></pre>
</listing>
<p>Kiedy sprÃ³bujemy skompilowaÄ‡ ten kod, otrzymamy taki bÅ‚Ä…d:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:16:7
   |
16 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed
   |
help: consider using `drop` function
   |
16 -     c.drop();
16 +     drop(c);
   |

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example` (bin "drop-example") due to 1 previous error
</code></pre>
<p>Ten komunikat o bÅ‚Ä™dzie informuje, Å¼e nie wolno nam jawnie wywoÅ‚ywaÄ‡ <code>drop</code>.
Komunikat o bÅ‚Ä™dzie uÅ¼ywa terminu <em>destruktor</em>, ktÃ³ry jest ogÃ³lnym terminem
programistycznym dla funkcji, ktÃ³ra oczyszcza instancjÄ™. <em>Destruktor</em> jest
analogiczny do <em>konstruktora</em>, ktÃ³ry tworzy instancjÄ™. Funkcja <code>drop</code> w Rust
jest jednym szczegÃ³lnym destruktorem.</p>
<p>Rust nie pozwala nam jawnie wywoÅ‚ywaÄ‡ <code>drop</code>, poniewaÅ¼ Rust nadal
automatycznie wywoÅ‚ywaÅ‚by <code>drop</code> na wartoÅ›ci na koÅ„cu <code>main</code>. SpowodowaÅ‚oby to
bÅ‚Ä…d podwÃ³jnego zwolnienia pamiÄ™ci, poniewaÅ¼ Rust prÃ³bowaÅ‚by dwukrotnie
posprzÄ…taÄ‡ tÄ™ samÄ… wartoÅ›Ä‡.</p>
<p>Nie moÅ¼emy wyÅ‚Ä…czyÄ‡ automatycznego wstawiania <code>drop</code>, gdy wartoÅ›Ä‡ wyjdzie poza
zakres, i nie moÅ¼emy jawnie wywoÅ‚aÄ‡ metody <code>drop</code>. WiÄ™c, jeÅ›li potrzebujemy
wymusiÄ‡ wczesne posprzÄ…tanie wartoÅ›ci, uÅ¼ywamy funkcji <code>std::mem::drop</code>.</p>
<p>Funkcja <code>std::mem::drop</code> rÃ³Å¼ni siÄ™ od metody <code>drop</code> w cechy <code>Drop</code>. WywoÅ‚ujemy
jÄ…, przekazujÄ…c jako argument wartoÅ›Ä‡, ktÃ³rÄ… chcemy wymusiÄ‡ usuniÄ™cie.
Funkcja znajduje siÄ™ w preambule, wiÄ™c moÅ¼emy zmodyfikowaÄ‡ <code>main</code> w Listingu
15-15, aby wywoÅ‚aÄ‡ funkcjÄ™ <code>drop</code>, jak pokazano w Listingu 15-16.</p>
<listing number="15-16" file-name="src/main.rs" caption="WywoÅ‚ywanie `std::mem::drop` w celu jawnego usuniÄ™cia wartoÅ›ci, zanim wyjdzie ona poza zakres">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created");
    drop(c);
    println!("CustomSmartPointer dropped before the end of main");
}</code></pre>
</listing>
<p>Uruchomienie tego kodu wypisze nastÄ™pujÄ…ce:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
CustomSmartPointer created
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main
</code></pre>
<p>Tekst <code>Dropping CustomSmartPointer with data `some data`!</code> jest wypisany
pomiÄ™dzy tekstami <code>CustomSmartPointer created</code> i <code>CustomSmartPointer dropped before the end of main</code>, pokazujÄ…c, Å¼e kod metody <code>drop</code> jest wywoÅ‚ywany w celu
usuniÄ™cia <code>c</code> w tym punkcie.</p>
<p>Kod okreÅ›lony w implementacji cechy <code>Drop</code> moÅ¼na wykorzystaÄ‡ na wiele sposobÃ³w,
aby czyszczenie byÅ‚o wygodne i bezpieczne: na przykÅ‚ad moÅ¼na go uÅ¼yÄ‡ do
stworzenia wÅ‚asnego alokatora pamiÄ™ci! DziÄ™ki cechy <code>Drop</code> i systemowi wÅ‚asnoÅ›ci
Rust nie musisz pamiÄ™taÄ‡ o czyszczeniu, poniewaÅ¼ Rust robi to automatycznie.</p>
<p>Nie musisz teÅ¼ martwiÄ‡ siÄ™ problemami wynikajÄ…cymi z przypadkowego czyszczenia
wartoÅ›ci nadal uÅ¼ywanych: System wÅ‚asnoÅ›ci, ktÃ³ry zapewnia, Å¼e referencje sÄ…
zawsze prawidÅ‚owe, gwarantuje rÃ³wnieÅ¼, Å¼e <code>drop</code> zostanie wywoÅ‚any tylko raz,
gdy wartoÅ›Ä‡ nie jest juÅ¼ uÅ¼ywana.</p>
<p>Teraz, gdy przeanalizowaliÅ›my <code>Box&lt;T&gt;</code> i niektÃ³re cechy wskaÅºnikÃ³w sprytnych,
przyjrzyjmy siÄ™ kilku innym wskaÅºnikom sprytnym zdefiniowanym w bibliotece
standardowej.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rct-wskaÅºnik-sprytny-zliczajÄ…cy-referencje-1"><a href="#rct-wskaÅºnik-sprytny-zliczajÄ…cy-referencje-1" class="header">`Rc&lt;T&gt;`, wskaÅºnik sprytny zliczajÄ…cy referencje</a></h1>
<h2 id="rct-wskaÅºnik-sprytny-zliczajÄ…cy-referencje"><a class="header" href="#rct-wskaÅºnik-sprytny-zliczajÄ…cy-referencje"><code>Rc&lt;T&gt;</code>, wskaÅºnik sprytny zliczajÄ…cy referencje</a></h2>
<p>W wiÄ™kszoÅ›ci przypadkÃ³w wÅ‚asnoÅ›Ä‡ jest jasna: dokÅ‚adnie wiesz, ktÃ³ra zmienna
posiada danÄ… wartoÅ›Ä‡. IstniejÄ… jednak sytuacje, gdy pojedyncza wartoÅ›Ä‡ moÅ¼e
mieÄ‡ wielu wÅ‚aÅ›cicieli. Na przykÅ‚ad, w strukturach danych grafowych, wiele
krawÄ™dzi moÅ¼e wskazywaÄ‡ na ten sam wÄ™zeÅ‚, a ten wÄ™zeÅ‚ jest koncepcyjnie
wÅ‚asnoÅ›ciÄ… wszystkich krawÄ™dzi, ktÃ³re na niego wskazujÄ…. WÄ™zeÅ‚ nie powinien
byÄ‡ usuwany, chyba Å¼e nie ma Å¼adnych krawÄ™dzi wskazujÄ…cych na niego, a zatem
nie ma wÅ‚aÅ›cicieli.</p>
<p>Musisz jawnie wÅ‚Ä…czyÄ‡ wielokrotnÄ… wÅ‚asnoÅ›Ä‡, uÅ¼ywajÄ…c typu Rust <code>Rc&lt;T&gt;</code>, co
jest skrÃ³tem od <em>reference counting</em> (zliczanie referencji). Typ <code>Rc&lt;T&gt;</code>
Å›ledzi liczbÄ™ referencji do wartoÅ›ci, aby okreÅ›liÄ‡, czy wartoÅ›Ä‡ jest nadal
uÅ¼ywana. JeÅ›li do wartoÅ›ci istnieje zero referencji, wartoÅ›Ä‡ moÅ¼e zostaÄ‡
usuniÄ™ta bez uniewaÅ¼niania Å¼adnych referencji.</p>
<p>WyobraÅº sobie <code>Rc&lt;T&gt;</code> jako telewizor w pokoju rodzinnym. Kiedy jedna osoba
wchodzi, Å¼eby oglÄ…daÄ‡ telewizor, wÅ‚Ä…cza go. Inni mogÄ… wejÅ›Ä‡ do pokoju i oglÄ…daÄ‡
telewizor. Kiedy ostatnia osoba opuszcza pokÃ³j, wyÅ‚Ä…cza telewizor, poniewaÅ¼
nie jest juÅ¼ uÅ¼ywany. Gdyby ktoÅ› wyÅ‚Ä…czyÅ‚ telewizor, podczas gdy inni nadal
go oglÄ…dajÄ…, pozostali widzowie wywoÅ‚aliby zamieszanie!</p>
<p>Typu <code>Rc&lt;T&gt;</code> uÅ¼ywamy, gdy chcemy alokowaÄ‡ dane na stercie, aby wiele czÄ™Å›ci
naszego programu mogÅ‚o je odczytywaÄ‡, a nie moÅ¼emy w czasie kompilacji
okreÅ›liÄ‡, ktÃ³ra czÄ™Å›Ä‡ zakoÅ„czy uÅ¼ywanie danych jako ostatnia. GdybyÅ›my
wiedzieli, ktÃ³ra czÄ™Å›Ä‡ zakoÅ„czy uÅ¼ywanie jako ostatnia, moglibyÅ›my po prostu
uczyniÄ‡ tÄ™ czÄ™Å›Ä‡ wÅ‚aÅ›cicielem danych, a normalne zasady wÅ‚asnoÅ›ci egzekwowane
w czasie kompilacji weszÅ‚yby w Å¼ycie.</p>
<p>ZauwaÅ¼, Å¼e <code>Rc&lt;T&gt;</code> jest przeznaczony wyÅ‚Ä…cznie do uÅ¼ytku w scenariuszach
jednowÄ…tkowych. Kiedy bÄ™dziemy omawiaÄ‡ wspÃ³Å‚bieÅ¼noÅ›Ä‡ w Rozdziale 16,
pokaÅ¼emy, jak realizowaÄ‡ zliczanie referencji w programach
wielowÄ…tkowych.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="using-rct-to-share-data"></a></p>
<h3 id="udostÄ™pnianie-danych"><a class="header" href="#udostÄ™pnianie-danych">UdostÄ™pnianie danych</a></h3>
<p>WrÃ³Ä‡my do naszego przykÅ‚adu listy konsensusowej z Listingu 15-5. Przypomnijmy,
Å¼e zdefiniowaliÅ›my jÄ… za pomocÄ… <code>Box&lt;T&gt;</code>. Tym razem stworzymy dwie listy, ktÃ³re
obie wspÃ³Å‚dzielÄ… wÅ‚asnoÅ›Ä‡ trzeciej listy. Koncepcyjnie wyglÄ…da to podobnie do
Rysunku 15-3.</p>
<p><img alt="A linked list with the label &#39;a&#39; pointing to three elements. The first element contains the integer 5 and points to the second element. Th
e second element contains the integer 10 and points to the third element. The third element contains the value &#39;Nil&#39; that signifies the end of the l
ist; it does not point anywhere. A linked list with the label &#39;b&#39; points to an element that contains the integer 3 and points to the first element o
f list &#39;a&#39;. A linked list with the label &#39;c&#39; points to an element that contains the integer 4 and also points to the first element of list &#39;a&#39; so th
at the tails of lists &#39;b&#39; and &#39;c&#39; are both list &#39;a&#39;." src="img/trpl15-03.svg" class="center" /></p>
<p><span class="caption">Rysunek 15-3: Dwie listy, <code>b</code> i <code>c</code>, wspÃ³Å‚dzielÄ…ce wÅ‚asnoÅ›Ä‡
trzeciej listy, <code>a</code></span></p>
<p>Stworzymy listÄ™ <code>a</code>, ktÃ³ra bÄ™dzie zawieraÄ‡ <code>5</code>, a nastÄ™pnie <code>10</code>. NastÄ™pnie,
stworzymy dwie kolejne listy: <code>b</code>, ktÃ³ra zaczyna siÄ™ od <code>3</code>, i <code>c</code>, ktÃ³ra
zaczyna siÄ™ od <code>4</code>. Obie listy <code>b</code> i <code>c</code> bÄ™dÄ… kontynuowane do pierwszej listy <code>a</code>
zawierajÄ…cej <code>5</code> i <code>10</code>. Innymi sÅ‚owy, obie listy bÄ™dÄ… wspÃ³Å‚dzieliÄ‡ pierwszÄ…
listÄ™ zawierajÄ…cÄ… <code>5</code> i <code>10</code>.</p>
<p>PrÃ³ba zaimplementowania tego scenariusza przy uÅ¼yciu naszej definicji <code>List</code> z
<code>Box&lt;T&gt;</code> nie zadziaÅ‚a, jak pokazano w Listingu 15-17.</p>
<listing number="15-17" file-name="src/main.rs" caption="Demonstrowanie, Å¼e nie wolno nam mieÄ‡ dwÃ³ch list uÅ¼ywajÄ…cych `Box&lt;T&gt;`, ktÃ³re prÃ³bujÄ… wspÃ³Å‚dzieliÄ‡ wÅ‚asnoÅ›Ä‡ trzeciej listy">
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}</code></pre>
</listing>
<p>Kiedy skompilujemy ten kod, otrzymamy taki bÅ‚Ä…d:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:11:30
   |
 9 |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move
   |
note: if `List` implemented `Clone`, you could clone the value
  --&gt; src/main.rs:1:1
   |
 1 | enum List {
   | ^^^^^^^^^ consider implementing `Clone` for this type
...
10 |     let b = Cons(3, Box::new(a));
   |                              - you could clone this value

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list` (bin "cons-list") due to 1 previous error
</code></pre>
<p>Warianty <code>Cons</code> posiadajÄ… przechowywane dane, wiÄ™c kiedy tworzymy listÄ™ <code>b</code>, <code>a</code>
zostaje przeniesione do <code>b</code>, a <code>b</code> staje siÄ™ wÅ‚aÅ›cicielem <code>a</code>. NastÄ™pnie, gdy
prÃ³bujemy ponownie uÅ¼yÄ‡ <code>a</code> podczas tworzenia <code>c</code>, nie jest to dozwolone,
poniewaÅ¼ <code>a</code> zostaÅ‚o przeniesione.</p>
<p>MoglibyÅ›my zmieniÄ‡ definicjÄ™ <code>Cons</code>, aby przechowywaÅ‚a referencje, ale wtedy
musielibyÅ›my okreÅ›liÄ‡ parametry czasu Å¼ycia. OkreÅ›lajÄ…c parametry czasu Å¼ycia,
okreÅ›lilibyÅ›my, Å¼e kaÅ¼dy element na liÅ›cie bÄ™dzie istniaÅ‚ co najmniej tak dÅ‚ugo
jak caÅ‚a lista. Tak jest w przypadku elementÃ³w i list w Listingu 15-17, ale
nie w kaÅ¼dym scenariuszu.</p>
<p>Zamiast tego zmienimy naszÄ… definicjÄ™ <code>List</code>, aby uÅ¼ywaÄ‡ <code>Rc&lt;T&gt;</code> zamiast
<code>Box&lt;T&gt;</code>, jak pokazano w Listingu 15-18. KaÅ¼dy wariant <code>Cons</code> bÄ™dzie teraz
przechowywaÅ‚ wartoÅ›Ä‡ i <code>Rc&lt;T&gt;</code> wskazujÄ…cy na <code>List</code>. Kiedy tworzymy <code>b</code>,
zamiast przejmowaÄ‡ wÅ‚asnoÅ›Ä‡ <code>a</code>, sklonujemy <code>Rc&lt;List&gt;</code>, ktÃ³re <code>a</code> przechowuje,
powiÄ…kszajÄ…c tym samym liczbÄ™ referencji z jednej do dwÃ³ch i pozwalajÄ…c <code>a</code> i <code>b</code>
wspÃ³Å‚dzieliÄ‡ wÅ‚asnoÅ›Ä‡ danych w tym <code>Rc&lt;List&gt;</code>. Sklonujemy rÃ³wnieÅ¼ <code>a</code> podczas
tworzenia <code>c</code>, zwiÄ™kszajÄ…c liczbÄ™ referencji z dwÃ³ch do trzech. Za kaÅ¼dym
razem, gdy wywoÅ‚amy <code>Rc::clone</code>, liczba referencji do danych w <code>Rc&lt;List&gt;</code>
wzroÅ›nie, a dane nie zostanÄ… usuniÄ™te, chyba Å¼e bÄ™dzie do nich zero referencji.</p>
<listing number="15-18" file-name="src/main.rs" caption="Definicja `List` uÅ¼ywajÄ…ca `Rc&lt;T&gt;`">
<pre class="playground"><code class="language-rust edition2024">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}</code></pre>
</listing>
<p>Musimy dodaÄ‡ instrukcjÄ™ <code>use</code>, aby wprowadziÄ‡ <code>Rc&lt;T&gt;</code> do zakresu, poniewaÅ¼ nie
znajduje siÄ™ on w preambule. W funkcji <code>main</code> tworzymy listÄ™ zawierajÄ…cÄ… <code>5</code> i
<code>10</code> i przechowujemy jÄ… w nowym <code>Rc&lt;List&gt;</code> w zmiennej <code>a</code>. NastÄ™pnie, gdy
tworzymy <code>b</code> i <code>c</code>, wywoÅ‚ujemy funkcjÄ™ <code>Rc::clone</code> i przekazujemy referencjÄ™
do <code>Rc&lt;List&gt;</code> w <code>a</code> jako argument.</p>
<p>MoglibyÅ›my wywoÅ‚aÄ‡ <code>a.clone()</code> zamiast <code>Rc::clone(&amp;a)</code>, ale konwencjÄ… Rust jest
uÅ¼ywanie <code>Rc::clone</code> w tym przypadku. Implementacja <code>Rc::clone</code> nie tworzy
gÅ‚Ä™bokiej kopii wszystkich danych, jak robiÄ… to implementacje <code>clone</code> wiÄ™kszoÅ›ci
typÃ³w. WywoÅ‚anie <code>Rc::clone</code> tylko zwiÄ™ksza licznik referencji, co nie
zabiera wiele czasu. GÅ‚Ä™bokie kopie danych mogÄ… zajmowaÄ‡ duÅ¼o czasu. UÅ¼ywajÄ…c
<code>Rc::clone</code> do zliczania referencji, moÅ¼emy wizualnie rozrÃ³Å¼niÄ‡ klony
tworzÄ…ce gÅ‚Ä™bokie kopie od klonÃ³w, ktÃ³re zwiÄ™kszajÄ… licznik referencji. SzukajÄ…c
problemÃ³w z wydajnoÅ›ciÄ… w kodzie, musimy braÄ‡ pod uwagÄ™ tylko klony tworzÄ…ce
gÅ‚Ä™bokie kopie i moÅ¼emy ignorowaÄ‡ wywoÅ‚ania <code>Rc::clone</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="cloning-an-rct-increases-the-reference-count"></a></p>
<h3 id="klonowanie-w-celu-zwiÄ™kszenia-licznika-referencji"><a class="header" href="#klonowanie-w-celu-zwiÄ™kszenia-licznika-referencji">Klonowanie w celu zwiÄ™kszenia licznika referencji</a></h3>
<p>ZmieÅ„my nasz dziaÅ‚ajÄ…cy przykÅ‚ad z Listingu 15-18, abyÅ›my mogli zobaczyÄ‡,
jak zmieniajÄ… siÄ™ liczniki referencji, gdy tworzymy i usuwamy referencje do
<code>Rc&lt;List&gt;</code> w <code>a</code>.</p>
<p>W Listingu 15-19 zmienimy <code>main</code> tak, aby zawieraÅ‚ wewnÄ™trzny zakres wokÃ³Å‚
listy <code>c</code>; wtedy bÄ™dziemy mogli zobaczyÄ‡, jak zmienia siÄ™ licznik referencji,
gdy <code>c</code> wyjdzie poza zakres.</p>
<listing number="15-19" file-name="src/main.rs" caption="Wypisywanie licznika referencji">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>// --snip--

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!("count after creating b = {}", Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!("count after creating c = {}", Rc::strong_count(&amp;a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&amp;a));
}</code></pre>
</listing>
<p>W kaÅ¼dym punkcie programu, w ktÃ³rym zmienia siÄ™ licznik referencji, wypisujemy
wartoÅ›Ä‡ licznika referencji, ktÃ³rÄ… uzyskujemy wywoÅ‚ujÄ…c funkcjÄ™
<code>Rc::strong_count</code>. Funkcja ta nazywa siÄ™ <code>strong_count</code> (silne zliczanie)
zamiast <code>count</code> (zliczanie), poniewaÅ¼ typ <code>Rc&lt;T&gt;</code> ma rÃ³wnieÅ¼ <code>weak_count</code>
(sÅ‚abe zliczanie); do czego sÅ‚uÅ¼y <code>weak_count</code> zobaczymy w sekcji <a href="#preventing-reference-cycles-turning-an-rct-into-a-weakt">â€Zapobieganie
cyklom referencji za pomocÄ… <code>Weak&lt;T&gt;</code>â€</a><!-- ignore -->.</p>
<p>Ten kod wypisuje nastÄ™pujÄ…ce:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<p>Widzimy, Å¼e <code>Rc&lt;List&gt;</code> w <code>a</code> ma poczÄ…tkowy licznik referencji rÃ³wny 1; nastÄ™pnie,
za kaÅ¼dym razem, gdy wywoÅ‚ujemy <code>clone</code>, licznik zwiÄ™ksza siÄ™ o 1. Gdy <code>c</code>
wyjdzie poza zakres, licznik zmniejsza siÄ™ o 1. Nie musimy wywoÅ‚ywaÄ‡ funkcji
w celu zmniejszenia licznika referencji, tak jak musimy wywoÅ‚aÄ‡ <code>Rc::clone</code>
w celu zwiÄ™kszenia licznika referencji: Implementacja cechy <code>Drop</code> automatycznie
zmniejsza licznik referencji, gdy wartoÅ›Ä‡ <code>Rc&lt;T&gt;</code> wyjdzie poza zakres.</p>
<p>Czego nie widzimy w tym przykÅ‚adzie, to to, Å¼e gdy <code>b</code>, a nastÄ™pnie <code>a</code> wyjdÄ…
poza zakres na koÅ„cu <code>main</code>, licznik wynosi 0, a <code>Rc&lt;List&gt;</code> zostaje caÅ‚kowicie
wyczyszczone. UÅ¼ycie <code>Rc&lt;T&gt;</code> pozwala jednej wartoÅ›ci mieÄ‡ wielu wÅ‚aÅ›cicieli, a
licznik zapewnia, Å¼e wartoÅ›Ä‡ pozostaje waÅ¼na tak dÅ‚ugo, jak dÅ‚ugo istnieje
ktÃ³rykolwiek z wÅ‚aÅ›cicieli.</p>
<p>Poprzez niemutowalne referencje, <code>Rc&lt;T&gt;</code> pozwala na wspÃ³Å‚dzielenie danych
pomiÄ™dzy wieloma czÄ™Å›ciami programu wyÅ‚Ä…cznie do odczytu. Gdyby <code>Rc&lt;T&gt;</code>
pozwalaÅ‚o na posiadanie rÃ³wnieÅ¼ wielu mutowalnych referencji, mogÅ‚oby to
naruszyÄ‡ jednÄ… z zasad poÅ¼yczania omÃ³wionych w Rozdziale 4: Wiele mutowalnych
poÅ¼yczeÅ„ do tego samego miejsca moÅ¼e prowadziÄ‡ do wyÅ›cigÃ³w danych i
niekonsekwencji. Ale moÅ¼liwoÅ›Ä‡ modyfikacji danych jest bardzo przydatna! W
nastÄ™pnej sekcji omÃ³wimy wzorzec mutowalnoÅ›ci wewnÄ™trznej i typ <code>RefCell&lt;T&gt;</code>,
ktÃ³rego moÅ¼na uÅ¼ywaÄ‡ w poÅ‚Ä…czeniu z <code>Rc&lt;T&gt;</code> do pracy z tym ograniczeniem
iemutowalnoÅ›ci.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="refcellt-i-wzorzec-mutowalnoÅ›ci-wewnÄ™trznej-1"><a href="#refcellt-i-wzorzec-mutowalnoÅ›ci-wewnÄ™trznej-1" class="header">`RefCell&lt;T&gt;` i wzorzec mutowalnoÅ›ci wewnÄ™trznej</a></h1>
<h2 id="refcellt-i-wzorzec-mutowalnoÅ›ci-wewnÄ™trznej"><a class="header" href="#refcellt-i-wzorzec-mutowalnoÅ›ci-wewnÄ™trznej"><code>RefCell&lt;T&gt;</code> i wzorzec mutowalnoÅ›ci wewnÄ™trznej</a></h2>
<p><em>MutowalnoÅ›Ä‡ wewnÄ™trzna</em> to wzorzec projektowy w Rust, ktÃ³ry pozwala na
modyfikowanie danych nawet wtedy, gdy istniejÄ… do nich niemutowalne referencje;
zazwyczaj takie dziaÅ‚anie jest zabronione przez zasady poÅ¼yczania. Aby
modyfikowaÄ‡ dane, wzorzec ten uÅ¼ywa kodu <code>unsafe</code> wewnÄ…trz struktury danych,
aby naginaÄ‡ zwykÅ‚e zasady Rust dotyczÄ…ce mutowalnoÅ›ci i poÅ¼yczania. Kod
niebezpieczny wskazuje kompilatorowi, Å¼e rÄ™cznie sprawdzamy zasady, zamiast
polegaÄ‡ na tym, Å¼e kompilator sprawdzi je za nas; o kodzie niebezpiecznym
bÄ™dziemy rozmawiaÄ‡ szerzej w Rozdziale 20.</p>
<p>Typy uÅ¼ywajÄ…ce wzorca mutowalnoÅ›ci wewnÄ™trznej moÅ¼emy stosowaÄ‡ tylko wtedy,
gdy jesteÅ›my pewni, Å¼e zasady poÅ¼yczania bÄ™dÄ… przestrzegane w czasie
wykonania, mimo Å¼e kompilator nie moÅ¼e tego zagwarantowaÄ‡. Kod <code>unsafe</code> jest
wtedy opakowany w bezpieczne API, a typ zewnÄ™trzny nadal pozostaje
iemutowalny.</p>
<p>Przyjrzyjmy siÄ™ tej koncepcji, badajÄ…c typ <code>RefCell&lt;T&gt;</code>, ktÃ³ry stosuje wzorzec
mutowalnoÅ›ci wewnÄ™trznej.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="enforcing-borrowing-rules-at-runtime-with-refcellt"></a></p>
<h3 id="egzekwowanie-zasad-poÅ¼yczania-w-czasie-wykonania"><a class="header" href="#egzekwowanie-zasad-poÅ¼yczania-w-czasie-wykonania">Egzekwowanie zasad poÅ¼yczania w czasie wykonania</a></h3>
<p>W przeciwieÅ„stwie do <code>Rc&lt;T&gt;</code>, typ <code>RefCell&lt;T&gt;</code> reprezentuje pojedynczÄ… wÅ‚asnoÅ›Ä‡
danych, ktÃ³re przechowuje. Co zatem odrÃ³Å¼nia <code>RefCell&lt;T&gt;</code> od typu takiego jak
<code>Box&lt;T&gt;</code>? Przypomnij sobie zasady poÅ¼yczania, ktÃ³rych nauczyÅ‚eÅ› siÄ™ w Rozdziale 4:</p>
<ul>
<li>W dowolnym momencie moÅ¼esz mieÄ‡ <em>albo</em> jednÄ… mutowalnÄ… referencjÄ™, <em>albo</em> dowolnÄ…
liczbÄ™ niemutowalnych referencji (ale nie obie naraz).</li>
<li>Referencje muszÄ… byÄ‡ zawsze prawidÅ‚owe.</li>
</ul>
<p>W przypadku referencji i <code>Box&lt;T&gt;</code>, niezmienniki zasad poÅ¼yczania sÄ…
egzekwowane w czasie kompilacji. W przypadku <code>RefCell&lt;T&gt;</code> te niezmienniki sÄ…
egzekwowane <em>w czasie wykonania</em>. W przypadku referencji, jeÅ›li naruszysz te
zasady, otrzymasz bÅ‚Ä…d kompilacji. W przypadku <code>RefCell&lt;T&gt;</code>, jeÅ›li naruszysz
te zasady, TwÃ³j program zostanie przerwany (<code>panic</code>) i zakoÅ„czy dziaÅ‚anie.</p>
<p>Zaletami sprawdzania zasad poÅ¼yczania w czasie kompilacji sÄ… to, Å¼e bÅ‚Ä™dy
zostanÄ… wykryte wczeÅ›niej w procesie rozwoju, a takÅ¼e brak wpÅ‚ywu na wydajnoÅ›Ä‡
w czasie wykonania, poniewaÅ¼ caÅ‚a analiza jest zakoÅ„czona wczeÅ›niej. Z tych
powodÃ³w sprawdzanie zasad poÅ¼yczania w czasie kompilacji jest najlepszym
wyborem w wiÄ™kszoÅ›ci przypadkÃ³w, dlatego jest to domyÅ›lne zachowanie Rust.</p>
<p>ZaletÄ… sprawdzania zasad poÅ¼yczania w czasie wykonania jest to, Å¼e pozwala to
na pewne scenariusze bezpieczne pod wzglÄ™dem pamiÄ™ci, ktÃ³re zostaÅ‚yby
zabronione przez sprawdzenia w czasie kompilacji. Analiza statyczna, taka jak
kompilator Rust, jest z natury konserwatywna. NiektÃ³re wÅ‚aÅ›ciwoÅ›ci kodu sÄ…
niemoÅ¼liwe do wykrycia poprzez analizÄ™ kodu: NajsÅ‚ynniejszym przykÅ‚adem jest
Problem Zatrzymania, ktÃ³ry wykracza poza zakres tej ksiÄ…Å¼ki, ale jest
ciekawym tematem do zbadania.</p>
<p>PoniewaÅ¼ niektÃ³re analizy sÄ… niemoÅ¼liwe, jeÅ›li kompilator Rust nie moÅ¼e byÄ‡
pewien, Å¼e kod jest zgodny z zasadami wÅ‚asnoÅ›ci, moÅ¼e odrzuciÄ‡ poprawny
program; w ten sposÃ³b jest konserwatywny. Gdyby Rust akceptowaÅ‚ niepoprawny
program, uÅ¼ytkownicy nie mogliby ufaÄ‡ gwarancjom, jakie daje Rust. Jednak
jeÅ›li Rust odrzuci poprawny program, programista bÄ™dzie miaÅ‚ niedogodnoÅ›ci,
ale nic katastrofalnego nie moÅ¼e siÄ™ wydarzyÄ‡. Typ <code>RefCell&lt;T&gt;</code> jest uÅ¼yteczny,
gdy jesteÅ› pewien, Å¼e TwÃ³j kod jest zgodny z zasadami poÅ¼yczania, ale
kompilator nie jest w stanie tego zrozumieÄ‡ i zagwarantowaÄ‡.</p>
<p>Podobnie jak <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> jest przeznaczony wyÅ‚Ä…cznie do uÅ¼ytku w
scenariuszach jednowÄ…tkowych i spowoduje bÅ‚Ä…d kompilacji, jeÅ›li sprÃ³bujesz go
uÅ¼yÄ‡ w kontekÅ›cie wielowÄ…tkowym. O tym, jak uzyskaÄ‡ funkcjonalnoÅ›Ä‡ <code>RefCell&lt;T&gt;</code>
w programie wielowÄ…tkowym, bÄ™dziemy rozmawiaÄ‡ w Rozdziale 16.</p>
<p>Oto podsumowanie powodÃ³w, dla ktÃ³rych warto wybraÄ‡ <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code> lub
<code>RefCell&lt;T&gt;</code>:</p>
<ul>
<li><code>Rc&lt;T&gt;</code> umoÅ¼liwia wielu wÅ‚aÅ›cicieli tych samych danych; <code>Box&lt;T&gt;</code> i
<code>RefCell&lt;T&gt;</code> majÄ… pojedynczych wÅ‚aÅ›cicieli.</li>
<li><code>Box&lt;T&gt;</code> pozwala na niemutowalne lub mutowalne poÅ¼yczenia sprawdzane w
czasie kompilacji; <code>Rc&lt;T&gt;</code> pozwala tylko na niemutowalne poÅ¼yczenia
sprawdzane w czasie kompilacji; <code>RefCell&lt;T&gt;</code> pozwala na niemutowalne lub
mutowalne poÅ¼yczenia sprawdzane w czasie wykonania.</li>
<li>PoniewaÅ¼ <code>RefCell&lt;T&gt;</code> pozwala na mutowalne poÅ¼yczenia sprawdzane w czasie
wykonania, moÅ¼esz modyfikowaÄ‡ wartoÅ›Ä‡ wewnÄ…trz <code>RefCell&lt;T&gt;</code>, nawet gdy
<code>RefCell&lt;T&gt;</code> jest niemutowalny.</li>
</ul>
<p>Modyfikacja wartoÅ›ci wewnÄ…trz niemutowalnej wartoÅ›ci to wzorzec mutowalnoÅ›ci
wewnÄ™trznej. Przyjrzyjmy siÄ™ sytuacji, w ktÃ³rej mutowalnoÅ›Ä‡ wewnÄ™trzna jest
przydatna i zbadajmy, jak jest to moÅ¼liwe.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="interior-mutability-a-mutable-borrow-to-an-immutable-value"></a></p>
<h3 id="uÅ¼ycie-mutowalnoÅ›ci-wewnÄ™trznej"><a class="header" href="#uÅ¼ycie-mutowalnoÅ›ci-wewnÄ™trznej">UÅ¼ycie mutowalnoÅ›ci wewnÄ™trznej</a></h3>
<p>KonsekwencjÄ… zasad poÅ¼yczania jest to, Å¼e gdy masz niemutowalnÄ… wartoÅ›Ä‡, nie
moÅ¼esz jej mutowalnie poÅ¼yczyÄ‡. Na przykÅ‚ad, ten kod siÄ™ nie skompiluje:</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}</code></pre>
<p>GdybyÅ› sprÃ³bowaÅ‚ skompilowaÄ‡ ten kod, otrzymaÅ‚byÅ› nastÄ™pujÄ…cy bÅ‚Ä…d:</p>
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable
  |
help: consider changing this to be mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` (bin "borrowing") due to 1 previous error
</code></pre>
<p>IstniejÄ… jednak sytuacje, w ktÃ³rych byÅ‚oby przydatne, aby wartoÅ›Ä‡ mogÅ‚a
modyfikowaÄ‡ siÄ™ w swoich metodach, ale wydawaÅ‚a siÄ™ niemutowalna dla innego
kodu. Kod poza metodami wartoÅ›ci nie mÃ³gÅ‚by modyfikowaÄ‡ wartoÅ›ci. UÅ¼ycie
<code>RefCell&lt;T&gt;</code> jest jednym ze sposobÃ³w na uzyskanie zdolnoÅ›ci do mutowalnoÅ›ci
wewnÄ™trznej, ale <code>RefCell&lt;T&gt;</code> nie omija caÅ‚kowicie zasad poÅ¼yczania: Sprawdzanie
poÅ¼yczania w kompilatorze pozwala na tÄ™ mutowalnoÅ›Ä‡ wewnÄ™trznÄ…, a zasady
poÅ¼yczania sÄ… sprawdzane w czasie wykonania. JeÅ›li naruszysz zasady,
otrzymasz <code>panic!</code> zamiast bÅ‚Ä™du kompilacji.</p>
<p>PrzejdÅºmy przez praktyczny przykÅ‚ad, w ktÃ³rym moÅ¼emy uÅ¼yÄ‡ <code>RefCell&lt;T&gt;</code> do
modyfikacji niemutowalnej wartoÅ›ci i zobaczyÄ‡, dlaczego jest to przydatne.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="a-use-case-for-interior-mutability-mock-objects"></a></p>
<h4 id="testowanie-z-obiektami-mockowymi"><a class="header" href="#testowanie-z-obiektami-mockowymi">Testowanie z obiektami mockowymi</a></h4>
<p>Czasami podczas testowania programista uÅ¼ywa jednego typu zamiast innego, aby
obserwowaÄ‡ okreÅ›lone zachowanie i upewniÄ‡ siÄ™, Å¼e jest ono poprawnie
zaimplementowane. Ten zastÄ™pczy typ nazywa siÄ™ <em>dublerem testowym</em>. PomyÅ›l o nim
w sensie dublera kaskaderskiego w filmie, gdzie osoba wchodzi i zastÄ™puje
aktora, aby wykonaÄ‡ szczegÃ³lnie trudnÄ… scenÄ™. Dublery testowe zastÄ™pujÄ… inne
typy, gdy przeprowadzamy testy. <em>Obiekty mockowe</em> to specyficzne typy
dublerÃ³w testowych, ktÃ³re rejestrujÄ…, co dzieje siÄ™ podczas testu, aby moÅ¼na
byÅ‚o stwierdziÄ‡, Å¼e podjÄ™to prawidÅ‚owe dziaÅ‚ania.</p>
<p>Rust nie ma obiektÃ³w w tym samym sensie, co inne jÄ™zyki, i Rust nie ma funkcji
obiektÃ³w mockowych wbudowanych w bibliotekÄ™ standardowÄ…, jak to robiÄ… niektÃ³re
inne jÄ™zyki. MoÅ¼esz jednak z pewnoÅ›ciÄ… stworzyÄ‡ strukturÄ™, ktÃ³ra bÄ™dzie
sÅ‚uÅ¼yÄ‡ tym samym celom, co obiekt mockowy.</p>
<p>Oto scenariusz, ktÃ³ry przetestujemy: stworzymy bibliotekÄ™, ktÃ³ra Å›ledzi
wartoÅ›Ä‡ w stosunku do wartoÅ›ci maksymalnej i wysyÅ‚a wiadomoÅ›ci w zaleÅ¼noÅ›ci od
tego, jak blisko wartoÅ›ci maksymalnej jest obecna wartoÅ›Ä‡. Ta biblioteka mogÅ‚aby
byÄ‡ uÅ¼ywana na przykÅ‚ad do Å›ledzenia limitu uÅ¼ytkownika na liczbÄ™ wywoÅ‚aÅ„ API,
ktÃ³re sÄ… dozwolone.</p>
<p>Nasza biblioteka bÄ™dzie zapewniaÄ‡ jedynie funkcjonalnoÅ›Ä‡ Å›ledzenia, jak blisko
wartoÅ›ci maksymalnej jest wartoÅ›Ä‡ i jakie wiadomoÅ›ci powinny byÄ‡ wysyÅ‚ane w
danych momentach. Aplikacje korzystajÄ…ce z naszej biblioteki bÄ™dÄ… musiaÅ‚y
dostarczyÄ‡ mechanizm wysyÅ‚ania wiadomoÅ›ci: Aplikacja moÅ¼e pokazaÄ‡ wiadomoÅ›Ä‡
uÅ¼ytkownikowi bezpoÅ›rednio, wysÅ‚aÄ‡ e-mail, wysÅ‚aÄ‡ wiadomoÅ›Ä‡ tekstowÄ… lub zrobiÄ‡
cokolwiek innego. Biblioteka nie musi znaÄ‡ tych szczegÃ³Å‚Ã³w. Potrzebuje tylko
czegoÅ›, co implementuje cechÄ™, ktÃ³rÄ… dostarczymy, nazwanÄ… <code>Messenger</code>. Listing
15-20 pokazuje kod biblioteki.</p>
<listing number="15-20" file-name="src/lib.rs" caption="Biblioteka do Å›ledzenia, jak blisko wartoÅ›Ä‡ jest wartoÅ›ci maksymalnej i ostrzegania, gdy wartoÅ›Ä‡ osiÄ…ga pewne poziomy">
<pre><code class="language-rust noplayground">pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send("Warning: You've used up over 75% of your quota!");
        }
    }
}</code></pre>
</listing>
<p>JednÄ… waÅ¼nÄ… czÄ™Å›ciÄ… tego kodu jest to, Å¼e cecha <code>Messenger</code> ma jednÄ… metodÄ™
o nazwie <code>send</code>, ktÃ³ra przyjmuje niemutowalnÄ… referencjÄ™ do <code>self</code> i tekst
wiadomoÅ›ci. Ta cecha jest interfejsem, ktÃ³ry nasz obiekt mockowy musi
implementowaÄ‡, aby mock mÃ³gÅ‚ byÄ‡ uÅ¼ywany w ten sam sposÃ³b, co prawdziwy obiekt.
Druga waÅ¼na czÄ™Å›Ä‡ to to, Å¼e chcemy przetestowaÄ‡ zachowanie metody <code>set_value</code>
w <code>LimitTracker</code>. MoÅ¼emy zmieniÄ‡ to, co przekazujemy jako parametr <code>value</code>,
ale <code>set_value</code> nie zwraca niczego, na czym moglibyÅ›my oprzeÄ‡ asercje. Chcemy
byÄ‡ w stanie powiedzieÄ‡, Å¼e jeÅ›li utworzymy <code>LimitTracker</code> z czymÅ›, co
implementuje cechÄ™ <code>Messenger</code> i okreÅ›lonÄ… wartoÅ›ciÄ… dla <code>max</code>, to messenger
otrzymuje polecenie wysÅ‚ania odpowiednich wiadomoÅ›ci, gdy przekazujemy
rÃ³Å¼ne liczby dla <code>value</code>.</p>
<p>Potrzebujemy obiektu mockowego, ktÃ³ry zamiast wysyÅ‚aÄ‡ e-mail lub wiadomoÅ›Ä‡
tekstowÄ… po wywoÅ‚aniu <code>send</code>, bÄ™dzie jedynie Å›ledziÅ‚ wiadomoÅ›ci, ktÃ³re mu
kazano wysÅ‚aÄ‡. MoÅ¼emy utworzyÄ‡ nowÄ… instancjÄ™ obiektu mockowego, stworzyÄ‡
<code>LimitTracker</code> uÅ¼ywajÄ…cy obiektu mockowego, wywoÅ‚aÄ‡ metodÄ™ <code>set_value</code> w
<code>LimitTracker</code>, a nastÄ™pnie sprawdziÄ‡, czy obiekt mockowy zawiera wiadomoÅ›ci,
ktÃ³rych oczekujemy. Listing 15-21 pokazuje prÃ³bÄ™ zaimplementowania obiektu
mockowego, ktÃ³ry ma to robiÄ‡, ale sprawdzajÄ…cy poÅ¼yczki na to nie zezwala.</p>
<listing number="15-21" file-name="src/lib.rs" caption="PrÃ³ba zaimplementowania `MockMessenger`, ktÃ³ra nie jest dozwolona przez sprawdzajÄ…cego poÅ¼yczki">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}</code></pre>
</listing>
<p>Ten kod testowy definiuje strukturÄ™ <code>MockMessenger</code>, ktÃ³ra ma pole
<code>sent_messages</code> z wektorem wartoÅ›ci <code>String</code>, aby Å›ledziÄ‡ wiadomoÅ›ci, ktÃ³re ma
wysyÅ‚aÄ‡. Definiujemy rÃ³wnieÅ¼ skojarzonÄ… funkcjÄ™ <code>new</code>, aby uÅ‚atwiÄ‡ tworzenie
nowych wartoÅ›ci <code>MockMessenger</code>, ktÃ³re zaczynajÄ… siÄ™ od pustej listy wiadomoÅ›ci.
NastÄ™pnie implementujemy cechÄ™ <code>Messenger</code> dla <code>MockMessenger</code>, aby mÃ³c
przekazaÄ‡ <code>MockMessenger</code> do <code>LimitTracker</code>. W definicji metody <code>send</code>
pobieramy wiadomoÅ›Ä‡ przekazanÄ… jako parametr i przechowujemy jÄ… na liÅ›cie
<code>sent_messages</code> <code>MockMessenger</code>.</p>
<p>W teÅ›cie sprawdzamy, co dzieje siÄ™, gdy <code>LimitTracker</code> otrzymuje polecenie
ustawienia <code>value</code> na wartoÅ›Ä‡ wiÄ™kszÄ… niÅ¼ 75 procent wartoÅ›ci <code>max</code>. Najpierw
tworzymy nowy <code>MockMessenger</code>, ktÃ³ry rozpocznie siÄ™ od pustej listy wiadomoÅ›ci.
NastÄ™pnie tworzymy nowy <code>LimitTracker</code> i przekazujemy mu referencjÄ™ do nowego
obiektu <code>MockMessenger</code> oraz wartoÅ›Ä‡ <code>max</code> rÃ³wnÄ… <code>100</code>. WywoÅ‚ujemy metodÄ™
<code>set_value</code> w <code>LimitTracker</code> z wartoÅ›ciÄ… <code>80</code>, co stanowi ponad 75 procent z
100. NastÄ™pnie twierdzimy, Å¼e lista wiadomoÅ›ci Å›ledzonych przez
<code>MockMessenger</code> powinna teraz zawieraÄ‡ jednÄ… wiadomoÅ›Ä‡.</p>
<p>Jest jednak jeden problem z tym testem, jak pokazano tutaj:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
   |
help: consider changing this to be a mutable reference in the `impl` method and the `trait` definition
   |
 2 ~     fn send(&amp;mut self, msg: &amp;str);
 3 | }
...
56 |     impl Messenger for MockMessenger {
57 ~         fn send(&amp;mut self, message: &amp;str) {
   |

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` (lib test) due to 1 previous error
</code></pre>
<p>Nie moÅ¼emy modyfikowaÄ‡ <code>MockMessenger</code>, aby Å›ledziÅ‚ wiadomoÅ›ci, poniewaÅ¼
metoda <code>send</code> przyjmuje niemutowalnÄ… referencjÄ™ do <code>self</code>. Nie moÅ¼emy rÃ³wnieÅ¼
skorzystaÄ‡ z sugestii komunikatu o bÅ‚Ä™dzie, aby uÅ¼yÄ‡ <code>&amp;mut self</code> zarÃ³wno w
metodzie <code>impl</code>, jak i w definicji cechy. Nie chcemy zmieniaÄ‡ cechy <code>Messenger</code>
wyÅ‚Ä…cznie dla celÃ³w testowania. Zamiast tego musimy znaleÅºÄ‡ sposÃ³b, aby nasz
kod testowy dziaÅ‚aÅ‚ poprawnie z naszym istniejÄ…cym projektem.</p>
<p>To sytuacja, w ktÃ³rej mutowalnoÅ›Ä‡ wewnÄ™trzna moÅ¼e pomÃ³c! BÄ™dziemy
przechowywaÄ‡ <code>sent_messages</code> wewnÄ…trz <code>RefCell&lt;T&gt;</code>, a nastÄ™pnie metoda <code>send</code>
bÄ™dzie mogÅ‚a modyfikowaÄ‡ <code>sent_messages</code> w celu przechowywania widzianych przez
nas wiadomoÅ›ci. Listing 15-22 pokazuje, jak to wyglÄ…da.</p>
<listing number="15-22" file-name="src/lib.rs" caption="UÅ¼ycie `RefCell&lt;T&gt;` do mutowania wewnÄ™trznej wartoÅ›ci, podczas gdy wartoÅ›Ä‡ zewnÄ™trzna jest uwaÅ¼ana za niemutowalnÄ…">
<pre><code class="language-rust noplayground"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}</code></pre>
</listing>
<p>Pole <code>sent_messages</code> jest teraz typu <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> zamiast
<code>Vec&lt;String&gt;</code>. W funkcji <code>new</code> tworzymy nowÄ… instancjÄ™ <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>
wokÃ³Å‚ pustego wektora.</p>
<p>Dla implementacji metody <code>send</code> pierwszy parametr nadal jest niemutowalnym
poÅ¼yczeniem <code>self</code>, co odpowiada definicji cechy. WywoÅ‚ujemy <code>borrow_mut</code> na
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code> w <code>self.sent_messages</code>, aby uzyskaÄ‡ mutowalnÄ… referencjÄ™
do wartoÅ›ci wewnÄ…trz <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, ktÃ³ra jest wektorem. NastÄ™pnie
moÅ¼emy wywoÅ‚aÄ‡ <code>push</code> na mutowalnej referencji do wektora, aby Å›ledziÄ‡ wiadomoÅ›ci
wysÅ‚ane podczas testu.</p>
<p>Ostatnia zmiana, jakÄ… musimy wprowadziÄ‡, dotyczy asercji: aby sprawdziÄ‡, ile
elementÃ³w jest w wewnÄ™trznym wektorze, wywoÅ‚ujemy <code>borrow</code> na
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, aby uzyskaÄ‡ niemutowalnÄ… referencjÄ™ do wektora.</p>
<p>Teraz, gdy widziaÅ‚eÅ›, jak uÅ¼ywaÄ‡ <code>RefCell&lt;T&gt;</code>, zagÅ‚Ä™bmy siÄ™ w to, jak to dziaÅ‚a!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="keeping-track-of-borrows-at-runtime-with-refcellt"></a></p>
<h4 id="Å›ledzenie-poÅ¼yczeÅ„-w-czasie-wykonania"><a class="header" href="#Å›ledzenie-poÅ¼yczeÅ„-w-czasie-wykonania">Åšledzenie poÅ¼yczeÅ„ w czasie wykonania</a></h4>
<p>Podczas tworzenia niemutowalnych i mutowalnych referencji uÅ¼ywamy odpowiednio
skÅ‚adni <code>&amp;</code> i <code>&amp;mut</code>. W przypadku <code>RefCell&lt;T&gt;</code> uÅ¼ywamy metod <code>borrow</code> i
<code>borrow_mut</code>, ktÃ³re sÄ… czÄ™Å›ciÄ… bezpiecznego API naleÅ¼Ä…cego do <code>RefCell&lt;T&gt;</code>. Metoda
<code>borrow</code> zwraca typ wskaÅºnika sprytnego <code>Ref&lt;T&gt;</code>, a <code>borrow_mut</code> zwraca typ
wskaÅºnika sprytnego <code>RefMut&lt;T&gt;</code>. Oba typy implementujÄ… <code>Deref</code>, wiÄ™c moÅ¼emy je
traktowaÄ‡ jak zwykÅ‚e referencje.</p>
<p><code>RefCell&lt;T&gt;</code> Å›ledzi, ile wskaÅºnikÃ³w sprytnych <code>Ref&lt;T&gt;</code> i <code>RefMut&lt;T&gt;</code> jest
aktywnie uÅ¼ywanych. Za kaÅ¼dym razem, gdy wywoÅ‚ujemy <code>borrow</code>, <code>RefCell&lt;T&gt;</code>
zwiÄ™ksza licznik aktywnych niemutowalnych poÅ¼yczeÅ„. Gdy wartoÅ›Ä‡ <code>Ref&lt;T&gt;</code> wyjdzie
poza zakres, licznik niemutowalnych poÅ¼yczeÅ„ zmniejsza siÄ™ o 1. Podobnie jak
zasady poÅ¼yczania w czasie kompilacji, <code>RefCell&lt;T&gt;</code> pozwala nam na wiele
niemutowalnych poÅ¼yczeÅ„ lub jedno mutowalne poÅ¼yczenie w dowolnym momencie.</p>
<p>JeÅ›li sprÃ³bujemy naruszyÄ‡ te zasady, zamiast otrzymania bÅ‚Ä™du kompilacji, jak
miaÅ‚oby to miejsce w przypadku referencji, implementacja <code>RefCell&lt;T&gt;</code> spowoduje
panikÄ™ w czasie wykonania. Listing 15-23 pokazuje modyfikacjÄ™ implementacji
<code>send</code> z Listingu 15-22. Celowo prÃ³bujemy stworzyÄ‡ dwa mutowalne poÅ¼yczenia
aktywne w tym samym zakresie, aby zilustrowaÄ‡, Å¼e <code>RefCell&lt;T&gt;</code> zapobiega temu
w czasie wykonania.</p>
<listing number="15-23" file-name="src/lib.rs" caption="Tworzenie dwÃ³ch mutowalnych referencji w tym samym zakresie, aby zobaczyÄ‡, Å¼e `RefCell&lt;T&gt;` spowoduje panikÄ™">
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MockMessenger {
</span><span class="boring">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MockMessenger {
</span><span class="boring">        fn new() -&gt; MockMessenger {
</span><span class="boring">            MockMessenger {
</span><span class="boring">                sent_messages: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_sends_an_over_75_percent_warning_message() {
</span><span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</listing>
<p>Tworzymy zmiennÄ… <code>one_borrow</code> dla wskaÅºnika sprytnego <code>RefMut&lt;T&gt;</code> zwrÃ³conego
przez <code>borrow_mut</code>. NastÄ™pnie tworzymy kolejne mutowalne poÅ¼yczenie w ten sam
sposÃ³b w zmiennej <code>two_borrow</code>. Tworzy to dwie mutowalne referencje w tym samym
zakresie, co jest niedozwolone. Kiedy uruchomimy testy dla naszej biblioteki,
kod z Listingu 15-23 skompiluje siÄ™ bez bÅ‚Ä™dÃ³w, ale test siÄ™ nie powiedzie:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----

thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at src/lib.rs:60:53:
RefCell already borrowed
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>ZauwaÅ¼, Å¼e kod spowodowaÅ‚ panikÄ™ z komunikatem <code>already borrowed: BorrowMutError</code>. W ten sposÃ³b <code>RefCell&lt;T&gt;</code> obsÅ‚uguje naruszenia zasad
poÅ¼yczania w czasie wykonania.</p>
<p>Decyzja o wychwytywaniu bÅ‚Ä™dÃ³w poÅ¼yczania w czasie wykonania, a nie w czasie
kompilacji, jak to zrobiliÅ›my tutaj, oznacza, Å¼e potencjalnie moÅ¼esz
znajdowaÄ‡ bÅ‚Ä™dy w swoim kodzie pÃ³Åºniej w procesie rozwoju: byÄ‡ moÅ¼e dopiero po
wdroÅ¼eniu kodu do produkcji. Ponadto, TwÃ³j kod poniesie niewielkÄ… karÄ™
wydajnoÅ›ciowÄ… w czasie wykonania w wyniku Å›ledzenia poÅ¼yczeÅ„ w czasie
wykonania, a nie w czasie kompilacji. JednakÅ¼e, uÅ¼ycie <code>RefCell&lt;T&gt;</code> umoÅ¼liwia
napisanie obiektu mockowego, ktÃ³ry moÅ¼e modyfikowaÄ‡ siÄ™, aby Å›ledziÄ‡
wiadomoÅ›ci, ktÃ³re widziaÅ‚, podczas gdy uÅ¼ywasz go w kontekÅ›cie, w ktÃ³rym
dozwolone sÄ… tylko niemutowalne wartoÅ›ci. MoÅ¼esz uÅ¼ywaÄ‡ <code>RefCell&lt;T&gt;</code> pomimo
jego kompromisÃ³w, aby uzyskaÄ‡ wiÄ™kszÄ… funkcjonalnoÅ›Ä‡ niÅ¼ zapewniajÄ… zwykÅ‚e
referencje.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="having-multiple-owners-of-mutable-data-by-combining-rc-t-and-ref-cell-t"></a>
<a id="allowing-multiple-owners-of-mutable-data-with-rct-and-refcellt"></a></p>
<h3 id="zezwalanie-na-wielu-wÅ‚aÅ›cicieli-mutowalnych-danych"><a class="header" href="#zezwalanie-na-wielu-wÅ‚aÅ›cicieli-mutowalnych-danych">Zezwalanie na wielu wÅ‚aÅ›cicieli mutowalnych danych</a></h3>
<p>CzÄ™stym sposobem uÅ¼ycia <code>RefCell&lt;T&gt;</code> jest poÅ‚Ä…czenie go z <code>Rc&lt;T&gt;</code>. Przypomnijmy,
Å¼e <code>Rc&lt;T&gt;</code> pozwala na posiadanie wielu wÅ‚aÅ›cicieli danych, ale daje dostÄ™p do
tych danych tylko w trybie niemutowalnym. JeÅ›li masz <code>Rc&lt;T&gt;</code>, ktÃ³ry zawiera
<code>RefCell&lt;T&gt;</code>, moÅ¼esz uzyskaÄ‡ wartoÅ›Ä‡, ktÃ³ra moÅ¼e mieÄ‡ wielu wÅ‚aÅ›cicieli <em>i</em> ktÃ³rÄ…
moÅ¼esz modyfikowaÄ‡!</p>
<p>Na przykÅ‚ad, przypomnij sobie przykÅ‚ad listy konsensusowej z Listingu 15-18,
w ktÃ³rym uÅ¼yliÅ›my <code>Rc&lt;T&gt;</code>, aby umoÅ¼liwiÄ‡ wielu listom wspÃ³Å‚dzielenie wÅ‚asnoÅ›ci
innej listy. PoniewaÅ¼ <code>Rc&lt;T&gt;</code> przechowuje tylko niemutowalne wartoÅ›ci, nie moÅ¼emy
zmieniÄ‡ Å¼adnej z wartoÅ›ci na liÅ›cie po ich utworzeniu. Dodajmy <code>RefCell&lt;T&gt;</code>,
aby mÃ³c zmieniaÄ‡ wartoÅ›ci na listach. Listing 15-24 pokazuje, Å¼e uÅ¼ywajÄ…c
<code>RefCell&lt;T&gt;</code> w definicji <code>Cons</code>, moÅ¼emy modyfikowaÄ‡ wartoÅ›Ä‡ przechowywanÄ… we
wszystkich listach.</p>
<listing number="15-24" file-name="src/main.rs" caption="UÅ¼ycie `Rc&lt;RefCell&lt;i32&gt;&gt;` do stworzenia mutowalnej `List`">
<pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!("a after = {a:?}");
    println!("b after = {b:?}");
    println!("c after = {c:?}");
}</code></pre>
</listing>
<p>Tworzymy wartoÅ›Ä‡, ktÃ³ra jest instancjÄ… <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> i przechowujemy jÄ…
w zmiennej o nazwie <code>value</code>, abyÅ›my mogli uzyskaÄ‡ do niej bezpoÅ›redni dostÄ™p
pÃ³Åºniej. NastÄ™pnie tworzymy <code>List</code> w <code>a</code> z wariantem <code>Cons</code>, ktÃ³ry przechowuje
<code>value</code>. Musimy sklonowaÄ‡ <code>value</code>, aby zarÃ³wno <code>a</code>, jak i <code>value</code> posiadaÅ‚y
wÅ‚asnoÅ›Ä‡ wewnÄ™trznej wartoÅ›ci <code>5</code>, zamiast przenosiÄ‡ wÅ‚asnoÅ›Ä‡ z <code>value</code> do <code>a</code>
lub aby <code>a</code> poÅ¼yczaÅ‚o z <code>value</code>.</p>
<p>Opakowujemy listÄ™ <code>a</code> w <code>Rc&lt;T&gt;</code>, aby po utworzeniu list <code>b</code> i <code>c</code> obie mogÅ‚y
odnosiÄ‡ siÄ™ do <code>a</code>, co zrobiliÅ›my w Listingu 15-18.</p>
<p>Po utworzeniu list w <code>a</code>, <code>b</code> i <code>c</code>, chcemy dodaÄ‡ 10 do wartoÅ›ci w <code>value</code>. Robimy
to, wywoÅ‚ujÄ…c <code>borrow_mut</code> na <code>value</code>, co wykorzystuje funkcjÄ™ automatycznego
rozpoÅ¼yczania, ktÃ³rÄ… omÃ³wiliÅ›my w <a href="#wheres-the---operator">â€Gdzie jest operator <code>-&gt;</code>?â€</a><!-- ignore -->
w Rozdziale 5, aby rozpoÅ¼yczyÄ‡ <code>Rc&lt;T&gt;</code> do wewnÄ™trznej wartoÅ›ci <code>RefCell&lt;T&gt;</code>. Metoda
<code>borrow_mut</code> zwraca wskaÅºnik sprytny <code>RefMut&lt;T&gt;</code>, a my uÅ¼ywamy na nim operatora
rozpoÅ¼yczania i zmieniamy wewnÄ™trznÄ… wartoÅ›Ä‡.</p>
<p>Kiedy wypiszemy <code>a</code>, <code>b</code> i <code>c</code>, widzimy, Å¼e wszystkie majÄ… zmodyfikowanÄ…
wartoÅ›Ä‡ <code>15</code> zamiast <code>5</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>Ta technika jest caÅ‚kiem sprytna! UÅ¼ywajÄ…c <code>RefCell&lt;T&gt;</code>, mamy zewnÄ™trznie
niemutowalnÄ… wartoÅ›Ä‡ <code>List</code>. Ale moÅ¼emy uÅ¼yÄ‡ metod <code>RefCell&lt;T&gt;</code>, ktÃ³re zapewniajÄ…
dostÄ™p do jego wewnÄ™trznej mutowalnoÅ›ci, dziÄ™ki czemu moÅ¼emy modyfikowaÄ‡ nasze
dane, gdy tego potrzebujemy. Sprawdzenia zasad poÅ¼yczania w czasie wykonania
chroniÄ… nas przed wyÅ›cigami danych, a czasami warto poÅ›wiÄ™ciÄ‡ trochÄ™ szybkoÅ›ci
dla tej elastycznoÅ›ci w naszych strukturach danych. ZauwaÅ¼, Å¼e <code>RefCell&lt;T&gt;</code>
nie dziaÅ‚a w kodzie wielowÄ…tkowym! <code>Mutex&lt;T&gt;</code> to wersja <code>RefCell&lt;T&gt;</code> bezpieczna
wielowÄ…tkowo, a o <code>Mutex&lt;T&gt;</code> bÄ™dziemy rozmawiaÄ‡ w Rozdziale 16.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cykle-referencji-mogÄ…-prowadziÄ‡-do-wyciekÃ³w-pamiÄ™ci-1"><a href="#cykle-referencji-mogÄ…-prowadziÄ‡-do-wyciekÃ³w-pamiÄ™ci-1" class="header">Cykle referencji mogÄ… prowadziÄ‡ do wyciekÃ³w pamiÄ™ci</a></h1>
<h2 id="cykle-referencji-mogÄ…-prowadziÄ‡-do-wyciekÃ³w-pamiÄ™ci"><a class="header" href="#cykle-referencji-mogÄ…-prowadziÄ‡-do-wyciekÃ³w-pamiÄ™ci">Cykle referencji mogÄ… prowadziÄ‡ do wyciekÃ³w pamiÄ™ci</a></h2>
<p>Gwarancje bezpieczeÅ„stwa pamiÄ™ci w Rust sprawiajÄ…, Å¼e trudno, ale nie jest
niemoÅ¼liwe, przypadkowe tworzenie pamiÄ™ci, ktÃ³ra nigdy nie jest zwalniana (znane
jako <em>wyciek pamiÄ™ci</em>). CaÅ‚kowite zapobieganie wyciekom pamiÄ™ci nie jest jednÄ…
z gwarancji Rust, co oznacza, Å¼e wycieki pamiÄ™ci sÄ… bezpieczne w Rust. MoÅ¼emy
zobaczyÄ‡, Å¼e Rust dopuszcza wycieki pamiÄ™ci, uÅ¼ywajÄ…c <code>Rc&lt;T&gt;</code> i <code>RefCell&lt;T&gt;</code>:
MoÅ¼liwe jest tworzenie referencji, w ktÃ³rych elementy odwoÅ‚ujÄ… siÄ™ do siebie
w cyklu. Tworzy to wycieki pamiÄ™ci, poniewaÅ¼ licznik referencji kaÅ¼dego
elementu w cyklu nigdy nie osiÄ…gnie 0, a wartoÅ›ci nigdy nie zostanÄ… usuniÄ™te.</p>
<h3 id="tworzenie-cyklu-referencji"><a class="header" href="#tworzenie-cyklu-referencji">Tworzenie cyklu referencji</a></h3>
<p>Przyjrzyjmy siÄ™, jak moÅ¼e powstaÄ‡ cykl referencji i jak mu zapobiec, zaczynajÄ…c
od definicji enum <code>List</code> i metody <code>tail</code> w Listingu 15-25.</p>
<listing number="15-25" file-name="src/main.rs" caption="Definicja listy konsensusowej, ktÃ³ra przechowuje `RefCell&lt;T&gt;`, abyÅ›my mogli modyfikowaÄ‡ to, do czego odwoÅ‚uje siÄ™ wariant `Cons`">
<pre class="playground"><code class="language-rust edition2024">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
</listing>
<p>UÅ¼ywamy kolejnej wariacji definicji <code>List</code> z Listingu 15-5. Drugi element
wariantu <code>Cons</code> to teraz <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, co oznacza, Å¼e zamiast moÅ¼liwoÅ›ci
modyfikacji wartoÅ›ci <code>i32</code>, jak to robiliÅ›my w Listingu 15-24, chcemy
modyfikowaÄ‡ wartoÅ›Ä‡ <code>List</code>, na ktÃ³rÄ… wskazuje wariant <code>Cons</code>. Dodajemy rÃ³wnieÅ¼
metodÄ™ <code>tail</code>, aby uÅ‚atwiÄ‡ nam dostÄ™p do drugiego elementu, jeÅ›li mamy wariant
<code>Cons</code>.</p>
<p>W Listingu 15-26 dodajemy funkcjÄ™ <code>main</code>, ktÃ³ra uÅ¼ywa definicji z Listingu
15-25. Ten kod tworzy listÄ™ w <code>a</code> i listÄ™ w <code>b</code>, ktÃ³ra wskazuje na listÄ™ w <code>a</code>.
NastÄ™pnie modyfikuje listÄ™ w <code>a</code>, aby wskazywaÅ‚a na <code>b</code>, tworzÄ…c cykl
referencji. Po drodze znajdujÄ… siÄ™ instrukcje <code>println!</code>, aby pokazaÄ‡, jakie
sÄ… liczniki referencji w rÃ³Å¼nych punktach tego procesu.</p>
<listing number="15-26" file-name="src/main.rs" caption="Tworzenie cyklu referencji dwÃ³ch wartoÅ›ci `List` wskazujÄ…cych na siebie nawzajem">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a initial rc count = {}", Rc::strong_count(&amp;a));
    println!("a next item = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!("a rc count after b creation = {}", Rc::strong_count(&amp;a));
    println!("b initial rc count = {}", Rc::strong_count(&amp;b));
    println!("b next item = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!("b rc count after changing a = {}", Rc::strong_count(&amp;b));
    println!("a rc count after changing a = {}", Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack.
    // println!("a next item = {:?}", a.tail());
}</code></pre>
</listing>
<p>Tworzymy instancjÄ™ <code>Rc&lt;List&gt;</code> przechowujÄ…cÄ… wartoÅ›Ä‡ <code>List</code> w zmiennej <code>a</code> z
poczÄ…tkowÄ… listÄ… <code>5, Nil</code>. NastÄ™pnie tworzymy instancjÄ™ <code>Rc&lt;List&gt;</code> przechowujÄ…cÄ…
inna wartoÅ›Ä‡ <code>List</code> w zmiennej <code>b</code>, ktÃ³ra zawiera wartoÅ›Ä‡ <code>10</code> i wskazuje na
listÄ™ w <code>a</code>.</p>
<p>Modyfikujemy <code>a</code> tak, aby wskazywaÅ‚a na <code>b</code> zamiast <code>Nil</code>, tworzÄ…c cykl.
Robimy to, uÅ¼ywajÄ…c metody <code>tail</code> do uzyskania referencji do
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code> w <code>a</code>, ktÃ³rÄ… umieszczamy w zmiennej <code>link</code>. NastÄ™pnie
uÅ¼ywamy metody <code>borrow_mut</code> w <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, aby zmieniÄ‡ wewnÄ™trznÄ…
wartoÅ›Ä‡ z <code>Rc&lt;List&gt;</code>, ktÃ³ra przechowuje wartoÅ›Ä‡ <code>Nil</code>, na <code>Rc&lt;List&gt;</code> w <code>b</code>.</p>
<p>Po uruchomieniu tego kodu, z pominiÄ™ciem ostatniego <code>println!</code> na razie,
otrzymamy nastÄ™pujÄ…cy wynik:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
</code></pre>
<p>Licznik referencji instancji <code>Rc&lt;List&gt;</code> zarÃ³wno w <code>a</code>, jak i <code>b</code> wynosi 2 po
zmianie listy w <code>a</code> na wskazujÄ…cÄ… na <code>b</code>. Na koÅ„cu <code>main</code> Rust usuwa zmiennÄ…
<code>b</code>, co zmniejsza licznik referencji instancji <code>Rc&lt;List&gt;</code> z <code>b</code> z 2 do 1.
PamiÄ™Ä‡, ktÃ³rÄ… <code>Rc&lt;List&gt;</code> ma na stercie, nie zostanie w tym momencie usuniÄ™ta,
poniewaÅ¼ jej licznik referencji wynosi 1, a nie 0. NastÄ™pnie Rust usuwa <code>a</code>, co
zmniejsza licznik referencji instancji <code>Rc&lt;List&gt;</code> z <code>a</code> rÃ³wnieÅ¼ z 2 do 1.
PamiÄ™Ä‡ tej instancji rÃ³wnieÅ¼ nie moÅ¼e zostaÄ‡ usuniÄ™ta, poniewaÅ¼ inna instancja
<code>Rc&lt;List&gt;</code> nadal siÄ™ do niej odwoÅ‚uje. PamiÄ™Ä‡ alokowana na listÄ™ pozostanie
niezebrana na zawsze. Aby zwizualizowaÄ‡ ten cykl referencji, stworzyliÅ›my
diagram na Rysunku 15-4.</p>
<img alt="A rectangle labeled &#39;a&#39; that points to a rectangle containing the integer 5. A rectangle labeled &#39;b&#39; that points to a rectangle containing the integer 10. The rectangle containing 5 points to the rectangle containing 10, and the rectangle containing 10 points back to the rectangle containing 5, creating a cycle." src="img/trpl15-04.svg" class="center" />
<p><span class="caption">Rysunek 15-4: Cykl referencji list <code>a</code> i <code>b</code>
wskazujÄ…cych na siebie nawzajem</span></p>
<p>JeÅ›li odkomentujesz ostatniÄ… instrukcjÄ™ <code>println!</code> i uruchomisz program, Rust
sprÃ³buje wypisaÄ‡ ten cykl, w ktÃ³rym <code>a</code> wskazuje na <code>b</code>, <code>b</code> na <code>a</code> i tak dalej,
aÅ¼ do przepeÅ‚nienia stosu.</p>
<p>W porÃ³wnaniu do rzeczywistego programu, konsekwencje tworzenia cyklu referencji
w tym przykÅ‚adzie nie sÄ… bardzo powaÅ¼ne: zaraz po utworzeniu cyklu referencji
program siÄ™ koÅ„czy. JednakÅ¼e, jeÅ›li bardziej zÅ‚oÅ¼ony program alokowaÅ‚by duÅ¼o
pamiÄ™ci w cyklu i utrzymywaÅ‚ jÄ… przez dÅ‚ugi czas, program zuÅ¼ywaÅ‚by wiÄ™cej
pamiÄ™ci niÅ¼ potrzebowaÅ‚ i mÃ³gÅ‚by przeciÄ…Å¼yÄ‡ system, powodujÄ…c wyczerpanie
dostÄ™pnej pamiÄ™ci.</p>
<p>Tworzenie cykli referencji nie jest Å‚atwe, ale teÅ¼ nie niemoÅ¼liwe. JeÅ›li masz
wartoÅ›ci <code>RefCell&lt;T&gt;</code>, ktÃ³re zawierajÄ… wartoÅ›ci <code>Rc&lt;T&gt;</code> lub podobne zagnieÅ¼dÅ¼one
poÅ‚Ä…czenia typÃ³w z mutowalnoÅ›ciÄ… wewnÄ™trznÄ… i zliczaniem referencji, musisz
zapewniÄ‡, Å¼e nie tworzysz cykli; nie moÅ¼esz polegaÄ‡ na Rust w ich
wykrywaniu. Tworzenie cyklu referencji byÅ‚oby bÅ‚Ä™dem logicznym w twoim
programie, ktÃ³ry powinieneÅ› minimalizowaÄ‡ za pomocÄ… automatycznych testÃ³w,
przeglÄ…dÃ³w kodu i innych praktyk rozwoju oprogramowania.</p>
<p>Innym rozwiÄ…zaniem pozwalajÄ…cym uniknÄ…Ä‡ cykli referencji jest reorganizacja
struktur danych tak, aby niektÃ³re referencje wyraÅ¼aÅ‚y wÅ‚asnoÅ›Ä‡, a inne nie.
W rezultacie moÅ¼esz mieÄ‡ cykle skÅ‚adajÄ…ce siÄ™ z relacji wÅ‚asnoÅ›ci i relacji
braku wÅ‚asnoÅ›ci, a tylko relacje wÅ‚asnoÅ›ci wpÅ‚ywajÄ… na to, czy wartoÅ›Ä‡ moÅ¼e
zostaÄ‡ usuniÄ™ta. W Listingu 15-25 zawsze chcemy, aby warianty <code>Cons</code> posiadaÅ‚y
swojÄ… listÄ™, wiÄ™c reorganizacja struktury danych nie jest moÅ¼liwa.
Przyjrzyjmy siÄ™ przykÅ‚adowi uÅ¼ywajÄ…cemu grafÃ³w skÅ‚adajÄ…cych siÄ™ z wÄ™zÅ‚Ã³w
rodzicielskich i wÄ™zÅ‚Ã³w potomnych, aby zobaczyÄ‡, kiedy relacje braku wÅ‚asnoÅ›ci
sÄ… odpowiednim sposobem na zapobieganie cyklom referencji.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="preventing-reference-cycles-turning-an-rct-into-a-weakt"></a></p>
<h3 id="zapobieganie-cyklom-referencji-za-pomocÄ…-weakt"><a class="header" href="#zapobieganie-cyklom-referencji-za-pomocÄ…-weakt">Zapobieganie cyklom referencji za pomocÄ… <code>Weak&lt;T&gt;</code></a></h3>
<p>Do tej pory wykazaliÅ›my, Å¼e wywoÅ‚anie <code>Rc::clone</code> zwiÄ™ksza <code>strong_count</code>
instancji <code>Rc&lt;T&gt;</code>, a instancja <code>Rc&lt;T&gt;</code> jest usuwana tylko, jeÅ›li jej
<code>strong_count</code> wynosi 0. MoÅ¼esz rÃ³wnieÅ¼ utworzyÄ‡ sÅ‚abÄ… referencjÄ™ do wartoÅ›ci
w instancji <code>Rc&lt;T&gt;</code>, wywoÅ‚ujÄ…c <code>Rc::downgrade</code> i przekazujÄ…c referencjÄ™ do
<code>Rc&lt;T&gt;</code>. <em>Silne referencje</em> to sposÃ³b na wspÃ³Å‚dzielenie wÅ‚asnoÅ›ci instancji
<code>Rc&lt;T&gt;</code>. <em>SÅ‚abe referencje</em> nie wyraÅ¼ajÄ… relacji wÅ‚asnoÅ›ci, a ich licznik nie
wpÅ‚ywa na to, kiedy instancja <code>Rc&lt;T&gt;</code> jest usuwana. Nie spowodujÄ… one cyklu
referencji, poniewaÅ¼ kaÅ¼dy cykl zawierajÄ…cy sÅ‚abe referencje zostanie przerwany,
gdy silny licznik referencji wartoÅ›ci w nim zaangaÅ¼owanych osiÄ…gnie 0.</p>
<p>Kiedy wywoÅ‚ujesz <code>Rc::downgrade</code>, otrzymujesz wskaÅºnik sprytny typu <code>Weak&lt;T&gt;</code>.
Zamiast zwiÄ™kszaÄ‡ <code>strong_count</code> w instancji <code>Rc&lt;T&gt;</code> o 1, wywoÅ‚anie
<code>Rc::downgrade</code> zwiÄ™ksza <code>weak_count</code> o 1. Typ <code>Rc&lt;T&gt;</code> uÅ¼ywa <code>weak_count</code> do
Å›ledzenia liczby istniejÄ…cych referencji <code>Weak&lt;T&gt;</code>, podobnie jak <code>strong_count</code>.
RÃ³Å¼nica polega na tym, Å¼e <code>weak_count</code> nie musi wynosiÄ‡ 0, aby instancja <code>Rc&lt;T&gt;</code>
zostaÅ‚a usuniÄ™ta.</p>
<p>PoniewaÅ¼ wartoÅ›Ä‡, do ktÃ³rej odwoÅ‚uje siÄ™ <code>Weak&lt;T&gt;</code>, mogÅ‚a zostaÄ‡ usuniÄ™ta, aby
coÅ› zrobiÄ‡ z wartoÅ›ciÄ…, na ktÃ³rÄ… wskazuje <code>Weak&lt;T&gt;</code>, musisz upewniÄ‡ siÄ™, Å¼e
wartoÅ›Ä‡ nadal istnieje. ZrÃ³b to, wywoÅ‚ujÄ…c metodÄ™ <code>upgrade</code> na instancji
<code>Weak&lt;T&gt;</code>, ktÃ³ra zwrÃ³ci <code>Option&lt;Rc&lt;T&gt;&gt;</code>. Otrzymasz wynik <code>Some</code>, jeÅ›li wartoÅ›Ä‡
<code>Rc&lt;T&gt;</code> nie zostaÅ‚a jeszcze usuniÄ™ta, i wynik <code>None</code>, jeÅ›li wartoÅ›Ä‡ <code>Rc&lt;T&gt;</code>
zostaÅ‚a usuniÄ™ta. PoniewaÅ¼ <code>upgrade</code> zwraca <code>Option&lt;Rc&lt;T&gt;&gt;</code>, Rust zapewni,
Å¼e przypadki <code>Some</code> i <code>None</code> zostanÄ… obsÅ‚uÅ¼one, i nie bÄ™dzie nieprawidÅ‚owego
wskaÅºnika.</p>
<p>Jako przykÅ‚ad, zamiast uÅ¼ywaÄ‡ listy, ktÃ³rej elementy wiedzÄ… tylko o nastÄ™pnym
elemencie, stworzymy drzewo, ktÃ³rego elementy wiedzÄ… o swoich elementach
potocznych <em>i</em> swoich elementach nadrzÄ™dnych.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-a-tree-data-structure-a-node-with-child-nodes"></a></p>
<h4 id="tworzenie-struktury-danych-drzewa"><a class="header" href="#tworzenie-struktury-danych-drzewa">Tworzenie struktury danych drzewa</a></h4>
<p>Na poczÄ…tek zbudujemy drzewo z wÄ™zÅ‚ami, ktÃ³re wiedzÄ… o swoich wÄ™zÅ‚ach
potocznych. Stworzymy strukturÄ™ o nazwie <code>Node</code>, ktÃ³ra bÄ™dzie zawieraÅ‚a wÅ‚asnÄ…
wartoÅ›Ä‡ <code>i32</code>, a takÅ¼e referencje do swoich potomnych wÄ™zÅ‚Ã³w <code>Node</code>:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre>
<p>Chcemy, aby <code>Node</code> byÅ‚ wÅ‚aÅ›cicielem swoich dzieci, i chcemy wspÃ³Å‚dzieliÄ‡ tÄ™
wÅ‚asnoÅ›Ä‡ ze zmiennymi, abyÅ›my mogli bezpoÅ›rednio uzyskiwaÄ‡ dostÄ™p do kaÅ¼dego
<code>Node</code> w drzewie. Aby to zrobiÄ‡, definiujemy elementy <code>Vec&lt;T&gt;</code> jako wartoÅ›ci
typu <code>Rc&lt;Node&gt;</code>. Chcemy rÃ³wnieÅ¼ modyfikowaÄ‡, ktÃ³re wÄ™zÅ‚y sÄ… dzieÄ‡mi innego
wÄ™zÅ‚a, wiÄ™c mamy <code>RefCell&lt;T&gt;</code> w <code>children</code> wokÃ³Å‚ <code>Vec&lt;Rc&lt;Node&gt;&gt;</code>.</p>
<p>NastÄ™pnie uÅ¼yjemy naszej definicji struktury i stworzymy jednÄ… instancjÄ™
<code>Node</code> o nazwie <code>leaf</code> z wartoÅ›ciÄ… <code>3</code> i bez dzieci, oraz innÄ… instancjÄ™ o
nazwie <code>branch</code> z wartoÅ›ciÄ… <code>5</code> i <code>leaf</code> jako jedno z jej dzieci, jak pokazano
w Listingu 15-27.</p>
<listing number="15-27" file-name="src/main.rs" caption="Tworzenie wÄ™zÅ‚a `leaf` bez dzieci i wÄ™zÅ‚a `branch` z `leaf` jako jednym z jego dzieci">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}</code></pre>
</listing>
<p>Klonujemy <code>Rc&lt;Node&gt;</code> z <code>leaf</code> i przechowujemy go w <code>branch</code>, co oznacza, Å¼e
<code>Node</code> z <code>leaf</code> ma teraz dwÃ³ch wÅ‚aÅ›cicieli: <code>leaf</code> i <code>branch</code>. MoÅ¼emy przejÅ›Ä‡
od <code>branch</code> do <code>leaf</code> poprzez <code>branch.children</code>, ale nie ma sposobu, aby
przejÅ›Ä‡ od <code>leaf</code> do <code>branch</code>. Powodem jest to, Å¼e <code>leaf</code> nie ma referencji do
<code>branch</code> i nie wie, Å¼e sÄ… ze sobÄ… powiÄ…zane. Chcemy, aby <code>leaf</code> wiedziaÅ‚o,
Å¼e <code>branch</code> jest jego rodzicem. Zrobimy to w nastÄ™pnym kroku.</p>
<h4 id="dodawanie-referencji-od-dziecka-do-jego-rodzica"><a class="header" href="#dodawanie-referencji-od-dziecka-do-jego-rodzica">Dodawanie referencji od dziecka do jego rodzica</a></h4>
<p>Aby wÄ™zeÅ‚ potomny byÅ‚ Å›wiadomy swojego rodzica, musimy dodaÄ‡ pole <code>parent</code> do
definicji naszej struktury <code>Node</code>. Problem polega na podjÄ™ciu decyzji, jaki
typ powinno mieÄ‡ <code>parent</code>. Wiemy, Å¼e nie moÅ¼e zawieraÄ‡ <code>Rc&lt;T&gt;</code>, poniewaÅ¼
stworzyÅ‚oby to cykl referencji, w ktÃ³rym <code>leaf.parent</code> wskazywaÅ‚oby na <code>branch</code>,
a <code>branch.children</code> na <code>leaf</code>, co spowodowaÅ‚oby, Å¼e ich wartoÅ›ci
<code>strong_count</code> nigdy nie byÅ‚yby rÃ³wne 0.</p>
<p>RozwaÅ¼ajÄ…c relacje w inny sposÃ³b, wÄ™zeÅ‚ rodzicielski powinien byÄ‡ wÅ‚aÅ›cicielem
swoich dzieci: JeÅ›li wÄ™zeÅ‚ rodzicielski zostanie usuniÄ™ty, jego wÄ™zÅ‚y potomne
rÃ³wnieÅ¼ powinny zostaÄ‡ usuniÄ™te. Jednak dziecko nie powinno byÄ‡ wÅ‚aÅ›cicielem
swojego rodzica: JeÅ›li usuniemy wÄ™zeÅ‚ potomny, rodzic powinien nadal istnieÄ‡.
To przypadek dla sÅ‚abych referencji!</p>
<p>Tak wiÄ™c, zamiast <code>Rc&lt;T&gt;</code>, typ <code>parent</code> bÄ™dzie uÅ¼ywaÅ‚ <code>Weak&lt;T&gt;</code>, a konkretnie
<code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>. Teraz definicja naszej struktury <code>Node</code> wyglÄ…da
tak:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);
</span><span class="boring">
</span><span class="boring">    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">}</span></code></pre>
<p>WÄ™zeÅ‚ bÄ™dzie mÃ³gÅ‚ odwoÅ‚ywaÄ‡ siÄ™ do swojego wÄ™zÅ‚a rodzicielskiego, ale nie
posiada swojego rodzica. W Listingu 15-28 aktualizujemy <code>main</code>, aby uÅ¼ywaÅ‚ tej
nowej definicji, tak aby wÄ™zeÅ‚ <code>leaf</code> miaÅ‚ sposÃ³b odwoÅ‚ywania siÄ™ do swojego
rodzica, <code>branch</code>.</p>
<listing number="15-28" file-name="src/main.rs" caption="WÄ™zeÅ‚ `leaf` ze sÅ‚abÄ… referencjÄ… do swojego wÄ™zÅ‚a rodzicielskiego, `branch`">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
}</code></pre>
</listing>
<p>Tworzenie wÄ™zÅ‚a <code>leaf</code> wyglÄ…da podobnie do Listingu 15-27, z wyjÄ…tkiem pola
<code>parent</code>: <code>leaf</code> zaczyna bez rodzica, wiÄ™c tworzymy nowÄ…, pustÄ… instancjÄ™
referencji <code>Weak&lt;Node&gt;</code>.</p>
<p>W tym momencie, gdy prÃ³bujemy uzyskaÄ‡ referencjÄ™ do rodzica <code>leaf</code> za pomocÄ…
metody <code>upgrade</code>, otrzymujemy wartoÅ›Ä‡ <code>None</code>. Widzimy to w wynikach pierwszej
instrukcji <code>println!</code>:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>Kiedy tworzymy wÄ™zeÅ‚ <code>branch</code>, bÄ™dzie on rÃ³wnieÅ¼ miaÅ‚ nowÄ… referencjÄ™ <code>Weak&lt;Node&gt;</code>
w polu <code>parent</code>, poniewaÅ¼ <code>branch</code> nie ma wÄ™zÅ‚a rodzicielskiego. Nadal mamy
<code>leaf</code> jako jedno z dzieci <code>branch</code>. Gdy juÅ¼ mamy instancjÄ™ <code>Node</code> w <code>branch</code>,
moÅ¼emy zmodyfikowaÄ‡ <code>leaf</code>, aby nadaÄ‡ mu referencjÄ™ <code>Weak&lt;Node&gt;</code> do jego rodzica.
UÅ¼ywamy metody <code>borrow_mut</code> w <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> w polu <code>parent</code> wÄ™zÅ‚a <code>leaf</code>,
a nastÄ™pnie uÅ¼ywamy funkcji <code>Rc::downgrade</code> do stworzenia referencji <code>Weak&lt;Node&gt;</code>
do <code>branch</code> z <code>Rc&lt;Node&gt;</code> w <code>branch</code>.</p>
<p>Kiedy ponownie wypiszemy rodzica <code>leaf</code>, tym razem otrzymamy wariant <code>Some</code>
przechowujÄ…cy <code>branch</code>: Teraz <code>leaf</code> moÅ¼e uzyskaÄ‡ dostÄ™p do swojego rodzica!
Gdy wypiszemy <code>leaf</code>, unikamy rÃ³wnieÅ¼ cyklu, ktÃ³ry ostatecznie zakoÅ„czyÅ‚ siÄ™
przepeÅ‚nieniem stosu, jak to miaÅ‚o miejsce w Listingu 15-26; referencje
<code>Weak&lt;Node&gt;</code> sÄ… wypisywane jako <code>(Weak)</code>:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>Brak nieskoÅ„czonego wyniku wskazuje, Å¼e ten kod nie stworzyÅ‚ cyklu referencji.
MoÅ¼emy to rÃ³wnieÅ¼ stwierdziÄ‡, patrzÄ…c na wartoÅ›ci, ktÃ³re otrzymujemy po
wywoÅ‚aniu <code>Rc::strong_count</code> i <code>Rc::weak_count</code>.</p>
<h4 id="wizualizacja-zmian-w-strong_count-i-weak_count"><a class="header" href="#wizualizacja-zmian-w-strong_count-i-weak_count">Wizualizacja zmian w <code>strong_count</code> i <code>weak_count</code></a></h4>
<p>SpÃ³jrzmy, jak zmieniajÄ… siÄ™ wartoÅ›ci <code>strong_count</code> i <code>weak_count</code> instancji
<code>Rc&lt;Node&gt;</code>, tworzÄ…c nowy wewnÄ™trzny zakres i przenoszÄ…c tworzenie <code>branch</code> do
tego zakresu. W ten sposÃ³b moÅ¼emy zobaczyÄ‡, co dzieje siÄ™, gdy <code>branch</code> jest
tworzone, a nastÄ™pnie usuwane, gdy wyjdzie poza zakres. Modyfikacje pokazano
w Listingu 15-29.</p>
<listing number="15-29" file-name="src/main.rs" caption="Tworzenie `branch` w wewnÄ™trznym zakresie i badanie licznikÃ³w silnych i sÅ‚abych referencji">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}</code></pre>
</listing>
<p>Po utworzeniu <code>leaf</code>, jego <code>Rc&lt;Node&gt;</code> ma silny licznik rÃ³wny 1 i sÅ‚aby licznik
rÃ³wny 0. W wewnÄ™trznym zakresie tworzymy <code>branch</code> i kojarzymy go z <code>leaf</code>, po
czym, gdy wypiszemy liczniki, <code>Rc&lt;Node&gt;</code> w <code>branch</code> bÄ™dzie miaÅ‚o silny licznik
rÃ³wny 1 i sÅ‚aby licznik rÃ³wny 1 (dla <code>leaf.parent</code> wskazujÄ…cego na <code>branch</code> za
pomocÄ… <code>Weak&lt;Node&gt;</code>). Kiedy wypiszemy liczniki w <code>leaf</code>, zobaczymy, Å¼e bÄ™dzie
miaÅ‚o silny licznik rÃ³wny 2, poniewaÅ¼ <code>branch</code> ma teraz klon <code>Rc&lt;Node&gt;</code> z <code>leaf</code>
przechowywany w <code>branch.children</code>, ale nadal bÄ™dzie miaÅ‚o sÅ‚aby licznik rÃ³wny
0.</p>
<p>Kiedy wewnÄ™trzny zakres siÄ™ koÅ„czy, <code>branch</code> wychodzi poza zakres, a silny
licznik <code>Rc&lt;Node&gt;</code> zmniejsza siÄ™ do 0, wiÄ™c jego <code>Node</code> zostaje usuniÄ™ty.
SÅ‚aby licznik rÃ³wny 1 z <code>leaf.parent</code> nie ma wpÅ‚ywu na to, czy <code>Node</code> jest
usuwany, wiÄ™c nie mamy wyciekÃ³w pamiÄ™ci!</p>
<p>JeÅ›li sprÃ³bujemy uzyskaÄ‡ dostÄ™p do rodzica <code>leaf</code> po zakoÅ„czeniu zakresu,
ponownie otrzymamy <code>None</code>. Na koÅ„cu programu <code>Rc&lt;Node&gt;</code> w <code>leaf</code> ma silny
licznik rÃ³wny 1 i sÅ‚aby licznik rÃ³wny 0, poniewaÅ¼ zmienna <code>leaf</code> jest teraz
ponownie jedynÄ… referencjÄ… do <code>Rc&lt;Node&gt;</code>.</p>
<p>Wszystkie logiki zarzÄ…dzajÄ…ce licznikami i usuwaniem wartoÅ›ci sÄ… wbudowane w
<code>Rc&lt;T&gt;</code> i <code>Weak&lt;T&gt;</code> oraz ich implementacje cechy <code>Drop</code>. OkreÅ›lajÄ…c, Å¼e
relacja od dziecka do rodzica powinna byÄ‡ referencjÄ… <code>Weak&lt;T&gt;</code> w definicji
<code>Node</code>, jesteÅ› w stanie sprawiÄ‡, Å¼e wÄ™zÅ‚y rodzicielskie wskazujÄ… na wÄ™zÅ‚y
potoczne i vice versa bez tworzenia cyklu referencji i wyciekÃ³w pamiÄ™ci.</p>
<h2 id="podsumowanie-14"><a class="header" href="#podsumowanie-14">Podsumowanie</a></h2>
<p>Ten rozdziaÅ‚ omÃ³wiÅ‚, jak uÅ¼ywaÄ‡ wskaÅºnikÃ³w sprytnych, aby uzyskaÄ‡ rÃ³Å¼ne
gwarancje i kompromisy w porÃ³wnaniu do tych, ktÃ³re Rust domyÅ›lnie zapewnia ze
zwykÅ‚ymi referencjami. Typ <code>Box&lt;T&gt;</code> ma znany rozmiar i wskazuje na dane
alokowane na stercie. Typ <code>Rc&lt;T&gt;</code> Å›ledzi liczbÄ™ referencji do danych na stercie,
tak aby dane mogÅ‚y mieÄ‡ wielu wÅ‚aÅ›cicieli. Typ <code>RefCell&lt;T&gt;</code> ze swojÄ…
mutowalnoÅ›ciÄ… wewnÄ™trznÄ… daje nam typ, ktÃ³rego moÅ¼emy uÅ¼ywaÄ‡, gdy potrzebujemy
nimutowalnego typu, ale musimy zmieniÄ‡ wewnÄ™trznÄ… wartoÅ›Ä‡ tego typu; egzekwuje
on rÃ³wnieÅ¼ zasady poÅ¼yczania w czasie wykonania zamiast w czasie kompilacji.</p>
<p>OmÃ³wiono rÃ³wnieÅ¼ cechy <code>Deref</code> i <code>Drop</code>, ktÃ³re umoÅ¼liwiajÄ… wiele funkcjonalnoÅ›ci
wskaÅºnikÃ³w sprytnych. ZbadaliÅ›my cykle referencji, ktÃ³re mogÄ… powodowaÄ‡ wycieki
pamiÄ™ci, i jak im zapobiegaÄ‡ za pomocÄ… <code>Weak&lt;T&gt;</code>.</p>
<p>JeÅ›li ten rozdziaÅ‚ wzbudziÅ‚ Twoje zainteresowanie i chcesz zaimplementowaÄ‡
wÅ‚asne wskaÅºniki sprytne, zajrzyj do <a href="../nomicon/index.html">â€The Rustonomiconâ€</a> po wiÄ™cej
przydatnych informacji.</p>
<p>NastÄ™pnie bÄ™dziemy rozmawiaÄ‡ o wspÃ³Å‚bieÅ¼noÅ›ci w Rust. Nauczysz siÄ™ nawet kilku
nowych wskaÅºnikÃ³w sprytnych.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="bezpieczna-wspÃ³Å‚bieÅ¼noÅ›Ä‡"><a class="header" href="#bezpieczna-wspÃ³Å‚bieÅ¼noÅ›Ä‡">Bezpieczna wspÃ³Å‚bieÅ¼noÅ›Ä‡</a></h1>
<p>Bezpieczne i efektywne zarzÄ…dzanie programowaniem wspÃ³Å‚bieÅ¼nym to kolejny z
gÅ‚Ã³wnych celÃ³w Rust. <em>Programowanie wspÃ³Å‚bieÅ¼ne</em>, w ktÃ³rym rÃ³Å¼ne czÄ™Å›ci programu
wykonujÄ… siÄ™ niezaleÅ¼nie, oraz <em>programowanie rÃ³wnolegÅ‚e</em>, w ktÃ³rym rÃ³Å¼ne czÄ™Å›ci
programu wykonujÄ… siÄ™ w tym samym czasie, stajÄ… siÄ™ coraz waÅ¼niejsze, poniewaÅ¼
coraz wiÄ™cej komputerÃ³w wykorzystuje swoje wieloprocesorowe moÅ¼liwoÅ›ci.
Historycznie programowanie w tych kontekstach byÅ‚o trudne i podatne na bÅ‚Ä™dy.
Rust ma nadziejÄ™ to zmieniÄ‡.</p>
<p>PoczÄ…tkowo zespÃ³Å‚ Rust uwaÅ¼aÅ‚, Å¼e zapewnienie bezpieczeÅ„stwa pamiÄ™ci i
zapobieganie problemom wspÃ³Å‚bieÅ¼noÅ›ci to dwa oddzielne wyzwania do rozwiÄ…zania
rÃ³Å¼nymi metodami. Z czasem zespÃ³Å‚ odkryÅ‚, Å¼e systemy wÅ‚asnoÅ›ci i typÃ³w to
potÄ™Å¼ny zestaw narzÄ™dzi pomagajÄ…cych zarzÄ…dzaÄ‡ zarÃ³wno bezpieczeÅ„stwem pamiÄ™ci,
jak i problemami wspÃ³Å‚bieÅ¼noÅ›ci! DziÄ™ki wykorzystaniu wÅ‚asnoÅ›ci i sprawdzania
typÃ³w, wiele bÅ‚Ä™dÃ³w wspÃ³Å‚bieÅ¼noÅ›ci w Rust to bÅ‚Ä™dy kompilacji, a nie bÅ‚Ä™dy
czasu wykonania. Dlatego, zamiast zmuszaÄ‡ CiÄ™ do spÄ™dzania wielu godzin na
prÃ³bach odtworzenia dokÅ‚adnych okolicznoÅ›ci, w ktÃ³rych wystÄ™puje bÅ‚Ä…d
wspÃ³Å‚bieÅ¼noÅ›ci w czasie wykonania, niepoprawny kod odmÃ³wi kompilacji i
wyÅ›wietli bÅ‚Ä…d wyjaÅ›niajÄ…cy problem. W rezultacie moÅ¼esz naprawiÄ‡ swÃ³j kod
podczas pracy nad nim, a nie potencjalnie po jego wdroÅ¼eniu do produkcji.
NazwaliÅ›my ten aspekt Rust <em>bezpiecznÄ… wspÃ³Å‚bieÅ¼noÅ›ciÄ…</em>. Bezpieczna
wspÃ³Å‚bieÅ¼noÅ›Ä‡ pozwala pisaÄ‡ kod wolny od subtelnych bÅ‚Ä™dÃ³w i Å‚atwy do
refaktoryzacji bez wprowadzania nowych bÅ‚Ä™dÃ³w.</p>
<blockquote>
<p>Uwaga: Dla uproszczenia bÄ™dziemy odnosiÄ‡ siÄ™ do wielu problemÃ³w jako
<em>wspÃ³Å‚bieÅ¼nych</em>, zamiast byÄ‡ bardziej precyzyjnym, mÃ³wiÄ…c <em>wspÃ³Å‚bieÅ¼nych i/lub
rÃ³wnolegÅ‚ych</em>. W tym rozdziale proszÄ™ mentalnie zastÄ™powaÄ‡ <em>wspÃ³Å‚bieÅ¼nych
i/lub rÃ³wnolegÅ‚ych</em> za kaÅ¼dym razem, gdy uÅ¼ywamy <em>wspÃ³Å‚bieÅ¼nych</em>. W nastÄ™pnym
rozdziale, gdzie rozrÃ³Å¼nienie ma wiÄ™ksze znaczenie, bÄ™dziemy bardziej
precyzyjni.</p>
</blockquote>
<p>Wiele jÄ™zykÃ³w jest dogmatycznych w kwestii rozwiÄ…zaÅ„, ktÃ³re oferujÄ… do
obsÅ‚ugi problemÃ³w wspÃ³Å‚bieÅ¼noÅ›ci. Na przykÅ‚ad, Erlang ma eleganckÄ…
funkcjonalnoÅ›Ä‡ dla wspÃ³Å‚bieÅ¼noÅ›ci opartej na przekazywaniu wiadomoÅ›ci, ale
ma tylko niejasne sposoby udostÄ™pniania stanu miÄ™dzy wÄ…tkami. ObsÅ‚ugiwanie
tylko podzbioru moÅ¼liwych rozwiÄ…zaÅ„ jest rozsÄ…dnÄ… strategiÄ… dla jÄ™zykÃ³w
wyÅ¼szego poziomu, poniewaÅ¼ jÄ™zyk wyÅ¼szego poziomu obiecuje korzyÅ›ci z
oddawania czÄ™Å›ci kontroli w zamian za abstrakcje. Jednak od jÄ™zykÃ³w niÅ¼szego
poziomu oczekuje siÄ™, Å¼e zapewniÄ… rozwiÄ…zanie o najlepszej wydajnoÅ›ci w kaÅ¼dej
danej sytuacji i bÄ™dÄ… miaÅ‚y mniej abstrakcji nad sprzÄ™tem. Dlatego Rust
oferuje rÃ³Å¼norodne narzÄ™dzia do modelowania problemÃ³w w sposÃ³b odpowiedni dla
twojej sytuacji i wymagaÅ„.</p>
<p>Oto tematy, ktÃ³re omÃ³wimy w tym rozdziale:</p>
<ul>
<li>Jak tworzyÄ‡ wÄ…tki do jednoczesnego uruchamiania wielu fragmentÃ³w kodu</li>
<li>WspÃ³Å‚bieÅ¼noÅ›Ä‡ oparta na <em>przekazywaniu wiadomoÅ›ci</em>, gdzie kanaÅ‚y wysyÅ‚ajÄ…
wiadomoÅ›ci miÄ™dzy wÄ…tkami</li>
<li>WspÃ³Å‚bieÅ¼noÅ›Ä‡ oparta na <em>wspÃ³Å‚dzielonym stanie</em>, gdzie wiele wÄ…tkÃ³w ma
dostÄ™p do pewnej czÄ™Å›ci danych</li>
<li>Cechy <code>Sync</code> i <code>Send</code>, ktÃ³re rozszerzajÄ… gwarancje wspÃ³Å‚bieÅ¼noÅ›ci Rust na
typy zdefiniowane przez uÅ¼ytkownika, a takÅ¼e na typy dostarczane przez
bibliotekÄ™ standardowÄ…</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="uÅ¼ywanie-wÄ…tkÃ³w-do-jednoczesnego-uruchamiania-kodu-1"><a href="#uÅ¼ywanie-wÄ…tkÃ³w-do-jednoczesnego-uruchamiania-kodu-1" class="header">UÅ¼ywanie wÄ…tkÃ³w do jednoczesnego uruchamiania kodu</a></h1>
<h2 id="uÅ¼ywanie-wÄ…tkÃ³w-do-jednoczesnego-uruchamiania-kodu"><a class="header" href="#uÅ¼ywanie-wÄ…tkÃ³w-do-jednoczesnego-uruchamiania-kodu">UÅ¼ywanie wÄ…tkÃ³w do jednoczesnego uruchamiania kodu</a></h2>
<p>W wiÄ™kszoÅ›ci obecnych systemÃ³w operacyjnych kod wykonywanego programu dziaÅ‚a w
<em>procesie</em>, a system operacyjny zarzÄ…dza wieloma procesami jednoczeÅ›nie.
WewnÄ…trz programu moÅ¼esz mieÄ‡ rÃ³wnieÅ¼ niezaleÅ¼ne czÄ™Å›ci, ktÃ³re dziaÅ‚ajÄ…
jednoczeÅ›nie. Funkcje, ktÃ³re uruchamiajÄ… te niezaleÅ¼ne czÄ™Å›ci, nazywane sÄ…
<em>wÄ…tkami</em>. Na przykÅ‚ad, serwer webowy moÅ¼e mieÄ‡ wiele wÄ…tkÃ³w, aby mÃ³gÅ‚
jednoczeÅ›nie odpowiadaÄ‡ na wiÄ™cej niÅ¼ jedno Å¼Ä…danie.</p>
<p>Podzielenie obliczeÅ„ w programie na wiele wÄ…tkÃ³w w celu jednoczesnego
uruchamiania wielu zadaÅ„ moÅ¼e poprawiÄ‡ wydajnoÅ›Ä‡, ale takÅ¼e zwiÄ™ksza
zÅ‚oÅ¼onoÅ›Ä‡. PoniewaÅ¼ wÄ…tki mogÄ… dziaÅ‚aÄ‡ jednoczeÅ›nie, nie ma inherentnej
gwarancji co do kolejnoÅ›ci, w jakiej bÄ™dÄ… dziaÅ‚aÄ‡ czÄ™Å›ci kodu na rÃ³Å¼nych
wÄ…tkach. MoÅ¼e to prowadziÄ‡ do problemÃ³w, takich jak:</p>
<ul>
<li>WyÅ›cigi danych, w ktÃ³rych wÄ…tki uzyskujÄ… dostÄ™p do danych lub zasobÃ³w w
niekonsekwentnej kolejnoÅ›ci</li>
<li>Zakleszczenia, w ktÃ³rych dwa wÄ…tki czekajÄ… na siebie nawzajem, uniemoÅ¼liwiajÄ…c
kontynuowanie obu wÄ…tkÃ³w</li>
<li>BÅ‚Ä™dy, ktÃ³re wystÄ™pujÄ… tylko w okreÅ›lonych sytuacjach i sÄ… trudne do
niezawodnego odtworzenia i naprawy</li>
</ul>
<p>Rust prÃ³buje zÅ‚agodziÄ‡ negatywne skutki uÅ¼ywania wÄ…tkÃ³w, ale programowanie w
kontekÅ›cie wielowÄ…tkowym nadal wymaga starannego przemyÅ›lenia i innej
struktury kodu niÅ¼ w programach dziaÅ‚ajÄ…cych w pojedynczym wÄ…tku.</p>
<p>JÄ™zyki programowania implementujÄ… wÄ…tki na kilka rÃ³Å¼nych sposobÃ³w, a wiele
systemÃ³w operacyjnych zapewnia API, ktÃ³re jÄ™zyk programowania moÅ¼e wywoÅ‚ywaÄ‡
w celu tworzenia nowych wÄ…tkÃ³w. Biblioteka standardowa Rust uÅ¼ywa modelu
implementacji wÄ…tkÃ³w <em>1:1</em>, w ktÃ³rym program uÅ¼ywa jednego wÄ…tku systemu
operacyjnego na jeden wÄ…tek jÄ™zykowy. IstniejÄ… crateâ€™y, ktÃ³re implementujÄ…
inne modele wÄ…tkowania, ktÃ³re dokonujÄ… innych kompromisÃ³w w stosunku do modelu
1:1. (System asynchroniczny Rust, ktÃ³ry zobaczymy w nastÄ™pnym rozdziale,
zapewnia rÃ³wnieÅ¼ inne podejÅ›cie do wspÃ³Å‚bieÅ¼noÅ›ci.)</p>
<h3 id="tworzenie-nowego-wÄ…tku-za-pomocÄ…-spawn"><a class="header" href="#tworzenie-nowego-wÄ…tku-za-pomocÄ…-spawn">Tworzenie nowego wÄ…tku za pomocÄ… <code>spawn</code></a></h3>
<p>Aby utworzyÄ‡ nowy wÄ…tek, wywoÅ‚ujemy funkcjÄ™ <code>thread::spawn</code> i przekazujemy jej
domkniÄ™cie (o domkniÄ™ciach mÃ³wiliÅ›my w Rozdziale 13) zawierajÄ…ce kod, ktÃ³ry
chcemy uruchomiÄ‡ w nowym wÄ…tku. PrzykÅ‚ad w Listingu 16-1 wypisuje tekst z
gÅ‚Ã³wnego wÄ…tku i inny tekst z nowego wÄ…tku.</p>
<listing number="16-1" file-name="src/main.rs" caption="Tworzenie nowego wÄ…tku do wypisania jednej rzeczy, podczas gdy gÅ‚Ã³wny wÄ…tek wypisuje coÅ› innego">
<pre class="playground"><code class="language-rust edition2024">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre>
</listing>
<p>ZauwaÅ¼, Å¼e gdy gÅ‚Ã³wny wÄ…tek programu Rust zakoÅ„czy dziaÅ‚anie, wszystkie
utworzone wÄ…tki zostajÄ… wyÅ‚Ä…czone, niezaleÅ¼nie od tego, czy zakoÅ„czyÅ‚y
dziaÅ‚anie. Wynik tego programu moÅ¼e byÄ‡ za kaÅ¼dym razem nieco inny, ale bÄ™dzie
wyglÄ…daÅ‚ podobnie do nastÄ™pujÄ…cego:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<p>WywoÅ‚ania <code>thread::sleep</code> zmuszajÄ… wÄ…tek do zatrzymania jego wykonania na krÃ³tki
okres, pozwalajÄ…c na uruchomienie innego wÄ…tku. WÄ…tki prawdopodobnie bÄ™dÄ…
dziaÅ‚aÄ‡ naprzemiennie, ale nie jest to gwarantowane: ZaleÅ¼y to od tego, jak
system operacyjny planuje wÄ…tki. W tym uruchomieniu gÅ‚Ã³wny wÄ…tek wypisaÅ‚ siÄ™
jako pierwszy, mimo Å¼e instrukcja <code>print</code> z utworzonego wÄ…tku pojawia siÄ™
pierwsza w kodzie. I chociaÅ¼ kazaliÅ›my utworzonemu wÄ…tkowi wypisywaÄ‡, dopÃ³ki <code>i</code>
nie bÄ™dzie rÃ³wne <code>9</code>, doszedÅ‚ tylko do <code>5</code>, zanim gÅ‚Ã³wny wÄ…tek siÄ™
wyÅ‚Ä…czyÅ‚.</p>
<p>JeÅ›li uruchomisz ten kod i zobaczysz tylko wynik z gÅ‚Ã³wnego wÄ…tku, lub nie
zobaczysz Å¼adnych nakÅ‚adek, sprÃ³buj zwiÄ™kszyÄ‡ liczby w zakresach, aby stworzyÄ‡
wiÄ™cej moÅ¼liwoÅ›ci dla systemu operacyjnego do przeÅ‚Ä…czania miÄ™dzy wÄ…tkami.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="waiting-for-all-threads-to-finish-using-join-handles"></a></p>
<h3 id="czekanie-na-zakoÅ„czenie-wszystkich-wÄ…tkÃ³w"><a class="header" href="#czekanie-na-zakoÅ„czenie-wszystkich-wÄ…tkÃ³w">Czekanie na zakoÅ„czenie wszystkich wÄ…tkÃ³w</a></h3>
<p>Kod z Listingu 16-1 nie tylko zatrzymuje utworzony wÄ…tek przedwczeÅ›nie w
w wiÄ™kszoÅ›ci przypadkÃ³w z powodu zakoÅ„czenia gÅ‚Ã³wnego wÄ…tku, ale poniewaÅ¼ nie
ma gwarancji co do kolejnoÅ›ci, w jakiej wÄ…tki dziaÅ‚ajÄ…, nie moÅ¼emy rÃ³wnieÅ¼
zagwarantowaÄ‡, Å¼e utworzony wÄ…tek w ogÃ³le siÄ™ uruchomi!</p>
<p>Problem przedwczesnego zakoÅ„czenia lub braku uruchomienia utworzonego wÄ…tku
moÅ¼emy naprawiÄ‡, zapisujÄ…c wartoÅ›Ä‡ zwracanÄ… przez <code>thread::spawn</code> w zmiennej.
Typem zwracanym przez <code>thread::spawn</code> jest <code>JoinHandle&lt;T&gt;</code>. <code>JoinHandle&lt;T&gt;</code>
jest wartoÅ›ciÄ… wÅ‚asnoÅ›ciowÄ…, ktÃ³ra po wywoÅ‚aniu na niej metody <code>join</code> bÄ™dzie
czekaÅ‚a na zakoÅ„czenie swojego wÄ…tku. Listing 16-2 pokazuje, jak uÅ¼yÄ‡
<code>JoinHandle&lt;T&gt;</code> z utworzonego w Listingu 16-1 wÄ…tku i jak wywoÅ‚aÄ‡ <code>join</code>, aby
upewniÄ‡ siÄ™, Å¼e utworzony wÄ…tek zakoÅ„czy siÄ™ przed zakoÅ„czeniem <code>main</code>.</p>
<listing number="16-2" file-name="src/main.rs" caption="Zapisywanie `JoinHandle&lt;T&gt;` z `thread::spawn` w celu zagwarantowania, Å¼e wÄ…tek zostanie uruchomiony do koÅ„ca">
<pre class="playground"><code class="language-rust edition2024">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}</code></pre>
</listing>
<p>WywoÅ‚anie <code>join</code> na uchwycie blokuje aktualnie dziaÅ‚ajÄ…cy wÄ…tek, uniemoÅ¼liwiajÄ…c
mu wykonywanie pracy lub zakoÅ„czenie, dopÃ³ki wÄ…tek reprezentowany przez uchwyt
siÄ™ nie zakoÅ„czy. <em>Blokowanie</em> wÄ…tku oznacza, Å¼e wÄ…tek jest uniemoÅ¼liwiony
wykonanie pracy lub wyjÅ›cia. PoniewaÅ¼ umieÅ›ciliÅ›my wywoÅ‚anie <code>join</code> po pÄ™tli
<code>for</code> gÅ‚Ã³wnego wÄ…tku, uruchomienie Listingu 16-2 powinno wygenerowaÄ‡ wynik
podobny do tego:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<p>Dwa wÄ…tki nadal dziaÅ‚ajÄ… naprzemiennie, ale gÅ‚Ã³wny wÄ…tek czeka z powodu wywoÅ‚ania
<code>handle.join()</code> i nie koÅ„czy dziaÅ‚ania, dopÃ³ki utworzony wÄ…tek siÄ™ nie
zakoÅ„czy.</p>
<p>Ale zobaczmy, co siÄ™ stanie, gdy zamiast tego przeniesiemy <code>handle.join()</code> przed
pÄ™tlÄ™ <code>for</code> w <code>main</code>, tak:</p>
<listing file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre>
</listing>
<p>GÅ‚Ã³wny wÄ…tek poczeka na zakoÅ„czenie utworzonego wÄ…tku, a nastÄ™pnie uruchomi
swojÄ… pÄ™tlÄ™ <code>for</code>, wiÄ™c wyniki nie bÄ™dÄ… juÅ¼ przeplatane, jak pokazano
tutaj:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<p>MaÅ‚e detale, takie jak miejsce wywoÅ‚ania <code>join</code>, mogÄ… wpÅ‚ywaÄ‡ na to, czy wÄ…tki
dziaÅ‚ajÄ… jednoczeÅ›nie.</p>
<h3 id="uÅ¼ywanie-domkniÄ™Ä‡-move-z-wÄ…tkami"><a class="header" href="#uÅ¼ywanie-domkniÄ™Ä‡-move-z-wÄ…tkami">UÅ¼ywanie domkniÄ™Ä‡ <code>move</code> z wÄ…tkami</a></h3>
<p>CzÄ™sto bÄ™dziemy uÅ¼ywaÄ‡ sÅ‚owa kluczowego <code>move</code> z domkniÄ™ciami przekazywanymi do
<code>thread::spawn</code>, poniewaÅ¼ domkniÄ™cie przejmie wtedy wÅ‚asnoÅ›Ä‡ wartoÅ›ci, ktÃ³rych
uÅ¼ywa ze Å›rodowiska, przenoszÄ…c w ten sposÃ³b wÅ‚asnoÅ›Ä‡ tych wartoÅ›ci z jednego
wÄ…tku do drugiego. W sekcji <a href="#capturing-references-or-moving-ownership">â€Przechwytywanie referencji lub przenoszenie
wÅ‚asnoÅ›ciâ€</a><!-- ignore --> w Rozdziale 13 omÃ³wiliÅ›my <code>move</code> w kontekÅ›cie
domkniÄ™Ä‡. Teraz skupimy siÄ™ bardziej na interakcji miÄ™dzy <code>move</code> a
<code>thread::spawn</code>.</p>
<p>ZauwaÅ¼ w Listingu 16-1, Å¼e domkniÄ™cie, ktÃ³re przekazujemy do <code>thread::spawn</code>,
nie przyjmuje Å¼adnych argumentÃ³w: Nie uÅ¼ywamy Å¼adnych danych z gÅ‚Ã³wnego wÄ…tku
w kodzie utworzonego wÄ…tku. Aby uÅ¼yÄ‡ danych z gÅ‚Ã³wnego wÄ…tku w utworzonym
wÄ…tku, domkniÄ™cie utworzonego wÄ…tku musi przechwyciÄ‡ wartoÅ›ci, ktÃ³rych
potrzebuje. Listing 16-3 pokazuje prÃ³bÄ™ utworzenia wektora w gÅ‚Ã³wnym wÄ…tku i
uÅ¼ycia go w utworzonym wÄ…tku. Jednak to jeszcze nie zadziaÅ‚a, jak zobaczysz za
chwilÄ™.</p>
<listing number="16-3" file-name="src/main.rs" caption="PrÃ³ba uÅ¼ycia wektora utworzonego przez gÅ‚Ã³wny wÄ…tek w innym wÄ…tku">
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {v:?}");
    });

    handle.join().unwrap();
}</code></pre>
</listing>
<p>DomkniÄ™cie uÅ¼ywa <code>v</code>, wiÄ™c przechwyci <code>v</code> i uczyni je czÄ™Å›ciÄ… Å›rodowiska
domkniÄ™cia. PoniewaÅ¼ <code>thread::spawn</code> uruchamia to domkniÄ™cie w nowym wÄ…tku,
powinniÅ›my mieÄ‡ dostÄ™p do <code>v</code> w tym nowym wÄ…tku. Ale kiedy kompilujemy ten
przykÅ‚ad, otrzymujemy nastÄ™pujÄ…cy bÅ‚Ä…d:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!("Here's a vector: {v:?}");
  |                                     - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!("Here's a vector: {v:?}");
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` (bin "threads") due to 1 previous error
</code></pre>
<p>Rust <em>wnioskuje</em>, jak przechwyciÄ‡ <code>v</code>, a poniewaÅ¼ <code>println!</code> potrzebuje tylko
referencji do <code>v</code>, domkniÄ™cie prÃ³buje poÅ¼yczyÄ‡ <code>v</code>. Jest jednak problem: Rust
nie jest w stanie okreÅ›liÄ‡, jak dÅ‚ugo bÄ™dzie dziaÅ‚aÄ‡ utworzony wÄ…tek, wiÄ™c nie
wie, czy referencja do <code>v</code> zawsze bÄ™dzie waÅ¼na.</p>
<p>Listing 16-4 przedstawia scenariusz, w ktÃ³rym referencja do <code>v</code> z wiÄ™kszym
prawdopodobieÅ„stwem nie bÄ™dzie waÅ¼na.</p>
<listing number="16-4" file-name="src/main.rs" caption="WÄ…tek z domkniÄ™ciem, ktÃ³re prÃ³buje przechwyciÄ‡ referencjÄ™ do `v` z gÅ‚Ã³wnego wÄ…tku, ktÃ³ry usuwa `v`">
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {v:?}");
    });

    drop(v); // oh no!

    handle.join().unwrap();
}</code></pre>
</listing>
<p>Gdyby Rust pozwoliÅ‚ nam uruchomiÄ‡ ten kod, istniaÅ‚aby moÅ¼liwoÅ›Ä‡, Å¼e utworzony
wÄ…tek zostaÅ‚by natychmiast przeniesiony do tÅ‚a bez uruchomienia. Utworzony
wÄ…tek ma w Å›rodku referencjÄ™ do <code>v</code>, ale gÅ‚Ã³wny wÄ…tek natychmiast usuwa <code>v</code>
uÅ¼ywajÄ…c funkcji <code>drop</code>, ktÃ³rÄ… omÃ³wiliÅ›my w Rozdziale 15. Wtedy, gdy
utworzony wÄ…tek zacznie siÄ™ wykonywaÄ‡, <code>v</code> nie jest juÅ¼ waÅ¼ne, wiÄ™c referencja
do niego rÃ³wnieÅ¼ jest niewaÅ¼na. Och nie!</p>
<p>Aby naprawiÄ‡ bÅ‚Ä…d kompilacji w Listingu 16-3, moÅ¼emy skorzystaÄ‡ z porady z
komunikatu o bÅ‚Ä™dzie:</p>
<!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
-->
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
</code></pre>
<p>DodajÄ…c sÅ‚owo kluczowe <code>move</code> przed domkniÄ™ciem, zmuszamy domkniÄ™cie do
przejÄ™cia wÅ‚asnoÅ›ci wartoÅ›ci, ktÃ³rych uÅ¼ywa, zamiast pozwalaÄ‡ Rustowi
wnioskowaÄ‡, Å¼e powinno ono poÅ¼yczyÄ‡ te wartoÅ›ci. Modyfikacja Listingu 16-3
przedstawiona w Listingu 16-5 skompiluje siÄ™ i zadziaÅ‚a zgodnie z naszym
zamierzeniem.</p>
<listing number="16-5" file-name="src/main.rs" caption="UÅ¼ycie sÅ‚owa kluczowego `move`, aby zmusiÄ‡ domkniÄ™cie do przejÄ™cia wÅ‚asnoÅ›ci uÅ¼ywanych wartoÅ›ci">
<pre class="playground"><code class="language-rust edition2024">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {v:?}");
    });

    handle.join().unwrap();
}</code></pre>
</listing>
<p>MoÅ¼emy byÄ‡ kuszeni, aby sprÃ³bowaÄ‡ tego samego, aby naprawiÄ‡ kod z Listingu
16-4, gdzie gÅ‚Ã³wny wÄ…tek wywoÅ‚aÅ‚ <code>drop</code> za pomocÄ… domkniÄ™cia <code>move</code>. JednakÅ¼e,
ta poprawka nie zadziaÅ‚a, poniewaÅ¼ to, co Listing 16-4 prÃ³buje zrobiÄ‡, jest
niedozwolone z innego powodu. GdybyÅ›my dodali <code>move</code> do domkniÄ™cia,
przenieÅ›libyÅ›my <code>v</code> do Å›rodowiska domkniÄ™cia i nie moglibyÅ›my juÅ¼ wywoÅ‚ywaÄ‡ na
<code>v</code> <code>drop</code> w gÅ‚Ã³wnym wÄ…tku. Zamiast tego otrzymalibyÅ›my bÅ‚Ä…d kompilacji:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
 4 |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
 5 |
 6 |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
 7 |         println!("Here's a vector: {v:?}");
   |                                     - variable moved due to use in closure
...
10 |     drop(v); // oh no!
   |          ^ value used here after move
   |
help: consider cloning the value before moving it into the closure
   |
 6 ~     let value = v.clone();
 7 ~     let handle = thread::spawn(move || {
 8 ~         println!("Here's a vector: {value:?}");
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads` (bin "threads") due to 1 previous error
</code></pre>
<p>Zasady wÅ‚asnoÅ›ci Rust znÃ³w nas uratowaÅ‚y! OtrzymaliÅ›my bÅ‚Ä…d z kodu w Listingu
16-3, poniewaÅ¼ Rust byÅ‚ konserwatywny i tylko poÅ¼yczaÅ‚ <code>v</code> dla wÄ…tku, co
oznaczaÅ‚o, Å¼e gÅ‚Ã³wny wÄ…tek teoretycznie mÃ³gÅ‚by uniewaÅ¼niÄ‡ referencjÄ™
utworzonego wÄ…tku. MÃ³wiÄ…c Rustowi, aby przeniÃ³sÅ‚ wÅ‚asnoÅ›Ä‡ <code>v</code> do utworzonego
wÄ…tku, gwarantujemy Rustowi, Å¼e gÅ‚Ã³wny wÄ…tek nie bÄ™dzie juÅ¼ uÅ¼ywaÅ‚ <code>v</code>. JeÅ›li
zmienimy Listing 16-4 w ten sam sposÃ³b, naruszamy wtedy zasady wÅ‚asnoÅ›ci,
gdy prÃ³bujemy uÅ¼yÄ‡ <code>v</code> w gÅ‚Ã³wnym wÄ…tku. SÅ‚owo kluczowe <code>move</code> nadpisuje
konserwatywnÄ… domyÅ›lnÄ… poÅ¼yczkÄ™ Rust; nie pozwala nam naruszaÄ‡ zasad
wÅ‚asnoÅ›ci.</p>
<p>Teraz, gdy omÃ³wiliÅ›my, czym sÄ… wÄ…tki i metody dostarczane przez API wÄ…tkÃ³w,
przyjrzyjmy siÄ™ kilku sytuacjom, w ktÃ³rych moÅ¼emy uÅ¼ywaÄ‡ wÄ…tkÃ³w.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="przesyÅ‚anie-danych-miÄ™dzy-wÄ…tkami-za-pomocÄ…-przekazywania-wiadomoÅ›ci-1"><a href="#przesyÅ‚anie-danych-miÄ™dzy-wÄ…tkami-za-pomocÄ…-przekazywania-wiadomoÅ›ci-1" class="header">PrzesyÅ‚anie danych miÄ™dzy wÄ…tkami za pomocÄ… przekazywania wiadomoÅ›ci</a></h1>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="using-message-passing-to-transfer-data-between-threads"></a></p>
<h2 id="przesyÅ‚anie-danych-miÄ™dzy-wÄ…tkami-za-pomocÄ…-przekazywania-wiadomoÅ›ci"><a class="header" href="#przesyÅ‚anie-danych-miÄ™dzy-wÄ…tkami-za-pomocÄ…-przekazywania-wiadomoÅ›ci">PrzesyÅ‚anie danych miÄ™dzy wÄ…tkami za pomocÄ… przekazywania wiadomoÅ›ci</a></h2>
<p>Jednym z coraz popularniejszych podejÅ›Ä‡ do zapewnienia bezpiecznej
wspÃ³Å‚bieÅ¼noÅ›ci jest przekazywanie wiadomoÅ›ci, gdzie wÄ…tki lub aktorzy
komunikujÄ… siÄ™, wysyÅ‚ajÄ…c sobie wiadomoÅ›ci zawierajÄ…ce dane. Oto idea w haÅ›le z
<a href="https://golang.org/doc/effective_go.html#concurrency">dokumentacji jÄ™zyka Go</a>:
â€Nie komunikuj siÄ™ poprzez wspÃ³Å‚dzielenie pamiÄ™ci; zamiast tego wspÃ³Å‚dziel
pamiÄ™Ä‡ poprzez komunikacjÄ™.â€</p>
<p>Aby zrealizowaÄ‡ wspÃ³Å‚bieÅ¼noÅ›Ä‡ opartÄ… na przekazywaniu wiadomoÅ›ci, biblioteka
standardowa Rust dostarcza implementacjÄ™ kanaÅ‚Ã³w. <em>KanaÅ‚</em> to ogÃ³lna koncepcja
programistyczna, za pomocÄ… ktÃ³rej dane sÄ… przesyÅ‚ane z jednego wÄ…tku do
drugiego.</p>
<p>MoÅ¼esz wyobraziÄ‡ sobie kanaÅ‚ w programowaniu jako kierunkowy kanaÅ‚ wodny, taki
jak strumieÅ„ lub rzeka. JeÅ›li wrzucisz coÅ›, na przykÅ‚ad gumowÄ… kaczkÄ™, do rzeki,
bÄ™dzie ona pÅ‚ynÄ™Å‚a w dÃ³Å‚ rzeki aÅ¼ do koÅ„ca szlaku wodnego.</p>
<p>KanaÅ‚ ma dwie poÅ‚Ã³wki: nadajnik i odbiornik. PoÅ‚Ã³wka nadajnika to miejsce
w gÃ³rze rzeki, gdzie wrzucasz gumowÄ… kaczkÄ™, a poÅ‚Ã³wka odbiornika to miejsce,
gdzie gumowa kaczka dociera w dÃ³Å‚ rzeki. Jedna czÄ™Å›Ä‡ twojego kodu wywoÅ‚uje
metody na nadajniku z danymi, ktÃ³re chcesz wysÅ‚aÄ‡, a inna czÄ™Å›Ä‡ sprawdza koniec
odbiorczy pod kÄ…tem nadchodzÄ…cych wiadomoÅ›ci. KanaÅ‚ jest uwaÅ¼any za <em>zamkniÄ™ty</em>,
jeÅ›li ktÃ³rakolwiek z poÅ‚Ã³wek â€“ nadajnik lub odbiornik â€“ zostanie usuniÄ™ta.</p>
<p>Tutaj stworzymy program, ktÃ³ry bÄ™dzie miaÅ‚ jeden wÄ…tek do generowania wartoÅ›ci
i wysyÅ‚ania ich przez kanaÅ‚, oraz inny wÄ…tek, ktÃ³ry bÄ™dzie odbieraÅ‚ te wartoÅ›ci
i wypisywaÅ‚ je. BÄ™dziemy przesyÅ‚aÄ‡ proste wartoÅ›ci miÄ™dzy wÄ…tkami za pomocÄ…
kanaÅ‚u, aby zilustrowaÄ‡ tÄ™ funkcjÄ™. Gdy juÅ¼ zapoznasz siÄ™ z tÄ… technikÄ…,
bÄ™dziesz mÃ³gÅ‚ uÅ¼ywaÄ‡ kanaÅ‚Ã³w dla dowolnych wÄ…tkÃ³w, ktÃ³re muszÄ… siÄ™ ze sobÄ…
komunikowaÄ‡, np. w systemie czatu lub w systemie, gdzie wiele wÄ…tkÃ³w wykonuje
czÄ™Å›ci obliczeÅ„ i wysyÅ‚a je do jednego wÄ…tku, ktÃ³ry agreguje wyniki.</p>
<p>Najpierw, w Listingu 16-6, stworzymy kanaÅ‚, ale nic z nim nie zrobimy. ZauwaÅ¼,
Å¼e to jeszcze siÄ™ nie skompiluje, poniewaÅ¼ Rust nie potrafi okreÅ›liÄ‡, jakiego
typu wartoÅ›ci chcemy przesyÅ‚aÄ‡ przez kanaÅ‚.</p>
<listing number="16-6" file-name="src/main.rs" caption="Tworzenie kanaÅ‚u i przypisywanie dwÃ³ch poÅ‚Ã³wek do `tx` i `rx`">
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}</code></pre>
</listing>
<p>Tworzymy nowy kanaÅ‚ za pomocÄ… funkcji <code>mpsc::channel</code>; <code>mpsc</code> oznacza
<em>multiple producer, single consumer</em> (wielu producentÃ³w, jeden konsument). W
skrÃ³cie, sposÃ³b, w jaki biblioteka standardowa Rust implementuje kanaÅ‚y,
oznacza, Å¼e kanaÅ‚ moÅ¼e mieÄ‡ wiele koÅ„cÃ³w <em>wysyÅ‚ajÄ…cych</em>, ktÃ³re produkujÄ…
wartoÅ›ci, ale tylko jeden koniec <em>odbierajÄ…cy</em>, ktÃ³ry te wartoÅ›ci konsumuje.
WyobraÅº sobie wiele strumieni spÅ‚ywajÄ…cych do jednej duÅ¼ej rzeki: Wszystko,
co zostanie wysÅ‚ane w dÃ³Å‚ ktÃ³regokolwiek ze strumieni, znajdzie siÄ™ w jednej
rzece na koÅ„cu. Na razie zaczniemy od jednego producenta, ale dodamy wielu
producentÃ³w, gdy ten przykÅ‚ad zadziaÅ‚a.</p>
<p>Funkcja <code>mpsc::channel</code> zwraca krotkÄ™, ktÃ³rej pierwszy element to koniec
wysyÅ‚ajÄ…cy â€“ nadajnik â€“ a drugi element to koniec odbierajÄ…cy â€“ odbiornik.
SkrÃ³ty <code>tx</code> i <code>rx</code> sÄ… tradycyjnie uÅ¼ywane w wielu dziedzinach odpowiednio dla
<em>transmitter</em> (nadajnik) i <em>receiver</em> (odbiornik), wiÄ™c tak nazywamy nasze
zmienne, aby wskazaÄ‡ kaÅ¼dy koniec. UÅ¼ywamy instrukcji <code>let</code> ze wzorcem,
ktÃ³ry dekomponuje krotki; o uÅ¼yciu wzorcÃ³w w instrukcjach <code>let</code> i
dekompozycji bÄ™dziemy rozmawiaÄ‡ w Rozdziale 19. Na razie wiedz, Å¼e uÅ¼ycie
instrukcji <code>let</code> w ten sposÃ³b jest wygodnym podejÅ›ciem do wyodrÄ™bniania
elementÃ³w krotki zwracanej przez <code>mpsc::channel</code>.</p>
<p>PrzenieÅ›my koniec nadawczy do utworzonego wÄ…tku i niech wyÅ›le jeden ciÄ…g
znakÃ³w, tak aby utworzony wÄ…tek komunikowaÅ‚ siÄ™ z gÅ‚Ã³wnym wÄ…tkiem, jak
pokazano w Listingu 16-7. To jest jak wrzucenie gumowej kaczki do rzeki w
gÃ³rnym biegu lub wysÅ‚anie wiadomoÅ›ci na czacie z jednego wÄ…tku do drugiego.</p>
<listing number="16-7" file-name="src/main.rs" caption="Przenoszenie `tx` do utworzonego wÄ…tku i wysyÅ‚anie `&quot;hi&quot;`">
<pre class="playground"><code class="language-rust edition2024">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });
}</code></pre>
</listing>
<p>Ponownie uÅ¼ywamy <code>thread::spawn</code> do utworzenia nowego wÄ…tku, a nastÄ™pnie
uÅ¼ywamy <code>move</code> do przeniesienia <code>tx</code> do domkniÄ™cia, tak aby utworzony wÄ…tek
byÅ‚ wÅ‚aÅ›cicielem <code>tx</code>. Utworzony wÄ…tek musi byÄ‡ wÅ‚aÅ›cicielem nadajnika, aby
mÃ³c wysyÅ‚aÄ‡ wiadomoÅ›ci przez kanaÅ‚.</p>
<p>Nadajnik ma metodÄ™ <code>send</code>, ktÃ³ra przyjmuje wartoÅ›Ä‡, ktÃ³rÄ… chcemy wysÅ‚aÄ‡.
Metoda <code>send</code> zwraca typ <code>Result&lt;T, E&gt;</code>, wiÄ™c jeÅ›li odbiornik zostaÅ‚ juÅ¼
usuniÄ™ty i nie ma dokÄ…d wysÅ‚aÄ‡ wartoÅ›ci, operacja wysyÅ‚ania zwrÃ³ci bÅ‚Ä…d.
W tym przykÅ‚adzie wywoÅ‚ujemy <code>unwrap</code>, aby spowodowaÄ‡ panikÄ™ w przypadku bÅ‚Ä™du.
Ale w prawdziwej aplikacji obsÅ‚uÅ¼ylibyÅ›my to poprawnie: WrÃ³Ä‡ do RozdziaÅ‚u 9,
aby przejrzeÄ‡ strategie wÅ‚aÅ›ciwej obsÅ‚ugi bÅ‚Ä™dÃ³w.</p>
<p>W Listingu 16-8 pobierzemy wartoÅ›Ä‡ z odbiornika w gÅ‚Ã³wnym wÄ…tku. To jest jak
pobieranie gumowej kaczki z wody na koÅ„cu rzeki lub odbieranie wiadomoÅ›ci na
czacie.</p>
<listing number="16-8" file-name="src/main.rs" caption="Odbieranie wartoÅ›ci `&quot;hi&quot;` w gÅ‚Ã³wnym wÄ…tku i jej wypisywanie">
<pre class="playground"><code class="language-rust edition2024">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}</code></pre>
</listing>
<p>Odbiornik ma dwie przydatne metody: <code>recv</code> i <code>try_recv</code>. UÅ¼ywamy <code>recv</code>,
skrÃ³tu od <em>receive</em> (odbierz), ktÃ³ra zablokuje wykonanie gÅ‚Ã³wnego wÄ…tku i
poczeka, aÅ¼ wartoÅ›Ä‡ zostanie wysÅ‚ana przez kanaÅ‚. Gdy tylko wartoÅ›Ä‡ zostanie
wysÅ‚ana, <code>recv</code> zwrÃ³ci jÄ… w <code>Result&lt;T, E&gt;</code>. Gdy nadajnik zostanie zamkniÄ™ty,
<code>recv</code> zwrÃ³ci bÅ‚Ä…d, sygnalizujÄ…c, Å¼e nie nadejdÄ… juÅ¼ wiÄ™cej wartoÅ›ci.</p>
<p>Metoda <code>try_recv</code> nie blokuje, ale zamiast tego natychmiast zwraca <code>Result&lt;T, E&gt;</code>: wartoÅ›Ä‡ <code>Ok</code> zawierajÄ…cÄ… wiadomoÅ›Ä‡, jeÅ›li jest dostÄ™pna, oraz wartoÅ›Ä‡
<code>Err</code>, jeÅ›li tym razem nie ma Å¼adnych wiadomoÅ›ci. UÅ¼ycie <code>try_recv</code> jest
przydatne, jeÅ›li ten wÄ…tek ma innÄ… pracÄ™ do wykonania podczas oczekiwania na
wiadomoÅ›ci: MoglibyÅ›my napisaÄ‡ pÄ™tlÄ™, ktÃ³ra co jakiÅ› czas wywoÅ‚uje <code>try_recv</code>,
obchodzi wiadomoÅ›Ä‡, jeÅ›li jest dostÄ™pna, a w przeciwnym razie wykonuje innÄ…
pracÄ™ przez jakiÅ› czas, zanim ponownie sprawdzi.</p>
<p>W tym przykÅ‚adzie dla uproszczenia uÅ¼yliÅ›my <code>recv</code>; gÅ‚Ã³wny wÄ…tek nie ma innej
pracy do wykonania poza czekaniem na wiadomoÅ›ci, wiÄ™c blokowanie gÅ‚Ã³wnego
wÄ…tku jest odpowiednie.</p>
<p>Po uruchomieniu kodu z Listingu 16-8 zobaczymy wartoÅ›Ä‡ wypisanÄ… z gÅ‚Ã³wnego
wÄ…tku:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
</code></pre>
<p>Idealnie!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="channels-and-ownership-transference"></a></p>
<h3 id="przenoszenie-wÅ‚asnoÅ›ci-przez-kanaÅ‚y"><a class="header" href="#przenoszenie-wÅ‚asnoÅ›ci-przez-kanaÅ‚y">Przenoszenie wÅ‚asnoÅ›ci przez kanaÅ‚y</a></h3>
<p>Zasady wÅ‚asnoÅ›ci odgrywajÄ… kluczowÄ… rolÄ™ w przesyÅ‚aniu wiadomoÅ›ci, poniewaÅ¼
pomagajÄ… pisaÄ‡ bezpieczny, wspÃ³Å‚bieÅ¼ny kod. Zapobieganie bÅ‚Ä™dom w programowaniu
wspÃ³Å‚bieÅ¼nym to zaleta myÅ›lenia o wÅ‚asnoÅ›ci w caÅ‚ym programie Rust. PrzeprowadÅºmy
eksperyment, aby pokazaÄ‡, jak kanaÅ‚y i wÅ‚asnoÅ›Ä‡ wspÃ³Å‚pracujÄ…, aby zapobiegaÄ‡
problemom: SprÃ³bujemy uÅ¼yÄ‡ wartoÅ›ci <code>val</code> w utworzonym wÄ…tku <em>po</em> tym, jak
wysÅ‚aliÅ›my jÄ… przez kanaÅ‚. SprÃ³buj skompilowaÄ‡ kod z Listingu 16-9, aby
zobaczyÄ‡, dlaczego ten kod jest niedozwolony.</p>
<listing number="16-9" file-name="src/main.rs" caption="PrÃ³ba uÅ¼ycia `val` po wysÅ‚aniu go przez kanaÅ‚">
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
        println!("val is {val}");
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}</code></pre>
</listing>
<p>Tutaj prÃ³bujemy wypisaÄ‡ <code>val</code> po tym, jak wysÅ‚aliÅ›my go przez kanaÅ‚ za pomocÄ…
<code>tx.send</code>. Zezwolenie na to byÅ‚oby zÅ‚ym pomysÅ‚em: Gdy wartoÅ›Ä‡ zostanie
wysÅ‚ana do innego wÄ…tku, ten wÄ…tek mÃ³gÅ‚by jÄ… zmodyfikowaÄ‡ lub usunÄ…Ä‡, zanim
ponownie sprÃ³bujemy jej uÅ¼yÄ‡. Potencjalnie modyfikacje innego wÄ…tku mogÅ‚yby
spowodowaÄ‡ bÅ‚Ä™dy lub nieoczekiwane rezultaty z powodu niespÃ³jnych lub
nieistniejÄ…cych danych. Jednak Rust zgÅ‚asza bÅ‚Ä…d, jeÅ›li sprÃ³bujemy
skompilowaÄ‡ kod z Listingu 16-9:</p>
<pre><code class="language-console">$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  --&gt; src/main.rs:10:27
   |
 8 |         let val = String::from("hi");
   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait
 9 |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!("val is {val}");
   |                           ^^^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` (bin "message-passing") due to 1 previous error
</code></pre>
<p>Nasz bÅ‚Ä…d wspÃ³Å‚bieÅ¼noÅ›ci spowodowaÅ‚ bÅ‚Ä…d kompilacji. Funkcja <code>send</code> przejmuje
wÅ‚asnoÅ›Ä‡ swojego parametru, a po przeniesieniu wartoÅ›ci odbiornik przejmuje jej
wÅ‚asnoÅ›Ä‡. To uniemoÅ¼liwia nam przypadkowe ponowne uÅ¼ycie wartoÅ›ci po jej
wysÅ‚aniu; system wÅ‚asnoÅ›ci sprawdza, czy wszystko jest w porzÄ…dku.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="sending-multiple-values-and-seeing-the-receiver-waiting"></a></p>
<h3 id="wysyÅ‚anie-wielu-wartoÅ›ci"><a class="header" href="#wysyÅ‚anie-wielu-wartoÅ›ci">WysyÅ‚anie wielu wartoÅ›ci</a></h3>
<p>Kod z Listingu 16-8 skompilowaÅ‚ siÄ™ i zadziaÅ‚aÅ‚, ale nie pokazaÅ‚ nam jasno, Å¼e
dwa oddzielne wÄ…tki komunikowaÅ‚y siÄ™ ze sobÄ… przez kanaÅ‚.</p>
<p>W Listingu 16-10 wprowadziliÅ›my pewne modyfikacje, ktÃ³re udowodniÄ…, Å¼e kod z
Listingu 16-8 dziaÅ‚a wspÃ³Å‚bieÅ¼nie: utworzony wÄ…tek bÄ™dzie teraz wysyÅ‚aÅ‚ wiele
wiadomoÅ›ci i pauzowaÅ‚ na sekundÄ™ miÄ™dzy kaÅ¼dÄ… wiadomoÅ›ciÄ….</p>
<listing number="16-10" file-name="src/main.rs" caption="WysyÅ‚anie wielu wiadomoÅ›ci i pauzowanie miÄ™dzy kaÅ¼dÄ… z nich">
<pre><code class="language-rust noplayground">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {received}");
    }
}</code></pre>
</listing>
<p>Tym razem utworzony wÄ…tek ma wektor ciÄ…gÃ³w, ktÃ³re chcemy wysÅ‚aÄ‡ do gÅ‚Ã³wnego
wÄ…tku. Iterujemy po nich, wysyÅ‚ajÄ…c kaÅ¼dy z osobna i pauzujÄ…c miÄ™dzy kaÅ¼dym,
wywoÅ‚ujÄ…c funkcjÄ™ <code>thread::sleep</code> z wartoÅ›ciÄ… <code>Duration</code> wynoszÄ…cÄ… jednÄ… sekundÄ™.</p>
<p>W gÅ‚Ã³wnym wÄ…tku nie wywoÅ‚ujemy juÅ¼ jawnie funkcji <code>recv</code>: Zamiast tego
traktujemy <code>rx</code> jako iterator. Dla kaÅ¼dej otrzymanej wartoÅ›ci wypisujemy jÄ….
Gdy kanaÅ‚ zostanie zamkniÄ™ty, iteracja siÄ™ zakoÅ„czy.</p>
<p>Podczas uruchamiania kodu z Listingu 16-10 powinieneÅ› zobaczyÄ‡ nastÄ™pujÄ…cy
wynik z jednominutowÄ… przerwÄ… miÄ™dzy kaÅ¼dÄ… liniÄ…:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<p>PoniewaÅ¼ nie mamy Å¼adnego kodu, ktÃ³ry pauzuje lub opÃ³Åºnia w pÄ™tli <code>for</code> w
gÅ‚Ã³wnym wÄ…tku, moÅ¼emy stwierdziÄ‡, Å¼e gÅ‚Ã³wny wÄ…tek czeka na odebranie wartoÅ›ci
z utworzonego wÄ…tku.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-multiple-producers-by-cloning-the-transmitter"></a></p>
<h3 id="tworzenie-wielu-producentÃ³w"><a class="header" href="#tworzenie-wielu-producentÃ³w">Tworzenie wielu producentÃ³w</a></h3>
<p>WczeÅ›niej wspomnieliÅ›my, Å¼e <code>mpsc</code> to skrÃ³t od <em>multiple producer, single
consumer</em> (wiele producentÃ³w, jeden konsument). Wykorzystajmy <code>mpsc</code> i
rozszerzmy kod z Listingu 16-10, aby utworzyÄ‡ wiele wÄ…tkÃ³w, ktÃ³re wszystkie
wysyÅ‚ajÄ… wartoÅ›ci do tego samego odbiornika. MoÅ¼emy to zrobiÄ‡, klonujÄ…c
nadajnik, jak pokazano w Listingu 16-11.</p>
<listing number="16-11" file-name="src/main.rs" caption="WysyÅ‚anie wielu wiadomoÅ›ci od wielu producentÃ³w">
<pre><code class="language-rust noplayground"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // --snip--

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {received}");
    }

    // --snip--
<span class="boring">}</span></code></pre>
</listing>
<p>Tym razem, zanim utworzymy pierwszy wÄ…tek, wywoÅ‚ujemy <code>clone</code> na nadajniku.
Spowoduje to utworzenie nowego nadajnika, ktÃ³ry moÅ¼emy przekazaÄ‡ do pierwszego
utworzonego wÄ…tku. Oryginalny nadajnik przekazujemy do drugiego utworzonego
wÄ…tku. Daje nam to dwa wÄ…tki, kaÅ¼dy wysyÅ‚ajÄ…cy rÃ³Å¼ne wiadomoÅ›ci do jednego
odbiornika.</p>
<p>Po uruchomieniu kodu, wynik powinien wyglÄ…daÄ‡ mniej wiÄ™cej tak:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<p>MoÅ¼esz zobaczyÄ‡ wartoÅ›ci w innej kolejnoÅ›ci, w zaleÅ¼noÅ›ci od twojego systemu.
To wÅ‚aÅ›nie sprawia, Å¼e wspÃ³Å‚bieÅ¼noÅ›Ä‡ jest interesujÄ…ca, a takÅ¼e trudna. JeÅ›li
poeksperymentujesz z <code>thread::sleep</code>, nadajÄ…c mu rÃ³Å¼ne wartoÅ›ci w rÃ³Å¼nych
wÄ…tkach, kaÅ¼de uruchomienie bÄ™dzie bardziej niedeterministyczne i za kaÅ¼dym
razem bÄ™dzie generowaÄ‡ inne dane wyjÅ›ciowe.</p>
<p>Teraz, gdy przyjrzeliÅ›my siÄ™, jak dziaÅ‚ajÄ… kanaÅ‚y, spÃ³jrzmy na innÄ… metodÄ™
wspÃ³Å‚bieÅ¼noÅ›ci.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wspÃ³Å‚bieÅ¼noÅ›Ä‡-ze-wspÃ³Å‚dzielonym-stanem-1"><a href="#wspÃ³Å‚bieÅ¼noÅ›Ä‡-ze-wspÃ³Å‚dzielonym-stanem-1" class="header">WspÃ³Å‚bieÅ¼noÅ›Ä‡ ze wspÃ³Å‚dzielonym stanem</a></h1>
<h2 id="wspÃ³Å‚bieÅ¼noÅ›Ä‡-ze-wspÃ³Å‚dzielonym-stanem"><a class="header" href="#wspÃ³Å‚bieÅ¼noÅ›Ä‡-ze-wspÃ³Å‚dzielonym-stanem">WspÃ³Å‚bieÅ¼noÅ›Ä‡ ze wspÃ³Å‚dzielonym stanem</a></h2>
<p>Przekazywanie wiadomoÅ›ci to dobry sposÃ³b na obsÅ‚ugÄ™ wspÃ³Å‚bieÅ¼noÅ›ci, ale nie
jedyny. InnÄ… metodÄ… byÅ‚oby, aby wiele wÄ…tkÃ³w uzyskiwaÅ‚o dostÄ™p do tych samych
wspÃ³Å‚dzielonych danych. Ponownie rozwaÅ¼my tÄ™ czÄ™Å›Ä‡ sloganu z dokumentacji
jÄ™zyka Go: â€Nie komunikuj siÄ™ poprzez wspÃ³Å‚dzielenie pamiÄ™ci.â€</p>
<p>Jak wyglÄ…daÅ‚aby komunikacja poprzez wspÃ³Å‚dzielenie pamiÄ™ci? Ponadto, dlaczego
entuzjaÅ›ci przekazywania wiadomoÅ›ci ostrzegaliby przed uÅ¼ywaniem wspÃ³Å‚dzielenia
pamiÄ™ci?</p>
<p>Pod pewnym wzglÄ™dem kanaÅ‚y w kaÅ¼dym jÄ™zyku programowania sÄ… podobne do
pojedynczej wÅ‚asnoÅ›ci, poniewaÅ¼ po przeniesieniu wartoÅ›ci przez kanaÅ‚ nie
powinno siÄ™ juÅ¼ wiÄ™cej uÅ¼ywaÄ‡ tej wartoÅ›ci. WspÃ³Å‚bieÅ¼noÅ›Ä‡ oparta na wspÃ³Å‚dzielonej
pamiÄ™ci jest jak wielokrotna wÅ‚asnoÅ›Ä‡: Wiele wÄ…tkÃ³w moÅ¼e uzyskiwaÄ‡ dostÄ™p do
tego samego miejsca w pamiÄ™ci w tym samym czasie. Jak widziaÅ‚eÅ› w Rozdziale 15,
gdzie wskaÅºniki sprytne umoÅ¼liwiÅ‚y wielokrotnÄ… wÅ‚asnoÅ›Ä‡, wielokrotna wÅ‚asnoÅ›Ä‡
moÅ¼e zwiÄ™kszyÄ‡ zÅ‚oÅ¼onoÅ›Ä‡, poniewaÅ¼ ci rÃ³Å¼ni wÅ‚aÅ›ciciele wymagajÄ… zarzÄ…dzania.
System typÃ³w Rust i zasady wÅ‚asnoÅ›ci znacznie pomagajÄ… w prawidÅ‚owym
zarzÄ…dzaniu. Na przykÅ‚ad, przyjrzyjmy siÄ™ muteksom, jednej z
najpopularniejszych prymitywÃ³w wspÃ³Å‚bieÅ¼noÅ›ci dla wspÃ³Å‚dzielonej pamiÄ™ci.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="using-mutexes-to-allow-access-to-data-from-one-thread-at-a-time"></a></p>
<h3 id="kontrolowanie-dostÄ™pu-za-pomocÄ…-muteksÃ³w"><a class="header" href="#kontrolowanie-dostÄ™pu-za-pomocÄ…-muteksÃ³w">Kontrolowanie dostÄ™pu za pomocÄ… muteksÃ³w</a></h3>
<p><em>Muteks</em> to skrÃ³t od <em>mutual exclusion</em> (wzajemne wykluczenie), co oznacza, Å¼e
muteks pozwala tylko jednemu wÄ…tkowi na dostÄ™p do danych w danym momencie.
Aby uzyskaÄ‡ dostÄ™p do danych w muteksie, wÄ…tek musi najpierw zasygnalizowaÄ‡,
Å¼e chce uzyskaÄ‡ dostÄ™p, proszÄ…c o nabycie blokady muteksu. <em>Blokada</em> to
struktura danych, ktÃ³ra jest czÄ™Å›ciÄ… muteksu i Å›ledzi, kto aktualnie ma
wyÅ‚Ä…czny dostÄ™p do danych. Dlatego muteks jest opisywany jako <em>ochraniajÄ…cy</em>
dane, ktÃ³re przechowuje, za pomocÄ… systemu blokowania.</p>
<p>Muteksy majÄ… reputacjÄ™ trudnych w uÅ¼yciu, poniewaÅ¼ trzeba pamiÄ™taÄ‡ o dwÃ³ch
zasadach:</p>
<ol>
<li>Musisz sprÃ³bowaÄ‡ uzyskaÄ‡ blokadÄ™ przed uÅ¼yciem danych.</li>
<li>Kiedy skoÅ„czysz korzystaÄ‡ z danych chronionych przez muteks, musisz
zwolniÄ‡ blokadÄ™, aby inne wÄ…tki mogÅ‚y jÄ… uzyskaÄ‡.</li>
</ol>
<p>Na przykÅ‚ad, wyobraÅº sobie panel dyskusyjny na konferencji z tylko jednym
mikrofonem. Zanim panelista bÄ™dzie mÃ³gÅ‚ mÃ³wiÄ‡, musi zapytaÄ‡ lub zasygnalizowaÄ‡,
Å¼e chce uÅ¼yÄ‡ mikrofonu. Kiedy dostanie mikrofon, moÅ¼e mÃ³wiÄ‡ tak dÅ‚ugo, jak
chce, a nastÄ™pnie przekazaÄ‡ mikrofon kolejnemu panelistowi, ktÃ³ry poprosi o
mÃ³wienie. JeÅ›li panelista zapomni oddaÄ‡ mikrofon, gdy skoÅ„czy z niego
korzystaÄ‡, nikt inny nie bÄ™dzie mÃ³gÅ‚ mÃ³wiÄ‡. JeÅ›li zarzÄ…dzanie wspÃ³lnym
mikrofonem pÃ³jdzie Åºle, panel nie zadziaÅ‚a zgodnie z planem!</p>
<p>ZarzÄ…dzanie muteksami moÅ¼e byÄ‡ niezwykle trudne do prawidÅ‚owego wykonania,
dlatego tak wiele osÃ³b jest entuzjastycznie nastawionych do kanaÅ‚Ã³w.
Jednak dziÄ™ki systemowi typÃ³w i zasadom wÅ‚asnoÅ›ci Rust, nie moÅ¼na pomyliÄ‡
siÄ™ z blokowaniem i odblokowywaniem.</p>
<h4 id="api-mutext"><a class="header" href="#api-mutext">API <code>Mutex&lt;T&gt;</code></a></h4>
<p>Jako przykÅ‚ad uÅ¼ycia muteksu, zacznijmy od uÅ¼ycia muteksu w kontekÅ›cie
jednowÄ…tkowym, jak pokazano w Listingu 16-12.</p>
<listing number="16-12" file-name="src/main.rs" caption="Badanie API `Mutex&lt;T&gt;` w kontekÅ›cie jednowÄ…tkowym dla uproszczenia">
<pre class="playground"><code class="language-rust edition2024">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {m:?}");
}</code></pre>
</listing>
<p>Podobnie jak w przypadku wielu typÃ³w, tworzymy <code>Mutex&lt;T&gt;</code> za pomocÄ…
skojarzonej funkcji <code>new</code>. Aby uzyskaÄ‡ dostÄ™p do danych wewnÄ…trz muteksu,
uÅ¼ywamy metody <code>lock</code>, aby uzyskaÄ‡ blokadÄ™. To wywoÅ‚anie zablokuje bieÅ¼Ä…cy
wÄ…tek, tak aby nie mÃ³gÅ‚ on wykonywaÄ‡ Å¼adnej pracy, dopÃ³ki nie nadejdzie nasza
kolej na uzyskanie blokady.</p>
<p>WywoÅ‚anie <code>lock</code> zakoÅ„czyÅ‚oby siÄ™ niepowodzeniem, gdyby inny wÄ…tek trzymajÄ…cy
blokadÄ™ wywoÅ‚aÅ‚ panikÄ™. W takim przypadku nikt nigdy nie mÃ³gÅ‚by uzyskaÄ‡ blokady,
dlatego zdecydowaliÅ›my siÄ™ na <code>unwrap</code>, aby ten wÄ…tek wywoÅ‚aÅ‚ panikÄ™, jeÅ›li
znajdziemy siÄ™ w takiej sytuacji.</p>
<p>Po uzyskaniu blokady, moÅ¼emy traktowaÄ‡ zwrÃ³conÄ… wartoÅ›Ä‡, nazwanÄ… w tym przypadku
<code>num</code>, jako mutowalnÄ… referencjÄ™ do wewnÄ™trznych danych. System typÃ³w
gwarantuje, Å¼e uzyskujemy blokadÄ™ przed uÅ¼yciem wartoÅ›ci w <code>m</code>. Typ <code>m</code> to
<code>Mutex&lt;i32&gt;</code>, a nie <code>i32</code>, wiÄ™c <em>musimy</em> wywoÅ‚aÄ‡ <code>lock</code>, aby mÃ³c uÅ¼yÄ‡ wartoÅ›ci
<code>i32</code>. Nie moÅ¼emy zapomnieÄ‡; system typÃ³w w przeciwnym razie nie pozwoli nam
na dostÄ™p do wewnÄ™trznej wartoÅ›ci <code>i32</code>.</p>
<p>WywoÅ‚anie <code>lock</code> zwraca typ nazwany <code>MutexGuard</code>, opakowany w <code>LockResult</code>,
ktÃ³ry obsÅ‚uÅ¼yliÅ›my wywoÅ‚aniem <code>unwrap</code>. Typ <code>MutexGuard</code> implementuje <code>Deref</code>,
aby wskazywaÄ‡ na nasze wewnÄ™trzne dane; typ ten ma rÃ³wnieÅ¼ implementacjÄ™ <code>Drop</code>,
ktÃ³ra automatycznie zwalnia blokadÄ™, gdy <code>MutexGuard</code> wyjdzie poza zakres,
co dzieje siÄ™ na koÅ„cu wewnÄ™trznego zakresu. W rezultacie nie ryzykujemy
zapomnienia o zwolnieniu blokady i zablokowania muteksu przed uÅ¼yciem przez
inne wÄ…tki, poniewaÅ¼ zwolnienie blokady odbywa siÄ™ automatycznie.</p>
<p>Po zwolnieniu blokady moÅ¼emy wypisaÄ‡ wartoÅ›Ä‡ muteksu i zobaczyÄ‡, Å¼e udaÅ‚o nam
siÄ™ zmieniÄ‡ wewnÄ™trznÄ… wartoÅ›Ä‡ <code>i32</code> na <code>6</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="sharing-a-mutext-between-multiple-threads"></a></p>
<h4 id="wspÃ³Å‚dzielony-dostÄ™p-do-mutext"><a class="header" href="#wspÃ³Å‚dzielony-dostÄ™p-do-mutext">WspÃ³Å‚dzielony dostÄ™p do <code>Mutex&lt;T&gt;</code></a></h4>
<p>Teraz sprÃ³bujmy wspÃ³Å‚dzieliÄ‡ wartoÅ›Ä‡ miÄ™dzy wieloma wÄ…tkami za pomocÄ… <code>Mutex&lt;T&gt;</code>.
Uruchomimy 10 wÄ…tkÃ³w i kaÅ¼dy z nich zwiÄ™kszy wartoÅ›Ä‡ licznika o 1, wiÄ™c licznik
wzroÅ›nie od 0 do 10. PrzykÅ‚ad w Listingu 16-13 spowoduje bÅ‚Ä…d kompilacji, a my
wykorzystamy ten bÅ‚Ä…d, aby dowiedzieÄ‡ siÄ™ wiÄ™cej o uÅ¼ywaniu <code>Mutex&lt;T&gt;</code> i o tym,
jak Rust pomaga nam uÅ¼ywaÄ‡ go poprawnie.</p>
<listing number="16-13" file-name="src/main.rs" caption="DziesiÄ™Ä‡ wÄ…tkÃ³w, z ktÃ³rych kaÅ¼dy zwiÄ™ksza licznik chroniony przez `Mutex&lt;T&gt;`">
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre>
</listing>
<p>Tworzymy zmiennÄ… <code>counter</code> do przechowywania <code>i32</code> wewnÄ…trz <code>Mutex&lt;T&gt;</code>, tak jak
zrobiliÅ›my to w Listingu 16-12. NastÄ™pnie tworzymy 10 wÄ…tkÃ³w, iterujÄ…c po
zakresie liczb. UÅ¼ywamy <code>thread::spawn</code> i przekazujemy wszystkim wÄ…tkom to
samo domkniÄ™cie: takie, ktÃ³re przenosi licznik do wÄ…tku, uzyskuje blokadÄ™ na
<code>Mutex&lt;T&gt;</code> poprzez wywoÅ‚anie metody <code>lock</code>, a nastÄ™pnie dodaje 1 do wartoÅ›ci w
muteksie. Gdy wÄ…tek zakoÅ„czy wykonywanie swojego domkniÄ™cia, <code>num</code> wyjdzie
poza zakres i zwolni blokadÄ™, aby inny wÄ…tek mÃ³gÅ‚ jÄ… uzyskaÄ‡.</p>
<p>W gÅ‚Ã³wnym wÄ…tku zbieramy wszystkie uchwyty <code>join</code>. NastÄ™pnie, jak to zrobiliÅ›my
w Listingu 16-2, wywoÅ‚ujemy <code>join</code> na kaÅ¼dym uchwycie, aby upewniÄ‡ siÄ™, Å¼e
wszystkie wÄ…tki siÄ™ zakoÅ„czyÅ‚y. W tym momencie gÅ‚Ã³wny wÄ…tek uzyska blokadÄ™ i
wypisze wynik tego programu.</p>
<p>SugerowaliÅ›my, Å¼e ten przykÅ‚ad siÄ™ nie skompiluje. Teraz dowiemy siÄ™, dlaczego!</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: borrow of moved value: `counter`
  --&gt; src/main.rs:21:29
   |
 5 |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`, which does not implement the `Copy` trait
...
 8 |     for _ in 0..10 {
   |     -------------- inside of this loop
 9 |         let handle = thread::spawn(move || {
   |                                    ------- value moved into closure here, in previous iteration of loop
...
21 |     println!("Result: {}", *counter.lock().unwrap());
   |                             ^^^^^^^ value borrowed here after move
   |
help: consider moving the expression out of the loop so it is only moved once
   |
 8 ~     let mut value = counter.lock();
 9 ~     for _ in 0..10 {
10 |         let handle = thread::spawn(move || {
11 ~             let mut num = value.unwrap();
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>Komunikat o bÅ‚Ä™dzie wskazuje, Å¼e wartoÅ›Ä‡ <code>counter</code> zostaÅ‚a przeniesiona w
poprzedniej iteracji pÄ™tli. Rust informuje nas, Å¼e nie moÅ¼emy przenieÅ›Ä‡ wÅ‚asnoÅ›ci
blokady <code>counter</code> do wielu wÄ…tkÃ³w. Naprawmy bÅ‚Ä…d kompilacji, uÅ¼ywajÄ…c metody
wielokrotnej wÅ‚asnoÅ›ci, ktÃ³rÄ… omÃ³wiliÅ›my w Rozdziale 15.</p>
<h4 id="wielokrotna-wÅ‚asnoÅ›Ä‡-z-wieloma-wÄ…tkami"><a class="header" href="#wielokrotna-wÅ‚asnoÅ›Ä‡-z-wieloma-wÄ…tkami">Wielokrotna wÅ‚asnoÅ›Ä‡ z wieloma wÄ…tkami</a></h4>
<p>W Rozdziale 15, nadaliÅ›my wartoÅ›Ä‡ wielu wÅ‚aÅ›cicielom, uÅ¼ywajÄ…c wskaÅºnika
sprytnego <code>Rc&lt;T&gt;</code> do stworzenia wartoÅ›ci zliczanej referencjami. ZrÃ³bmy to samo
tutaj i zobaczmy, co siÄ™ stanie. Opakujemy <code>Mutex&lt;T&gt;</code> w <code>Rc&lt;T&gt;</code> w Listingu 16-14
i sklonujemy <code>Rc&lt;T&gt;</code> przed przeniesieniem wÅ‚asnoÅ›ci do wÄ…tku.</p>
<listing number="16-14" file-name="src/main.rs" caption="PrÃ³ba uÅ¼ycia `Rc&lt;T&gt;`, aby umoÅ¼liwiÄ‡ wielu wÄ…tkom posiadanie `Mutex&lt;T&gt;`">
<pre><code class="language-rust ignore does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre>
</listing>
<p>Ponownie kompilujemy i otrzymujemyâ€¦ inne bÅ‚Ä™dy! Kompilator wiele nas uczy:</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
  --&gt; src/main.rs:11:36
   |
11 |           let handle = thread::spawn(move || {
   |                        ------------- ^------
   |                        |             |
   |  ______________________|_____________within this `{closure@src/main.rs:11:36: 11:43}`
   | |                      |
   | |                      required by a bound introduced by this call
12 | |             let mut num = counter.lock().unwrap();
13 | |
14 | |             *num += 1;
15 | |         });
   | |_________^ `Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   |
   = help: within `{closure@src/main.rs:11:36: 11:43}`, the trait `Send` is not implemented for `Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`
note: required because it's used within this closure
  --&gt; src/main.rs:11:36
   |
11 |         let handle = thread::spawn(move || {
   |                                    ^^^^^^^
note: required by a bound in `spawn`
  --&gt; /rustc/1159e78c4747b02ef996e55082b704c09b970588/library/std/src/thread/mod.rs:723:1

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>Wow, ten komunikat o bÅ‚Ä™dzie jest bardzo rozwlekÅ‚y! Oto najwaÅ¼niejsza czÄ™Å›Ä‡, na
ktÃ³rej naleÅ¼y siÄ™ skupiÄ‡: <code>`Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>. Kompilator podaje nam rÃ³wnieÅ¼ przyczynÄ™: <code>the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`</code>. O <code>Send</code> bÄ™dziemy rozmawiaÄ‡ w nastÄ™pnej
sekcji: Jest to jedna z cech, ktÃ³ra zapewnia, Å¼e typy, ktÃ³rych uÅ¼ywamy z
wÄ…tkami, sÄ… przeznaczone do uÅ¼ytku w sytuacjach wspÃ³Å‚bieÅ¼nych.</p>
<p>Niestety, <code>Rc&lt;T&gt;</code> nie jest bezpieczny do wspÃ³Å‚dzielenia miÄ™dzy wÄ…tkami. Kiedy
<code>Rc&lt;T&gt;</code> zarzÄ…dza licznikiem referencji, dodaje do licznika dla kaÅ¼dego wywoÅ‚ania
<code>clone</code> i odejmuje od licznika, gdy kaÅ¼dy klon zostanie usuniÄ™ty. Ale nie uÅ¼ywa
Å¼adnych prymitywÃ³w wspÃ³Å‚bieÅ¼noÅ›ci, aby upewniÄ‡ siÄ™, Å¼e zmiany w liczniku nie
mogÄ… byÄ‡ przerwane przez inny wÄ…tek. MoÅ¼e to prowadziÄ‡ do bÅ‚Ä™dnych licznikÃ³w
â€” subtelnych bÅ‚Ä™dÃ³w, ktÃ³re z kolei mogÄ… prowadziÄ‡ do wyciekÃ³w pamiÄ™ci lub
przedwczesnego usuniÄ™cia wartoÅ›ci. Potrzebujemy typu, ktÃ³ry jest dokÅ‚adnie
taki jak <code>Rc&lt;T&gt;</code>, ale ktÃ³ry dokonuje zmian w liczniku referencji w sposÃ³b
bardzo bezpieczny dla wÄ…tkÃ³w.</p>
<h4 id="atomowe-zliczanie-referencji-za-pomocÄ…-arct"><a class="header" href="#atomowe-zliczanie-referencji-za-pomocÄ…-arct">Atomowe zliczanie referencji za pomocÄ… <code>Arc&lt;T&gt;</code></a></h4>
<p>Na szczÄ™Å›cie <code>Arc&lt;T&gt;</code> <em>jest</em> typem podobnym do <code>Rc&lt;T&gt;</code>, ktÃ³ry jest bezpieczny
w uÅ¼yciu w sytuacjach wspÃ³Å‚bieÅ¼nych. Litera <em>a</em> oznacza <em>atomic</em>, co oznacza,
Å¼e jest to typ <em>atomowo zliczajÄ…cy referencje</em>. Atomy to dodatkowy rodzaj
prymitywu wspÃ³Å‚bieÅ¼noÅ›ci, ktÃ³rego nie bÄ™dziemy szczegÃ³Å‚owo omawiaÄ‡: WiÄ™cej
szczegÃ³Å‚Ã³w moÅ¼na znaleÅºÄ‡ w dokumentacji biblioteki standardowej dla
<a href="../std/sync/atomic/index.html"><code>std::sync::atomic</code></a><!-- ignore -->. W tym momencie wystarczy wiedzieÄ‡,
Å¼e atomy dziaÅ‚ajÄ… jak typy prymitywne, ale sÄ… bezpieczne do wspÃ³Å‚dzielenia
miÄ™dzy wÄ…tkami.</p>
<p>MoÅ¼esz siÄ™ wtedy zastanawiaÄ‡, dlaczego wszystkie typy prymitywne nie sÄ…
atomowe i dlaczego typy biblioteki standardowej nie sÄ… domyÅ›lnie
zimplementowane do uÅ¼ywania <code>Arc&lt;T&gt;</code>. Powodem jest to, Å¼e bezpieczeÅ„stwo
wÄ…tkowe wiÄ…Å¼e siÄ™ z karÄ… wydajnoÅ›ciowÄ…, ktÃ³rÄ… chcesz ponieÅ›Ä‡ tylko wtedy, gdy
rzeczywiÅ›cie tego potrzebujesz. JeÅ›li wykonujesz operacje na wartoÅ›ciach
jednowÄ…tkowo, twÃ³j kod moÅ¼e dziaÅ‚aÄ‡ szybciej, jeÅ›li nie musi egzekwowaÄ‡
gwarancji zapewnianych przez atomy.</p>
<p>WrÃ³Ä‡my do naszego przykÅ‚adu: <code>Arc&lt;T&gt;</code> i <code>Rc&lt;T&gt;</code> majÄ… to samo API, wiÄ™c
naprawiamy nasz program, zmieniajÄ…c liniÄ™ <code>use</code>, wywoÅ‚anie <code>new</code> i wywoÅ‚anie
<code>clone</code>. Kod w Listingu 16-15 ostatecznie skompiluje siÄ™ i uruchomi.</p>
<listing number="16-15" file-name="src/main.rs" caption="UÅ¼ycie `Arc&lt;T&gt;` do opakowania `Mutex&lt;T&gt;`, aby mÃ³c wspÃ³Å‚dzieliÄ‡ wÅ‚asnoÅ›Ä‡ miÄ™dzy wieloma wÄ…tkami">
<pre class="playground"><code class="language-rust edition2024">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre>
</listing>
<p>Ten kod wypisze nastÄ™pujÄ…ce:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Result: 10
</code></pre>
<p>UdaÅ‚o siÄ™! PoliczyliÅ›my od 0 do 10, co moÅ¼e nie wydawaÄ‡ siÄ™ zbyt imponujÄ…ce,
ale wiele nas nauczyÅ‚o o <code>Mutex&lt;T&gt;</code> i bezpieczeÅ„stwie wÄ…tkowym. MoÅ¼esz rÃ³wnieÅ¼
wykorzystaÄ‡ strukturÄ™ tego programu do bardziej skomplikowanych operacji niÅ¼
samo zwiÄ™kszanie licznika. UÅ¼ywajÄ…c tej strategii, moÅ¼esz podzieliÄ‡ obliczenia
na niezaleÅ¼ne czÄ™Å›ci, rozdzieliÄ‡ te czÄ™Å›ci miÄ™dzy wÄ…tki, a nastÄ™pnie uÅ¼yÄ‡
<code>Mutex&lt;T&gt;</code>, aby kaÅ¼dy wÄ…tek aktualizowaÅ‚ ostateczny wynik swojÄ… czÄ™Å›ciÄ….</p>
<p>ZauwaÅ¼, Å¼e jeÅ›li wykonujesz proste operacje numeryczne, istniejÄ… typy
prostsze niÅ¼ <code>Mutex&lt;T&gt;</code> udostÄ™pniane przez moduÅ‚
<a href="../std/sync/atomic/index.html"><code>std::sync::atomic</code> biblioteki standardowej</a><!-- ignore -->. Typy te
zapewniajÄ… bezpieczny, wspÃ³Å‚bieÅ¼ny, atomowy dostÄ™p do typÃ³w prymitywnych.
WybraliÅ›my uÅ¼ycie <code>Mutex&lt;T&gt;</code> z typem prymitywnym w tym przykÅ‚adzie, abyÅ›my mogli
skupiÄ‡ siÄ™ na tym, jak dziaÅ‚a <code>Mutex&lt;T&gt;</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="similarities-between-refcelltrct-and-mutextarct"></a></p>
<h3 id="porÃ³wnanie-refcelltrct-i-mutextarct"><a class="header" href="#porÃ³wnanie-refcelltrct-i-mutextarct">PorÃ³wnanie <code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> i <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code></a></h3>
<p>ByÄ‡ moÅ¼e zauwaÅ¼yÅ‚eÅ›, Å¼e <code>counter</code> jest niemutowalny, ale mogliÅ›my uzyskaÄ‡ do
wartoÅ›ci w nim mutowalnÄ… referencjÄ™; oznacza to, Å¼e <code>Mutex&lt;T&gt;</code> zapewnia
mutowalnoÅ›Ä‡ wewnÄ™trznÄ…, podobnie jak rodzina <code>Cell</code>. W ten sam sposÃ³b, w jaki
wykorzystaliÅ›my <code>RefCell&lt;T&gt;</code> w Rozdziale 15, aby umoÅ¼liwiÄ‡ nam mutowanie
zawartoÅ›ci wewnÄ…trz <code>Rc&lt;T&gt;</code>, uÅ¼ywamy <code>Mutex&lt;T&gt;</code> do mutowania zawartoÅ›ci wewnÄ…trz
<code>Arc&lt;T&gt;</code>.</p>
<p>Kolejny szczegÃ³Å‚ do odnotowania to to, Å¼e Rust nie jest w stanie ochroniÄ‡ CiÄ™
przed wszystkimi rodzajami bÅ‚Ä™dÃ³w logicznych, gdy uÅ¼ywasz <code>Mutex&lt;T&gt;</code>. Przypomnij
sobie z RozdziaÅ‚u 15, Å¼e uÅ¼ycie <code>Rc&lt;T&gt;</code> wiÄ…zaÅ‚o siÄ™ z ryzykiem tworzenia cykli
referencji, gdzie dwie wartoÅ›ci <code>Rc&lt;T&gt;</code> odwoÅ‚ujÄ… siÄ™ do siebie nawzajem,
powodujÄ…c wycieki pamiÄ™ci. Podobnie, <code>Mutex&lt;T&gt;</code> wiÄ…Å¼e siÄ™ z ryzykiem tworzenia
<em>zakleszczeÅ„</em>. Dzieje siÄ™ to, gdy operacja musi zablokowaÄ‡ dwa zasoby, a dwa
wÄ…tki uzyskaÅ‚y po jednej blokadzie, powodujÄ…c, Å¼e czekajÄ… na siebie nawzajem w
nieskoÅ„czonoÅ›Ä‡. JeÅ›li interesujÄ… CiÄ™ zakleszczenia, sprÃ³buj stworzyÄ‡ program
w Rust, ktÃ³ry ma zakleszczenie; nastÄ™pnie zbadaj strategie Å‚agodzenia
zakleszczeÅ„ dla muteksÃ³w w dowolnym jÄ™zyku i sprÃ³buj je zaimplementowaÄ‡ w Rust.
Dokumentacja API biblioteki standardowej dla <code>Mutex&lt;T&gt;</code> i <code>MutexGuard</code> oferuje
przydatne informacje.</p>
<p>UkoÅ„czymy ten rozdziaÅ‚, mÃ³wiÄ…c o cechach <code>Send</code> i <code>Sync</code> oraz o tym, jak moÅ¼emy
ich uÅ¼ywaÄ‡ z niestandardowymi typami.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rozszerzalna-wspÃ³Å‚bieÅ¼noÅ›Ä‡-dziÄ™ki-cechom-send-i-sync-1"><a href="#rozszerzalna-wspÃ³Å‚bieÅ¼noÅ›Ä‡-dziÄ™ki-cechom-send-i-sync-1" class="header">Rozszerzalna wspÃ³Å‚bieÅ¼noÅ›Ä‡ dziÄ™ki cechom `Send` i `Sync`</a></h1>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="extensible-concurrency-with-the-sync-and-send-traits"></a>
<a id="extensible-concurrency-with-the-send-and-sync-traits"></a></p>
<h2 id="rozszerzalna-wspÃ³Å‚bieÅ¼noÅ›Ä‡-dziÄ™ki-cechom-send-i-sync"><a class="header" href="#rozszerzalna-wspÃ³Å‚bieÅ¼noÅ›Ä‡-dziÄ™ki-cechom-send-i-sync">Rozszerzalna wspÃ³Å‚bieÅ¼noÅ›Ä‡ dziÄ™ki cechom <code>Send</code> i <code>Sync</code></a></h2>
<p>Co ciekawe, prawie kaÅ¼da funkcja wspÃ³Å‚bieÅ¼noÅ›ci, o ktÃ³rej do tej pory
mÃ³wiliÅ›my w tym rozdziale, byÅ‚a czÄ™Å›ciÄ… biblioteki standardowej, a nie jÄ™zyka.
Twoje opcje obsÅ‚ugi wspÃ³Å‚bieÅ¼noÅ›ci nie ograniczajÄ… siÄ™ do jÄ™zyka ani
biblioteki standardowej; moÅ¼esz pisaÄ‡ wÅ‚asne funkcje wspÃ³Å‚bieÅ¼noÅ›ci lub
korzystaÄ‡ z tych napisanych przez innych.</p>
<p>JednakÅ¼e, wÅ›rÃ³d kluczowych koncepcji wspÃ³Å‚bieÅ¼noÅ›ci, ktÃ³re sÄ… osadzone w jÄ™zyku,
a nie w bibliotece standardowej, znajdujÄ… siÄ™ cechy znacznika <code>std::marker</code>
<code>Send</code> i <code>Sync</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="allowing-transference-of-ownership-between-threads-with-send"></a></p>
<h3 id="przenoszenie-wÅ‚asnoÅ›ci-miÄ™dzy-wÄ…tkami"><a class="header" href="#przenoszenie-wÅ‚asnoÅ›ci-miÄ™dzy-wÄ…tkami">Przenoszenie wÅ‚asnoÅ›ci miÄ™dzy wÄ…tkami</a></h3>
<p>Cecha znacznikowa <code>Send</code> wskazuje, Å¼e wÅ‚asnoÅ›Ä‡ wartoÅ›ci typu implementujÄ…cego
<code>Send</code> moÅ¼e byÄ‡ przenoszona miÄ™dzy wÄ…tkami. Prawie kaÅ¼dy typ Rust
implementuje <code>Send</code>, ale istniejÄ… pewne wyjÄ…tki, w tym <code>Rc&lt;T&gt;</code>: Nie moÅ¼e on
implementowaÄ‡ <code>Send</code>, poniewaÅ¼ gdybyÅ› sklonowaÅ‚ wartoÅ›Ä‡ <code>Rc&lt;T&gt;</code> i prÃ³bowaÅ‚
przenieÅ›Ä‡ wÅ‚asnoÅ›Ä‡ klonu do innego wÄ…tku, oba wÄ…tki mogÅ‚yby jednoczeÅ›nie
zaktualizowaÄ‡ licznik referencji. Z tego powodu <code>Rc&lt;T&gt;</code> jest zaimplementowany
do uÅ¼ytku w sytuacjach jednowÄ…tkowych, gdzie nie chcesz ponosiÄ‡ kary
wydajnoÅ›ciowej zwiÄ…zanej z bezpieczeÅ„stwem wÄ…tkÃ³w.</p>
<p>Dlatego system typÃ³w Rust i ograniczenia cech zapewniajÄ…, Å¼e nigdy nie moÅ¼esz
przypadkowo wysÅ‚aÄ‡ wartoÅ›ci <code>Rc&lt;T&gt;</code> miÄ™dzy wÄ…tkami w sposÃ³b niebezpieczny.
Kiedy prÃ³bowaliÅ›my to zrobiÄ‡ w Listingu 16-14, otrzymaliÅ›my bÅ‚Ä…d <code>the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`</code>. Kiedy zmieniliÅ›my na <code>Arc&lt;T&gt;</code>,
ktÃ³ry implementuje <code>Send</code>, kod siÄ™ skompilowaÅ‚.</p>
<p>KaÅ¼dy typ skÅ‚adajÄ…cy siÄ™ wyÅ‚Ä…cznie z typÃ³w <code>Send</code> jest automatycznie
oznaczany jako <code>Send</code>. Prawie wszystkie typy prymitywne sÄ… <code>Send</code>, poza
surowymi wskaÅºnikami, o ktÃ³rych bÄ™dziemy rozmawiaÄ‡ w Rozdziale 20.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="allowing-access-from-multiple-threads-with-sync"></a></p>
<h3 id="dostÄ™p-z-wielu-wÄ…tkÃ³w"><a class="header" href="#dostÄ™p-z-wielu-wÄ…tkÃ³w">DostÄ™p z wielu wÄ…tkÃ³w</a></h3>
<p>Cecha znacznikowa <code>Sync</code> wskazuje, Å¼e bezpieczne jest odwoÅ‚ywanie siÄ™ do typu
implementujÄ…cego <code>Sync</code> z wielu wÄ…tkÃ³w. Innymi sÅ‚owy, kaÅ¼dy typ <code>T</code>
implementuje <code>Sync</code>, jeÅ›li <code>&amp;T</code> (niemutowalna referencja do <code>T</code>) implementuje
<code>Send</code>, co oznacza, Å¼e referencja moÅ¼e byÄ‡ bezpiecznie wysÅ‚ana do innego wÄ…tku.
Podobnie jak <code>Send</code>, wszystkie typy prymitywne implementujÄ… <code>Sync</code>, a typy
skÅ‚adajÄ…ce siÄ™ wyÅ‚Ä…cznie z typÃ³w implementujÄ…cych <code>Sync</code> rÃ³wnieÅ¼ implementujÄ…
<code>Sync</code>.</p>
<p>WskaÅºnik sprytny <code>Rc&lt;T&gt;</code> rÃ³wnieÅ¼ nie implementuje <code>Sync</code> z tych samych powodÃ³w,
dla ktÃ³rych nie implementuje <code>Send</code>. Typ <code>RefCell&lt;T&gt;</code> (o ktÃ³rym mÃ³wiliÅ›my w
Rozdziale 15) i rodzina powiÄ…zanych typÃ³w <code>Cell&lt;T&gt;</code> nie implementujÄ… <code>Sync</code>.
Implementacja sprawdzania poÅ¼yczeÅ„, ktÃ³rÄ… <code>RefCell&lt;T&gt;</code> wykonuje w czasie
wykonania, nie jest bezpieczna wÄ…tkowo. WskaÅºnik sprytny <code>Mutex&lt;T&gt;</code> implementuje
<code>Sync</code> i moÅ¼e byÄ‡ uÅ¼ywany do wspÃ³Å‚dzielenia dostÄ™pu z wieloma wÄ…tkami, jak
widziaÅ‚eÅ› w sekcji <a href="#shared-access-to-mutext">â€WspÃ³Å‚dzielony dostÄ™p do <code>Mutex&lt;T&gt;</code>â€</a><!-- ignore -->.</p>
<h3 id="rÄ™czna-implementacja-send-i-sync-jest-niebezpieczna"><a class="header" href="#rÄ™czna-implementacja-send-i-sync-jest-niebezpieczna">RÄ™czna implementacja <code>Send</code> i <code>Sync</code> jest niebezpieczna</a></h3>
<p>PoniewaÅ¼ typy skÅ‚adajÄ…ce siÄ™ wyÅ‚Ä…cznie z innych typÃ³w, ktÃ³re implementujÄ…
cechy <code>Send</code> i <code>Sync</code>, automatycznie implementujÄ… rÃ³wnieÅ¼ <code>Send</code> i <code>Sync</code>, nie
musimy implementowaÄ‡ tych cech rÄ™cznie. Jako cechy znacznikowe, nie majÄ… one
nawet Å¼adnych metod do zaimplementowania. SÄ… po prostu przydatne do
egzekwowania niezmiennikÃ³w zwiÄ…zanych ze wspÃ³Å‚bieÅ¼noÅ›ciÄ….</p>
<p>RÄ™czna implementacja tych cech wiÄ…Å¼e siÄ™ z uÅ¼yciem niebezpiecznego kodu Rust.
O uÅ¼ywaniu niebezpiecznego kodu Rust bÄ™dziemy rozmawiaÄ‡ w Rozdziale 20;
na razie waÅ¼nÄ… informacjÄ… jest to, Å¼e budowanie nowych typÃ³w wspÃ³Å‚bieÅ¼nych nie
skÅ‚adajÄ…cych siÄ™ z czÄ™Å›ci <code>Send</code> i <code>Sync</code> wymaga starannego przemyÅ›lenia w
c celu utrzymania gwarancji bezpieczeÅ„stwa. <a href="../nomicon/index.html">â€The Rustonomiconâ€</a>
zawiera wiÄ™cej informacji na temat tych gwarancji i sposobÃ³w ich
podtrzymywania.</p>
<h2 id="podsumowanie-15"><a class="header" href="#podsumowanie-15">Podsumowanie</a></h2>
<p>To nie jest ostatni raz, kiedy spotkasz siÄ™ ze wspÃ³Å‚bieÅ¼noÅ›ciÄ… w tej ksiÄ…Å¼ce:
nastÄ™pny rozdziaÅ‚ skupia siÄ™ na programowaniu asynchronicznym, a projekt w
Rozdziale 21 wykorzysta koncepcje z tego rozdziaÅ‚u w bardziej realistycznej
sytuacji niÅ¼ omÃ³wione tutaj mniejsze przykÅ‚ady.</p>
<p>Jak wspomniano wczeÅ›niej, poniewaÅ¼ niewiele z tego, jak Rust obsÅ‚uguje
wspÃ³Å‚bieÅ¼noÅ›Ä‡, jest czÄ™Å›ciÄ… jÄ™zyka, wiele rozwiÄ…zaÅ„ wspÃ³Å‚bieÅ¼noÅ›ci jest
implementowanych jako crateâ€™y. EwoluujÄ… one szybciej niÅ¼ biblioteka standardowa,
wiÄ™c pamiÄ™taj, aby szukaÄ‡ w Internecie aktualnych, najnowoczeÅ›niejszych
crateâ€™Ã³w do uÅ¼ycia w sytuacjach wielowÄ…tkowych.</p>
<p>Biblioteka standardowa Rust zapewnia kanaÅ‚y do przekazywania wiadomoÅ›ci oraz
typy wskaÅºnikÃ³w sprytnych, takie jak <code>Mutex&lt;T&gt;</code> i <code>Arc&lt;T&gt;</code>, ktÃ³re sÄ… bezpieczne
w uÅ¼yciu w kontekstach wspÃ³Å‚bieÅ¼nych. System typÃ³w i sprawdzajÄ…cy poÅ¼yczki
zapewniajÄ…, Å¼e kod uÅ¼ywajÄ…cy tych rozwiÄ…zaÅ„ nie doprowadzi do wyÅ›cigÃ³w danych
oraz do niewaÅ¼nych referencji. Gdy kod siÄ™ skompiluje, moÅ¼esz byÄ‡ pewien, Å¼e
bÄ™dzie dziaÅ‚aÅ‚ na wielu wÄ…tkach bez trudnych do znalezienia bÅ‚Ä™dÃ³w, typowych
dla innych jÄ™zykÃ³w. Programowanie wspÃ³Å‚bieÅ¼ne nie jest juÅ¼ pojÄ™ciem, ktÃ³rego
naleÅ¼y siÄ™ obawiaÄ‡: idÅº i spraw, aby twoje programy byÅ‚y wspÃ³Å‚bieÅ¼ne,
bez strachu!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="podstawy-programowania-asynchronicznego-async-await-futures-i-streams"><a class="header" href="#podstawy-programowania-asynchronicznego-async-await-futures-i-streams">Podstawy programowania asynchronicznego: Async, Await, Futures i Streams</a></h1>
<p>Wiele operacji, o ktÃ³re prosimy komputer, moÅ¼e zajÄ…Ä‡ trochÄ™ czasu. Dobrze by
byÅ‚o, gdybyÅ›my mogli robiÄ‡ coÅ› innego, czekajÄ…c na zakoÅ„czenie tych
dÅ‚ugotrwaÅ‚ych procesÃ³w. Nowoczesne komputery oferujÄ… dwie techniki pracy nad
wiÄ™cej niÅ¼ jednÄ… operacjÄ… jednoczeÅ›nie: rÃ³wnolegÅ‚oÅ›Ä‡ i wspÃ³Å‚bieÅ¼noÅ›Ä‡. Logika
naszych programÃ³w jest jednak pisana w sposÃ³b gÅ‚Ã³wnie liniowy. ChcielibyÅ›my
mÃ³c okreÅ›laÄ‡ operacje, ktÃ³re program powinien wykonaÄ‡, oraz punkty, w ktÃ³rych
funkcja mogÅ‚aby siÄ™ zatrzymaÄ‡, a jakaÅ› inna czÄ™Å›Ä‡ programu mogÅ‚aby dziaÅ‚aÄ‡
zamiast niej, bez koniecznoÅ›ci wczeÅ›niejszego precyzowania dokÅ‚adnej
kolejnoÅ›ci i sposobu, w jaki kaÅ¼dy fragment kodu powinien dziaÅ‚aÄ‡.
<em>Programowanie asynchroniczne</em> to abstrakcja, ktÃ³ra pozwala nam wyraÅ¼aÄ‡ kod w
terminach potencjalnych punktÃ³w pauzy i ostatecznych wynikÃ³w, ktÃ³ra zajmuje
siÄ™ szczegÃ³Å‚ami koordynacji za nas.</p>
<p>Ten rozdziaÅ‚ opiera siÄ™ na uÅ¼yciu wÄ…tkÃ³w do rÃ³wnolegÅ‚oÅ›ci i wspÃ³Å‚bieÅ¼noÅ›ci z
RozdziaÅ‚u 16, wprowadzajÄ…c alternatywne podejÅ›cie do pisania kodu: futures i
streams Rust oraz skÅ‚adniÄ™ <code>async</code> i <code>await</code>, ktÃ³re pozwalajÄ… nam wyraziÄ‡, jak
operacje mogÄ… byÄ‡ asynchroniczne, oraz crateâ€™y zewnÄ™trzne, ktÃ³re
implementujÄ… Å›rodowiska uruchomieniowe asynchroniczne: kod, ktÃ³ry zarzÄ…dza i
koordynuje wykonywanie operacji asynchronicznych.</p>
<p>RozwaÅ¼my przykÅ‚ad. Powiedzmy, Å¼e eksportujesz wideo, ktÃ³re stworzyÅ‚eÅ› z
rodzinnej uroczystoÅ›ci â€“ operacja, ktÃ³ra moÅ¼e trwaÄ‡ od kilku minut do kilku
godzin. Eksport wideo wykorzysta tyle mocy CPU i GPU, ile tylko moÅ¼e. GdybyÅ›
miaÅ‚ tylko jeden rdzeÅ„ CPU, a system operacyjny nie wstrzymywaÅ‚by tego eksportu
do momentu jego zakoÅ„czenia â€“ to znaczy, gdyby wykonywaÅ‚ eksport
<em>synchronicznie</em> â€“ nie mÃ³gÅ‚byÅ› robiÄ‡ niczego innego na swoim komputerze, podczas
gdy to zadanie byÅ‚oby uruchomione. ByÅ‚oby to doÅ›Ä‡ frustrujÄ…ce doÅ›wiadczenie.
Na szczÄ™Å›cie system operacyjny twojego komputera moÅ¼e, i robi to, niewidocznie
przerywaÄ‡ eksport wystarczajÄ…co czÄ™sto, abyÅ› mÃ³gÅ‚ jednoczeÅ›nie wykonywaÄ‡ innÄ…
pracÄ™.</p>
<p>Teraz powiedzmy, Å¼e pobierasz wideo udostÄ™pnione przez kogoÅ› innego, co rÃ³wnieÅ¼
moÅ¼e trochÄ™ potrwaÄ‡, ale nie zajmuje tyle czasu procesora. W tym przypadku
procesor musi czekaÄ‡ na dane z sieci. ChociaÅ¼ moÅ¼esz zaczÄ…Ä‡ odczytywaÄ‡ dane, gdy
zacznÄ… napÅ‚ywaÄ‡, moÅ¼e minÄ…Ä‡ trochÄ™ czasu, zanim wszystkie siÄ™ pojawiÄ…. Nawet
gdy wszystkie dane sÄ… juÅ¼ dostÄ™pne, jeÅ›li wideo jest doÅ›Ä‡ duÅ¼e, zaÅ‚adowanie
caÅ‚oÅ›ci moÅ¼e zajÄ…Ä‡ co najmniej sekundÄ™ lub dwie. MoÅ¼e to nie brzmieÄ‡ jak wiele,
ale to bardzo dÅ‚ugo dla nowoczesnego procesora, ktÃ³ry potrafi wykonywaÄ‡
miliardy operacji na sekundÄ™. Ponownie, system operacyjny niewidocznie
przerwie TwÃ³j program, aby umoÅ¼liwiÄ‡ procesorowi wykonywanie innej pracy,
podczas gdy czeka na zakoÅ„czenie wywoÅ‚ania sieciowego.</p>
<p>Eksport wideo jest przykÅ‚adem operacji <em>CPU-bound</em> (ograniczonej przez CPU)
lub <em>compute-bound</em> (ograniczonej przez obliczenia). Jest ograniczony przez
potencjalnÄ… szybkoÅ›Ä‡ przetwarzania danych przez komputer w obrÄ™bie CPU lub GPU
oraz przez to, ile z tej szybkoÅ›ci moÅ¼e poÅ›wiÄ™ciÄ‡ na operacjÄ™. Pobieranie wideo
jest przykÅ‚adem operacji <em>I/O-bound</em> (ograniczonej przez wejÅ›cie/wyjÅ›cie),
poniewaÅ¼ jest ograniczone szybkoÅ›ciÄ… <em>wejÅ›cia i wyjÅ›cia</em> komputera; moÅ¼e dziaÅ‚aÄ‡
tylko tak szybko, jak dane mogÄ… byÄ‡ przesyÅ‚ane przez sieÄ‡.</p>
<p>W obu tych przykÅ‚adach niewidoczne przerwania systemu operacyjnego zapewniajÄ…
pewnÄ… formÄ™ wspÃ³Å‚bieÅ¼noÅ›ci. WspÃ³Å‚bieÅ¼noÅ›Ä‡ ta ma jednak miejsce tylko na
poziomie caÅ‚ego programu: system operacyjny przerywa jeden program, aby
inne programy mogÅ‚y wykonywaÄ‡ swojÄ… pracÄ™. W wielu przypadkach, poniewaÅ¼
rozumiemy nasze programy na znacznie bardziej szczegÃ³Å‚owym poziomie niÅ¼ system
operacyjny, moÅ¼emy dostrzec moÅ¼liwoÅ›ci wspÃ³Å‚bieÅ¼noÅ›ci, ktÃ³rych system
operacyjny nie jest w stanie zobaczyÄ‡.</p>
<p>Na przykÅ‚ad, jeÅ›li budujemy narzÄ™dzie do zarzÄ…dzania pobieraniem plikÃ³w,
powinniÅ›my mÃ³c napisaÄ‡ nasz program tak, aby rozpoczÄ™cie jednego pobierania
nie blokowaÅ‚o interfejsu uÅ¼ytkownika, a uÅ¼ytkownicy mogli rozpoczÄ…Ä‡ wiele
pobieraÅ„ jednoczeÅ›nie. Wiele API systemÃ³w operacyjnych do interakcji z sieciÄ…
jest jednak <em>blokujÄ…cych</em>; to znaczy, blokujÄ… one postÄ™p programu, dopÃ³ki
przetwarzane dane nie bÄ™dÄ… caÅ‚kowicie gotowe.</p>
<blockquote>
<p>Uwaga: Tak dziaÅ‚a <em>wiÄ™kszoÅ›Ä‡</em> wywoÅ‚aÅ„ funkcji, jeÅ›li siÄ™ nad tym zastanowisz.
Jednak termin <em>blokujÄ…cy</em> jest zazwyczaj zarezerwowany dla wywoÅ‚aÅ„ funkcji,
ktÃ³re wspÃ³Å‚dziaÅ‚ajÄ… z plikami, sieciÄ… lub innymi zasobami na komputerze,
poniewaÅ¼ to wÅ‚aÅ›nie w tych przypadkach indywidualny program skorzystaÅ‚by na
tym, aby operacja byÅ‚a <em>nie</em>-blokujÄ…ca.</p>
</blockquote>
<p>MoglibyÅ›my uniknÄ…Ä‡ blokowania naszego gÅ‚Ã³wnego wÄ…tku, tworzÄ…c dedykowany
wÄ…tek do pobierania kaÅ¼dego pliku. Jednak narzut zasobÃ³w systemowych
wykorzystywanych przez te wÄ…tki w koÅ„cu staÅ‚by siÄ™ problemem. ByÅ‚oby lepiej,
gdyby wywoÅ‚anie w ogÃ³le nie blokowaÅ‚o, a zamiast tego moglibyÅ›my zdefiniowaÄ‡
wiele zadaÅ„, ktÃ³re chcielibyÅ›my, aby nasz program wykonaÅ‚, i pozwoliÄ‡ Å›rodowisku
uruchomieniowemu wybraÄ‡ najlepszÄ… kolejnoÅ›Ä‡ i sposÃ³b ich wykonania.</p>
<p>WÅ‚aÅ›nie to zapewnia nam abstrakcja <em>async</em> (skrÃ³t od <em>asynchronous</em>) w Rust.
W tym rozdziale dowiesz siÄ™ wszystkiego o async, omawiajÄ…c nastÄ™pujÄ…ce tematy:</p>
<ul>
<li>Jak uÅ¼ywaÄ‡ skÅ‚adni <code>async</code> i <code>await</code> Rust oraz wykonywaÄ‡ funkcje
asynchroniczne w Å›rodowisku uruchomieniowym</li>
<li>Jak uÅ¼ywaÄ‡ modelu async do rozwiÄ…zywania niektÃ³rych z tych samych problemÃ³w,
ktÃ³re rozwaÅ¼aliÅ›my w Rozdziale 16</li>
<li>Jak wielowÄ…tkowoÅ›Ä‡ i async zapewniajÄ… uzupeÅ‚niajÄ…ce siÄ™ rozwiÄ…zania, ktÃ³re
moÅ¼na Å‚Ä…czyÄ‡ w wielu przypadkach</li>
</ul>
<p>Zanim jednak zobaczymy, jak async dziaÅ‚a w praktyce, musimy zrobiÄ‡ krÃ³tki
objazd, aby omÃ³wiÄ‡ rÃ³Å¼nice miÄ™dzy rÃ³wnolegÅ‚oÅ›ciÄ… a wspÃ³Å‚bieÅ¼noÅ›ciÄ….</p>
<h2 id="rÃ³wnolegÅ‚oÅ›Ä‡-i-wspÃ³Å‚bieÅ¼noÅ›Ä‡"><a class="header" href="#rÃ³wnolegÅ‚oÅ›Ä‡-i-wspÃ³Å‚bieÅ¼noÅ›Ä‡">RÃ³wnolegÅ‚oÅ›Ä‡ i wspÃ³Å‚bieÅ¼noÅ›Ä‡</a></h2>
<p>Do tej pory traktowaliÅ›my rÃ³wnolegÅ‚oÅ›Ä‡ i wspÃ³Å‚bieÅ¼noÅ›Ä‡ jako w wiÄ™kszoÅ›ci
wymienne. Teraz musimy je precyzyjniej rozrÃ³Å¼niÄ‡, poniewaÅ¼ rÃ³Å¼nice pojawiÄ…
siÄ™, gdy zaczniemy pracowaÄ‡.</p>
<p>RozwaÅ¼my rÃ³Å¼ne sposoby, w jakie zespÃ³Å‚ mÃ³gÅ‚by podzieliÄ‡ pracÄ™ nad projektem
o programowaniu. MoÅ¼na by przydzieliÄ‡ jednemu czÅ‚onkowi wiele zadaÅ„, kaÅ¼demu
czÅ‚onkowi jedno zadanie, lub zastosowaÄ‡ poÅ‚Ä…czenie obu podejÅ›Ä‡.</p>
<p>Kiedy jednostka pracuje nad kilkoma rÃ³Å¼nymi zadaniami, zanim ktÃ³rekolwiek z
nich zostanie ukoÅ„czone, jest to <em>wspÃ³Å‚bieÅ¼noÅ›Ä‡</em>. Jeden ze sposobÃ³w
implementacji wspÃ³Å‚bieÅ¼noÅ›ci jest podobny do posiadania dwÃ³ch rÃ³Å¼nych
projektÃ³w pobranych na komputerze, a kiedy siÄ™ znudzisz lub utkniesz na jednym
projekcie, przeÅ‚Ä…czasz siÄ™ na drugi. JesteÅ› tylko jednÄ… osobÄ…, wiÄ™c nie moÅ¼esz
poczyniÄ‡ postÄ™pÃ³w w obu zadaniach dokÅ‚adnie w tym samym czasie, ale moÅ¼esz
wielozadaniowo, robiÄ…c postÄ™py w jednym zadaniu naraz, przeÅ‚Ä…czajÄ…c siÄ™ miÄ™dzy
nimi (patrz Rysunek 17-1).</p>
<figure>
<img src="img/trpl17-01.svg" class="center" alt="A diagram with stacked boxes labeled Task A and Task B, with diamonds in them representing subtasks. Arrows point from A1 to B1, B1 to A2, A2 to B2, B2 to A3, A3 to A4, and A4 to B3. The arrows between the subtasks cross the boxes between Task A and Task B." />
<figcaption>Rysunek 17-1: WspÃ³Å‚bieÅ¼ny przepÅ‚yw pracy, przeÅ‚Ä…czanie miÄ™dzy Zadaniem A i Zadaniem B</figcaption>
</figure>
<p>Kiedy zespÃ³Å‚ dzieli grupÄ™ zadaÅ„, tak Å¼e kaÅ¼dy czÅ‚onek bierze jedno zadanie i
pracuje nad nim samodzielnie, jest to <em>rÃ³wnolegÅ‚oÅ›Ä‡</em>. KaÅ¼da osoba w zespole
moÅ¼e robiÄ‡ postÄ™py dokÅ‚adnie w tym samym czasie (patrz Rysunek 17-2).</p>
<figure>
<img src="img/trpl17-02.svg" class="center" alt="A diagram with stacked boxes labeled Task A and Task B, with diamonds in them representing subtasks. Arrows point from A1 to A2, A2 to A3, A3 to A4, B1 to B2, and B2 to B3. No arrows cross between the boxes for Task A and Task B." />
<figcaption>Rysunek 17-2: RÃ³wnolegÅ‚y przepÅ‚yw pracy, gdzie praca odbywa siÄ™ niezaleÅ¼nie w Zadaniu A i Zadaniu B</figcaption>
</figure>
<p>W obu tych przepÅ‚ywach pracy, moÅ¼esz musieÄ‡ koordynowaÄ‡ dziaÅ‚ania miÄ™dzy
rÃ³Å¼nymi zadaniami. MoÅ¼e myÅ›laÅ‚eÅ›, Å¼e zadanie przydzielone jednej osobie byÅ‚o
caÅ‚kowicie niezaleÅ¼ne od pracy innych, ale w rzeczywistoÅ›ci wymaga ono od innej
osoby w zespole najpierw zakoÅ„czenia swojego zadania. CzÄ™Å›Ä‡ pracy mogÅ‚a byÄ‡
wykonana rÃ³wnolegle, ale czÄ™Å›Ä‡ z nich byÅ‚a w rzeczywistoÅ›ci <em>sekwencyjna</em>: mogÅ‚a
dziaÄ‡ siÄ™ tylko w serii, jedno zadanie po drugim, jak na Rysunku 17-3.</p>
<figure>
<img src="img/trpl17-03.svg" class="center" alt="A diagram with stacked boxes labeled Task A and Task B, with diamonds in them representing subtasks. In Task A, arrows point from A1 to A2, from A2 to a pair of thick vertical lines like a â€œpauseâ€ symbol, and from that symbol to A3. In task B, arrows point from B1 to B2, from B2 to B3, from B3 to A3, and from B3 to B4." />
<figcaption>Rysunek 17-3: CzÄ™Å›ciowo rÃ³wnolegÅ‚y przepÅ‚yw pracy, gdzie praca odbywa siÄ™ niezaleÅ¼nie w Zadaniu A i Zadaniu B, dopÃ³ki Zadanie A3 nie zostanie zablokowane przez wyniki Zadania B3.</figcaption>
</figure>
<p>Podobnie, moÅ¼esz zdaÄ‡ sobie sprawÄ™, Å¼e jedno z twoich zadaÅ„ zaleÅ¼y od innego z
twoich zadaÅ„. Wtedy twoja wspÃ³Å‚bieÅ¼na praca rÃ³wnieÅ¼ staÅ‚a siÄ™ szeregowa.</p>
<p>RÃ³wnolegÅ‚oÅ›Ä‡ i wspÃ³Å‚bieÅ¼noÅ›Ä‡ mogÄ… siÄ™ rÃ³wnieÅ¼ ze sobÄ… krzyÅ¼owaÄ‡. JeÅ›li dowiesz
siÄ™, Å¼e kolega utknÄ…Å‚, dopÃ³ki nie skoÅ„czysz jednego ze swoich zadaÅ„,
prawdopodobnie skupisz wszystkie swoje wysiÅ‚ki na tym zadaniu, aby â€odblokowaÄ‡â€
swojego kolegÄ™. Ty i twÃ³j wspÃ³Å‚pracownik nie jesteÅ›cie juÅ¼ w stanie pracowaÄ‡
rÃ³wnolegle, a takÅ¼e nie jesteÅ›cie juÅ¼ w stanie pracowaÄ‡ wspÃ³Å‚bieÅ¼nie nad
wÅ‚asnymi zadaniami.</p>
<p>Ta sama podstawowa dynamika wchodzi w grÄ™ w oprogramowaniu i sprzÄ™cie. Na
maszynie z pojedynczym rdzeniem CPU, CPU moÅ¼e wykonywaÄ‡ tylko jednÄ… operacjÄ™ na
raz, ale nadal moÅ¼e dziaÅ‚aÄ‡ wspÃ³Å‚bieÅ¼nie. UÅ¼ywajÄ…c narzÄ™dzi takich jak wÄ…tki,
procesy i async, komputer moÅ¼e wstrzymaÄ‡ jednÄ… aktywnoÅ›Ä‡ i przeÅ‚Ä…czyÄ‡ siÄ™ na
inne, zanim ostatecznie powrÃ³ci do tej pierwszej aktywnoÅ›ci. Na maszynie z
wieloma rdzeniami CPU, moÅ¼e rÃ³wnieÅ¼ wykonywaÄ‡ pracÄ™ rÃ³wnolegle. Jeden rdzeÅ„ moÅ¼e
wykonywaÄ‡ jedno zadanie, podczas gdy inny rdzeÅ„ wykonuje zupeÅ‚nie
niepowiÄ…zane zadanie, a te operacje faktycznie dziejÄ… siÄ™ w tym samym czasie.</p>
<p>Uruchamianie kodu async w Rust zazwyczaj odbywa siÄ™ wspÃ³Å‚bieÅ¼nie. W zaleÅ¼noÅ›ci
od sprzÄ™tu, systemu operacyjnego i uÅ¼ywanego Å›rodowiska asynchronicznego
(wiÄ™cej o Å›rodowiskach asynchronicznych wkrÃ³tce), ta wspÃ³Å‚bieÅ¼noÅ›Ä‡ moÅ¼e rÃ³wnieÅ¼
wykorzystywaÄ‡ rÃ³wnolegÅ‚oÅ›Ä‡ pod maskÄ….</p>
<p>Teraz zagÅ‚Ä™bmy siÄ™ w to, jak faktycznie dziaÅ‚a programowanie asynchroniczne w
Rust.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="futures-i-skÅ‚adnia-async-1"><a href="#futures-i-skÅ‚adnia-async-1" class="header">Futures i skÅ‚adnia `async`</a></h1>
<h2 id="futures-i-skÅ‚adnia-async"><a class="header" href="#futures-i-skÅ‚adnia-async">Futures i skÅ‚adnia <code>async</code></a></h2>
<p>Kluczowymi elementami programowania asynchronicznego w Rust sÄ… <em>futures</em> oraz
sÅ‚owa kluczowe <code>async</code> i <code>await</code> Rust.</p>
<p><em>Future</em> to wartoÅ›Ä‡, ktÃ³ra moÅ¼e nie byÄ‡ gotowa teraz, ale stanie siÄ™ gotowa w
pewnym momencie w przyszÅ‚oÅ›ci. (Ta sama koncepcja pojawia siÄ™ w wielu jÄ™zykach,
czasami pod innymi nazwami, takimi jak <em>task</em> lub <em>promise</em>.) Rust zapewnia
cechÄ™ <code>Future</code> jako element konstrukcyjny, dziÄ™ki czemu rÃ³Å¼ne operacje
asynchroniczne mogÄ… byÄ‡ implementowane z rÃ³Å¼nymi strukturami danych, ale z
jednolitym interfejsem. W Rust futures to typy, ktÃ³re implementujÄ… cechÄ™
<code>Future</code>. KaÅ¼da przyszÅ‚oÅ›Ä‡ przechowuje wÅ‚asne informacje o postÄ™pie, ktÃ³ry
zostaÅ‚ osiÄ…gniÄ™ty, i co oznacza â€gotowyâ€.</p>
<p>MoÅ¼esz zastosowaÄ‡ sÅ‚owo kluczowe <code>async</code> do blokÃ³w i funkcji, aby okreÅ›liÄ‡,
Å¼e mogÄ… byÄ‡ one przerywane i wznawiane. WewnÄ…trz bloku async lub funkcji async,
moÅ¼esz uÅ¼yÄ‡ sÅ‚owa kluczowego <code>await</code>, aby <em>oczekiwaÄ‡ na przyszÅ‚oÅ›Ä‡</em> (czyli
poczekaÄ‡, aÅ¼ stanie siÄ™ gotowa). KaÅ¼dy punkt, w ktÃ³rym oczekujesz na przyszÅ‚oÅ›Ä‡
w bloku async lub funkcji async, jest potencjalnym miejscem, w ktÃ³rym ten blok
lub funkcja moÅ¼e siÄ™ zatrzymaÄ‡ i wznowiÄ‡. Proces sprawdzania z przyszÅ‚oÅ›ciÄ…, czy
jej wartoÅ›Ä‡ jest juÅ¼ dostÄ™pna, nazywa siÄ™ <em>polling</em> (odpytywaniem).</p>
<p>NiektÃ³re inne jÄ™zyki, takie jak C# i JavaScript, rÃ³wnieÅ¼ uÅ¼ywajÄ… sÅ‚Ã³w
kluczowych <code>async</code> i <code>await</code> do programowania asynchronicznego. JeÅ›li znasz te
jÄ™zyki, moÅ¼esz zauwaÅ¼yÄ‡ pewne znaczÄ…ce rÃ³Å¼nice w sposobie obsÅ‚ugi skÅ‚adni przez
Rust. Ma to dobry powÃ³d, jak zobaczymy!</p>
<p>PiszÄ…c kod async w Rust, uÅ¼ywamy sÅ‚Ã³w kluczowych <code>async</code> i <code>await</code> przez wiÄ™kszoÅ›Ä‡
czasu. Rust kompiluje je do rÃ³wnowaÅ¼nego kodu uÅ¼ywajÄ…cego cechy <code>Future</code>,
podobnie jak kompiluje pÄ™tle <code>for</code> do rÃ³wnowaÅ¼nego kodu uÅ¼ywajÄ…cego cechy
<code>Iterator</code>. PoniewaÅ¼ Rust zapewnia cechÄ™ <code>Future</code>, moÅ¼esz jÄ… rÃ³wnieÅ¼
zaimplementowaÄ‡ dla wÅ‚asnych typÃ³w danych, gdy tego potrzebujesz. Wiele funkcji,
ktÃ³re zobaczymy w tym rozdziale, zwraca typy z wÅ‚asnymi implementacjami
<code>Future</code>. WrÃ³Ä‡my do definicji cechy na koÅ„cu rozdziaÅ‚u i zagÅ‚Ä™bmy siÄ™ w to, jak
dziaÅ‚a, ale to wystarczy, abyÅ›my mogli kontynuowaÄ‡.</p>
<p>Wszystko to moÅ¼e wydawaÄ‡ siÄ™ nieco abstrakcyjne, wiÄ™c napiszmy nasz pierwszy
program asynchroniczny: maÅ‚y scraper internetowy. PrzekaÅ¼emy dwa adresy URL z
wiersza poleceÅ„, pobierzemy je oba wspÃ³Å‚bieÅ¼nie i zwrÃ³cimy wynik tego, ktÃ³ry
zakoÅ„czy siÄ™ jako pierwszy. Ten przykÅ‚ad bÄ™dzie zawieraÅ‚ sporo nowej skÅ‚adni,
ale nie martw siÄ™ â€“ wyjaÅ›nimy wszystko, co musisz wiedzieÄ‡, w trakcie.</p>
<h2 id="nasz-pierwszy-program-asynchroniczny"><a class="header" href="#nasz-pierwszy-program-asynchroniczny">Nasz pierwszy program asynchroniczny</a></h2>
<p>Aby skupiÄ‡ siÄ™ w tym rozdziale na nauce async, a nie na Å¼onglowaniu czÄ™Å›ciami
ekosystemu, stworzyliÅ›my crate <code>trpl</code> (<code>trpl</code> to skrÃ³t od â€The Rust Programming
Languageâ€). Reeksportuje on wszystkie typy, cechy i funkcje, ktÃ³rych bÄ™dziesz
potrzebowaÄ‡, gÅ‚Ã³wnie z crateâ€™Ã³w <a href="https://crates.io/crates/futures"><code>futures</code></a><!-- ignore --> i
<a href="https://tokio.rs"><code>tokio</code></a><!-- ignore -->. Crate <code>futures</code> jest oficjalnym miejscem
eksperymentÃ³w Rust dla kodu async i to wÅ‚aÅ›nie tam pierwotnie zaprojektowano
cechÄ™ <code>Future</code>. Tokio jest obecnie najczÄ™Å›ciej uÅ¼ywanym Å›rodowiskiem
asynchronicznym w Rust, zwÅ‚aszcza w aplikacjach internetowych. IstniejÄ… inne
dobre Å›rodowiska uruchomieniowe, ktÃ³re mogÄ… byÄ‡ bardziej odpowiednie dla Twoich
potrzeb. UÅ¼ywamy crateâ€™a <code>tokio</code> pod maskÄ… dla <code>trpl</code>, poniewaÅ¼ jest dobrze
przetestowany i szeroko stosowany.</p>
<p>W niektÃ³rych przypadkach <code>trpl</code> rÃ³wnieÅ¼ zmienia nazwy lub opakowuje oryginalne
API, abyÅ› skupiÅ‚ siÄ™ na szczegÃ³Å‚ach istotnych dla tego rozdziaÅ‚u. JeÅ›li chcesz
zrozumieÄ‡, co robi ten crate, zachÄ™camy do zapoznania siÄ™ z <a href="https://github.com/rust-lang/book/tree/main/packages/trpl">jego kodem
ÅºrÃ³dÅ‚owym</a>. BÄ™dziesz mÃ³gÅ‚ zobaczyÄ‡, z ktÃ³rego crateâ€™a pochodzi
kaÅ¼dy reeksport, a my zostawiliÅ›my obszerne komentarze wyjaÅ›niajÄ…ce, co robi
crate.</p>
<p>StwÃ³rzmy nowy projekt binarny o nazwie <code>hello-async</code> i dodajmy crate <code>trpl</code>
jako zaleÅ¼noÅ›Ä‡:</p>
<pre><code class="language-console">$ cargo new hello-async
$ cd hello-async
$ cargo add trpl
</code></pre>
<p>Teraz moÅ¼emy uÅ¼yÄ‡ rÃ³Å¼nych elementÃ³w dostarczonych przez <code>trpl</code> do napisania
naszego pierwszego programu asynchronicznego. Zbudujemy maÅ‚e narzÄ™dzie
wiersza poleceÅ„, ktÃ³re pobierze dwie strony internetowe, wyciÄ…gnie z kaÅ¼dej z
nich element <code>&lt;title&gt;</code> i wypisze tytuÅ‚ tej strony, ktÃ³ra zakoÅ„czy caÅ‚y proces
pierwsza.</p>
<h3 id="definiowanie-funkcji-page_title"><a class="header" href="#definiowanie-funkcji-page_title">Definiowanie funkcji <code>page_title</code></a></h3>
<p>Zacznijmy od napisania funkcji, ktÃ³ra przyjmuje jeden URL strony jako parametr,
wykonuje do niego Å¼Ä…danie i zwraca tekst elementu <code>&lt;title&gt;</code> (patrz Listing 17-1).</p>
<listing number="17-1" file-name="src/main.rs" caption="Definiowanie funkcji `async` do pobierania elementu `title` ze strony HTML">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // TODO: we'll add this next!
</span><span class="boring">}
</span><span class="boring">
</span>use trpl::Html;

async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
    let response = trpl::get(url).await;
    let response_text = response.text().await;
    Html::parse(&amp;response_text)
        .select_first("title")
        .map(|title| title.inner_html())
}</code></pre>
</listing>
<p>Najpierw definiujemy funkcjÄ™ o nazwie <code>page_title</code> i oznaczamy jÄ… sÅ‚owem
kluczowym <code>async</code>. NastÄ™pnie uÅ¼ywamy funkcji <code>trpl::get</code>, aby pobraÄ‡ dowolny
przekazany URL i dodajemy sÅ‚owo kluczowe <code>await</code>, aby oczekiwaÄ‡ na
odpowiedÅº. Aby uzyskaÄ‡ tekst <code>response</code>, wywoÅ‚ujemy jego metodÄ™ <code>text</code> i
ponownie oczekujemy na niÄ… za pomocÄ… sÅ‚owa kluczowego <code>await</code>. Oba te kroki
sÄ… asynchroniczne. Dla funkcji <code>get</code> musimy poczekaÄ‡, aÅ¼ serwer odeÅ›le
pierwszÄ… czÄ™Å›Ä‡ swojej odpowiedzi, ktÃ³ra bÄ™dzie zawieraÅ‚a nagÅ‚Ã³wki HTTP,
ciasteczka itd. i moÅ¼e byÄ‡ dostarczana osobno od treÅ›ci odpowiedzi. ZwÅ‚aszcza
jeÅ›li treÅ›Ä‡ jest bardzo duÅ¼a, jej dotarcie moÅ¼e zajÄ…Ä‡ trochÄ™ czasu. PoniewaÅ¼
musimy poczekaÄ‡ na <em>caÅ‚oÅ›Ä‡</em> odpowiedzi, metoda <code>text</code> rÃ³wnieÅ¼ jest asynchroniczna.</p>
<p>Musimy jawnie oczekiwaÄ‡ na obie te futures, poniewaÅ¼ futures w Rust sÄ…
<em>leniwymi</em>: nie robiÄ… nic, dopÃ³ki nie poprosisz ich o to sÅ‚owem kluczowym
<code>await</code>. (W rzeczywistoÅ›ci Rust wyÅ›wietli ostrzeÅ¼enie kompilatora, jeÅ›li nie
uÅ¼yjesz future.) To moÅ¼e przypominaÄ‡ dyskusjÄ™ o iteratorach w sekcji
<a href="#przetwarzanie-serii-elementÃ³w-za-pomocÄ…-iteratorÃ³w-1">â€Przetwarzanie sekwencji elementÃ³w za pomocÄ… iteratorÃ³wâ€</a><!--
ignore --> w Rozdziale 13. Iteratory nic nie robiÄ…, dopÃ³ki nie wywoÅ‚asz ich
metody <code>next</code> â€“ bezpoÅ›rednio lub za pomocÄ… pÄ™tli <code>for</code> lub metod takich jak
<code>map</code>, ktÃ³re uÅ¼ywajÄ… <code>next</code> pod maskÄ…. Podobnie, futures nic nie robiÄ…, dopÃ³ki
nie poprosisz ich o to jawnie. Ta leniwoÅ›Ä‡ pozwala Rustowi uniknÄ…Ä‡
uruchamiania kodu async, dopÃ³ki nie jest on faktycznie potrzebny.</p>
<blockquote>
<p>Uwaga: RÃ³Å¼ni siÄ™ to od zachowania, ktÃ³re widzieliÅ›my podczas uÅ¼ywania
<code>thread::spawn</code> w sekcji <a href="#creating-a-new-thread-with-spawn">â€Tworzenie nowego wÄ…tku za pomocÄ…
spawnâ€</a><!-- ignore --> w Rozdziale 16, gdzie domkniÄ™cie,
ktÃ³re przekazaliÅ›my do innego wÄ…tku, zaczÄ™Å‚o dziaÅ‚aÄ‡ natychmiast. RÃ³Å¼ni siÄ™
to rÃ³wnieÅ¼ od podejÅ›cia wielu innych jÄ™zykÃ³w do async. Ale jest to waÅ¼ne,
aby Rust mÃ³gÅ‚ zapewniÄ‡ swoje gwarancje wydajnoÅ›ci, tak jak w przypadku
iteratorÃ³w.</p>
</blockquote>
<p>Gdy mamy <code>response_text</code>, moÅ¼emy jÄ… przetworzyÄ‡ na instancjÄ™ typu <code>Html</code> za
pomocÄ… <code>Html::parse</code>. Zamiast surowego ciÄ…gu znakÃ³w, mamy teraz typ danych,
ktÃ³rego moÅ¼emy uÅ¼yÄ‡ do pracy z HTML-em jako bogatszÄ… strukturÄ… danych. W
szczegÃ³lnoÅ›ci, moÅ¼emy uÅ¼yÄ‡ metody <code>select_first</code> do znalezienia pierwszej
instancji danego selektora CSS. PrzekazujÄ…c ciÄ…g <code>"title"</code>, otrzymamy pierwszy
element <code>&lt;title&gt;</code> w dokumencie, jeÅ›li taki istnieje. PoniewaÅ¼ moÅ¼e nie byÄ‡
Å¼adnego pasujÄ…cego elementu, <code>select_first</code> zwraca <code>Option&lt;ElementRef&gt;</code>.
Na koniec uÅ¼ywamy metody <code>Option::map</code>, ktÃ³ra pozwala nam pracowaÄ‡ z elementem
w <code>Option</code>, jeÅ›li jest obecny, i nic nie robiÄ‡, jeÅ›li go nie ma. (MoglibyÅ›my
teÅ¼ uÅ¼yÄ‡ tutaj wyraÅ¼enia <code>match</code>, ale <code>map</code> jest bardziej idiomatyczne.) W treÅ›ci
funkcji, ktÃ³rÄ… przekazujemy do <code>map</code>, wywoÅ‚ujemy <code>inner_html</code> na <code>title</code>, aby
pobraÄ‡ jego zawartoÅ›Ä‡, ktÃ³ra jest <code>String</code>. Po wszystkim mamy
<code>Option&lt;String&gt;</code>.</p>
<p>ZauwaÅ¼, Å¼e sÅ‚owo kluczowe <code>await</code> w Rust znajduje siÄ™ <em>po</em> wyraÅ¼eniu, na ktÃ³re
oczekujesz, a nie przed nim. To znaczy, jest to sÅ‚owo kluczowe <em>postfixowe</em>.
MoÅ¼e siÄ™ to rÃ³Å¼niÄ‡ od tego, do czego jesteÅ› przyzwyczajony, jeÅ›li uÅ¼ywaÅ‚eÅ›
<code>async</code> w innych jÄ™zykach, ale w Rust sprawia, Å¼e Å‚aÅ„cuchy metod sÄ… znacznie
przyjemniejsze w pracy. W rezultacie, mogliÅ›my zmieniÄ‡ ciaÅ‚o <code>page_title</code>, aby
poÅ‚Ä…czyÄ‡ wywoÅ‚ania funkcji <code>trpl::get</code> i <code>text</code> za pomocÄ… <code>await</code> miÄ™dzy nimi,
jak pokazano w Listingu 17-2.</p>
<listing number="17-2" file-name="src/main.rs" caption="ÅaÅ„cuchowanie ze sÅ‚owem kluczowym `await`">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // TODO: we'll add this next!
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span>    let response_text = trpl::get(url).await.text().await;
<span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title| title.inner_html())
</span><span class="boring">}</span></code></pre>
</listing>
<p>I w ten sposÃ³b pomyÅ›lnie napisaliÅ›my naszÄ… pierwszÄ… funkcjÄ™ asynchronicznÄ…!
Zanim dodamy kod w <code>main</code>, aby jÄ… wywoÅ‚aÄ‡, porozmawiajmy trochÄ™ wiÄ™cej o tym,
co napisaliÅ›my i co to oznacza.</p>
<p>Kiedy Rust widzi <em>blok</em> oznaczony sÅ‚owem kluczowym <code>async</code>, kompiluje go do
unikalnego, anonimowego typu danych, ktÃ³ry implementuje cechÄ™ <code>Future</code>. Kiedy
Rust widzi <em>funkcjÄ™</em> oznaczonÄ… <code>async</code>, kompiluje jÄ… do funkcji nieasync,
ktÃ³rej ciaÅ‚o jest blokiem async. Typ zwracany przez funkcjÄ™ async jest typem
anonimowego typu danych, ktÃ³ry kompilator tworzy dla tego bloku async.</p>
<p>W zwiÄ…zku z tym, pisanie <code>async fn</code> jest rÃ³wnowaÅ¼ne pisaniu funkcji,
ktÃ³ra zwraca <em>future</em> typu zwracanego. Dla kompilatora, definicja funkcji,
taka jak <code>async fn page_title</code> w Listingu 17-1, jest z grubsza rÃ³wnowaÅ¼na
funkcji nieasync zdefiniowanej w ten sposÃ³b:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate trpl; // required for mdbook test
</span>use std::future::Future;
use trpl::Html;

fn page_title(url: &amp;str) -&gt; impl Future&lt;Output = Option&lt;String&gt;&gt; {
    async move {
        let text = trpl::get(url).await.text().await;
        Html::parse(&amp;text)
            .select_first("title")
            .map(|title| title.inner_html())
    }
}
<span class="boring">}</span></code></pre>
<p>PrzejdÅºmy przez kaÅ¼dÄ… czÄ™Å›Ä‡ przeksztaÅ‚conej wersji:</p>
<ul>
<li>UÅ¼ywa skÅ‚adni <code>impl Trait</code>, ktÃ³rÄ… omÃ³wiliÅ›my w Rozdziale 10 w sekcji
<a href="#traits-as-parameters">â€Cechy jako parametryâ€</a><!-- ignore -->.</li>
<li>ZwrÃ³cona wartoÅ›Ä‡ implementuje cechÄ™ <code>Future</code> ze skojarzonym typem <code>Output</code>.
ZauwaÅ¼, Å¼e typ <code>Output</code> to <code>Option&lt;String&gt;</code>, czyli ten sam typ, co oryginalny
typ zwracany przez wersjÄ™ <code>async fn</code> <code>page_title</code>.</li>
<li>CaÅ‚y kod wywoÅ‚any w treÅ›ci oryginalnej funkcji jest opakowany w blok
<code>async move</code>. PamiÄ™taj, Å¼e bloki sÄ… wyraÅ¼eniami. CaÅ‚y ten blok jest
wyraÅ¼eniem zwracanym z funkcji.</li>
<li>Ten blok async produkuje wartoÅ›Ä‡ typu <code>Option&lt;String&gt;</code>, jak wÅ‚aÅ›nie
opisano. Ta wartoÅ›Ä‡ odpowiada typowi <code>Output</code> w typie zwracanym. Jest to
tak samo jak inne bloki, ktÃ³re widziaÅ‚eÅ›.</li>
<li>Nowe ciaÅ‚o funkcji to blok <code>async move</code> ze wzglÄ™du na sposÃ³b uÅ¼ycia parametru
<code>url</code>. (O <code>async</code> kontra <code>async move</code> bÄ™dziemy rozmawiaÄ‡ znacznie wiÄ™cej
pÃ³Åºniej w rozdziale.)</li>
</ul>
<p>Teraz moÅ¼emy wywoÅ‚aÄ‡ <code>page_title</code> w <code>main</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="determining-a-single-pages-title"></a></p>
<h3 id="wykonanie-funkcji-async-w-Å›rodowisku-uruchomieniowym"><a class="header" href="#wykonanie-funkcji-async-w-Å›rodowisku-uruchomieniowym">Wykonanie funkcji <code>async</code> w Å›rodowisku uruchomieniowym</a></h3>
<p>Aby zaczÄ…Ä‡, pobierzemy tytuÅ‚ dla pojedynczej strony, pokazany w Listingu 17-3.
Niestety, ten kod jeszcze siÄ™ nie skompiluje.</p>
<listing number="17-3" file-name="src/main.rs" caption="WywoÅ‚anie funkcji `page_title` z `main` z argumentem dostarczonym przez uÅ¼ytkownika">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span>async fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();
    let url = &amp;args[1];
    match page_title(url).await {
        Some(title) =&gt; println!("The title for {url} was {title}"),
        None =&gt; println!("{url} had no title"),
    }
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title| title.inner_html())
</span><span class="boring">}</span></code></pre>
</listing>
<p>PostÄ™pujemy zgodnie z tym samym wzorcem, ktÃ³rego uÅ¼yliÅ›my do pobierania
argumentÃ³w wiersza poleceÅ„ w sekcji <a href="#akceptowanie-argumentÃ³w-wiersza-poleceÅ„-1">â€Akceptowanie argumentÃ³w wiersza
poleceÅ„â€</a><!-- ignore --> w Rozdziale 12. NastÄ™pnie przekazujemy
argument URL do <code>page_title</code> i czekamy na wynik. PoniewaÅ¼ wartoÅ›Ä‡
produkowana przez future jest <code>Option&lt;String&gt;</code>, uÅ¼ywamy wyraÅ¼enia <code>match</code>, aby
wypisaÄ‡ rÃ³Å¼ne komunikaty w zaleÅ¼noÅ›ci od tego, czy strona miaÅ‚a element
<code>&lt;title&gt;</code>.</p>
<p>Jedynym miejscem, w ktÃ³rym moÅ¼emy uÅ¼yÄ‡ sÅ‚owa kluczowego <code>await</code>, sÄ… funkcje
lub bloki async, a Rust nie pozwoli nam oznaczyÄ‡ specjalnej funkcji <code>main</code> jako
<code>async</code>.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-03
cargo build # skip all the build noise
copy just the compiler error
-->
<pre><code class="language-text">error[E0752]: `main` function is not allowed to be `async`
 --&gt; src/main.rs:6:1
  |
6 | async fn main() {
  | ^^^^^^^^^^^^^^^ `main` function is not allowed to be `async`
</code></pre>
<p>Powodem, dla ktÃ³rego <code>main</code> nie moÅ¼e byÄ‡ oznaczona jako <code>async</code>, jest to, Å¼e
kod asynchroniczny potrzebuje <em>Å›rodowiska uruchomieniowego</em> (runtime): crateâ€™a
Rust, ktÃ³ry zarzÄ…dza szczegÃ³Å‚ami wykonywania kodu asynchronicznego. Funkcja
<code>main</code> programu moÅ¼e <em>zainicjalizowaÄ‡</em> Å›rodowisko uruchomieniowe, ale sama nie
jest Å›rodowiskiem uruchomieniowym. (WiÄ™cej o tym, dlaczego tak jest, dowiemy
siÄ™ za chwilÄ™.) KaÅ¼dy program Rust, ktÃ³ry wykonuje kod asynchroniczny, ma
przynajmniej jedno miejsce, w ktÃ³rym konfiguruje Å›rodowisko uruchomieniowe,
ktÃ³re wykonuje futures.</p>
<p>WiÄ™kszoÅ›Ä‡ jÄ™zykÃ³w obsÅ‚ugujÄ…cych async dostarcza Å›rodowisko uruchomieniowe,
ale Rust tego nie robi. Zamiast tego dostÄ™pnych jest wiele rÃ³Å¼nych
Å›rodowisk uruchomieniowych async, z ktÃ³rych kaÅ¼de dokonuje rÃ³Å¼nych
kompromisÃ³w, odpowiednich dla docelowego przypadku uÅ¼ycia. Na przykÅ‚ad,
wydajny serwer webowy z wieloma rdzeniami CPU i duÅ¼Ä… iloÅ›ciÄ… pamiÄ™ci RAM ma
bardzo rÃ³Å¼ne potrzeby niÅ¼ mikrokontroler z pojedynczym rdzeniem, maÅ‚Ä… iloÅ›ciÄ…
pamiÄ™ci RAM i brakiem moÅ¼liwoÅ›ci alokacji na stercie. Crates, ktÃ³re
dostarczajÄ… te Å›rodowiska uruchomieniowe, czÄ™sto dostarczajÄ… rÃ³wnieÅ¼
asynchroniczne wersje typowych funkcji, takich jak wejÅ›cie/wyjÅ›cie plikÃ³w
lub sieci.</p>
<p>Tutaj i przez resztÄ™ tego rozdziaÅ‚u bÄ™dziemy uÅ¼ywaÄ‡ funkcji <code>block_on</code> z crateâ€™a
<code>trpl</code>, ktÃ³ra przyjmuje przyszÅ‚oÅ›Ä‡ jako argument i blokuje bieÅ¼Ä…cy wÄ…tek,
dopÃ³ki ta przyszÅ‚oÅ›Ä‡ nie zostanie ukoÅ„czona. Pod maskÄ…, wywoÅ‚anie <code>block_on</code>
konfiguruje Å›rodowisko uruchomieniowe za pomocÄ… crateâ€™a <code>tokio</code>, ktÃ³re jest
uÅ¼ywane do uruchamiania przekazanej przyszÅ‚oÅ›ci (zachowanie <code>trpl::block_on</code>
jest podobne do funkcji <code>block_on</code> innych crateâ€™Ã³w Å›rodowiskowych).
Gdy przyszÅ‚oÅ›Ä‡ zostanie ukoÅ„czona, <code>block_on</code> zwraca wartoÅ›Ä‡, ktÃ³rÄ… przyszÅ‚oÅ›Ä‡
wyprodukowaÅ‚a.</p>
<p>MoglibyÅ›my przekazaÄ‡ przyszÅ‚oÅ›Ä‡ zwrÃ³conÄ… przez <code>page_title</code> bezpoÅ›rednio do
<code>block_on</code> i, po jej zakoÅ„czeniu, dopasowaÄ‡ wynikowy <code>Option&lt;String&gt;</code>, jak to
prÃ³bowaliÅ›my zrobiÄ‡ w Listingu 17-3. Jednak w wiÄ™kszoÅ›ci przykÅ‚adÃ³w w rozdziale
(i w wiÄ™kszoÅ›ci kodu async w prawdziwym Å›wiecie) bÄ™dziemy wykonywaÄ‡ wiÄ™cej niÅ¼
jedno wywoÅ‚anie funkcji async, wiÄ™c zamiast tego przekaÅ¼emy blok <code>async</code> i
jawnie poczekamy na wynik wywoÅ‚ania <code>page_title</code>, jak w Listingu 17-4.</p>
<listing number="17-4" caption="Oczekiwanie na blok `async` za pomocÄ… `trpl::block_on`" file-name="src/main.rs">
<!-- should_panic,noplayground because mdbook test does not pass args -->
<pre><code class="language-rust should_panic noplayground"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::block_on(async {
        let url = &amp;args[1];
        match page_title(url).await {
            Some(title) =&gt; println!("The title for {url} was {title}"),
            None =&gt; println!("{url} had no title"),
        }
    })
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title| title.inner_html())
</span><span class="boring">}</span></code></pre>
</listing>
<p>Po uruchomieniu tego kodu otrzymujemy zachowanie, ktÃ³rego poczÄ…tkowo siÄ™
spodziewaliÅ›my:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-04
cargo build # skip all the build noise
cargo run -- "https://www.rust-lang.org"
# copy the output here
-->
<pre><code class="language-console">$ cargo run -- "https://www.rust-lang.org"
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/async_await 'https://www.rust-lang.org'`
The title for https://www.rust-lang.org was
            Rust Programming Language
</code></pre>
<p>Uff â€“ w koÅ„cu mamy dziaÅ‚ajÄ…cy kod async! Ale zanim dodamy kod do wyÅ›cigÃ³w
dwÃ³ch witryn ze sobÄ…, poÅ›wiÄ™Ä‡my chwilÄ™, aby powrÃ³ciÄ‡ do tego, jak dziaÅ‚ajÄ…
futures.</p>
<p>KaÅ¼dy <em>punkt oczekiwania</em> â€“ to znaczy kaÅ¼de miejsce, w ktÃ³rym kod uÅ¼ywa sÅ‚owa
kluczowego <code>await</code> â€“ reprezentuje miejsce, w ktÃ³rym kontrola zostaje
przekazana z powrotem do Å›rodowiska uruchomieniowego. Aby to zadziaÅ‚aÅ‚o, Rust
musi Å›ledziÄ‡ stan zaangaÅ¼owany w blok async, tak aby Å›rodowisko uruchomieniowe
mogÅ‚o rozpoczÄ…Ä‡ innÄ… pracÄ™, a nastÄ™pnie powrÃ³ciÄ‡, gdy bÄ™dzie gotowe, aby
ponownie sprÃ³bowaÄ‡ posunÄ…Ä‡ pierwszÄ… pracÄ™. Jest to niewidoczna maszyna stanÃ³w,
tak jakbyÅ› napisaÅ‚ enum w ten sposÃ³b, aby zapisaÄ‡ bieÅ¼Ä…cy stan w kaÅ¼dym punkcie
oczekiwania:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>enum PageTitleFuture&lt;'a&gt; {
    Initial { url: &amp;'a str },
    GetAwaitPoint { url: &amp;'a str },
    TextAwaitPoint { response: trpl::Response },
}
<span class="boring">}</span></code></pre>
<p>RÄ™czne pisanie kodu do przechodzenia miÄ™dzy poszczegÃ³lnymi stanami byÅ‚oby
udrÄ™kÄ… i podatne na bÅ‚Ä™dy, zwÅ‚aszcza gdy trzeba pÃ³Åºniej dodaÄ‡ wiÄ™cej
funkcjonalnoÅ›ci i stanÃ³w do kodu. Na szczÄ™Å›cie kompilator Rust automatycznie
tworzy i zarzÄ…dza strukturami danych maszyny stanÃ³w dla kodu async. Normalne
zasady poÅ¼yczania i wÅ‚asnoÅ›ci dotyczÄ…ce struktur danych nadal obowiÄ…zujÄ…, a co
najwaÅ¼niejsze, kompilator zajmuje siÄ™ rÃ³wnieÅ¼ ich sprawdzaniem i dostarcza
przydatne komunikaty o bÅ‚Ä™dach. Kilka z nich omÃ³wimy pÃ³Åºniej w tym rozdziale.</p>
<p>Ostatecznie, coÅ› musi wykonaÄ‡ tÄ™ maszynÄ™ stanÃ³w, a tym czymÅ› jest Å›rodowisko
uruchomieniowe. (Dlatego moÅ¼esz natknÄ…Ä‡ siÄ™ na wzmianki o <em>executorach</em>,
szukajÄ…c informacji o Å›rodowiskach uruchomieniowych: executor to czÄ™Å›Ä‡
Å›rodowiska uruchomieniowego odpowiedzialna za wykonywanie kodu async.)</p>
<p>Teraz widzisz, dlaczego kompilator powstrzymaÅ‚ nas przed uczynieniem <code>main</code>
samego w sobie funkcjÄ… asynchronicznÄ… w Listingu 17-3. Gdyby <code>main</code> byÅ‚o
funkcjÄ… asynchronicznÄ…, coÅ› innego musiaÅ‚oby zarzÄ…dzaÄ‡ maszynÄ… stanÃ³w dla
dowolnej przyszÅ‚oÅ›ci, ktÃ³rÄ… <code>main</code> zwrÃ³ciÅ‚o, ale <code>main</code> jest punktem
poczÄ…tkowym programu! Zamiast tego wywoÅ‚aliÅ›my funkcjÄ™ <code>trpl::block_on</code> w
<code>main</code>, aby skonfigurowaÄ‡ Å›rodowisko uruchomieniowe i uruchomiÄ‡ przyszÅ‚oÅ›Ä‡
zwracanÄ… przez blok <code>async</code>, dopÃ³ki nie zostanie ona ukoÅ„czona.</p>
<blockquote>
<p>Uwaga: NiektÃ³re Å›rodowiska uruchomieniowe zapewniajÄ… makra, dziÄ™ki czemu <em>moÅ¼esz</em>
pisaÄ‡ funkcjÄ™ <code>main</code> async. Te makra przepisujÄ… <code>async fn main() { ... }</code> na
zwykÅ‚Ä… funkcjÄ™ <code>fn main</code>, ktÃ³ra robi to samo, co zrobiliÅ›my rÄ™cznie w Listingu
17-4: wywoÅ‚uje funkcjÄ™, ktÃ³ra uruchamia przyszÅ‚oÅ›Ä‡ do koÅ„ca w sposÃ³b, w jaki to
robi <code>trpl::block_on</code>.</p>
</blockquote>
<p>Teraz poÅ‚Ä…czmy te elementy i zobaczmy, jak moÅ¼emy pisaÄ‡ kod wspÃ³Å‚bieÅ¼ny.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="racing-our-two-urls-against-each-other"></a></p>
<h3 id="wyÅ›cig-dwÃ³ch-adresÃ³w-url-ze-sobÄ…-wspÃ³Å‚bieÅ¼nie"><a class="header" href="#wyÅ›cig-dwÃ³ch-adresÃ³w-url-ze-sobÄ…-wspÃ³Å‚bieÅ¼nie">WyÅ›cig dwÃ³ch adresÃ³w URL ze sobÄ… wspÃ³Å‚bieÅ¼nie</a></h3>
<p>W Listingu 17-5 wywoÅ‚ujemy <code>page_title</code> z dwoma rÃ³Å¼nymi adresami URL
przekazanymi z wiersza poleceÅ„ i Å›cigamy je, wybierajÄ…c tÄ™ future, ktÃ³ra
zakoÅ„czy siÄ™ jako pierwsza.</p>
<listing number="17-5" caption="WywoÅ‚anie `page_title` dla dwÃ³ch adresÃ³w URL, aby zobaczyÄ‡, ktÃ³ry zwrÃ³ci siÄ™ pierwszy" file-name="src/main.rs">
<!-- should_panic,noplayground because mdbook does not pass args -->
<pre><code class="language-rust should_panic noplayground"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::{Either, Html};

fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::block_on(async {
        let title_fut_1 = page_title(&amp;args[1]);
        let title_fut_2 = page_title(&amp;args[2]);

        let (url, maybe_title) =
            match trpl::select(title_fut_1, title_fut_2).await {
                Either::Left(left) =&gt; left,
                Either::Right(right) =&gt; right,
            };

        println!("{url} returned first");
        match maybe_title {
            Some(title) =&gt; println!("Its page title was: '{title}'"),
            None =&gt; println!("It had no title."),
        }
    })
}

async fn page_title(url: &amp;str) -&gt; (&amp;str, Option&lt;String&gt;) {
    let response_text = trpl::get(url).await.text().await;
    let title = Html::parse(&amp;response_text)
        .select_first("title")
        .map(|title| title.inner_html());
    (url, title)
}</code></pre>
</listing>
<p>Zaczynamy od wywoÅ‚ania <code>page_title</code> dla kaÅ¼dego z adresÃ³w URL podanych przez
uÅ¼ytkownika. Wynikowe futures zapisujemy jako <code>title_fut_1</code> i <code>title_fut_2</code>.
PamiÄ™taj, Å¼e te futures jeszcze nic nie robiÄ…, poniewaÅ¼ sÄ… leniwe i jeszcze
na nie nie czekaliÅ›my. NastÄ™pnie przekazujemy futures do <code>trpl::select</code>, ktÃ³ry
zwraca wartoÅ›Ä‡ wskazujÄ…cÄ…, ktÃ³ra z przekazanych do niego futures zakoÅ„czyÅ‚a
dziaÅ‚anie jako pierwsza.</p>
<blockquote>
<p>Uwaga: Pod maskÄ…, <code>trpl::select</code> jest zbudowany na bardziej ogÃ³lnej funkcji
<code>select</code> zdefiniowanej w crateâ€™cie <code>futures</code>. Funkcja <code>select</code> z crateâ€™a
<code>futures</code> potrafi wiele rzeczy, ktÃ³rych funkcja <code>trpl::select</code> nie potrafi,
ale ma teÅ¼ pewne dodatkowe zÅ‚oÅ¼onoÅ›ci, ktÃ³re na razie moÅ¼emy pominÄ…Ä‡.</p>
</blockquote>
<p>KaÅ¼da przyszÅ‚oÅ›Ä‡ moÅ¼e legalnie â€wygraÄ‡â€, wiÄ™c zwracanie <code>Result</code> nie ma sensu.
Zamiast tego, <code>trpl::select</code> zwraca typ, ktÃ³rego wczeÅ›niej nie widzieliÅ›my,
<code>trpl::Either</code>. Typ <code>Either</code> jest nieco podobny do <code>Result</code> w tym, Å¼e ma dwa
przypadki. Jednak w przeciwieÅ„stwie do <code>Result</code>, w <code>Either</code> nie ma pojÄ™cia
czynnika sukcesu ani poraÅ¼ki. Zamiast tego, uÅ¼ywa <code>Left</code> i <code>Right</code>, aby wskazaÄ‡
â€jedno lub drugieâ€:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Either&lt;A, B&gt; {
    Left(A),
    Right(B),
}
<span class="boring">}</span></code></pre>
<p>Funkcja <code>select</code> zwraca <code>Left</code> z wynikiem tej future, jeÅ›li pierwszy argument
wygra, i <code>Right</code> z wynikiem future drugiego argumentu, jeÅ›li <em>ta</em> wygra.
Odpowiada to kolejnoÅ›ci, w jakiej argumenty pojawiajÄ… siÄ™ podczas wywoÅ‚ywania
funkcji: pierwszy argument jest na lewo od drugiego argumentu.</p>
<p>Aktualizujemy rÃ³wnieÅ¼ <code>page_title</code>, aby zwracaÅ‚a ten sam URL, ktÃ³ry zostaÅ‚
przekazany. W ten sposÃ³b, jeÅ›li strona, ktÃ³ra zwrÃ³ci siÄ™ jako pierwsza, nie ma
<code>&lt;title&gt;</code>, ktÃ³rÄ… moÅ¼emy rozwiÄ…zaÄ‡, nadal moÅ¼emy wypisaÄ‡ sensowny komunikat.
Po uzyskaniu tych informacji, koÅ„czymy aktualizacjÄ™ naszego wyjÅ›cia <code>println!</code>,
aby wskazaÄ‡ zarÃ³wno to, ktÃ³ry URL zakoÅ„czyÅ‚ siÄ™ jako pierwszy, jak i jaki,
jeÅ›li w ogÃ³le, jest <code>&lt;title&gt;</code> dla strony internetowej pod tym URL-em.</p>
<p>ZbudowaÅ‚eÅ› teraz maÅ‚y, dziaÅ‚ajÄ…cy scraper internetowy! Wybierz kilka adresÃ³w URL
i uruchom narzÄ™dzie wiersza poleceÅ„. MoÅ¼esz odkryÄ‡, Å¼e niektÃ³re witryny sÄ…
konsekwentnie szybsze od innych, podczas gdy w innych przypadkach szybsza
witryna zmienia siÄ™ z uruchomienia na uruchomienie. Co waÅ¼niejsze, nauczyÅ‚eÅ›
siÄ™ podstaw pracy z futures, wiÄ™c teraz moÅ¼emy zagÅ‚Ä™biÄ‡ siÄ™ w to, co moÅ¼emy
zrobiÄ‡ z <code>async</code>.</p>
<!-- TODO: map source link version to version of Rust? -->
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="stosowanie-wspÃ³Å‚bieÅ¼noÅ›ci-z-async-1"><a href="#stosowanie-wspÃ³Å‚bieÅ¼noÅ›ci-z-async-1" class="header">Stosowanie wspÃ³Å‚bieÅ¼noÅ›ci z `async`</a></h1>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="concurrency-with-async"></a></p>
<h2 id="stosowanie-wspÃ³Å‚bieÅ¼noÅ›ci-z-async"><a class="header" href="#stosowanie-wspÃ³Å‚bieÅ¼noÅ›ci-z-async">Stosowanie wspÃ³Å‚bieÅ¼noÅ›ci z <code>async</code></a></h2>
<p>W tej sekcji zastosujemy async do niektÃ³rych z tych samych wyzwaÅ„
wspÃ³Å‚bieÅ¼noÅ›ci, ktÃ³re rozwiÄ…zaliÅ›my za pomocÄ… wÄ…tkÃ³w w Rozdziale 16. PoniewaÅ¼
wiele kluczowych idei zostaÅ‚o tam juÅ¼ omÃ³wionych, w tej sekcji skupimy siÄ™ na
rÃ³Å¼nicach miÄ™dzy wÄ…tkami a futures.</p>
<p>W wielu przypadkach API do pracy z wspÃ³Å‚bieÅ¼noÅ›ciÄ… przy uÅ¼yciu async sÄ… bardzo
podobne do tych do pracy z wÄ…tkami. W innych przypadkach sÄ… one zupeÅ‚nie
rÃ³Å¼ne. Nawet gdy API <em>wyglÄ…dajÄ…</em> podobnie miÄ™dzy wÄ…tkami a async, czÄ™sto majÄ…
rÃ³Å¼ne zachowania â€” i prawie zawsze majÄ… rÃ³Å¼ne charakterystyki wydajnoÅ›ci.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="counting"></a></p>
<h3 id="tworzenie-nowego-zadania-za-pomocÄ…-spawn_task"><a class="header" href="#tworzenie-nowego-zadania-za-pomocÄ…-spawn_task">Tworzenie nowego zadania za pomocÄ… <code>spawn_task</code></a></h3>
<p>PierwszÄ… operacjÄ…, ktÃ³rÄ… zajÄ™liÅ›my siÄ™ w sekcji <a href="#creating-a-new-thread-with-spawn">â€Tworzenie nowego wÄ…tku za
pomocÄ… <code>spawn</code>â€</a><!-- ignore --> w Rozdziale 16, byÅ‚o zliczanie
na dwÃ³ch oddzielnych wÄ…tkach. ZrÃ³bmy to samo, uÅ¼ywajÄ…c async. Crate <code>trpl</code>
dostarcza funkcjÄ™ <code>spawn_task</code>, ktÃ³ra wyglÄ…da bardzo podobnie do API
<code>thread::spawn</code>, oraz funkcjÄ™ <code>sleep</code>, ktÃ³ra jest asynchronicznÄ… wersjÄ… API
<code>thread::sleep</code>. MoÅ¼emy ich uÅ¼yÄ‡ razem do zaimplementowania przykÅ‚adu
zliczania, jak pokazano w Listingu 17-6.</p>
<listing number="17-6" caption="Tworzenie nowego zadania do wypisania jednej rzeczy, podczas gdy gÅ‚Ã³wne zadanie wypisuje coÅ› innego" file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use std::time::Duration;

fn main() {
    trpl::block_on(async {
        trpl::spawn_task(async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("hi number {i} from the second task!");
            trpl::sleep(Duration::from_millis(500)).await;
        }
    });
}</code></pre>
</listing>
<p>Jako punkt wyjÅ›cia, konfigurujemy naszÄ… funkcjÄ™ <code>main</code> z <code>trpl::block_on</code>,
tak aby nasza funkcja najwyÅ¼szego poziomu mogÅ‚a byÄ‡ asynchroniczna.</p>
<blockquote>
<p>Uwaga: Od tego momentu w rozdziale, kaÅ¼dy przykÅ‚ad bÄ™dzie zawieraÅ‚ ten sam
kod opakowujÄ…cy z <code>trpl::block_on</code> w <code>main</code>, wiÄ™c czÄ™sto bÄ™dziemy go
pomijaÄ‡, tak jak to robimy z <code>main</code>. PamiÄ™taj, aby uwzglÄ™dniÄ‡ go w swoim
kodzie!</p>
</blockquote>
<p>NastÄ™pnie piszemy dwie pÄ™tle w tym bloku, kaÅ¼da zawierajÄ…ca wywoÅ‚anie
<code>trpl::sleep</code>, ktÃ³re czeka pÃ³Å‚ sekundy (500 milisekund) przed wysÅ‚aniem
kolejnej wiadomoÅ›ci. JednÄ… pÄ™tlÄ™ umieszczamy w ciele <code>trpl::spawn_task</code>, a drugÄ…
w pÄ™tli <code>for</code> najwyÅ¼szego poziomu. Dodajemy rÃ³wnieÅ¼ <code>await</code> po wywoÅ‚aniach
<code>sleep</code>.</p>
<p>Ten kod zachowuje siÄ™ podobnie do implementacji opartej na wÄ…tkach â€“ w tym
takÅ¼e to, Å¼e moÅ¼esz zobaczyÄ‡ wiadomoÅ›ci pojawiajÄ…ce siÄ™ w innej kolejnoÅ›ci w
wÅ‚asnym terminalu, gdy go uruchomisz:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
</code></pre>
<p>Ta wersja zatrzymuje siÄ™, gdy tylko zakoÅ„czy siÄ™ pÄ™tla <code>for</code> w ciele gÅ‚Ã³wnego
bloku async, poniewaÅ¼ zadanie uruchomione przez <code>spawn_task</code> zostaje
wyÅ‚Ä…czone, gdy funkcja <code>main</code> siÄ™ koÅ„czy. JeÅ›li chcesz, aby dziaÅ‚aÅ‚o do koÅ„ca
zadania, bÄ™dziesz musiaÅ‚ uÅ¼yÄ‡ uchwytu <code>join</code> do oczekiwania na zakoÅ„czenie
pierwszego zadania. W przypadku wÄ…tkÃ³w, uÅ¼yliÅ›my metody <code>join</code> do â€blokowaniaâ€,
dopÃ³ki wÄ…tek nie zakoÅ„czyÅ‚ dziaÅ‚ania. W Listingu 17-7 moÅ¼emy uÅ¼yÄ‡ <code>await</code> do
zrobienia tego samego, poniewaÅ¼ sam uchwyt zadania jest future. Jego typ
<code>Output</code> to <code>Result</code>, wiÄ™c rÃ³wnieÅ¼ go rozpakowujemy po oczekiwaniu na niego.</p>
<listing number="17-7" caption="UÅ¼ycie `await` z uchwytem `join` do uruchomienia zadania do koÅ„ca" file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let handle = trpl::spawn_task(async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("hi number {i} from the second task!");
            trpl::sleep(Duration::from_millis(500)).await;
        }

        handle.await.unwrap();
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</listing>
<p>Ta zaktualizowana wersja dziaÅ‚a, dopÃ³ki <em>obie</em> pÄ™tle siÄ™ nie zakoÅ„czÄ…:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
</code></pre>
<p>Jak dotÄ…d, wydaje siÄ™, Å¼e async i wÄ…tki dajÄ… nam podobne wyniki, tylko z
innÄ… skÅ‚adniÄ…: uÅ¼ywajÄ…c <code>await</code> zamiast wywoÅ‚ywania <code>join</code> na uchwycie <code>join</code>,
oraz oczekujÄ…c na wywoÅ‚ania <code>sleep</code>.</p>
<p>WiÄ™kszÄ… rÃ³Å¼nicÄ… jest to, Å¼e nie musieliÅ›my tworzyÄ‡ kolejnego wÄ…tku systemu
operacyjnego, aby to zrobiÄ‡. W rzeczywistoÅ›ci, nie musimy nawet tworzyÄ‡ tutaj
Å¼adnego zadania. PoniewaÅ¼ bloki async kompilujÄ… siÄ™ do anonimowych futures,
moÅ¼emy umieÅ›ciÄ‡ kaÅ¼dÄ… pÄ™tlÄ™ w bloku async i pozwoliÄ‡ Å›rodowisku uruchomieniowemu
uruchomiÄ‡ je obie do koÅ„ca za pomocÄ… funkcji <code>trpl::join</code>.</p>
<p>W sekcji <a href="#waiting-for-all-threads-to-finish">â€Czekanie na zakoÅ„czenie wszystkich wÄ…tkÃ³wâ€</a><!-- ignore
--> w Rozdziale 16 pokazaliÅ›my, jak uÅ¼ywaÄ‡ metody <code>join</code> na typie
<code>JoinHandle</code> zwracanym po wywoÅ‚aniu <code>std::thread::spawn</code>. Funkcja <code>trpl::join</code>
jest podobna, ale dla futures. Kiedy podasz jej dwie futures, produkuje jednÄ…
nowÄ… future, ktÃ³rej wynikiem jest krotka zawierajÄ…ca wyniki kaÅ¼dej future,
ktÃ³rÄ… przekazaÅ‚eÅ›, gdy <em>obie</em> zakoÅ„czÄ… dziaÅ‚anie. Tak wiÄ™c, w Listingu 17-8
uÅ¼ywamy <code>trpl::join</code>, aby poczekaÄ‡ na zakoÅ„czenie zarÃ³wno <code>fut1</code>, jak i <code>fut2</code>.
Nie oczekujemy na <code>fut1</code> i <code>fut2</code>, ale zamiast tego na nowÄ… future
produkowanÄ… przez <code>trpl::join</code>. Ignorujemy wynik, poniewaÅ¼ jest to tylko krotka
zawierajÄ…ca dwie wartoÅ›ci jednostkowe.</p>
<listing number="17-8" caption="UÅ¼ycie `trpl::join` do oczekiwania na dwie anonimowe futures" file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let fut1 = async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let fut2 = async {
            for i in 1..5 {
                println!("hi number {i} from the second task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        trpl::join(fut1, fut2).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</listing>
<p>Po uruchomieniu widzimy, Å¼e obie futures dziaÅ‚ajÄ… do koÅ„ca:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the first task!
hi number 1 from the second task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
</code></pre>
<p>Teraz zobaczysz dokÅ‚adnie tÄ™ samÄ… kolejnoÅ›Ä‡ za kaÅ¼dym razem, co jest bardzo
rÃ³Å¼ne od tego, co widzieliÅ›my w przypadku wÄ…tkÃ³w i <code>trpl::spawn_task</code> w Listingu
17-7. Dzieje siÄ™ tak, poniewaÅ¼ funkcja <code>trpl::join</code> jest <em>sprawiedliwa</em>,
oznacza to, Å¼e sprawdza kaÅ¼dÄ… future tak samo czÄ™sto, naprzemiennie miÄ™dzy nimi,
i nigdy nie pozwala jednej wyprzedziÄ‡ drugiej, jeÅ›li ta druga jest gotowa.
W przypadku wÄ…tkÃ³w, system operacyjny decyduje, ktÃ³ry wÄ…tek sprawdziÄ‡ i jak
dÅ‚ugo pozwoliÄ‡ mu dziaÅ‚aÄ‡. W przypadku async Rust, Å›rodowisko uruchomieniowe
decyduje, ktÃ³re zadanie sprawdziÄ‡. (W praktyce, szczegÃ³Å‚y stajÄ… siÄ™
skomplikowane, poniewaÅ¼ Å›rodowisko uruchomieniowe async moÅ¼e wykorzystywaÄ‡
wÄ…tki systemu operacyjnego pod maskÄ… jako czÄ™Å›Ä‡ sposobu zarzÄ…dzania
wspÃ³Å‚bieÅ¼noÅ›ciÄ…, wiÄ™c zagwarantowanie sprawiedliwoÅ›ci moÅ¼e byÄ‡ bardziej
pracochÅ‚onne dla Å›rodowiska uruchomieniowego â€“ ale nadal jest to moÅ¼liwe!)
Åšrodowiska uruchomieniowe nie muszÄ… gwarantowaÄ‡ sprawiedliwoÅ›ci dla Å¼adnej
danej operacji i czÄ™sto oferujÄ… rÃ³Å¼ne API, aby umoÅ¼liwiÄ‡ wybÃ³r, czy chcesz
sprawiedliwoÅ›ci, czy nie.</p>
<p>WyprÃ³buj niektÃ³re z tych wariacji oczekiwania na futures i zobacz, co robiÄ…:</p>
<ul>
<li>UsuÅ„ blok async wokÃ³Å‚ jednej lub obu pÄ™tli.</li>
<li>Oczekuj na kaÅ¼dy blok async natychmiast po jego zdefiniowaniu.</li>
<li>Opakuj tylko pierwszÄ… pÄ™tlÄ™ w blok async i oczekuj na wynikowÄ… future po
ciele drugiej pÄ™tli.</li>
</ul>
<p>Dodatkowym wyzwaniem jest sprawdzenie, czy potrafisz przewidzieÄ‡, jaki bÄ™dzie
wynik w kaÅ¼dym przypadku <em>przed</em> uruchomieniem kodu!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="message-passing"></a>
<a id="counting-up-on-two-tasks-using-message-passing"></a></p>
<h3 id="przesyÅ‚anie-danych-miÄ™dzy-dwoma-zadaniami-za-pomocÄ…-przekazywania-wiadomoÅ›ci"><a class="header" href="#przesyÅ‚anie-danych-miÄ™dzy-dwoma-zadaniami-za-pomocÄ…-przekazywania-wiadomoÅ›ci">PrzesyÅ‚anie danych miÄ™dzy dwoma zadaniami za pomocÄ… przekazywania wiadomoÅ›ci</a></h3>
<p>WspÃ³Å‚dzielenie danych miÄ™dzy futures rÃ³wnieÅ¼ bÄ™dzie znajome: ponownie uÅ¼yjemy
przekazywania wiadomoÅ›ci, ale tym razem z asynchronicznymi wersjami typÃ³w i
funkcji. Obierzemy nieco innÄ… Å›cieÅ¼kÄ™ niÅ¼ w sekcji <a href="#przesyÅ‚anie-danych-miÄ™dzy-wÄ…tkami-za-pomocÄ…-przekazywania-wiadomoÅ›ci-1">â€PrzesyÅ‚anie danych miÄ™dzy
wÄ…tkami za pomocÄ… przekazywania wiadomoÅ›ciâ€</a><!--
ignore --> w Rozdziale 16, aby zilustrowaÄ‡ niektÃ³re kluczowe rÃ³Å¼nice miÄ™dzy
wspÃ³Å‚bieÅ¼noÅ›ciÄ… opartÄ… na wÄ…tkach a wspÃ³Å‚bieÅ¼noÅ›ciÄ… opartÄ… na futures. W Listingu
17-9 zaczniemy od pojedynczego bloku async â€“ <em>nie</em> uruchamiajÄ…c oddzielnego
zadania, tak jak uruchomiliÅ›my oddzielny wÄ…tek.</p>
<listing number="17-9" caption="Tworzenie kanaÅ‚u asynchronicznego i przypisywanie dwÃ³ch poÅ‚Ã³wek do `tx` i `rx`" file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let (tx, mut rx) = trpl::channel();

        let val = String::from("hi");
        tx.send(val).unwrap();

        let received = rx.recv().await.unwrap();
        println!("received '{received}'");
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</listing>
<p>Tutaj uÅ¼ywamy <code>trpl::channel</code>, asynchronicznej wersji API kanaÅ‚u typu
wiele-producentÃ³w, jeden-konsument, ktÃ³rego uÅ¼yliÅ›my z wÄ…tkami w Rozdziale 16.
Asynchroniczna wersja API rÃ³Å¼ni siÄ™ tylko nieco od wersji opartej na wÄ…tkach:
uÅ¼ywa mutowalnego, a nie niemutowalnego odbiornika <code>rx</code>, a jego metoda <code>recv</code>
produkuje future, na ktÃ³rÄ… musimy czekaÄ‡, zamiast bezpoÅ›rednio produkowaÄ‡
wartoÅ›Ä‡. Teraz moÅ¼emy wysyÅ‚aÄ‡ wiadomoÅ›ci z nadawcy do odbiornika. ZauwaÅ¼, Å¼e
nie musimy uruchamiaÄ‡ oddzielnego wÄ…tku ani nawet zadania; wystarczy, Å¼e
bÄ™dziemy czekaÄ‡ na wywoÅ‚anie <code>rx.recv</code>.</p>
<p>Synchroniczna metoda <code>Receiver::recv</code> w <code>std::mpsc::channel</code> blokuje do czasu
otrzymania wiadomoÅ›ci. Metoda <code>trpl::Receiver::recv</code> tego nie robi, poniewaÅ¼
jest asynchroniczna. Zamiast blokowaÄ‡, przekazuje kontrolÄ™ z powrotem do
Å›rodowiska uruchomieniowego, dopÃ³ki nie zostanie odebrana wiadomoÅ›Ä‡ lub strona
wysyÅ‚ajÄ…ca kanaÅ‚u nie zostanie zamkniÄ™ta. Natomiast nie czekamy na wywoÅ‚anie
<code>send</code>, poniewaÅ¼ nie blokuje. Nie musi, poniewaÅ¼ kanaÅ‚, do ktÃ³rego wysyÅ‚amy,
jest nieograniczony.</p>
<blockquote>
<p>Uwaga: PoniewaÅ¼ caÅ‚y ten kod async dziaÅ‚a w bloku async w wywoÅ‚aniu
<code>trpl::block_on</code>, wszystko w nim moÅ¼e uniknÄ…Ä‡ blokowania. Jednak kod <em>poza</em>
im blokiem bÄ™dzie blokowaÅ‚, dopÃ³ki funkcja <code>block_on</code> nie zwrÃ³ci wartoÅ›ci. Na
tym polega caÅ‚a idea funkcji <code>trpl::block_on</code>: pozwala <em>wybraÄ‡</em>, gdzie
zablokowaÄ‡ na jakimÅ› zestawie kodu async, a tym samym, gdzie przejÅ›Ä‡ miÄ™dzy
kodem synchronicznym a asynchronicznym.</p>
</blockquote>
<p>ZauwaÅ¼ dwie rzeczy dotyczÄ…ce tego przykÅ‚adu. Po pierwsze, wiadomoÅ›Ä‡ dotrze
natychmiast. Po drugie, choÄ‡ uÅ¼ywamy tutaj przyszÅ‚oÅ›ci, nie ma jeszcze
wspÃ³Å‚bieÅ¼noÅ›ci. Wszystko w listingu dzieje siÄ™ sekwencyjnie, tak jakby nie byÅ‚o
Å¼adnych futures.</p>
<p>Zajmijmy siÄ™ pierwszÄ… czÄ™Å›ciÄ…, wysyÅ‚ajÄ…c seriÄ™ wiadomoÅ›ci i pauzujÄ…c miÄ™dzy
nimi, jak pokazano w Listingu 17-10.</p>
<!-- We cannot test this one because it never stops! -->
<listing number="17-10" caption="WysyÅ‚anie i odbieranie wielu wiadomoÅ›ci przez kanaÅ‚ asynchroniczny i pauzowanie z `await` miÄ™dzy kaÅ¼dÄ… wiadomoÅ›ciÄ…" file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let (tx, mut rx) = trpl::channel();

        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("future"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            trpl::sleep(Duration::from_millis(500)).await;
        }

        while let Some(value) = rx.recv().await {
            println!("received '{value}'");
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</listing>
<p>OprÃ³cz wysyÅ‚ania wiadomoÅ›ci, musimy je odbieraÄ‡. W tym przypadku, poniewaÅ¼
wiemy, ile wiadomoÅ›ci nadejdzie, moglibyÅ›my to zrobiÄ‡ rÄ™cznie, wywoÅ‚ujÄ…c
<code>rx.recv().await</code> cztery razy. Jednak w prawdziwym Å›wiecie zazwyczaj bÄ™dziemy
czekaÄ‡ na <em>nieznanÄ…</em> liczbÄ™ wiadomoÅ›ci, wiÄ™c musimy czekaÄ‡, aÅ¼ ustalimy, Å¼e
nie ma juÅ¼ wiÄ™cej wiadomoÅ›ci.</p>
<p>W Listingu 16-10 uÅ¼yliÅ›my pÄ™tli <code>for</code> do przetwarzania wszystkich elementÃ³w
otrzymanych z kanaÅ‚u synchronicznego. Rust nie ma jeszcze sposobu na uÅ¼ycie
pÄ™tli <code>for</code> z asynchronicznie produkowanym strumieniem elementÃ³w, wiÄ™c musimy
uÅ¼yÄ‡ pÄ™tli, ktÃ³rej wczeÅ›niej nie widzieliÅ›my: warunkowej pÄ™tli <code>while let</code>.
Jest to wersja pÄ™tli konstrukcji <code>if let</code>, ktÃ³rÄ… widzieliÅ›my w sekcji <a href="#zwiÄ™zÅ‚a-kontrola-przepÅ‚ywu-z-if-let-i-letelse-1">â€ZwiÄ™zÅ‚a
kontrola przepÅ‚ywu z <code>if let</code> i <code>let...else</code>â€</a><!-- ignore --> w
Rozdziale 6. PÄ™tla bÄ™dzie wykonywaÄ‡ siÄ™ tak dÅ‚ugo, jak dÅ‚ugo okreÅ›lony wzorzec
bÄ™dzie pasowaÅ‚ do wartoÅ›ci.</p>
<p>WywoÅ‚anie <code>rx.recv</code> produkuje future, na ktÃ³rÄ… czekamy. Åšrodowisko uruchomieniowe
wstrzyma future, dopÃ³ki nie bÄ™dzie gotowa. Gdy tylko nadejdzie wiadomoÅ›Ä‡,
future rozstrzygnie siÄ™ na <code>Some(message)</code> tyle razy, ile wiadomoÅ›ci nadejdzie.
Gdy kanaÅ‚ zostanie zamkniÄ™ty, niezaleÅ¼nie od tego, czy <em>jakiekolwiek</em> wiadomoÅ›ci
nadeszÅ‚y, future zamiast tego rozstrzygnie siÄ™ na <code>None</code>, aby wskazaÄ‡, Å¼e nie
ma juÅ¼ wiÄ™cej wartoÅ›ci i w zwiÄ…zku z tym powinniÅ›my przestaÄ‡ odpytywaÄ‡ â€“ to
znaczy, przestaÄ‡ oczekiwaÄ‡.</p>
<p>PÄ™tla <code>while let</code> Å‚Ä…czy to wszystko w caÅ‚oÅ›Ä‡. JeÅ›li wynik wywoÅ‚ania
<code>rx.recv().await</code> to <code>Some(message)</code>, uzyskujemy dostÄ™p do wiadomoÅ›ci i moÅ¼emy
jej uÅ¼ywaÄ‡ w ciele pÄ™tli, tak jak w przypadku <code>if let</code>. JeÅ›li wynik to <code>None</code>,
pÄ™tla siÄ™ koÅ„czy. Za kaÅ¼dym razem, gdy pÄ™tla siÄ™ koÅ„czy, ponownie trafia na
punkt oczekiwania, wiÄ™c Å›rodowisko uruchomieniowe ponownie jÄ… wstrzymuje,
dopÃ³ki nie nadejdzie kolejna wiadomoÅ›Ä‡.</p>
<p>Kod teraz pomyÅ›lnie wysyÅ‚a i odbiera wszystkie wiadomoÅ›ci. Niestety, nadal
istniejÄ… dwa problemy. Po pierwsze, wiadomoÅ›ci nie docierajÄ… w odstÄ™pach
pÃ³Å‚sekundowych. DocierajÄ… wszystkie naraz, 2 sekundy (2000 milisekund) po
uruchomieniu programu. Po drugie, ten program rÃ³wnieÅ¼ nigdy siÄ™ nie koÅ„czy!
Zamiast tego czeka w nieskoÅ„czonoÅ›Ä‡ na nowe wiadomoÅ›ci. Musisz go wyÅ‚Ä…czyÄ‡,
uÅ¼ywajÄ…c <kbd>ctrl</kbd>-<kbd>C</kbd>.</p>
<h4 id="kod-w-jednym-bloku-async-wykonuje-siÄ™-liniowo"><a class="header" href="#kod-w-jednym-bloku-async-wykonuje-siÄ™-liniowo">Kod w jednym bloku Async wykonuje siÄ™ liniowo</a></h4>
<p>Zacznijmy od zbadania, dlaczego wiadomoÅ›ci przychodzÄ… wszystkie naraz po peÅ‚nym
opÃ³Åºnieniu, zamiast przychodziÄ‡ z opÃ³Åºnieniami miÄ™dzy kaÅ¼dÄ… z nich. W danym
bloku async kolejnoÅ›Ä‡, w jakiej sÅ‚owa kluczowe <code>await</code> pojawiajÄ… siÄ™ w kodzie,
jest rÃ³wnieÅ¼ kolejnoÅ›ciÄ…, w jakiej sÄ… wykonywane, gdy program dziaÅ‚a.</p>
<p>W Listingu 17-10 jest tylko jeden blok async, wiÄ™c wszystko w nim dziaÅ‚a
liniowo. Nadal nie ma wspÃ³Å‚bieÅ¼noÅ›ci. Wszystkie wywoÅ‚ania <code>tx.send</code> odbywajÄ… siÄ™,
przeplatane wszystkimi wywoÅ‚aniami <code>trpl::sleep</code> i ich powiÄ…zanymi punktami
oczekiwania. Dopiero wtedy pÄ™tla <code>while let</code> moÅ¼e przejÅ›Ä‡ przez ktÃ³rykolwiek z
punktÃ³w oczekiwania na wywoÅ‚ania <code>recv</code>.</p>
<p>Aby uzyskaÄ‡ poÅ¼Ä…dane zachowanie, w ktÃ³rym opÃ³Åºnienie snu nastÄ™puje miÄ™dzy
kaÅ¼dÄ… wiadomoÅ›ciÄ…, musimy umieÅ›ciÄ‡ operacje <code>tx</code> i <code>rx</code> w ich wÅ‚asnych blokach
async, jak pokazano w Listingu 17-11. Wtedy Å›rodowisko uruchomieniowe moÅ¼e
wykonaÄ‡ kaÅ¼dÄ… z nich oddzielnie, uÅ¼ywajÄ…c funkcji <code>trpl::join</code>, podobnie jak
w Listingu 17-8. Ponownie, czekamy na wynik wywoÅ‚ania <code>trpl::join</code>, a nie na
poszczegÃ³lne futures. GdybyÅ›my czekali na poszczegÃ³lne futures w sekwencji,
skutkowaÅ‚oby to powrotem do sekwencyjnego przepÅ‚ywu â€“ dokÅ‚adnie tego, czego
prÃ³bujemy <em>nie</em> robiÄ‡.</p>
<!-- We cannot test this one because it never stops! -->
<listing number="17-11" caption="Rozdzielenie `send` i `recv` na wÅ‚asne bloki `async` i oczekiwanie na futures dla tych blokÃ³w" file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span>        let tx_fut = async {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</listing>
<p>DziÄ™ki zaktualizowanemu kodowi z Listingu 17-11, wiadomoÅ›ci sÄ… drukowane w
odstÄ™pach 500 milisekund, a nie wszystkie naraz po 2 sekundach.</p>
<h4 id="przenoszenie-wÅ‚asnoÅ›ci-do-bloku-async"><a class="header" href="#przenoszenie-wÅ‚asnoÅ›ci-do-bloku-async">Przenoszenie wÅ‚asnoÅ›ci do bloku <code>async</code></a></h4>
<p>Program nadal nigdy siÄ™ nie koÅ„czy z powodu sposobu, w jaki pÄ™tla <code>while let</code>
wspÃ³Å‚dziaÅ‚a z <code>trpl::join</code>:</p>
<ul>
<li>Future zwrÃ³cona przez <code>trpl::join</code> koÅ„czy siÄ™ dopiero, gdy <em>obie</em> future,
ktÃ³re zostaÅ‚y do niej przekazane, zakoÅ„czÄ… swoje dziaÅ‚anie.</li>
<li>Future <code>tx_fut</code> koÅ„czy siÄ™, gdy zakoÅ„czy spanie po wysÅ‚aniu ostatniej
wiadomoÅ›ci w <code>vals</code>.</li>
<li>Future <code>rx_fut</code> nie zakoÅ„czy siÄ™, dopÃ³ki pÄ™tla <code>while let</code> siÄ™ nie zakoÅ„czy.</li>
<li>PÄ™tla <code>while let</code> nie zakoÅ„czy siÄ™, dopÃ³ki oczekiwanie na <code>rx.recv</code> nie
zwrÃ³ci <code>None</code>.</li>
<li>Oczekiwanie na <code>rx.recv</code> zwrÃ³ci <code>None</code> dopiero po zamkniÄ™ciu drugiego koÅ„ca
kanaÅ‚u.</li>
<li>KanaÅ‚ zostanie zamkniÄ™ty tylko, jeÅ›li wywoÅ‚amy <code>rx.close</code> lub gdy strona
nadawcy, <code>tx</code>, zostanie usuniÄ™ta.</li>
<li>Nigdzie nie wywoÅ‚ujemy <code>rx.close</code>, a <code>tx</code> nie zostanie usuniÄ™te, dopÃ³ki
najbardziej zewnÄ™trzny blok async przekazany do <code>trpl::block_on</code> siÄ™ nie
zakoÅ„czy.</li>
<li>Blok nie moÅ¼e siÄ™ zakoÅ„czyÄ‡, poniewaÅ¼ jest zablokowany przez zakoÅ„czenie
<code>trpl::join</code>, co cofa nas na poczÄ…tek tej listy.</li>
</ul>
<p>Obecnie blok async, w ktÃ³rym wysyÅ‚amy wiadomoÅ›ci, jedynie <em>poÅ¼ycza</em> <code>tx</code>,
poniewaÅ¼ wysyÅ‚anie wiadomoÅ›ci nie wymaga wÅ‚asnoÅ›ci, ale gdybyÅ›my mogli
<em>przenieÅ›Ä‡</em> <code>tx</code> do tego bloku async, zostaÅ‚oby ono usuniÄ™te po zakoÅ„czeniu
tego bloku. W sekcji <a href="#capturing-references-or-moving-ownership">â€Przechwytywanie referencji lub przenoszenie
wÅ‚asnoÅ›ciâ€</a><!-- ignore --> w Rozdziale 13 nauczyÅ‚eÅ› siÄ™, jak
uÅ¼ywaÄ‡ sÅ‚owa kluczowego <code>move</code> z domkniÄ™ciami, a jak omÃ³wiono w sekcji
<a href="#using-move-closures-with-threads">â€UÅ¼ywanie domkniÄ™Ä‡ <code>move</code> z wÄ…tkamiâ€</a><!-- ignore --> w Rozdziale
16, czÄ™sto musimy przenosiÄ‡ dane do domkniÄ™Ä‡, pracujÄ…c z wÄ…tkami. Te same
podstawowe dynamiki dotyczÄ… blokÃ³w async, wiÄ™c sÅ‚owo kluczowe <code>move</code> dziaÅ‚a z
blokami async tak samo, jak z domkniÄ™ciami.</p>
<p>W Listingu 17-12 zmieniamy blok uÅ¼ywany do wysyÅ‚ania wiadomoÅ›ci z <code>async</code> na
<code>async move</code>.</p>
<listing number="17-12" caption="Poprawiona wersja kodu z Listingu 17-11, ktÃ³ra poprawnie zamyka siÄ™ po zakoÅ„czeniu" file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx_fut = async move {
            // --snip--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_millis(500)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        trpl::join(tx_fut, rx_fut).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre>
</listing>
<p>Po uruchomieniu <em>tej</em> wersji kodu, zamyka siÄ™ ona pÅ‚ynnie po wysÅ‚aniu i
odebraniu ostatniej wiadomoÅ›ci. NastÄ™pnie, zobaczmy, co musiaÅ‚oby siÄ™ zmieniÄ‡,
aby wysyÅ‚aÄ‡ dane z wiÄ™cej niÅ¼ jednej future.</p>
<h4 id="Å‚Ä…czenie-wielu-futures-za-pomocÄ…-makra-join"><a class="header" href="#Å‚Ä…czenie-wielu-futures-za-pomocÄ…-makra-join">ÅÄ…czenie wielu futures za pomocÄ… makra <code>join!</code></a></h4>
<p>Ten kanaÅ‚ async jest rÃ³wnieÅ¼ kanaÅ‚em wieloproducentowym, wiÄ™c moÅ¼emy wywoÅ‚aÄ‡
<code>clone</code> na <code>tx</code>, jeÅ›li chcemy wysyÅ‚aÄ‡ wiadomoÅ›ci z wielu futures, jak pokazano
w Listingu 17-13.</p>
<listing number="17-13" caption="UÅ¼ycie wielu producentÃ³w z blokami `async`" file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx1 = tx.clone();
        let tx1_fut = async move {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        let tx_fut = async move {
            let vals = vec![
                String::from("more"),
                String::from("messages"),
                String::from("for"),
                String::from("you"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(1500)).await;
            }
        };

        trpl::join!(tx1_fut, tx_fut, rx_fut);
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</listing>
<p>Najpierw klonujemy <code>tx</code>, tworzÄ…c <code>tx1</code> poza pierwszym blokiem async. Przenosimy
<code>tx1</code> do tego bloku, tak jak wczeÅ›niej z <code>tx</code>. NastÄ™pnie, pÃ³Åºniej, przenosimy
oryginalne <code>tx</code> do <em>nowego</em> bloku async, gdzie wysyÅ‚amy wiÄ™cej wiadomoÅ›ci z
nieco wolniejszym opÃ³Åºnieniem. Akurat umieszczamy ten nowy blok async po bloku
async do odbierania wiadomoÅ›ci, ale rÃ³wnie dobrze mÃ³gÅ‚by byÄ‡ przed nim. Kluczem
jest kolejnoÅ›Ä‡, w jakiej futures sÄ… oczekiwane, a nie w jakiej sÄ… tworzone.</p>
<p>Oba bloki async do wysyÅ‚ania wiadomoÅ›ci muszÄ… byÄ‡ blokami <code>async move</code>,
tak aby zarÃ³wno <code>tx</code>, jak i <code>tx1</code> zostaÅ‚y usuniÄ™te po zakoÅ„czeniu tych blokÃ³w.
W przeciwnym razie wrÃ³cimy do tej samej nieskoÅ„czonej pÄ™tli, w ktÃ³rej zaczÄ™liÅ›my.</p>
<p>Na koniec, przeÅ‚Ä…czamy siÄ™ z <code>trpl::join</code> na <code>trpl::join!</code>, aby obsÅ‚uÅ¼yÄ‡
dodatkowe future: makro <code>join!</code> oczekuje na dowolnÄ… liczbÄ™ futures, gdzie
liczbÄ™ futures znamy w czasie kompilacji. O oczekiwaniu na kolekcjÄ™ nieznanej
liczby futures bÄ™dziemy rozmawiaÄ‡ pÃ³Åºniej w tym rozdziale.</p>
<p>Teraz widzimy wszystkie wiadomoÅ›ci z obu futures wysyÅ‚ajÄ…cych, a poniewaÅ¼
futures wysyÅ‚ajÄ…ce uÅ¼ywajÄ… nieco innych opÃ³ÅºnieÅ„ po wysÅ‚aniu, wiadomoÅ›ci sÄ…
rÃ³wnieÅ¼ odbierane w tych rÃ³Å¼nych odstÄ™pach czasu:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">received 'hi'
received 'more'
received 'from'
received 'the'
received 'messages'
received 'future'
received 'for'
received 'you'
</code></pre>
<p>MoÅ¼esz zobaczyÄ‡ wartoÅ›ci w innej kolejnoÅ›ci, w zaleÅ¼noÅ›ci od twojego systemu.
To wÅ‚aÅ›nie sprawia, Å¼e wspÃ³Å‚bieÅ¼noÅ›Ä‡ jest interesujÄ…ca, a takÅ¼e trudna. JeÅ›li
poeksperymentujesz z <code>thread::sleep</code>, nadajÄ…c mu rÃ³Å¼ne wartoÅ›ci w rÃ³Å¼nych
wÄ…tkach, kaÅ¼de uruchomienie bÄ™dzie bardziej niedeterministyczne i za kaÅ¼dym
razem bÄ™dzie generowaÄ‡ inne dane wyjÅ›ciowe.</p>
<p>Teraz, gdy przyjrzeliÅ›my siÄ™, jak dziaÅ‚ajÄ… kanaÅ‚y, spÃ³jrzmy na innÄ… metodÄ™
wspÃ³Å‚bieÅ¼noÅ›ci.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="praca-z-dowolnÄ…-liczbÄ…-futures"><a href="#praca-z-dowolnÄ…-liczbÄ…-futures" class="header">Praca z dowolnÄ… liczbÄ… futures</a></h1>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="yielding"></a></p>
<h3 id="przekazywanie-kontroli-do-Å›rodowiska-wykonawczego"><a class="header" href="#przekazywanie-kontroli-do-Å›rodowiska-wykonawczego">Przekazywanie kontroli do Å›rodowiska wykonawczego</a></h3>
<p>Przypomnijmy z sekcji <a href="#our-first-async-program">â€Nasz pierwszy program asynchronicznyâ€</a><!-- ignore -->, Å¼e w kaÅ¼dym punkcie <code>await</code> Rust daje Å›rodowisku wykonawczemu szansÄ™ na wstrzymanie zadania i przeÅ‚Ä…czenie siÄ™ na inne, jeÅ›li oczekiwany future nie jest gotowy. OdwrotnoÅ›Ä‡ jest rÃ³wnieÅ¼ prawdziwa: Rust <em>tylko</em> wstrzymuje bloki asynchroniczne i przekazuje kontrolÄ™ Å›rodowisku wykonawczemu w punkcie <code>await</code>. Wszystko pomiÄ™dzy punktami <code>await</code> jest synchroniczne.</p>
<p>Oznacza to, Å¼e jeÅ›li wykonasz duÅ¼o pracy w bloku asynchronicznym bez punktu <code>await</code>, ten future zablokuje postÄ™p innych futures. Czasami usÅ‚yszysz, Å¼e jeden future <em>zagÅ‚adza</em> inne futures. W niektÃ³rych przypadkach moÅ¼e to nie byÄ‡ duÅ¼y problem. Jednak jeÅ›li wykonujesz jakÄ…Å› kosztownÄ… konfiguracjÄ™ lub dÅ‚ugotrwaÅ‚Ä… pracÄ™, albo jeÅ›li masz future, ktÃ³re bÄ™dzie wykonywaÄ‡ pewne zadanie w nieskoÅ„czonoÅ›Ä‡, bÄ™dziesz musiaÅ‚ pomyÅ›leÄ‡ o tym, kiedy i gdzie przekazaÄ‡ kontrolÄ™ Å›rodowisku wykonawczemu.</p>
<p>Zasymulujmy dÅ‚ugotrwaÅ‚Ä… operacjÄ™, aby zilustrowaÄ‡ problem zagÅ‚adzania, a nastÄ™pnie zbadajmy, jak go rozwiÄ…zaÄ‡. Listing 17-14 wprowadza funkcjÄ™ <code>slow</code>.</p>
<listing number="17-14" caption="UÅ¼ycie `thread::sleep` do symulacji wolnych operacji" file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span><span class="boring">        // We will call `slow` here later
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>fn slow(name: &amp;str, ms: u64) {
    thread::sleep(Duration::from_millis(ms));
    println!("'{name}' ran for {ms}ms");
}</code></pre>
</listing>
<p>Ten kod uÅ¼ywa <code>std::thread::sleep</code> zamiast <code>trpl::sleep</code>, wiÄ™c wywoÅ‚anie <code>slow</code> zablokuje bieÅ¼Ä…cy wÄ…tek na okreÅ›lonÄ… liczbÄ™ milisekund. MoÅ¼emy uÅ¼yÄ‡ <code>slow</code> do reprezentowania rzeczywistych operacji, ktÃ³re sÄ… zarÃ³wno dÅ‚ugotrwaÅ‚e, jak i blokujÄ…ce.</p>
<p>W Listing 17-15 uÅ¼ywamy <code>slow</code> do emulacji tego rodzaju pracy zwiÄ…zanej z CPU w parze futures.</p>
<listing number="17-15" caption="WywoÅ‚ywanie funkcji `slow` w celu symulacji wolnych operacji" file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let a = async {
            println!("'a' started.");
            slow("a", 30);
            slow("a", 10);
            slow("a", 20);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            slow("b", 10);
            slow("b", 15);
            slow("b", 350);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'b' finished.");
        };

        trpl::select(a, b).await;
<span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre>
</listing>
<p>KaÅ¼dy future przekazuje kontrolÄ™ Å›rodowisku wykonawczemu dopiero <em>po</em> wykonaniu szeregu wolnych operacji. JeÅ›li uruchomisz ten kod, zobaczysz nastÄ™pujÄ…cy wynik:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-15/
cargo run
copy just the output
-->
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'a' ran for 10ms
'a' ran for 20ms
'b' started.
'b' ran for 75ms
'b' ran for 10ms
'b' ran for 15ms
'b' ran for 350ms
'a' finished.
</code></pre>
<p>Podobnie jak w Listing 17-5, gdzie uÅ¼yliÅ›my <code>trpl::select</code> do wspÃ³Å‚zawodnictwa futures pobierajÄ…cych dwa adresy URL, <code>select</code> nadal koÅ„czy dziaÅ‚anie, gdy tylko <code>a</code> zostanie zakoÅ„czone. Nie ma jednak przeplatania miÄ™dzy wywoÅ‚aniami <code>slow</code> w dwÃ³ch futures. Future <code>a</code> wykonuje caÅ‚Ä… swojÄ… pracÄ™, dopÃ³ki nie zostanie oczekiwane wywoÅ‚anie <code>trpl::sleep</code>, nastÄ™pnie future <code>b</code> wykonuje caÅ‚Ä… swojÄ… pracÄ™, dopÃ³ki nie zostanie oczekiwane jego wÅ‚asne wywoÅ‚anie <code>trpl::sleep</code>, a na koniec future <code>a</code> zostaje zakoÅ„czone. Aby umoÅ¼liwiÄ‡ obu futures postÄ™p miÄ™dzy ich wolnymi zadaniami, potrzebujemy punktÃ³w <code>await</code>, abyÅ›my mogli przekazaÄ‡ kontrolÄ™ Å›rodowisku wykonawczemu. Oznacza to, Å¼e potrzebujemy czegoÅ›, na co moÅ¼emy czekaÄ‡!</p>
<p>JuÅ¼ widzimy, jak tego rodzaju przekazywanie dzieje siÄ™ w Listing 17-15: gdybyÅ›my usunÄ™li <code>trpl::sleep</code> na koÅ„cu future <code>a</code>, zostaÅ‚oby ono zakoÅ„czone bez <em>jakiegokolwiek</em> uruchomienia future <code>b</code>. SprÃ³bujmy uÅ¼yÄ‡ funkcji <code>trpl::sleep</code> jako punktu wyjÅ›cia do umoÅ¼liwienia operacjom przeÅ‚Ä…czania siÄ™ w celu osiÄ…gania postÄ™pu, jak pokazano w Listing 17-16.</p>
<listing number="17-16" caption="UÅ¼ycie `trpl::sleep` do umoÅ¼liwienia operacjom przeÅ‚Ä…czania siÄ™ w celu osiÄ…gania postÄ™pu" file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let one_ms = Duration::from_millis(1);

        let a = async {
            println!("'a' started.");
            slow("a", 30);
            trpl::sleep(one_ms).await;
            slow("a", 10);
            trpl::sleep(one_ms).await;
            slow("a", 20);
            trpl::sleep(one_ms).await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            trpl::sleep(one_ms).await;
            slow("b", 10);
            trpl::sleep(one_ms).await;
            slow("b", 15);
            trpl::sleep(one_ms).await;
            slow("b", 350);
            trpl::sleep(one_ms).await;
            println!("'b' finished.");
        };
<span class="boring">
</span><span class="boring">        trpl::select(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre>
</listing>
<p>DodaliÅ›my wywoÅ‚ania <code>trpl::sleep</code> z punktami <code>await</code> miÄ™dzy kaÅ¼dym wywoÅ‚aniem <code>slow</code>. Teraz praca obu futures jest przeplatana:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-16
cargo run
copy just the output
-->
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'b' started.
'b' ran for 75ms
'a' ran for 10ms
'b' ran for 10ms
'a' ran for 20ms
'b' ran for 15ms
'a' finished.
</code></pre>
<p>Future <code>a</code> nadal dziaÅ‚a przez chwilÄ™, zanim przekaÅ¼e kontrolÄ™ do <code>b</code>, poniewaÅ¼ wywoÅ‚uje <code>slow</code> przed wywoÅ‚aniem <code>trpl::sleep</code>, ale potem futures zamieniajÄ… siÄ™ miejscami za kaÅ¼dym razem, gdy jedna z nich osiÄ…ga punkt <code>await</code>. W tym przypadku zrobiliÅ›my to po kaÅ¼dym wywoÅ‚aniu <code>slow</code>, ale mogliÅ›my podzieliÄ‡ pracÄ™ w sposÃ³b, ktÃ³ry miaÅ‚by dla nas najwiÄ™kszy sens.</p>
<p>Nie chcemy jednak tutaj faktycznie <em>spaÄ‡</em>: chcemy postÄ™powaÄ‡ tak szybko, jak to moÅ¼liwe. Po prostu musimy przekazaÄ‡ kontrolÄ™ Å›rodowisku wykonawczemu. MoÅ¼emy to zrobiÄ‡ bezpoÅ›rednio, uÅ¼ywajÄ…c funkcji <code>trpl::yield_now</code>. W Listing 17-17 zastÄ™pujemy wszystkie te wywoÅ‚ania <code>trpl::sleep</code> wywoÅ‚aniami <code>trpl::yield_now</code>.</p>
<listing number="17-17" caption="UÅ¼ycie `yield_now` do umoÅ¼liwienia operacjom przeÅ‚Ä…czania siÄ™ w celu osiÄ…gania postÄ™pu" file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let a = async {
            println!("'a' started.");
            slow("a", 30);
            trpl::yield_now().await;
            slow("a", 10);
            trpl::yield_now().await;
            slow("a", 20);
            trpl::yield_now().await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            trpl::yield_now().await;
            slow("b", 10);
            trpl::yield_now().await;
            slow("b", 15);
            trpl::yield_now().await;
            slow("b", 350);
            trpl::yield_now().await;
            println!("'b' finished.");
        };
<span class="boring">
</span><span class="boring">        trpl::select(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre>
</listing>
<p>Ten kod jest zarÃ³wno jaÅ›niejszy pod wzglÄ™dem rzeczywistego zamiaru, jak i moÅ¼e byÄ‡ znacznie szybszy niÅ¼ uÅ¼ycie <code>sleep</code>, poniewaÅ¼ timery takie jak ten uÅ¼ywany przez <code>sleep</code> czÄ™sto majÄ… ograniczenia co do tego, jak granularne mogÄ… byÄ‡. Na przykÅ‚ad, wersja <code>sleep</code>, ktÃ³rej uÅ¼ywamy, zawsze bÄ™dzie spaÄ‡ przez co najmniej milisekundÄ™, nawet jeÅ›li przekaÅ¼emy jej <code>Duration</code> o dÅ‚ugoÅ›ci jednej nanosekundy. Ponownie, nowoczesne komputery sÄ… <em>szybkie</em>: mogÄ… zrobiÄ‡ wiele w ciÄ…gu jednej milisekundy!</p>
<p>Oznacza to, Å¼e async moÅ¼e byÄ‡ uÅ¼yteczne nawet dla zadaÅ„ zwiÄ…zanych z obliczeniami, w zaleÅ¼noÅ›ci od tego, co jeszcze robi twÃ³j program, poniewaÅ¼ dostarcza przydatne narzÄ™dzie do strukturyzowania relacji miÄ™dzy rÃ³Å¼nymi czÄ™Å›ciami programu (ale kosztem narzutu maszyny stanÃ³w async). Jest to forma <em>wielozadaniowoÅ›ci kooperacyjnej</em>, gdzie kaÅ¼dy future ma moc decydowania, kiedy przekaÅ¼e kontrolÄ™ za poÅ›rednictwem punktÃ³w <code>await</code>. KaÅ¼dy future ponosi zatem rÃ³wnieÅ¼ odpowiedzialnoÅ›Ä‡ za unikanie zbyt dÅ‚ugiego blokowania. W niektÃ³rych wbudowanych systemach operacyjnych opartych na Rust jest to <em>jedyny</em> rodzaj wielozadaniowoÅ›ci!</p>
<p>W rzeczywistym kodzie oczywiÅ›cie nie bÄ™dziesz na kaÅ¼dej linii przeplataÄ‡ wywoÅ‚aÅ„ funkcji z punktami <code>await</code>. ChociaÅ¼ przekazywanie kontroli w ten sposÃ³b jest stosunkowo niedrogie, nie jest darmowe. W wielu przypadkach prÃ³ba podziaÅ‚u zadania intensywnie obciÄ…Å¼ajÄ…cego CPU moÅ¼e znacznie je spowolniÄ‡, wiÄ™c czasami dla <em>ogÃ³lnej</em> wydajnoÅ›ci lepiej jest pozwoliÄ‡ operacji na krÃ³tkie zablokowanie. Zawsze mierz, aby zobaczyÄ‡, gdzie sÄ… rzeczywiste wÄ…skie gardÅ‚a wydajnoÅ›ci twojego kodu. WaÅ¼ne jest jednak, aby pamiÄ™taÄ‡ o podstawowej dynamice, jeÅ›li <em>widzisz</em> duÅ¼o pracy wykonywanej szeregowo, a spodziewaÅ‚eÅ› siÄ™, Å¼e bÄ™dzie ona wykonywana rÃ³wnolegle!</p>
<h3 id="budowanie-wÅ‚asnych-abstrakcji-asynchronicznych"><a class="header" href="#budowanie-wÅ‚asnych-abstrakcji-asynchronicznych">Budowanie wÅ‚asnych abstrakcji asynchronicznych</a></h3>
<p>MoÅ¼emy rÃ³wnieÅ¼ Å‚Ä…czyÄ‡ futures, aby tworzyÄ‡ nowe wzorce. Na przykÅ‚ad moÅ¼emy zbudowaÄ‡ funkcjÄ™ <code>timeout</code> z juÅ¼ posiadanych asynchronicznych blokÃ³w konstrukcyjnych. Kiedy skoÅ„czymy, wynik bÄ™dzie kolejnym blokiem konstrukcyjnym, ktÃ³rego moglibyÅ›my uÅ¼yÄ‡ do tworzenia jeszcze bardziej asynchronicznych abstrakcji.</p>
<p>Listing 17-18 pokazuje, jak ten <code>timeout</code> powinien dziaÅ‚aÄ‡ z wolnym future.</p>
<listing number="17-18" caption="UÅ¼ycie naszego wyobraÅ¼onego `timeout` do uruchomienia wolnej operacji z limitem czasu" file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let slow = async {
            trpl::sleep(Duration::from_secs(5)).await;
            "Finally finished"
        };

        match timeout(slow, Duration::from_secs(2)).await {
            Ok(message) =&gt; println!("Succeeded with '{message}'"),
            Err(duration) =&gt; {
                println!("Failed after {} seconds", duration.as_secs())
            }
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</listing>
<p>Zaimplementujmy to! Na poczÄ…tek pomyÅ›lmy o API dla <code>timeout</code>:</p>
<ul>
<li>Musi to byÄ‡ funkcja asynchroniczna sama w sobie, abyÅ›my mogli na niÄ… czekaÄ‡ (<code>await</code>).</li>
<li>Jej pierwszy parametr powinien byÄ‡ futurem do uruchomienia. MoÅ¼emy uczyniÄ‡ go generycznym, aby mÃ³gÅ‚ dziaÅ‚aÄ‡ z dowolnym futurem.</li>
<li>Jej drugi parametr bÄ™dzie maksymalnym czasem oczekiwania. JeÅ›li uÅ¼yjemy <code>Duration</code>, uÅ‚atwi to przekazanie do <code>trpl::sleep</code>.</li>
<li>Powinna zwracaÄ‡ <code>Result</code>. JeÅ›li future zakoÅ„czy siÄ™ pomyÅ›lnie, <code>Result</code> bÄ™dzie <code>Ok</code> z wartoÅ›ciÄ… wyprodukowanÄ… przez future. JeÅ›li limit czasu upÅ‚ynie wczeÅ›niej, <code>Result</code> bÄ™dzie <code>Err</code> z czasem trwania, na ktÃ³ry timeout czekaÅ‚.</li>
</ul>
<p>Listing 17-19 pokazuje tÄ™ deklaracjÄ™.</p>
<!-- This is not tested because it intentionally does not compile. -->
<listing number="17-19" caption="Definiowanie sygnatury `timeout`" file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span><span class="boring">        let slow = async {
</span><span class="boring">            trpl::sleep(Duration::from_secs(5)).await;
</span><span class="boring">            "Finally finished"
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        match timeout(slow, Duration::from_secs(2)).await {
</span><span class="boring">            Ok(message) =&gt; println!("Succeeded with '{message}'"),
</span><span class="boring">            Err(duration) =&gt; {
</span><span class="boring">                println!("Failed after {} seconds", duration.as_secs())
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    // Here is where our implementation will go!
}</code></pre>
</listing>
<p>To speÅ‚nia nasze cele dotyczÄ…ce typÃ³w. Teraz pomyÅ›lmy o <em>zachowaniu</em>, ktÃ³rego potrzebujemy: chcemy, aby future przekazane w tle konkurowaÅ‚o z czasem trwania. MoÅ¼emy uÅ¼yÄ‡ <code>trpl::sleep</code>, aby utworzyÄ‡ future timera z czasu trwania, i uÅ¼yÄ‡ <code>trpl::select</code>, aby uruchomiÄ‡ ten timer z futurem przekazanym przez wywoÅ‚ujÄ…cego.</p>
<p>W Listing 17-20 implementujemy <code>timeout</code> poprzez dopasowanie do wyniku oczekiwania (<code>await</code>) na <code>trpl::select</code>.</p>
<listing number="17-20" caption="Definiowanie `timeout` za pomocÄ… `select` i `sleep`" file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>use trpl::Either;

// --snip--

<span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span><span class="boring">        let slow = async {
</span><span class="boring">            trpl::sleep(Duration::from_secs(5)).await;
</span><span class="boring">            "Finally finished"
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        match timeout(slow, Duration::from_secs(2)).await {
</span><span class="boring">            Ok(message) =&gt; println!("Succeeded with '{message}'"),
</span><span class="boring">            Err(duration) =&gt; {
</span><span class="boring">                println!("Failed after {} seconds", duration.as_secs())
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    match trpl::select(future_to_try, trpl::sleep(max_time)).await {
        Either::Left(output) =&gt; Ok(output),
        Either::Right(_) =&gt; Err(max_time),
    }
}</code></pre>
</listing>
<p>Implementacja <code>trpl::select</code> nie jest sprawiedliwa: zawsze odpytuje argumenty w kolejnoÅ›ci, w jakiej zostaÅ‚y przekazane (inne implementacje <code>select</code> losowo wybierajÄ…, ktÃ³ry argument odpytaÄ‡ jako pierwszy). W ten sposÃ³b przekazujemy <code>future_to_try</code> do <code>select</code> jako pierwszy, aby miaÅ‚ szansÄ™ na ukoÅ„czenie, nawet jeÅ›li <code>max_time</code> jest bardzo krÃ³tkim czasem trwania. JeÅ›li <code>future_to_try</code> zakoÅ„czy siÄ™ jako pierwszy, <code>select</code> zwrÃ³ci <code>Left</code> z wynikiem z <code>future_to_try</code>. JeÅ›li <code>timer</code> zakoÅ„czy siÄ™ jako pierwszy, <code>select</code> zwrÃ³ci <code>Right</code> z wynikiem timera <code>()</code>.</p>
<p>JeÅ›li <code>future_to_try</code> zakoÅ„czy siÄ™ sukcesem i otrzymamy <code>Left(output)</code>, zwracamy <code>Ok(output)</code>. JeÅ›li zamiast tego upÅ‚ynie czas timera uÅ›pienia i otrzymamy <code>Right(())</code>, ignorujemy <code>()</code> za pomocÄ… <code>_</code> i zamiast tego zwracamy <code>Err(max_time)</code>.</p>
<p>DziÄ™ki temu mamy dziaÅ‚ajÄ…cÄ… funkcjÄ™ <code>timeout</code> zbudowanÄ… z dwÃ³ch innych asynchronicznych pomocnikÃ³w. JeÅ›li uruchomimy nasz kod, wydrukuje on tryb awarii po upÅ‚ywie limitu czasu:</p>
<pre><code class="language-text">Failed after 2 seconds
</code></pre>
<p>PoniewaÅ¼ futures komponujÄ… siÄ™ z innymi futures, moÅ¼esz budowaÄ‡ naprawdÄ™ potÄ™Å¼ne narzÄ™dzia, uÅ¼ywajÄ…c mniejszych asynchronicznych blokÃ³w konstrukcyjnych. Na przykÅ‚ad, moÅ¼esz uÅ¼yÄ‡ tego samego podejÅ›cia do Å‚Ä…czenia limitÃ³w czasu z ponownymi prÃ³bami, a z kolei uÅ¼ywaÄ‡ ich z operacjami takimi jak wywoÅ‚ania sieciowe (takie jak te w Listing 17-5).</p>
<p>W praktyce zazwyczaj bÄ™dziesz pracowaÄ‡ bezpoÅ›rednio z <code>async</code> i <code>await</code>, a w drugiej kolejnoÅ›ci z funkcjami takimi jak <code>select</code> i makrami takimi jak makro <code>join!</code> do kontrolowania sposobu wykonywania zewnÄ™trznych futures.</p>
<p>WidzieliÅ›my juÅ¼ wiele sposobÃ³w pracy z wieloma futures jednoczeÅ›nie. NastÄ™pnie przyjrzymy siÄ™, jak moÅ¼emy pracowaÄ‡ z wieloma futures w sekwencji w czasie za pomocÄ… <em>strumieni</em>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="strumienie-futures-w-sekwencji-1"><a href="#strumienie-futures-w-sekwencji-1" class="header">Strumienie: Futures w sekwencji</a></h1>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="streams"></a></p>
<h2 id="strumienie-futures-w-sekwencji"><a class="header" href="#strumienie-futures-w-sekwencji">Strumienie: Futures w sekwencji</a></h2>
<p>Przypomnijmy, jak uÅ¼ywaliÅ›my odbiornika dla naszego asynchronicznego kanaÅ‚u wczeÅ›niej w tym rozdziale w sekcji <a href="#message-passing">â€Przekazywanie wiadomoÅ›ciâ€</a><!-- ignore -->. Asynchroniczna metoda <code>recv</code> wytwarza sekwencjÄ™ elementÃ³w w czasie. Jest to instancja znacznie bardziej ogÃ³lnego wzorca znanego jako <em>strumieÅ„</em>. Wiele koncepcji jest naturalnie reprezentowanych jako strumienie: elementy stajÄ… siÄ™ dostÄ™pne w kolejce, fragmenty danych sÄ… pobierane przyrostowo z systemu plikÃ³w, gdy peÅ‚ny zestaw danych jest zbyt duÅ¼y dla pamiÄ™ci komputera, lub dane przychodzÄ… przez sieÄ‡ w czasie. PoniewaÅ¼ strumienie sÄ… futures, moÅ¼emy ich uÅ¼ywaÄ‡ z dowolnym innym rodzajem future i Å‚Ä…czyÄ‡ je w interesujÄ…ce sposoby. Na przykÅ‚ad, moÅ¼emy grupowaÄ‡ zdarzenia, aby uniknÄ…Ä‡ wywoÅ‚ywania zbyt wielu wywoÅ‚aÅ„ sieciowych, ustawiaÄ‡ limity czasu na sekwencje dÅ‚ugotrwaÅ‚ych operacji lub ograniczaÄ‡ zdarzenia interfejsu uÅ¼ytkownika, aby uniknÄ…Ä‡ wykonywania zbÄ™dnej pracy.</p>
<p>WidzieliÅ›my sekwencjÄ™ elementÃ³w w Rozdziale 13, kiedy przyglÄ…daliÅ›my siÄ™ cechom Iterator w sekcji <a href="#the-iterator-trait-and-the-next-method">â€Cechy Iterator i metoda <code>next</code>â€</a><!-- ignore -->, ale istniejÄ… dwie rÃ³Å¼nice miÄ™dzy iteratorami a asynchronicznym odbiornikiem kanaÅ‚u. Pierwsza rÃ³Å¼nica to czas: iteratory sÄ… synchroniczne, podczas gdy odbiornik kanaÅ‚u jest asynchroniczny. Druga rÃ³Å¼nica to API. PracujÄ…c bezpoÅ›rednio z <code>Iterator</code>, wywoÅ‚ujemy jego synchronicznÄ… metodÄ™ <code>next</code>. W przypadku strumienia <code>trpl::Receiver</code> w szczegÃ³lnoÅ›ci, zamiast tego wywoÅ‚aliÅ›my asynchronicznÄ… metodÄ™ <code>recv</code>. Poza tym te API sÄ… bardzo podobne, a to podobieÅ„stwo nie jest przypadkowe. StrumieÅ„ jest jak asynchroniczna forma iteracji. Podczas gdy <code>trpl::Receiver</code> w szczegÃ³lnoÅ›ci czeka na odebranie wiadomoÅ›ci, ogÃ³lne API strumienia jest znacznie szersze: dostarcza nastÄ™pny element w taki sam sposÃ³b jak <code>Iterator</code>, ale asynchronicznie.</p>
<p>PodobieÅ„stwo miÄ™dzy iteratorami a strumieniami w Rust oznacza, Å¼e faktycznie moÅ¼emy stworzyÄ‡ strumieÅ„ z dowolnego iteratora. Podobnie jak w przypadku iteratora, moÅ¼emy pracowaÄ‡ ze strumieniem, wywoÅ‚ujÄ…c jego metodÄ™ <code>next</code>, a nastÄ™pnie oczekujÄ…c na wynik, jak w Listing 17-21, ktÃ³ry jeszcze siÄ™ nie skompiluje.</p>
<listing number="17-21" caption="Tworzenie strumienia z iteratora i drukowanie jego wartoÅ›ci" file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        let iter = values.iter().map(|n| n * 2);
        let mut stream = trpl::stream_from_iter(iter);

        while let Some(value) = stream.next().await {
            println!("The value was: {value}");
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</listing>
<p>Zaczynamy od tablicy liczb, ktÃ³rÄ… przeksztaÅ‚camy w iterator, a nastÄ™pnie wywoÅ‚ujemy <code>map</code>, aby podwoiÄ‡ wszystkie wartoÅ›ci. NastÄ™pnie przeksztaÅ‚camy iterator w strumieÅ„ za pomocÄ… funkcji <code>trpl::stream_from_iter</code>. Dalej pÄ™tlujemy po elementach w strumieniu, gdy te docierajÄ…, za pomocÄ… pÄ™tli <code>while let</code>.</p>
<p>Niestety, kiedy prÃ³bujemy uruchomiÄ‡ ten kod, nie kompiluje siÄ™ on, lecz zgÅ‚asza brak metody <code>next</code>:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-21
cargo build
copy only the error output
-->
<pre><code class="language-text">error[E0599]: no method named `next` found for struct `tokio_stream::iter::Iter` in the current scope
  --&gt; src/main.rs:10:40
   |
10 |         while let Some(value) = stream.next().await {
   |                                        ^^^^
   |
   = help: items from traits can only be used if the trait is in scope
help: the following traits which provide `next` are implemented but not in scope; perhaps you want to import one of them
   |
1  + use crate::trpl::StreamExt;
   |
1  + use futures_util::stream::stream::StreamExt;
   |
1  + use std::iter::Iterator;
   |
1  + use std::str::pattern::Searcher;
   |
help: there is a method `try_next` with a similar name
   |
10 |         while let Some(value) = stream.try_next().await {
   |                                        ~~~~~~~~
</code></pre>
<p>Jak wyjaÅ›nia ten wynik, przyczynÄ… bÅ‚Ä™du kompilacji jest to, Å¼e do uÅ¼ycia metody <code>next</code> potrzebujemy odpowiedniej cechy w zasiÄ™gu. BiorÄ…c pod uwagÄ™ naszÄ… dotychczasowÄ… dyskusjÄ™, moÅ¼na by rozsÄ…dnie oczekiwaÄ‡, Å¼e bÄ™dzie to cecha <code>Stream</code>, ale w rzeczywistoÅ›ci jest to <code>StreamExt</code>. SkrÃ³t od <em>extension</em> (<code>rozszerzenie</code>), <code>Ext</code> to powszechny wzorzec w spoÅ‚ecznoÅ›ci Rust sÅ‚uÅ¼Ä…cy do rozszerzania jednej cechy innÄ….</p>
<p>Cecha <code>Stream</code> definiuje niskopoziomowy interfejs, ktÃ³ry skutecznie Å‚Ä…czy cechy <code>Iterator</code> i <code>Future</code>. <code>StreamExt</code> dostarcza wyÅ¼szopoziomowy zestaw API ponad <code>Stream</code>, w tym metodÄ™ <code>next</code>, a takÅ¼e inne metody narzÄ™dziowe podobne do tych dostarczanych przez cechÄ™ <code>Iterator</code>. <code>Stream</code> i <code>StreamExt</code> nie sÄ… jeszcze czÄ™Å›ciÄ… standardowej biblioteki Rust, ale wiÄ™kszoÅ›Ä‡ skÅ‚adowych ekosystemu uÅ¼ywa podobnych definicji.</p>
<p>NaprawÄ… bÅ‚Ä™du kompilatora jest dodanie instrukcji <code>use</code> dla <code>trpl::StreamExt</code>, jak w Listing 17-22.</p>
<listing number="17-22" caption="PomyÅ›lne uÅ¼ycie iteratora jako podstawy dla strumienia" file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::StreamExt;

fn main() {
    trpl::block_on(async {
        let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        // --snip--
<span class="boring">        let iter = values.iter().map(|n| n * 2);
</span><span class="boring">        let mut stream = trpl::stream_from_iter(iter);
</span><span class="boring">
</span><span class="boring">        while let Some(value) = stream.next().await {
</span><span class="boring">            println!("The value was: {value}");
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre>
</listing>
<p>Po poÅ‚Ä…czeniu wszystkich tych elementÃ³w ten kod dziaÅ‚a tak, jak chcemy! Co wiÄ™cej, teraz, gdy mamy <code>StreamExt</code> w zasiÄ™gu, moÅ¼emy uÅ¼ywaÄ‡ wszystkich jego metod narzÄ™dziowych, tak samo jak w przypadku iteratorÃ³w.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="bliÅ¼sze-spojrzenie-na-cechy-dla-async-1"><a href="#bliÅ¼sze-spojrzenie-na-cechy-dla-async-1" class="header">BliÅ¼sze spojrzenie na cechy dla async</a></h1>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="digging-into-the-traits-for-async"></a></p>
<h2 id="bliÅ¼sze-spojrzenie-na-cechy-dla-async"><a class="header" href="#bliÅ¼sze-spojrzenie-na-cechy-dla-async">BliÅ¼sze spojrzenie na cechy dla Async</a></h2>
<p>W caÅ‚ym rozdziale uÅ¼ywaliÅ›my cech <code>Future</code>, <code>Stream</code> i <code>StreamExt</code> na rÃ³Å¼ne sposoby. Jak dotÄ…d unikaliÅ›my jednak zagÅ‚Ä™biania siÄ™ w szczegÃ³Å‚y ich dziaÅ‚ania lub ich wzajemnego dopasowania, co w wiÄ™kszoÅ›ci przypadkÃ³w jest w porzÄ…dku w codziennej pracy z Rust. Czasami jednak napotkasz sytuacje, w ktÃ³rych bÄ™dziesz musiaÅ‚ zrozumieÄ‡ kilka wiÄ™cej szczegÃ³Å‚Ã³w tych cech, a takÅ¼e typ <code>Pin</code> i cechÄ™ <code>Unpin</code>. W tej sekcji zagÅ‚Ä™bimy siÄ™ w nie na tyle, aby pomÃ³c w takich scenariuszach, pozostawiajÄ…c <em>naprawdÄ™</em> dogÅ‚Ä™bne badanie innym dokumentacjom.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="future"></a></p>
<h3 id="cechy-future"><a class="header" href="#cechy-future">Cechy <code>Future</code></a></h3>
<p>Zacznijmy od bliÅ¼szego przyjrzenia siÄ™, jak dziaÅ‚a cecha <code>Future</code>. Oto jak Rust jÄ… definiuje:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre>
<p>Ta definicja cechy zawiera wiele nowych typÃ³w, a takÅ¼e pewnÄ… skÅ‚adniÄ™, ktÃ³rej wczeÅ›niej nie widzieliÅ›my, wiÄ™c przejdÅºmy przez definicjÄ™ kawaÅ‚ek po kawaÅ‚ku.</p>
<p>Po pierwsze, typ skojarzony <code>Output</code> z cechy <code>Future</code> mÃ³wi, do czego future siÄ™ rozwiÄ…zuje. Jest to analogiczne do typu skojarzonego <code>Item</code> z cechy <code>Iterator</code>. Po drugie, cecha <code>Future</code> ma metodÄ™ <code>poll</code>, ktÃ³ra przyjmuje specjalnÄ… referencjÄ™ <code>Pin</code> dla swojego parametru <code>self</code> oraz mutowalnÄ… referencjÄ™ do typu <code>Context</code> i zwraca <code>Poll&lt;Self::Output&gt;</code>. WiÄ™cej o <code>Pin</code> i <code>Context</code> powiemy za chwilÄ™. Na razie skupmy siÄ™ na tym, co zwraca metoda, czyli na typie <code>Poll</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
<span class="boring">}</span></code></pre>
<p>Ten typ <code>Poll</code> jest podobny do <code>Option</code>. Ma jeden wariant, ktÃ³ry ma wartoÅ›Ä‡, <code>Ready(T)</code>, i jeden, ktÃ³ry nie ma, <code>Pending</code>. <code>Poll</code> oznacza jednak coÅ› zupeÅ‚nie innego niÅ¼ <code>Option</code>! Wariant <code>Pending</code> wskazuje, Å¼e future nadal ma pracÄ™ do wykonania, wiÄ™c wywoÅ‚ujÄ…cy bÄ™dzie musiaÅ‚ sprawdziÄ‡ ponownie pÃ³Åºniej. Wariant <code>Ready</code> wskazuje, Å¼e <code>Future</code> zakoÅ„czyÅ‚o swojÄ… pracÄ™ i wartoÅ›Ä‡ <code>T</code> jest dostÄ™pna.</p>
<blockquote>
<p>Uwaga: Rzadko zdarza siÄ™ potrzeba bezpoÅ›redniego wywoÅ‚ania <code>poll</code>, ale jeÅ›li zajdzie taka potrzeba, pamiÄ™taj, Å¼e w przypadku wiÄ™kszoÅ›ci futures, wywoÅ‚ujÄ…cy nie powinien ponownie wywoÅ‚ywaÄ‡ <code>poll</code> po tym, jak future zwrÃ³ciÅ‚o <code>Ready</code>. Wiele futures panikuje, jeÅ›li zostanie ponownie odpytanych po staniu siÄ™ gotowymi. Futures, ktÃ³re sÄ… bezpieczne do ponownego odpytania, bÄ™dÄ… o tym wyraÅºnie informowaÄ‡ w swojej dokumentacji. Jest to podobne do zachowania <code>Iterator::next</code>.</p>
</blockquote>
<p>Kiedy widzisz kod, ktÃ³ry uÅ¼ywa <code>await</code>, Rust kompiluje go pod spodem do kodu, ktÃ³ry wywoÅ‚uje <code>poll</code>. JeÅ›li spojrzysz ponownie na Listing 17-4, gdzie wydrukowaliÅ›my tytuÅ‚ strony dla pojedynczego adresu URL po jego rozwiÄ…zaniu, Rust kompiluje go do czegoÅ› w rodzaju (choÄ‡ nie dokÅ‚adnie) tego:</p>
<pre><code class="language-rust ignore">match page_title(url).poll() {
    Ready(page_title) =&gt; match page_title {
        Some(title) =&gt; println!("The title for {url} was {title}"),
        None =&gt; println!("{url} had no title"),
    }
    Pending =&gt; {
        // But what goes here?
    }
}</code></pre>
<p>Co powinniÅ›my zrobiÄ‡, gdy future jest nadal w stanie <code>Pending</code>? Potrzebujemy jakiegoÅ› sposobu, aby sprÃ³bowaÄ‡ ponownie, i ponownie, i ponownie, aÅ¼ future bÄ™dzie w koÅ„cu gotowe. Innymi sÅ‚owy, potrzebujemy pÄ™tli:</p>
<pre><code class="language-rust ignore">let mut page_title_fut = page_title(url);
loop {
    match page_title_fut.poll() {
        Ready(value) =&gt; match page_title {
            Some(title) =&gt; println!("The title for {url} was {title}"),
            None =&gt; println!("{url} had no title"),
        }
        Pending =&gt; {
            // continue
        }
    }
}</code></pre>
<p>Jednak gdyby Rust skompilowaÅ‚ to dokÅ‚adnie na taki kod, kaÅ¼de <code>await</code> byÅ‚oby blokujÄ…ce â€“ dokÅ‚adnie przeciwnie do tego, co zamierzaliÅ›my! Zamiast tego Rust zapewnia, Å¼e pÄ™tla moÅ¼e przekazaÄ‡ kontrolÄ™ czemuÅ›, co moÅ¼e wstrzymaÄ‡ pracÄ™ nad tym future, aby pracowaÄ‡ nad innymi futures, a nastÄ™pnie sprawdziÄ‡ ten ponownie pÃ³Åºniej. Jak widzieliÅ›my, tym czymÅ› jest Å›rodowisko uruchomieniowe async, a ta praca zwiÄ…zana z planowaniem i koordynacjÄ… jest jednym z jego gÅ‚Ã³wnych zadaÅ„.</p>
<p>W sekcji <a href="#sending-data-between-two-tasks-using-message-passing">â€WysyÅ‚anie danych miÄ™dzy dwoma zadaniami za pomocÄ… przekazywania wiadomoÅ›ciâ€</a><!-- ignore --> opisaliÅ›my oczekiwanie na <code>rx.recv</code>. WywoÅ‚anie <code>recv</code> zwraca future, a oczekiwanie na future odpytuje je. ZauwaÅ¼yliÅ›my, Å¼e Å›rodowisko uruchomieniowe wstrzyma future, dopÃ³ki nie bÄ™dzie ono gotowe z <code>Some(message)</code> lub <code>None</code>, gdy kanaÅ‚ zostanie zamkniÄ™ty. DziÄ™ki naszemu gÅ‚Ä™bszemu zrozumieniu cechy <code>Future</code>, a konkretnie <code>Future::poll</code>, moÅ¼emy zobaczyÄ‡, jak to dziaÅ‚a. Åšrodowisko uruchomieniowe wie, Å¼e future nie jest gotowe, gdy zwraca <code>Poll::Pending</code>. Odwrotnie, Å›rodowisko uruchomieniowe wie, Å¼e future <em>jest</em> gotowe i kontynuuje je, gdy <code>poll</code> zwraca <code>Poll::Ready(Some(message))</code> lub <code>Poll::Ready(None)</code>.</p>
<p>DokÅ‚adne szczegÃ³Å‚y tego, jak Å›rodowisko wykonawcze to robi, wykraczajÄ… poza zakres tej ksiÄ…Å¼ki, ale kluczem jest zrozumienie podstawowych mechanizmÃ³w futures: Å›rodowisko wykonawcze <em>odpytuje</em> kaÅ¼dy future, za ktÃ³ry jest odpowiedzialne, usypiajÄ…c future ponownie, gdy nie jest jeszcze gotowe.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="pinning-and-the-pin-and-unpin-traits"></a>
<a id="the-pin-and-unpin-traits"></a></p>
<h3 id="typ-pin-i-cecha-unpin"><a class="header" href="#typ-pin-i-cecha-unpin">Typ <code>Pin</code> i cecha <code>Unpin</code></a></h3>
<p>W Listing 17-13 uÅ¼yliÅ›my makra <code>trpl::join!</code> do oczekiwania na trzy futures. Jednak czÄ™sto zdarza siÄ™ mieÄ‡ kolekcjÄ™, takÄ… jak wektor, zawierajÄ…cÄ… pewnÄ… liczbÄ™ futures, ktÃ³rej nie bÄ™dzie znana do czasu wykonania. ZmieÅ„my Listing 17-13 na kod z Listing 17-23, ktÃ³ry umieszcza trzy futures w wektorze i wywoÅ‚uje funkcjÄ™ <code>trpl::join_all</code> zamiast tego, co jeszcze siÄ™ nie skompiluje.</p>
<listing number="17-23" caption="Oczekiwanie na futures w kolekcji" file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let tx_fut = async move {
            // --snip--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span>        };

        let futures: Vec&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt; =
            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];

        trpl::join_all(futures).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</listing>
<p>KaÅ¼dy future umieszczamy w <code>Box</code>, aby zamieniÄ‡ je w <em>obiekty cech</em>, tak jak to zrobiliÅ›my w sekcji â€Zwracanie bÅ‚Ä™dÃ³w z <code>run</code>â€ w Rozdziale 12. (Obiekty cech szczegÃ³Å‚owo omÃ³wimy w Rozdziale 18.) UÅ¼ywanie obiektÃ³w cech pozwala nam traktowaÄ‡ kaÅ¼dy z anonimowych futures wyprodukowanych przez te typy jako ten sam typ, poniewaÅ¼ wszystkie one implementujÄ… cechÄ™ <code>Future</code>.</p>
<p>MoÅ¼e to byÄ‡ zaskakujÄ…ce. PrzecieÅ¼ Å¼aden z blokÃ³w async niczego nie zwraca, wiÄ™c kaÅ¼dy z nich produkuje <code>Future&lt;Output = ()&gt;</code>. PamiÄ™taj jednak, Å¼e <code>Future</code> jest cechÄ…, a kompilator tworzy unikalny enum dla kaÅ¼dego bloku async, nawet jeÅ›li majÄ… identyczne typy wyjÅ›ciowe. Tak jak nie moÅ¼esz umieÅ›ciÄ‡ dwÃ³ch rÃ³Å¼nych, rÄ™cznie napisanych struktur w <code>Vec</code>, tak samo nie moÅ¼esz mieszaÄ‡ enumÃ³w generowanych przez kompilator.</p>
<p>NastÄ™pnie przekazujemy kolekcjÄ™ futures do funkcji <code>trpl::join_all</code> i czekamy na wynik. Jednak to siÄ™ nie kompiluje; oto odpowiednia czÄ™Å›Ä‡ komunikatÃ³w o bÅ‚Ä™dach.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-23
cargo build
copy *only* the final `error` block from the errors
-->
<pre><code class="language-text">error[E0277]: `dyn Future&lt;Output = ()&gt;` cannot be unpinned
  --&gt; src/main.rs:48:33
   |
48 |         trpl::join_all(futures).await;
   |                                 ^^^^^ the trait `Unpin` is not implemented for `dyn Future&lt;Output = ()&gt;`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;dyn Future&lt;Output = ()&gt;&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`
</code></pre>
<p>Notatka w komunikacie o bÅ‚Ä™dzie mÃ³wi nam, Å¼e powinniÅ›my uÅ¼yÄ‡ makra <code>pin!</code>, aby <em>przypiÄ…Ä‡</em> wartoÅ›ci, co oznacza umieszczenie ich w typie <code>Pin</code>, ktÃ³ry gwarantuje, Å¼e wartoÅ›ci nie zostanÄ… przeniesione w pamiÄ™ci. Komunikat o bÅ‚Ä™dzie mÃ³wi, Å¼e przypinanie jest wymagane, poniewaÅ¼ <code>dyn Future&lt;Output = ()&gt;</code> musi implementowaÄ‡ cechÄ™ <code>Unpin</code>, a obecnie tego nie robi.</p>
<p>Funkcja <code>trpl::join_all</code> zwraca strukturÄ™ o nazwie <code>JoinAll</code>. Ta struktura jest generyczna na typie <code>F</code>, ktÃ³ry jest ograniczony do implementacji cechy <code>Future</code>. BezpoÅ›rednie oczekiwanie na future za pomocÄ… <code>await</code> niejawnie przypina future. Dlatego nie musimy uÅ¼ywaÄ‡ <code>pin!</code> wszÄ™dzie tam, gdzie chcemy oczekiwaÄ‡ na futures.</p>
<p>Nie oczekujemy tu jednak bezpoÅ›rednio na future. Zamiast tego konstruujemy nowe future, <code>JoinAll</code>, przekazujÄ…c kolekcjÄ™ futures do funkcji <code>join_all</code>. Sygnatura <code>join_all</code> wymaga, aby typy elementÃ³w w kolekcji implementowaÅ‚y cechÄ™ <code>Future</code>, a <code>Box&lt;T&gt;</code> implementuje <code>Future</code> tylko wtedy, gdy opakowywany przez niego <code>T</code> jest futurem, ktÃ³ry implementuje cechÄ™ <code>Unpin</code>.</p>
<p>To duÅ¼o do przyswojenia! Aby to naprawdÄ™ zrozumieÄ‡, zagÅ‚Ä™bmy siÄ™ nieco bardziej w to, jak dziaÅ‚a cecha <code>Future</code>, szczegÃ³lnie w kontekÅ›cie przypinania. SpÃ³jrzmy jeszcze raz na definicjÄ™ cechy <code>Future</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    // Required method
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre>
<p>Parametr <code>cx</code> i jego typ <code>Context</code> sÄ… kluczem do tego, jak Å›rodowisko wykonawcze faktycznie wie, kiedy sprawdziÄ‡ dany future, jednoczeÅ›nie pozostajÄ…c leniwym. Ponownie, szczegÃ³Å‚y tego, jak to dziaÅ‚a, wykraczajÄ… poza zakres tego rozdziaÅ‚u, i zazwyczaj musisz o tym myÅ›leÄ‡ tylko wtedy, gdy piszesz niestandardowÄ… implementacjÄ™ <code>Future</code>. Zamiast tego skupimy siÄ™ na typie <code>self</code>, poniewaÅ¼ jest to pierwszy raz, gdy widzieliÅ›my metodÄ™, w ktÃ³rej <code>self</code> ma adnotacjÄ™ typu. Adnotacja typu dla <code>self</code> dziaÅ‚a jak adnotacje typu dla innych parametrÃ³w funkcji, ale z dwoma kluczowymi rÃ³Å¼nicami:</p>
<ul>
<li>MÃ³wi Rustowi, jakiego typu musi byÄ‡ <code>self</code>, aby metoda mogÅ‚a zostaÄ‡ wywoÅ‚ana.</li>
<li>Nie moÅ¼e to byÄ‡ dowolny typ. Jest ograniczony do typu, na ktÃ³rym metoda jest zaimplementowana, referencji lub inteligentnego wskaÅºnika do tego typu, lub <code>Pin</code> opakowujÄ…cego referencjÄ™ do tego typu.</li>
</ul>
<p>WiÄ™cej na temat tej skÅ‚adni zobaczymy w <a href="#cechy-programowania-zorientowanego-obiektowo">Rozdziale 18</a><!-- ignore -->. Na razie wystarczy wiedzieÄ‡, Å¼e jeÅ›li chcemy odpytaÄ‡ future, aby sprawdziÄ‡, czy jest <code>Pending</code> czy <code>Ready(Output)</code>, potrzebujemy mutowalnej referencji do typu opakowanej w <code>Pin</code>.</p>
<p><code>Pin</code> to opakowanie dla typÃ³w wskaÅºnikopodobnych, takich jak <code>&amp;</code>, <code>&amp;mut</code>, <code>Box</code> i <code>Rc</code>. (Technicznie <code>Pin</code> dziaÅ‚a z typami implementujÄ…cymi cechy <code>Deref</code> lub <code>DerefMut</code>, ale to jest skutecznie rÃ³wnowaÅ¼ne z pracÄ… tylko z referencjami i inteligentnymi wskaÅºnikami.) <code>Pin</code> sam w sobie nie jest wskaÅºnikiem i nie ma Å¼adnego wÅ‚asnego zachowania, jak <code>Rc</code> i <code>Arc</code> zliczajÄ…ce referencje; jest to czysto narzÄ™dzie, ktÃ³rego kompilator moÅ¼e uÅ¼ywaÄ‡ do wymuszania ograniczeÅ„ na uÅ¼ycie wskaÅºnikÃ³w.</p>
<p>PrzypominajÄ…c, Å¼e <code>await</code> jest implementowane w kategoriach wywoÅ‚aÅ„ <code>poll</code>, zaczyna wyjaÅ›niaÄ‡ siÄ™ komunikat o bÅ‚Ä™dzie, ktÃ³ry widzieliÅ›my wczeÅ›niej, ale byÅ‚ on w kategoriach <code>Unpin</code>, a nie <code>Pin</code>. Jak wiÄ™c dokÅ‚adnie <code>Pin</code> odnosi siÄ™ do <code>Unpin</code> i dlaczego <code>Future</code> potrzebuje, aby <code>self</code> byÅ‚o w typie <code>Pin</code>, aby wywoÅ‚aÄ‡ <code>poll</code>?</p>
<p>Przypomnijmy z wczeÅ›niejszej czÄ™Å›ci tego rozdziaÅ‚u, Å¼e seria punktÃ³w oczekiwania w future jest kompilowana w maszynÄ™ stanÃ³w, a kompilator dba o to, aby ta maszyna stanÃ³w przestrzegaÅ‚a wszystkich normalnych zasad Rusta dotyczÄ…cych bezpieczeÅ„stwa, w tym poÅ¼yczania i wÅ‚asnoÅ›ci. Aby to dziaÅ‚aÅ‚o, Rust patrzy na to, jakie dane sÄ… potrzebne miÄ™dzy jednym punktem oczekiwania a nastÄ™pnym punktem oczekiwania lub koÅ„cem bloku async. NastÄ™pnie tworzy odpowiedni wariant w skompilowanej maszynie stanÃ³w. KaÅ¼dy wariant uzyskuje potrzebny dostÄ™p do danych, ktÃ³re bÄ™dÄ… uÅ¼ywane w tej sekcji kodu ÅºrÃ³dÅ‚owego, albo poprzez przejÄ™cie wÅ‚asnoÅ›ci tych danych, albo poprzez uzyskanie mutowalnej lub niemutowalnej referencji do nich.</p>
<p>Jak dotÄ…d, wszystko dobrze: jeÅ›li popeÅ‚nimy bÅ‚Ä…d w kwestii wÅ‚asnoÅ›ci lub referencji w danym bloku async, narzÄ™dzie borrow checker nas o tym poinformuje. Kiedy chcemy przenosiÄ‡ future odpowiadajÄ…ce temu blokowi â€“ na przykÅ‚ad przenoszÄ…c je do <code>Vec</code>, aby przekazaÄ‡ do <code>join_all</code> â€“ sprawy stajÄ… siÄ™ bardziej skomplikowane.</p>
<p>Kiedy przenosimy future â€“ czy to poprzez wÅ‚oÅ¼enie go do struktury danych w celu uÅ¼ycia jako iteratora z <code>join_all</code>, czy zwracajÄ…c je z funkcji â€“ oznacza to faktycznie przeniesienie maszyny stanÃ³w, ktÃ³rÄ… Rust dla nas tworzy. I w przeciwieÅ„stwie do wiÄ™kszoÅ›ci innych typÃ³w w Rust, futures, ktÃ³re Rust tworzy dla blokÃ³w async, mogÄ… mieÄ‡ odwoÅ‚ania do samych siebie w polach dowolnego wariantu, jak pokazano na uproszczonej ilustracji na Rysunku 17-4.</p>
<figure>
<img alt="A single-column, three-row table representing a future, fut1, which has data values 0 and 1 in the first two rows and an arrow pointing from the third row back to the second row, representing an internal reference within the future." src="img/trpl17-04.svg" class="center" />
<figcaption>Rysunek 17-4: Typ danych z referencjami do siebie</figcaption>
</figure>
<p>JednakÅ¼e, domyÅ›lnie kaÅ¼dy obiekt, ktÃ³ry ma do siebie referencjÄ™, jest niebezpieczny do przenoszenia, poniewaÅ¼ referencje zawsze wskazujÄ… na rzeczywisty adres pamiÄ™ci tego, do czego siÄ™ odnoszÄ… (patrz Rysunek 17-5). JeÅ›li przeniesiesz samÄ… strukturÄ™ danych, te wewnÄ™trzne referencje bÄ™dÄ… wskazywaÄ‡ na stare miejsce. Jednak to miejsce w pamiÄ™ci jest teraz nieprawidÅ‚owe. Po pierwsze, jego wartoÅ›Ä‡ nie zostanie zaktualizowana, gdy wprowadzisz zmiany w strukturze danych. Po drugie â€“ co waÅ¼niejsze â€“ komputer moÅ¼e teraz swobodnie ponownie wykorzystaÄ‡ tÄ™ pamiÄ™Ä‡ do innych celÃ³w! PÃ³Åºniej moÅ¼esz odczytaÄ‡ zupeÅ‚nie niepowiÄ…zane dane.</p>
<figure>
<img alt="Two tables, depicting two futures, fut1 and fut2, each of which has one column and three rows, representing the result of having moved a future out of fut1 into fut2. The first, fut1, is grayed out, with a question mark in each index, representing unknown memory. The second, fut2, has 0 and 1 in the first and second rows and an arrow pointing from its third row back to the second row of fut1, representing a pointer that is referencing the old location in memory of the future before it was moved." src="img/trpl17-05.svg" class="center" />
<figcaption>Rysunek 17-5: Niebezpieczny wynik przenoszenia typu danych z referencjami do siebie</figcaption>
</figure>
<p>Teoretycznie, kompilator Rust mÃ³gÅ‚by prÃ³bowaÄ‡ aktualizowaÄ‡ kaÅ¼dÄ… referencjÄ™ do obiektu, gdy jest on przenoszony, ale to mogÅ‚oby dodaÄ‡ wiele narzutu wydajnoÅ›ciowego, zwÅ‚aszcza jeÅ›li caÅ‚a sieÄ‡ referencji wymaga aktualizacji. GdybyÅ›my zamiast tego mogli zapewniÄ‡, Å¼e dana struktura danych <em>nie przesuwa siÄ™ w pamiÄ™ci</em>, nie musielibyÅ›my aktualizowaÄ‡ Å¼adnych referencji. Do tego wÅ‚aÅ›nie sÅ‚uÅ¼y borrow checker Rusta: w bezpiecznym kodzie zapobiega przenoszeniu jakiegokolwiek elementu, do ktÃ³rego istnieje aktywna referencja.</p>
<p><code>Pin</code> opiera siÄ™ na tym, aby zapewniÄ‡ nam dokÅ‚adnie takÄ… gwarancjÄ™, jakiej potrzebujemy. Kiedy <em>przypinamy</em> wartoÅ›Ä‡, opakowujÄ…c wskaÅºnik do tej wartoÅ›ci w <code>Pin</code>, nie moÅ¼e siÄ™ ona juÅ¼ przesuwaÄ‡. Zatem, jeÅ›li masz <code>Pin&lt;Box&lt;SomeType&gt;&gt;</code>, faktycznie przypinasz wartoÅ›Ä‡ <code>SomeType</code>, <em>nie</em> wskaÅºnik <code>Box</code>. Rysunek 17-6 ilustruje ten proces.</p>
<figure>
<img alt="Three boxes laid out side by side. The first is labeled â€œPinâ€, the second â€œb1â€, and the third â€œpinnedâ€. Within â€œpinnedâ€ is a table labeled â€œfutâ€, with a single column; it represents a future with cells for each part of the data structure. Its first cell has the value â€œ0â€, its second cell has an arrow coming out of it and pointing to the fourth and final cell, which has the value â€œ1â€ in it, and the third cell has dashed lines and an ellipsis to indicate there may be other parts to the data structure. All together, the â€œfutâ€ table represents a future which is self-referential. An arrow leaves the box labeled â€œPinâ€, goes through the box labeled â€œb1â€ and terminates inside the â€œpinnedâ€ box at the â€œfutâ€ table." src="img/trpl17-06.svg" class="center" />
<figcaption>Rysunek 17-6: Przypinanie `Box`, ktÃ³ry wskazuje na samoodwoÅ‚ujÄ…cy siÄ™ typ future</figcaption>
</figure>
<p>W rzeczywistoÅ›ci wskaÅºnik <code>Box</code> moÅ¼e nadal swobodnie siÄ™ przemieszczaÄ‡. PamiÄ™taj: zaleÅ¼y nam na tym, aby dane, do ktÃ³rych ostatecznie siÄ™ odwoÅ‚ujemy, pozostaÅ‚y na miejscu. JeÅ›li wskaÅºnik siÄ™ przemieszcza, <em>ale dane, na ktÃ³re wskazuje</em>, znajdujÄ… siÄ™ w tym samym miejscu, jak na Rysunku 17-7, nie ma potencjalnego problemu. (Jako niezaleÅ¼ne Ä‡wiczenie, spÃ³jrz na dokumentacjÄ™ typÃ³w oraz moduÅ‚u <code>std::pin</code> i sprÃ³buj ustaliÄ‡, jak byÅ› to zrobiÅ‚ z <code>Pin</code> opakowujÄ…cym <code>Box</code>.) Kluczem jest to, Å¼e samoodwoÅ‚ujÄ…cy siÄ™ typ sam w sobie nie moÅ¼e siÄ™ przemieszczaÄ‡, poniewaÅ¼ jest nadal przypiÄ™ty.</p>
<figure>
<img alt="Four boxes laid out in three rough columns, identical to the previous diagram with a change to the second column. Now there are two boxes in the second column, labeled â€œb1â€ and â€œb2â€, â€œb1â€ is grayed out, and the arrow from â€œPinâ€ goes through â€œb2â€ instead of â€œb1â€, indicating that the pointer has moved from â€œb1â€ to â€œb2â€, but the data in â€œpinnedâ€ has not moved." src="img/trpl17-07.svg" class="center" />
<figcaption>Rysunek 17-7: Przenoszenie `Box`, ktÃ³ry wskazuje na samoodwoÅ‚ujÄ…cy siÄ™ typ future</figcaption>
</figure>
<p>Jednak wiÄ™kszoÅ›Ä‡ typÃ³w jest caÅ‚kowicie bezpieczna do przenoszenia, nawet jeÅ›li znajdujÄ… siÄ™ za wskaÅºnikiem <code>Pin</code>. Musimy myÅ›leÄ‡ o przypinaniu tylko wtedy, gdy elementy majÄ… wewnÄ™trzne referencje. Prymitywne wartoÅ›ci, takie jak liczby i wartoÅ›ci logiczne, sÄ… bezpieczne, poniewaÅ¼ oczywiÅ›cie nie majÄ… Å¼adnych wewnÄ™trznych referencji.
Podobnie jak wiÄ™kszoÅ›Ä‡ typÃ³w, z ktÃ³rymi normalnie pracujesz w Rust. MoÅ¼esz przenosiÄ‡ <code>Vec</code>, na przykÅ‚ad, bez obaw. BiorÄ…c pod uwagÄ™ to, co widzieliÅ›my do tej pory, jeÅ›li masz <code>Pin&lt;Vec&lt;String&gt;&gt;</code>, musiaÅ‚byÅ› robiÄ‡ wszystko za pomocÄ… bezpiecznych, ale restrykcyjnych API dostarczonych przez <code>Pin</code>, mimo Å¼e <code>Vec&lt;String&gt;</code> jest zawsze bezpieczny do przenoszenia, jeÅ›li nie ma do niego innych referencji. Potrzebujemy sposobu, aby powiedzieÄ‡ kompilatorowi, Å¼e w takich przypadkach moÅ¼na przenosiÄ‡ elementy â€“ i tu wÅ‚aÅ›nie wchodzi <code>Unpin</code>.</p>
<p><code>Unpin</code> to cecha znacznikowa, podobna do cech <code>Send</code> i <code>Sync</code>, ktÃ³re widzieliÅ›my w Rozdziale 16, i dlatego nie ma wÅ‚asnej funkcjonalnoÅ›ci. Cechy znacznikowe istniejÄ… tylko po to, aby poinformowaÄ‡ kompilator, Å¼e bezpieczne jest uÅ¼ycie typu implementujÄ…cego danÄ… cechÄ™ w okreÅ›lonym kontekÅ›cie. <code>Unpin</code> informuje kompilator, Å¼e dany typ <em>nie</em> musi przestrzegaÄ‡ Å¼adnych gwarancji dotyczÄ…cych tego, czy dana wartoÅ›Ä‡ moÅ¼e byÄ‡ bezpiecznie przeniesiona.</p>
<!--
  The inline `<code>` in the next block is to allow the inline `<em>` inside it,
  matching what NoStarch does style-wise, and emphasizing within the text here
  that it is something distinct from a normal type.
-->
<p>Podobnie jak w przypadku <code>Send</code> i <code>Sync</code>, kompilator automatycznie implementuje <code>Unpin</code> dla wszystkich typÃ³w, dla ktÃ³rych moÅ¼e to udowodniÄ‡, Å¼e jest bezpieczne. SzczegÃ³lnym przypadkiem, ponownie podobnym do <code>Send</code> i <code>Sync</code>, jest sytuacja, gdy <code>Unpin</code> <em>nie</em> jest implementowany dla typu. Oznaczenie dla tego to <code>impl !Unpin for <em>SomeType</em></code>, gdzie <code><em>SomeType</em></code> to nazwa typu, ktÃ³ry <em>musi</em> przestrzegaÄ‡ tych gwarancji, aby byÄ‡ bezpiecznym za kaÅ¼dym razem, gdy wskaÅºnik do tego typu jest uÅ¼ywany w <code>Pin</code>.</p>
<p>Innymi sÅ‚owy, istniejÄ… dwie rzeczy, o ktÃ³rych naleÅ¼y pamiÄ™taÄ‡ w zwiÄ…zku z relacjÄ… miÄ™dzy <code>Pin</code> a <code>Unpin</code>. Po pierwsze, <code>Unpin</code> jest przypadkiem â€normalnymâ€, a <code>!Unpin</code> jest przypadkiem specjalnym. Po drugie, to, czy typ implementuje <code>Unpin</code> czy <code>!Unpin</code>, ma znaczenie <em>tylko</em> wtedy, gdy uÅ¼ywasz przypiÄ™tego wskaÅºnika do tego typu, takiego jak <code>Pin&lt;&amp;mut <em>SomeType</em>&gt;</code>.</p>
<p>Aby to uÅ›ciÅ›liÄ‡, pomyÅ›l o <code>String</code>: ma dÅ‚ugoÅ›Ä‡ i znaki Unicode, ktÃ³re jÄ… tworzÄ…. MoÅ¼emy opakowaÄ‡ <code>String</code> w <code>Pin</code>, jak widaÄ‡ na Rysunku 17-8. Jednak <code>String</code> automatycznie implementuje <code>Unpin</code>, podobnie jak wiÄ™kszoÅ›Ä‡ innych typÃ³w w Rust.</p>
<figure>
<img alt="A box labeled â€œPinâ€ on the left with an arrow going from it to a box labeled â€œStringâ€ on the right. The â€œStringâ€ box contains the data 5usize, representing the length of the string, and the letters â€œhâ€, â€œeâ€, â€œlâ€, â€œlâ€, and â€œoâ€ representing the characters of the string â€œhelloâ€ stored in this String instance. A dotted rectangle surrounds the â€œStringâ€ box and its label, but not the â€œPinâ€ box." src="img/trpl17-08.svg" class="center" />
<figcaption>Rysunek 17-8: Przypinanie `String`; przerywana linia wskazuje, Å¼e `String` implementuje cechÄ™ `Unpin` i dlatego nie jest przypiÄ™ty</figcaption>
</figure>
<p>W rezultacie moÅ¼emy robiÄ‡ rzeczy, ktÃ³re byÅ‚yby nielegalne, gdyby <code>String</code> implementowaÅ‚ zamiast tego <code>!Unpin</code>, takie jak zastÄ™powanie jednego ciÄ…gu znakÃ³w innym w dokÅ‚adnie tym samym miejscu w pamiÄ™ci, jak na Rysunku 17-9. Nie narusza to kontraktu <code>Pin</code>, poniewaÅ¼ <code>String</code> nie ma wewnÄ™trznych odwoÅ‚aÅ„, ktÃ³re czyniÅ‚yby jego przenoszenie niebezpiecznym. WÅ‚aÅ›nie dlatego implementuje <code>Unpin</code>, a nie <code>!Unpin</code>.</p>
<figure>
<img alt="The same â€œhelloâ€ string data from the previous example, now labeled â€œs1â€ and grayed out. The â€œPinâ€ box from the previous example now points to a different String instance, one that is labeled â€œs2â€, is valid, has a length of 7usize, and contains the characters of the string â€œgoodbyeâ€. s2 is surrounded by a dotted rectangle because it, too, implements the Unpin trait." src="img/trpl17-09.svg" class="center" />
<figcaption>Rysunek 17-9: ZastÄ™powanie `String` zupeÅ‚nie innym `String` w pamiÄ™ci</figcaption>
</figure>
<p>Teraz wiemy wystarczajÄ…co duÅ¼o, aby zrozumieÄ‡ bÅ‚Ä™dy zgÅ‚oszone dla wywoÅ‚ania <code>join_all</code> z Listing 17-23. Pierwotnie prÃ³bowaliÅ›my przenieÅ›Ä‡ futures wyprodukowane przez bloki async do <code>Vec&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;</code>, ale jak widzieliÅ›my, te futures mogÄ… mieÄ‡ wewnÄ™trzne referencje, wiÄ™c nie implementujÄ… automatycznie <code>Unpin</code>. Po ich przypiÄ™ciu moÅ¼emy przekazaÄ‡ wynikowy typ <code>Pin</code> do <code>Vec</code>, ufajÄ…c, Å¼e bazowe dane w futures <em>nie</em> zostanÄ… przeniesione. Listing 17-24 pokazuje, jak naprawiÄ‡ kod, wywoÅ‚ujÄ…c makro <code>pin!</code> tam, gdzie zdefiniowane sÄ… wszystkie trzy futures, i dostosowujÄ…c typ obiektu cechy.</p>
<listing number="17-24" caption="Przypinanie futures, aby umoÅ¼liwiÄ‡ ich przenoszenie do wektora">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use std::pin::{Pin, pin};

// --snip--

<span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span>        let tx1_fut = pin!(async move {
            // --snip--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span>        });

        let rx_fut = pin!(async {
            // --snip--
<span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span>        });

        let tx_fut = pin!(async move {
            // --snip--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span>        });

        let futures: Vec&lt;Pin&lt;&amp;mut dyn Future&lt;Output = ()&gt;&gt;&gt; =
            vec![tx1_fut, rx_fut, tx_fut];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre>
</listing>
<p>Ten przykÅ‚ad kompiluje siÄ™ i dziaÅ‚a, a my moglibyÅ›my dodawaÄ‡ lub usuwaÄ‡ futures z wektora w czasie wykonania i Å‚Ä…czyÄ‡ je wszystkie.</p>
<p><code>Pin</code> i <code>Unpin</code> sÄ… gÅ‚Ã³wnie waÅ¼ne przy tworzeniu bibliotek niÅ¼szego poziomu lub gdy budujesz samo Å›rodowisko wykonawcze, a nie w codziennym kodzie Rust. Kiedy jednak zobaczysz te cechy w komunikatach o bÅ‚Ä™dach, bÄ™dziesz miaÅ‚ lepszy pomysÅ‚, jak naprawiÄ‡ swÃ³j kod!</p>
<blockquote>
<p>Uwaga: To poÅ‚Ä…czenie <code>Pin</code> i <code>Unpin</code> umoÅ¼liwia bezpiecznÄ… implementacjÄ™ caÅ‚ej klasy zÅ‚oÅ¼onych typÃ³w w Rust, ktÃ³re w przeciwnym razie okazaÅ‚yby siÄ™ trudne, poniewaÅ¼ sÄ… samoreferencyjne. Typy wymagajÄ…ce <code>Pin</code> pojawiajÄ… siÄ™ najczÄ™Å›ciej w dzisiejszym asynchronicznym Rust, ale co jakiÅ› czas moÅ¼esz je rÃ³wnieÅ¼ zobaczyÄ‡ w innych kontekstach.</p>
<p>SzczegÃ³Å‚y dotyczÄ…ce dziaÅ‚ania <code>Pin</code> i <code>Unpin</code> oraz zasad, ktÃ³rych muszÄ… przestrzegaÄ‡, sÄ… szczegÃ³Å‚owo omÃ³wione w dokumentacji API dla <code>std::pin</code>, wiÄ™c jeÅ›li jesteÅ› zainteresowany pogÅ‚Ä™bianiem wiedzy, to Å›wietne miejsce, aby zaczÄ…Ä‡.</p>
<p>JeÅ›li chcesz zrozumieÄ‡, jak wszystko dziaÅ‚a pod maskÄ… jeszcze bardziej szczegÃ³Å‚owo, zobacz RozdziaÅ‚y <a href="https://rust-lang.github.io/async-book/02_execution/01_chapter.html">2</a><!-- ignore --> i <a href="https://rust-lang.github.io/async-book/04_pinning/01_chapter.html">4</a><!-- ignore --> z ksiÄ…Å¼ki <em>Asynchronous Programming in Rust</em> <a href="https://rust-lang.github.io/async-book/">async-book</a>.</p>
</blockquote>
<h3 id="cecha-stream"><a class="header" href="#cecha-stream">Cecha <code>Stream</code></a></h3>
<p>Teraz, gdy masz gÅ‚Ä™bsze zrozumienie cech <code>Future</code>, <code>Pin</code> i <code>Unpin</code>, moÅ¼emy zwrÃ³ciÄ‡ uwagÄ™ na cechÄ™ <code>Stream</code>. Jak dowiedziaÅ‚eÅ› siÄ™ wczeÅ›niej w rozdziale, strumienie sÄ… podobne do asynchronicznych iteratorÃ³w. Jednak w przeciwieÅ„stwie do <code>Iterator</code> i <code>Future</code>, <code>Stream</code> nie ma definicji w standardowej bibliotece w momencie pisania tego tekstu, ale <em>istnieje</em> bardzo powszechna definicja z kraty <code>futures</code> uÅ¼ywana w caÅ‚ym ekosystemie.</p>
<p>Przyjrzyjmy siÄ™ definicjom cech <code>Iterator</code> i <code>Future</code>, zanim zastanowimy siÄ™, jak cecha <code>Stream</code> mogÅ‚aby je poÅ‚Ä…czyÄ‡. Z <code>Iterator</code> mamy ideÄ™ sekwencji: jego metoda <code>next</code> dostarcza <code>Option&lt;Self::Item&gt;</code>. Z <code>Future</code> mamy ideÄ™ gotowoÅ›ci w czasie: jego metoda <code>poll</code> dostarcza <code>Poll&lt;Self::Output&gt;</code>. Aby reprezentowaÄ‡ sekwencjÄ™ elementÃ³w, ktÃ³re stajÄ… siÄ™ gotowe w czasie, definiujemy cechÄ™ <code>Stream</code>, ktÃ³ra Å‚Ä…czy te funkcje:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

trait Stream {
    type Item;

    fn poll_next(
        self: Pin&lt;&amp;mut Self&gt;,
        cx: &amp;mut Context&lt;'_&gt;
    ) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
}
<span class="boring">}</span></code></pre>
<p>Cecha <code>Stream</code> definiuje typ skojarzony o nazwie <code>Item</code> dla typu elementÃ³w wytwarzanych przez strumieÅ„. Jest to podobne do <code>Iterator</code>, gdzie moÅ¼e byÄ‡ zero lub wiele elementÃ³w, i w przeciwieÅ„stwie do <code>Future</code>, gdzie zawsze jest pojedynczy <code>Output</code>, nawet jeÅ›li jest to typ jednostkowy <code>()</code>.</p>
<p><code>Stream</code> definiuje rÃ³wnieÅ¼ metodÄ™ do pobierania tych elementÃ³w. Nazywamy jÄ… <code>poll_next</code>, aby jasno pokazaÄ‡, Å¼e odpytuje w ten sam sposÃ³b, co <code>Future::poll</code>, i wytwarza sekwencjÄ™ elementÃ³w w ten sam sposÃ³b, co <code>Iterator::next</code>. Jej typ zwracany Å‚Ä…czy <code>Poll</code> z <code>Option</code>. Typ zewnÄ™trzny to <code>Poll</code>, poniewaÅ¼ musi byÄ‡ sprawdzany pod kÄ…tem gotowoÅ›ci, tak jak future. Typ wewnÄ™trzny to <code>Option</code>, poniewaÅ¼ musi sygnalizowaÄ‡, czy sÄ… wiÄ™cej wiadomoÅ›ci, tak jak iterator.</p>
<p>CoÅ› bardzo podobnego do tej definicji prawdopodobnie znajdzie siÄ™ w standardowej bibliotece Rusta. W miÄ™dzyczasie jest to czÄ™Å›Ä‡ zestawu narzÄ™dzi wiÄ™kszoÅ›ci Å›rodowisk wykonawczych, wiÄ™c moÅ¼esz na tym polegaÄ‡, a wszystko, co omÃ³wimy dalej, powinno generalnie obowiÄ…zywaÄ‡!</p>
<p>W przykÅ‚adach, ktÃ³re widzieliÅ›my w sekcji <a href="#strumienie-futures-w-sekwencji-1">â€Strumienie: Futures w sekwencjiâ€</a><!-- ignore -->, nie uÅ¼yliÅ›my jednak <code>poll_next</code> <em>ani</em> <code>Stream</code>, lecz <code>next</code> i <code>StreamExt</code>. OczywiÅ›cie <em>mogliÅ›my</em> pracowaÄ‡ bezpoÅ›rednio w kategoriach API <code>poll_next</code>, rÄ™cznie piszÄ…c wÅ‚asne maszyny stanÃ³w <code>Stream</code>, tak samo jak <em>mogliÅ›my</em> pracowaÄ‡ z futures bezpoÅ›rednio za poÅ›rednictwem ich metody <code>poll</code>. UÅ¼ycie <code>await</code> jest jednak znacznie przyjemniejsze, a cecha <code>StreamExt</code> dostarcza metodÄ™ <code>next</code>, dziÄ™ki czemu moÅ¼emy to zrobiÄ‡:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::pin::Pin;
</span><span class="boring">use std::task::{Context, Poll};
</span><span class="boring">
</span><span class="boring">trait Stream {
</span><span class="boring">    type Item;
</span><span class="boring">    fn poll_next(
</span><span class="boring">        self: Pin&lt;&amp;mut Self&gt;,
</span><span class="boring">        cx: &amp;mut Context&lt;'_&gt;,
</span><span class="boring">    ) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>trait StreamExt: Stream {
    async fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;
    where
        Self: Unpin;

    // other methods...
}
<span class="boring">}</span></code></pre>
<!--
TODO: update this if/when tokio/etc. update their MSRV and switch to using async functions
in traits, since the lack thereof is the reason they do not yet have this.
-->
<blockquote>
<p>Uwaga: Rzeczywista definicja, ktÃ³rej uÅ¼yliÅ›my wczeÅ›niej w rozdziale, wyglÄ…da nieco inaczej, poniewaÅ¼ obsÅ‚uguje wersje Rust, ktÃ³re nie obsÅ‚ugiwaÅ‚y jeszcze uÅ¼ywania funkcji async w cechach. W rezultacie wyglÄ…da to tak:</p>
<pre><code class="language-rust ignore">fn next(&amp;mut self) -&gt; Next&lt;'_, Self&gt; where Self: Unpin;</code></pre>
<p>Ten typ <code>Next</code> to <code>struct</code>, ktÃ³ra implementuje <code>Future</code> i pozwala nam nazwaÄ‡ czas Å¼ycia referencji do <code>self</code> za pomocÄ… <code>Next&lt;'_, Self&gt;</code>, tak aby <code>await</code> mÃ³gÅ‚ dziaÅ‚aÄ‡ z tÄ… metodÄ….</p>
</blockquote>
<p>Cecha <code>StreamExt</code> jest rÃ³wnieÅ¼ miejscem, gdzie znajdujÄ… siÄ™ wszystkie interesujÄ…ce metody dostÄ™pne do uÅ¼ytku ze strumieniami. <code>StreamExt</code> jest automatycznie implementowana dla kaÅ¼dego typu, ktÃ³ry implementuje <code>Stream</code>, ale te cechy sÄ… definiowane oddzielnie, aby umoÅ¼liwiÄ‡ spoÅ‚ecznoÅ›ci iterowanie po wygodnych API bez wpÅ‚ywu na podstawowÄ… cechÄ™.</p>
<p>W wersji <code>StreamExt</code> uÅ¼ytej w skrzynce <code>trpl</code> cecha ta nie tylko definiuje metodÄ™ <code>next</code>, ale takÅ¼e dostarcza domyÅ›lnÄ… implementacjÄ™ <code>next</code>, ktÃ³ra poprawnie obsÅ‚uguje szczegÃ³Å‚y wywoÅ‚ywania <code>Stream::poll_next</code>. Oznacza to, Å¼e nawet gdy musisz napisaÄ‡ wÅ‚asny typ danych strumieniowych, <em>tylko</em> musisz zaimplementowaÄ‡ <code>Stream</code>, a nastÄ™pnie kaÅ¼dy, kto uÅ¼ywa twojego typu danych, moÅ¼e automatycznie uÅ¼ywaÄ‡ <code>StreamExt</code> i jego metod.</p>
<p>To wszystko, co omÃ³wimy w kwestii niskopoziomowych szczegÃ³Å‚Ã³w tych cech. Na zakoÅ„czenie zastanÃ³wmy siÄ™, jak futures (w tym strumienie), zadania i wÄ…tki pasujÄ… do siebie!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="futures-zadania-i-wÄ…tki"><a href="#futures-zadania-i-wÄ…tki" class="header">Futures, Zadania i WÄ…tki</a></h1>
<h2 id="Å‚Ä…czenie-wszystkiego-w-caÅ‚oÅ›Ä‡-futures-zadania-i-wÄ…tki"><a class="header" href="#Å‚Ä…czenie-wszystkiego-w-caÅ‚oÅ›Ä‡-futures-zadania-i-wÄ…tki">ÅÄ…czenie wszystkiego w caÅ‚oÅ›Ä‡: Futures, Zadania i WÄ…tki</a></h2>
<p>Jak widzieliÅ›my w <a href="http://localhost:3000/ch16-00-concurrency.html">Rozdziale 16</a><!-- ignore -->, wÄ…tki stanowiÄ… jedno z podejÅ›Ä‡ do wspÃ³Å‚bieÅ¼noÅ›ci. W tym rozdziale poznaliÅ›my inne podejÅ›cie: uÅ¼ywanie async z futures i strumieniami. JeÅ›li zastanawiasz siÄ™, kiedy wybraÄ‡ jednÄ… metodÄ™ zamiast drugiej, odpowiedÅº brzmi: to zaleÅ¼y! I w wielu przypadkach wyborem nie sÄ… wÄ…tki <em>lub</em> async, ale raczej wÄ…tki <em>i</em> async.</p>
<p>Wiele systemÃ³w operacyjnych od dziesiÄ™cioleci dostarczaÅ‚o modele wspÃ³Å‚bieÅ¼noÅ›ci oparte na wÄ…tkach, a wiele jÄ™zykÃ³w programowania je obsÅ‚uguje. Jednak te modele majÄ… swoje kompromisy. Na wielu systemach operacyjnych zuÅ¼ywajÄ… sporo pamiÄ™ci na kaÅ¼dy wÄ…tek. WÄ…tki sÄ… rÃ³wnieÅ¼ opcjÄ… tylko wtedy, gdy system operacyjny i sprzÄ™t je obsÅ‚ugujÄ…. W przeciwieÅ„stwie do popularnych komputerÃ³w stacjonarnych i mobilnych, niektÃ³re systemy wbudowane w ogÃ³le nie majÄ… systemu operacyjnego, wiÄ™c nie majÄ… teÅ¼ wÄ…tkÃ³w.</p>
<p>Model async zapewnia inny â€“ i ostatecznie uzupeÅ‚niajÄ…cy â€“ zestaw kompromisÃ³w. W modelu async operacje wspÃ³Å‚bieÅ¼ne nie wymagajÄ… wÅ‚asnych wÄ…tkÃ³w. Zamiast tego mogÄ… dziaÅ‚aÄ‡ na zadaniach, tak jak uÅ¼ywaliÅ›my <code>trpl::spawn_task</code> do uruchomienia pracy z funkcji synchronicznej w sekcji strumieni. Zadanie jest podobne do wÄ…tku, ale zamiast byÄ‡ zarzÄ…dzanym przez system operacyjny, jest zarzÄ…dzane przez kod na poziomie biblioteki: Å›rodowisko uruchomieniowe.</p>
<p>Istnieje powÃ³d, dla ktÃ³rego API do uruchamiania wÄ…tkÃ³w i uruchamiania zadaÅ„ sÄ… tak podobne. WÄ…tki dziaÅ‚ajÄ… jako granica dla zestawÃ³w operacji synchronicznych; wspÃ³Å‚bieÅ¼noÅ›Ä‡ jest moÅ¼liwa <em>miÄ™dzy</em> wÄ…tkami. Zadania dziaÅ‚ajÄ… jako granica dla zestawÃ³w operacji <em>asynchronicznych</em>; wspÃ³Å‚bieÅ¼noÅ›Ä‡ jest moÅ¼liwa zarÃ³wno <em>miÄ™dzy</em>, jak i <em>wewnÄ…trz</em> zadaÅ„, poniewaÅ¼ zadanie moÅ¼e przeÅ‚Ä…czaÄ‡ siÄ™ miÄ™dzy futures w swoim ciele. Wreszcie, futures sÄ… najbardziej szczegÃ³Å‚owÄ… jednostkÄ… wspÃ³Å‚bieÅ¼noÅ›ci w Rust, a kaÅ¼da future moÅ¼e reprezentowaÄ‡ drzewo innych futures. Åšrodowisko uruchomieniowe â€“ a konkretnie jego egzekutor â€“ zarzÄ…dza zadaniami, a zadania zarzÄ…dzajÄ… futures. W tym wzglÄ™dzie zadania sÄ… podobne do lekkich, zarzÄ…dzanych przez Å›rodowisko uruchomieniowe wÄ…tkÃ³w z dodatkowymi moÅ¼liwoÅ›ciami wynikajÄ…cymi z bycia zarzÄ…dzanym przez Å›rodowisko uruchomieniowe, a nie przez system operacyjny.</p>
<p>Nie oznacza to, Å¼e zadania async sÄ… zawsze lepsze od wÄ…tkÃ³w (lub odwrotnie). WspÃ³Å‚bieÅ¼noÅ›Ä‡ z wÄ…tkami jest pod pewnymi wzglÄ™dami prostszym modelem programowania niÅ¼ wspÃ³Å‚bieÅ¼noÅ›Ä‡ z <code>async</code>. MoÅ¼e to byÄ‡ siÅ‚a lub sÅ‚aboÅ›Ä‡. WÄ…tki sÄ… nieco w stylu â€odpal i zapomnijâ€; nie majÄ… natywnego odpowiednika dla future, wiÄ™c po prostu dziaÅ‚ajÄ… do koÅ„ca, bez przerywania, chyba Å¼e przez sam system operacyjny.</p>
<p>Okazuje siÄ™, Å¼e wÄ…tki i zadania czÄ™sto bardzo dobrze wspÃ³Å‚pracujÄ…, poniewaÅ¼ zadania mogÄ… (przynajmniej w niektÃ³rych Å›rodowiskach uruchomieniowych) byÄ‡ przenoszone miÄ™dzy wÄ…tkami. W rzeczywistoÅ›ci, pod maskÄ…, Å›rodowisko uruchomieniowe, ktÃ³rego uÅ¼ywaliÅ›my â€“ w tym funkcje <code>spawn_blocking</code> i <code>spawn_task</code> â€“ jest domyÅ›lnie wielowÄ…tkowe! Wiele Å›rodowisk uruchomieniowych stosuje podejÅ›cie zwane <em>work stealing</em> (kradzieÅ¼Ä… pracy) do transparentnego przenoszenia zadaÅ„ miÄ™dzy wÄ…tkami, w oparciu o bieÅ¼Ä…ce wykorzystanie wÄ…tkÃ³w, aby poprawiÄ‡ ogÃ³lnÄ… wydajnoÅ›Ä‡ systemu. To podejÅ›cie faktycznie wymaga <em>wÄ…tkÃ³w</em> i <em>zadaÅ„</em>, a zatem i futures.</p>
<p>ZastanawiajÄ…c siÄ™, ktÃ³rÄ… metodÄ™ zastosowaÄ‡, rozwaÅ¼ te zasady:</p>
<ul>
<li>JeÅ›li praca jest <em>bardzo rÃ³wnolegÅ‚a</em> (czyli CPU-bound), taka jak przetwarzanie duÅ¼ej iloÅ›ci danych, gdzie kaÅ¼da czÄ™Å›Ä‡ moÅ¼e byÄ‡ przetwarzana oddzielnie, wÄ…tki sÄ… lepszym wyborem.</li>
<li>JeÅ›li praca jest <em>bardzo wspÃ³Å‚bieÅ¼na</em> (czyli I/O-bound), taka jak obsÅ‚uga wiadomoÅ›ci z wielu rÃ³Å¼nych ÅºrÃ³deÅ‚, ktÃ³re mogÄ… przychodziÄ‡ w rÃ³Å¼nych odstÄ™pach czasu lub z rÃ³Å¼nymi prÄ™dkoÅ›ciami, async jest lepszym wyborem.</li>
</ul>
<p>AJeÅ›li potrzebujesz zarÃ³wno rÃ³wnolegÅ‚oÅ›ci, jak i wspÃ³Å‚bieÅ¼noÅ›ci, nie musisz wybieraÄ‡ miÄ™dzy wÄ…tkami a async. MoÅ¼esz ich swobodnie uÅ¼ywaÄ‡ razem, pozwalajÄ…c kaÅ¼demu odgrywaÄ‡ rolÄ™, w ktÃ³rej jest najlepszy. Na przykÅ‚ad, Lista 17-25 pokazuje doÅ›Ä‡ powszechny przykÅ‚ad tego rodzaju poÅ‚Ä…czenia w rzeczywistym kodzie Rust.</p>
<figure class="listing" id="listing-17-25">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // for mdbook test
</span><span class="boring">
</span>use std::{thread, time::Duration};

fn main() {
    let (tx, mut rx) = trpl::channel();

    thread::spawn(move || {
        for i in 1..11 {
            tx.send(i).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    trpl::block_on(async {
        while let Some(message) = rx.recv().await {
            println!("{message}");
        }
    });
}</code></pre>
<figcaption><a href="#listing-17-25">Lista 17-25</a>: WysyÅ‚anie wiadomoÅ›ci z blokujÄ…cym kodem w wÄ…tku i oczekiwanie na wiadomoÅ›ci w bloku async</figcaption>
</figure>
<p>Zaczynamy od utworzenia kanaÅ‚u async, a nastÄ™pnie uruchamiamy wÄ…tek, ktÃ³ry przejmuje wÅ‚asnoÅ›Ä‡ strony nadawcy kanaÅ‚u za pomocÄ… sÅ‚owa kluczowego <code>move</code>. W wÄ…tku wysyÅ‚amy liczby od 1 do 10, usypiajÄ…c na sekundÄ™ miÄ™dzy kaÅ¼dÄ… z nich. Na koniec uruchamiamy future utworzonÄ… za pomocÄ… bloku async przekazanego do <code>trpl::block_on</code>, tak jak robiliÅ›my to w caÅ‚ym rozdziale. W tej future oczekujemy na te wiadomoÅ›ci, tak jak w innych przykÅ‚adach przekazywania wiadomoÅ›ci, ktÃ³re widzieliÅ›my.</p>
<p>PowracajÄ…c do scenariusza, od ktÃ³rego zaczÄ™liÅ›my rozdziaÅ‚, wyobraÅº sobie uruchamianie zestawu zadaÅ„ kodowania wideo przy uÅ¼yciu dedykowanego wÄ…tku (poniewaÅ¼ kodowanie wideo jest obciÄ…Å¼ajÄ…ce dla procesora), ale powiadamianie interfejsu uÅ¼ytkownika o zakoÅ„czeniu tych operacji za pomocÄ… kanaÅ‚u async. IstniejÄ… niezliczone przykÅ‚ady tego rodzaju kombinacji w rzeczywistych przypadkach uÅ¼ycia.</p>
<h2 id="podsumowanie-16"><a class="header" href="#podsumowanie-16">Podsumowanie</a></h2>
<p>To nie ostatni raz, kiedy spotkasz siÄ™ ze wspÃ³Å‚bieÅ¼noÅ›ciÄ… w tej ksiÄ…Å¼ce. Projekt w <a href="#projekt-koÅ„cowy-budowanie-wielowÄ…tkowego-serwera-www">Rozdziale 21</a><!-- ignore --> zastosuje te koncepcje w bardziej realistycznej sytuacji niÅ¼ prostsze przykÅ‚ady omÃ³wione tutaj i porÃ³wna bezpoÅ›rednio rozwiÄ…zywanie problemÃ³w za pomocÄ… wÄ…tkÃ³w kontra zadaÅ„ i futures.</p>
<p>NiezaleÅ¼nie od tego, ktÃ³re z tych podejÅ›Ä‡ wybierzesz, Rust daje ci narzÄ™dzia potrzebne do pisania bezpiecznego, szybkiego, wspÃ³Å‚bieÅ¼nego kodu â€“ czy to dla serwera WWW o wysokiej przepustowoÅ›ci, czy dla wbudowanego systemu operacyjnego.</p>
<p>NastÄ™pnie omÃ³wimy idiomatyczne sposoby modelowania problemÃ³w i strukturyzowania rozwiÄ…zaÅ„ w miarÄ™ wzrostu programÃ³w Rust. Ponadto omÃ³wimy, jak idiomy Rust odnoszÄ… siÄ™ do tych, ktÃ³re moÅ¼esz znaÄ‡ z programowania zorientowanego obiektowo.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cechy-programowania-zorientowanego-obiektowo"><a class="header" href="#cechy-programowania-zorientowanego-obiektowo">Cechy Programowania Zorientowanego Obiektowo</a></h1>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="object-oriented-programming-features-of-rust"></a></p>
<p>Programowanie zorientowane obiektowo (OOP) to sposÃ³b modelowania programÃ³w. Obiekty jako koncepcja programistyczna zostaÅ‚y wprowadzone w jÄ™zyku programowania Simula w latach 60. Te obiekty wpÅ‚ynÄ™Å‚y na architekturÄ™ programistycznÄ… Alana Kaya, w ktÃ³rej obiekty przekazujÄ… sobie wiadomoÅ›ci. Aby opisaÄ‡ tÄ™ architekturÄ™, ukuÅ‚ on termin <em>programowanie zorientowane obiektowo</em> w 1967 roku. Wiele konkurujÄ…cych definicji opisuje, czym jest OOP, i wedÅ‚ug niektÃ³rych z tych definicji Rust jest obiektowy, ale wedÅ‚ug innych nie jest. W tym rozdziale zbadamy pewne cechy, ktÃ³re sÄ… powszechnie uwaÅ¼ane za obiektowe i jak te cechy przekÅ‚adajÄ… siÄ™ na idiomatyczny Rust. NastÄ™pnie pokaÅ¼emy, jak zaimplementowaÄ‡ obiektowy wzorzec projektowy w Rust i omÃ³wimy kompromisy zwiÄ…zane z tym w porÃ³wnaniu do implementacji rozwiÄ…zania wykorzystujÄ…cego niektÃ³re mocne strony Rust.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="charakterystyka-jÄ™zykÃ³w-zorientowanych-obiektowo-1"><a href="#charakterystyka-jÄ™zykÃ³w-zorientowanych-obiektowo-1" class="header">Charakterystyka JÄ™zykÃ³w Zorientowanych Obiektowo</a></h1>
<h2 id="charakterystyka-jÄ™zykÃ³w-zorientowanych-obiektowo"><a class="header" href="#charakterystyka-jÄ™zykÃ³w-zorientowanych-obiektowo">Charakterystyka JÄ™zykÃ³w Zorientowanych Obiektowo</a></h2>
<p>W spoÅ‚ecznoÅ›ci programistycznej nie ma zgody co do tego, jakie cechy musi posiadaÄ‡ jÄ™zyk, aby byÅ‚ uwaÅ¼any za zorientowany obiektowo. Rust jest pod wpÅ‚ywem wielu paradygmatÃ³w programowania, w tym OOP; na przykÅ‚ad, zbadaliÅ›my cechy pochodzÄ…ce z programowania funkcyjnego w Rozdziale 13. Prawdopodobnie, jÄ™zyki OOP dzielÄ… pewne wspÃ³lne cechy â€“ a mianowicie obiekty, hermetyzacjÄ™ i dziedziczenie. Przyjrzyjmy siÄ™, co oznacza kaÅ¼da z tych cech i czy Rust je obsÅ‚uguje.</p>
<h3 id="obiekty-zawierajÄ…-dane-i-zachowanie"><a class="header" href="#obiekty-zawierajÄ…-dane-i-zachowanie">Obiekty ZawierajÄ… Dane i Zachowanie</a></h3>
<p>KsiÄ…Å¼ka <em>Wzorce projektowe: Elementy reuÅ¼ywalnego oprogramowania obiektowego</em> Ericha Gammy, Richarda Helma, Ralpha Johnsona i Johna Vlissidesa (Addison-Wesley, 1994), potocznie nazywana ksiÄ…Å¼kÄ… <em>Gang of Four</em>, jest katalogiem obiektowych wzorcÃ³w projektowych. Definiuje OOP w ten sposÃ³b:</p>
<blockquote>
<p>Programy zorientowane obiektowo skÅ‚adajÄ… siÄ™ z obiektÃ³w. <strong>Obiekt</strong> pakuje zarÃ³wno dane, jak i procedury, ktÃ³re operujÄ… na tych danych. Procedury sÄ… zazwyczaj nazywane <strong>metodami</strong> lub <strong>operacjami</strong>.</p>
</blockquote>
<p>Zgodnie z tÄ… definicjÄ…, Rust jest zorientowany obiektowo: struktury i wyliczenia posiadajÄ… dane, a bloki <code>impl</code> dostarczajÄ… metody dla struktur i wyliczeÅ„. Mimo Å¼e struktur i wyliczeÅ„ z metodami nie <em>nazywa siÄ™</em> obiektami, zapewniajÄ… one tÄ™ samÄ… funkcjonalnoÅ›Ä‡, zgodnie z definicjÄ… obiektÃ³w wedÅ‚ug Gang of Four.</p>
<h3 id="hermetyzacja-ukrywajÄ…ca-szczegÃ³Å‚y-implementacji"><a class="header" href="#hermetyzacja-ukrywajÄ…ca-szczegÃ³Å‚y-implementacji">Hermetyzacja UkrywajÄ…ca SzczegÃ³Å‚y Implementacji</a></h3>
<p>Innym aspektem powszechnie kojarzonym z OOP jest idea <em>hermetyzacji</em>, co oznacza, Å¼e szczegÃ³Å‚y implementacji obiektu nie sÄ… dostÄ™pne dla kodu korzystajÄ…cego z tego obiektu. Dlatego jedynym sposobem interakcji z obiektem jest jego publiczne API; kod uÅ¼ywajÄ…cy obiektu nie powinien byÄ‡ w stanie bezpoÅ›rednio zmieniaÄ‡ wewnÄ™trznych danych ani zachowaÅ„ obiektu. UmoÅ¼liwia to programiÅ›cie zmianÄ™ i refaktoryzacjÄ™ wewnÄ™trznych elementÃ³w obiektu bez koniecznoÅ›ci zmiany kodu, ktÃ³ry go uÅ¼ywa.</p>
<p>OmÃ³wiliÅ›my, jak kontrolowaÄ‡ hermetyzacjÄ™ w Rozdziale 7: MoÅ¼emy uÅ¼yÄ‡ sÅ‚owa kluczowego <code>pub</code>, aby zdecydowaÄ‡, ktÃ³re moduÅ‚y, typy, funkcje i metody w naszym kodzie powinny byÄ‡ publiczne, a domyÅ›lnie wszystko inne jest prywatne. Na przykÅ‚ad, moÅ¼emy zdefiniowaÄ‡ strukturÄ™ <code>AveragedCollection</code>, ktÃ³ra ma pole zawierajÄ…ce wektor wartoÅ›ci <code>i32</code>. Struktura moÅ¼e rÃ³wnieÅ¼ mieÄ‡ pole zawierajÄ…ce Å›redniÄ… wartoÅ›ci w wektorze, co oznacza, Å¼e Å›rednia nie musi byÄ‡ obliczana na Å¼Ä…danie za kaÅ¼dym razem, gdy ktoÅ› jej potrzebuje. Innymi sÅ‚owy, <code>AveragedCollection</code> bÄ™dzie dla nas buforowaÄ‡ obliczonÄ… Å›redniÄ…. Lista 18-1 zawiera definicjÄ™ struktury <code>AveragedCollection</code>.</p>
<figure class="listing" id="listing-18-1">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}</code></pre>
<figcaption><a href="#listing-18-1">Lista 18-1</a>: Struktura <code>AveragedCollection</code>, ktÃ³ra przechowuje listÄ™ liczb caÅ‚kowitych i Å›redniÄ… elementÃ³w w kolekcji</figcaption>
</figure>
<p>Struktura jest oznaczona jako <code>pub</code>, aby inny kod mÃ³gÅ‚ jej uÅ¼ywaÄ‡, ale pola wewnÄ…trz struktury pozostajÄ… prywatne. Jest to waÅ¼ne w tym przypadku, poniewaÅ¼ chcemy zapewniÄ‡, Å¼e za kaÅ¼dym razem, gdy wartoÅ›Ä‡ jest dodawana lub usuwana z listy, Å›rednia jest rÃ³wnieÅ¼ aktualizowana. Robimy to, implementujÄ…c metody <code>add</code>, <code>remove</code> i <code>average</code> dla struktury, jak pokazano na LiÅ›cie 18-2.</p>
<figure class="listing" id="listing-18-2">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct AveragedCollection {
</span><span class="boring">    list: Vec&lt;i32&gt;,
</span><span class="boring">    average: f64,
</span><span class="boring">}
</span><span class="boring">
</span>impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            }
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}</code></pre>
<figcaption><a href="#listing-18-2">Lista 18-2</a>: Implementacje publicznych metod <code>add</code>, <code>remove</code> i <code>average</code> w <code>AveragedCollection</code></figcaption>
</figure>
<p>Publiczne metody <code>add</code>, <code>remove</code> i <code>average</code> to jedyne sposoby dostÄ™pu lub modyfikacji danych w instancji <code>AveragedCollection</code>. Gdy element jest dodawany do <code>list</code> za pomocÄ… metody <code>add</code> lub usuwany za pomocÄ… metody <code>remove</code>, implementacje obu metod wywoÅ‚ujÄ… prywatnÄ… metodÄ™ <code>update_average</code>, ktÃ³ra zajmuje siÄ™ rÃ³wnieÅ¼ aktualizacjÄ… pola <code>average</code>.</p>
<p>Pozostawiamy pola <code>list</code> i <code>average</code> prywatne, aby zewnÄ™trzny kod nie mÃ³gÅ‚ bezpoÅ›rednio dodawaÄ‡ ani usuwaÄ‡ elementÃ³w z pola <code>list</code>; w przeciwnym razie pole <code>average</code> mogÅ‚oby staÄ‡ siÄ™ niespÃ³jne, gdy <code>list</code> siÄ™ zmienia. Metoda <code>average</code> zwraca wartoÅ›Ä‡ z pola <code>average</code>, umoÅ¼liwiajÄ…c zewnÄ™trznemu kodowi odczyt <code>average</code>, ale nie jego modyfikacjÄ™.</p>
<p>PoniewaÅ¼ hermetyzowaliÅ›my szczegÃ³Å‚y implementacji struktury <code>AveragedCollection</code>, moÅ¼emy w przyszÅ‚oÅ›ci Å‚atwo zmieniaÄ‡ aspekty, takie jak struktura danych. Na przykÅ‚ad, moglibyÅ›my uÅ¼yÄ‡ <code>HashSet&lt;i32&gt;</code> zamiast <code>Vec&lt;i32&gt;</code> dla pola <code>list</code>. DopÃ³ki sygnatury publicznych metod <code>add</code>, <code>remove</code> i <code>average</code> pozostaÅ‚yby takie same, kod uÅ¼ywajÄ…cy <code>AveragedCollection</code> nie wymagaÅ‚by zmian. GdybyÅ›my uczynili <code>list</code> publicznym, niekoniecznie tak by byÅ‚o: <code>HashSet&lt;i32&gt;</code> i <code>Vec&lt;i32&gt;</code> majÄ… rÃ³Å¼ne metody dodawania i usuwania elementÃ³w, wiÄ™c kod zewnÄ™trzny prawdopodobnie musiaÅ‚by siÄ™ zmieniÄ‡, gdyby modyfikowaÅ‚ <code>list</code> bezpoÅ›rednio.</p>
<p>JeÅ›li hermetyzacja jest wymaganym aspektem, aby jÄ™zyk byÅ‚ uwaÅ¼any za obiektowy, to Rust speÅ‚nia to wymaganie. Opcja uÅ¼ycia <code>pub</code> lub nie dla rÃ³Å¼nych czÄ™Å›ci kodu umoÅ¼liwia hermetyzacjÄ™ szczegÃ³Å‚Ã³w implementacji.</p>
<h3 id="dziedziczenie-jako-system-typÃ³w-i-jako-udostÄ™pnianie-kodu"><a class="header" href="#dziedziczenie-jako-system-typÃ³w-i-jako-udostÄ™pnianie-kodu">Dziedziczenie jako System TypÃ³w i jako UdostÄ™pnianie Kodu</a></h3>
<p><em>Dziedziczenie</em> to mechanizm, dziÄ™ki ktÃ³remu obiekt moÅ¼e dziedziczyÄ‡ elementy z definicji innego obiektu, uzyskujÄ…c w ten sposÃ³b dane i zachowanie obiektu-rodzica bez koniecznoÅ›ci ponownego ich definiowania.</p>
<p>JeÅ›li jÄ™zyk musi posiadaÄ‡ dziedziczenie, aby byÄ‡ obiektowym, to Rust nie jest takim jÄ™zykiem. Nie ma sposobu, aby zdefiniowaÄ‡ strukturÄ™, ktÃ³ra dziedziczy pola i implementacje metod struktury-rodzica bez uÅ¼ycia makra.</p>
<p>JednakÅ¼e, jeÅ›li jesteÅ› przyzwyczajony do posiadania dziedziczenia w swoim zestawie narzÄ™dzi programistycznych, moÅ¼esz uÅ¼yÄ‡ innych rozwiÄ…zaÅ„ w Rust, w zaleÅ¼noÅ›ci od powodu, dla ktÃ³rego pierwotnie siÄ™gnÄ…Å‚eÅ› po dziedziczenie.</p>
<p>Dziedziczenie wybraÅ‚byÅ› z dwÃ³ch gÅ‚Ã³wnych powodÃ³w. Jeden to ponowne wykorzystanie kodu: moÅ¼esz zaimplementowaÄ‡ okreÅ›lone zachowanie dla jednego typu, a dziedziczenie umoÅ¼liwia ponowne wykorzystanie tej implementacji dla innego typu. MoÅ¼esz to zrobiÄ‡ w ograniczony sposÃ³b w kodzie Rust, uÅ¼ywajÄ…c domyÅ›lnych implementacji metod cech, co widziaÅ‚eÅ› na LiÅ›cie 10-14, gdy dodaliÅ›my domyÅ›lnÄ… implementacjÄ™ metody <code>summarize</code> do cechy <code>Summary</code>. KaÅ¼dy typ implementujÄ…cy cechÄ™ <code>Summary</code> miaÅ‚by dostÄ™pnÄ… metodÄ™ <code>summarize</code> bez dodatkowego kodu. Jest to podobne do klasy nadrzÄ™dnej posiadajÄ…cej implementacjÄ™ metody i dziedziczÄ…cej klasy podrzÄ™dnej rÃ³wnieÅ¼ posiadajÄ…cej implementacjÄ™ metody. MoÅ¼emy rÃ³wnieÅ¼ nadpisaÄ‡ domyÅ›lnÄ… implementacjÄ™ metody <code>summarize</code> podczas implementowania cechy <code>Summary</code>, co jest podobne do klasy podrzÄ™dnej nadpisujÄ…cej implementacjÄ™ metody odziedziczonej z klasy nadrzÄ™dnej.</p>
<p>Drugi powÃ³d uÅ¼ycia dziedziczenia dotyczy systemu typÃ³w: aby umoÅ¼liwiÄ‡ uÅ¼ycie typu potomnego w tych samych miejscach co typ nadrzÄ™dny. Nazywa siÄ™ to rÃ³wnieÅ¼ <em>polimorfizmem</em>, co oznacza, Å¼e moÅ¼na podstawiaÄ‡ wiele obiektÃ³w jeden za drugi w czasie wykonania, jeÅ›li dzielÄ… one pewne cechy.</p>
<section class="note" aria-role="note">
<h3 id="polimorfizm"><a class="header" href="#polimorfizm">Polimorfizm</a></h3>
<p>Dla wielu osÃ³b polimorfizm jest synonimem dziedziczenia. Ale w rzeczywistoÅ›ci jest to bardziej ogÃ³lna koncepcja, ktÃ³ra odnosi siÄ™ do kodu, ktÃ³ry moÅ¼e pracowaÄ‡ z danymi wielu typÃ³w. Dla dziedziczenia te typy sÄ… zazwyczaj podklasami.</p>
<p>Rust zamiast tego uÅ¼ywa generykÃ³w do abstrakcji nad rÃ³Å¼nymi moÅ¼liwymi typami i ograniczeÅ„ cech do narzucania ograniczeÅ„ na to, co te typy muszÄ… zapewniaÄ‡. Jest to czasami nazywane <em>ograniczonym polimorfizmem parametrycznym</em>.</p>
</section>
<p>Rust wybraÅ‚ inny zestaw kompromisÃ³w, nie oferujÄ…c dziedziczenia. Dziedziczenie czÄ™sto grozi wspÃ³Å‚dzieleniem wiÄ™kszej iloÅ›ci kodu niÅ¼ to konieczne. Podklasy nie zawsze powinny dzieliÄ‡ wszystkie cechy swojej klasy nadrzÄ™dnej, ale bÄ™dÄ… to robiÄ‡ w przypadku dziedziczenia. MoÅ¼e to sprawiÄ‡, Å¼e projekt programu bÄ™dzie mniej elastyczny. Wprowadza to rÃ³wnieÅ¼ moÅ¼liwoÅ›Ä‡ wywoÅ‚ywania metod w podklasach, ktÃ³re nie majÄ… sensu lub powodujÄ… bÅ‚Ä™dy, poniewaÅ¼ metody nie majÄ… zastosowania do podklasy. Ponadto, niektÃ³re jÄ™zyki zezwalajÄ… tylko na <em>pojedyncze dziedziczenie</em> (co oznacza, Å¼e podklasa moÅ¼e dziedziczyÄ‡ tylko z jednej klasy), co dodatkowo ogranicza elastycznoÅ›Ä‡ projektu programu.</p>
<p>Z tych powodÃ³w Rust przyjmuje inne podejÅ›cie, uÅ¼ywajÄ…c obiektÃ³w cech zamiast dziedziczenia, aby osiÄ…gnÄ…Ä‡ polimorfizm w czasie wykonania. Przyjrzyjmy siÄ™, jak dziaÅ‚ajÄ… obiekty cech.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="uÅ¼ywanie-obiektÃ³w-trait-do-abstrakcji-nad-wspÃ³lnym-zachowaniem-1"><a href="#uÅ¼ywanie-obiektÃ³w-trait-do-abstrakcji-nad-wspÃ³lnym-zachowaniem-1" class="header">UÅ¼ywanie ObiektÃ³w Trait do Abstrakcji nad WspÃ³lnym Zachowaniem</a></h1>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="using-trait-objects-that-allow-for-values-of-different-types"></a></p>
<h2 id="uÅ¼ywanie-obiektÃ³w-trait-do-abstrakcji-nad-wspÃ³lnym-zachowaniem"><a class="header" href="#uÅ¼ywanie-obiektÃ³w-trait-do-abstrakcji-nad-wspÃ³lnym-zachowaniem">UÅ¼ywanie ObiektÃ³w Trait do Abstrakcji nad WspÃ³lnym Zachowaniem</a></h2>
<p>W Rozdziale 8 wspomnieliÅ›my, Å¼e jednym z ograniczeÅ„ wektorÃ³w jest to, Å¼e mogÄ… przechowywaÄ‡ elementy tylko jednego typu. StworzyliÅ›my obejÅ›cie w LiÅ›cie 8-9, gdzie zdefiniowaliÅ›my wyliczenie <code>SpreadsheetCell</code> z wariantami do przechowywania liczb caÅ‚kowitych, zmiennoprzecinkowych i tekstu. OznaczaÅ‚o to, Å¼e mogliÅ›my przechowywaÄ‡ rÃ³Å¼ne typy danych w kaÅ¼dej komÃ³rce i nadal mieÄ‡ wektor reprezentujÄ…cy wiersz komÃ³rek. Jest to doskonale dobre rozwiÄ…zanie, gdy nasze wymienne elementy to staÅ‚y zestaw typÃ³w, ktÃ³re znamy w momencie kompilacji kodu.</p>
<p>Jednak czasami chcemy, aby uÅ¼ytkownik naszej biblioteki mÃ³gÅ‚ rozszerzyÄ‡ zestaw typÃ³w, ktÃ³re sÄ… prawidÅ‚owe w danej sytuacji. Aby pokazaÄ‡, jak to osiÄ…gnÄ…Ä‡, stworzymy przykÅ‚ad narzÄ™dzia graficznego interfejsu uÅ¼ytkownika (GUI), ktÃ³re iteruje przez listÄ™ elementÃ³w, wywoÅ‚ujÄ…c metodÄ™ <code>draw</code> na kaÅ¼dym z nich, aby narysowaÄ‡ go na ekranie â€” powszechna technika w narzÄ™dziach GUI. Stworzymy bibliotekÄ™ <code>gui</code>, ktÃ³ra bÄ™dzie zawieraÄ‡ strukturÄ™ biblioteki GUI. Ta biblioteka moÅ¼e zawieraÄ‡ typy dla uÅ¼ytkownikÃ³w, takie jak <code>Button</code> lub <code>TextField</code>. Ponadto uÅ¼ytkownicy <code>gui</code> bÄ™dÄ… chcieli tworzyÄ‡ wÅ‚asne typy, ktÃ³re moÅ¼na rysowaÄ‡: na przykÅ‚ad jeden programista moÅ¼e dodaÄ‡ <code>Image</code>, a inny <code>SelectBox</code>.</p>
<p>W momencie pisania biblioteki nie moÅ¼emy znaÄ‡ i zdefiniowaÄ‡ wszystkich typÃ³w, ktÃ³re inni programiÅ›ci mogÄ… chcieÄ‡ stworzyÄ‡. Wiemy jednak, Å¼e <code>gui</code> musi Å›ledziÄ‡ wiele wartoÅ›ci rÃ³Å¼nych typÃ³w i musi wywoÅ‚ywaÄ‡ metodÄ™ <code>draw</code> na kaÅ¼dej z tych wartoÅ›ci o rÃ³Å¼nych typach. Nie musi wiedzieÄ‡ dokÅ‚adnie, co siÄ™ stanie, gdy wywoÅ‚amy metodÄ™ <code>draw</code>, tylko tyle, Å¼e wartoÅ›Ä‡ bÄ™dzie miaÅ‚a tÄ™ metodÄ™ dostÄ™pnÄ… do wywoÅ‚ania.</p>
<p>Aby to zrobiÄ‡ w jÄ™zyku z dziedziczeniem, moglibyÅ›my zdefiniowaÄ‡ klasÄ™ o nazwie <code>Component</code>, ktÃ³ra miaÅ‚aby metodÄ™ <code>draw</code>. Inne klasy, takie jak <code>Button</code>, <code>Image</code> i <code>SelectBox</code>, dziedziczyÅ‚yby po <code>Component</code> i w ten sposÃ³b dziedziczyÅ‚yby metodÄ™ <code>draw</code>. KaÅ¼da z nich mogÅ‚aby nadpisaÄ‡ metodÄ™ <code>draw</code>, aby zdefiniowaÄ‡ swoje niestandardowe zachowanie, ale framework mÃ³gÅ‚by traktowaÄ‡ wszystkie typy tak, jakby byÅ‚y instancjami <code>Component</code> i wywoÅ‚ywaÄ‡ na nich <code>draw</code>. Ale poniewaÅ¼ Rust nie ma dziedziczenia, potrzebujemy innego sposobu na zbudowanie biblioteki <code>gui</code>, aby umoÅ¼liwiÄ‡ uÅ¼ytkownikom tworzenie nowych typÃ³w zgodnych z bibliotekÄ….</p>
<h3 id="definiowanie-traitu-dla-wspÃ³lnego-zachowania"><a class="header" href="#definiowanie-traitu-dla-wspÃ³lnego-zachowania">Definiowanie Traitu dla WspÃ³lnego Zachowania</a></h3>
<p>Aby zaimplementowaÄ‡ zachowanie, ktÃ³re chcemy, aby <code>gui</code> miaÅ‚o, zdefiniujemy cechÄ™ <code>Draw</code>, ktÃ³ra bÄ™dzie miaÅ‚a jednÄ… metodÄ™ <code>draw</code>. NastÄ™pnie moÅ¼emy zdefiniowaÄ‡ wektor, ktÃ³ry przyjmuje obiekt cechy. <em>Obiekt cechy</em> wskazuje zarÃ³wno instancjÄ™ typu implementujÄ…cego naszÄ… okreÅ›lonÄ… cechÄ™, jak i tabelÄ™ uÅ¼ywanÄ… do wyszukiwania metod cech na tym typie w czasie wykonania. Tworzymy obiekt cechy, okreÅ›lajÄ…c jakiÅ› rodzaj wskaÅºnika, taki jak referencja lub inteligentny wskaÅºnik <code>Box&lt;T&gt;</code>, nastÄ™pnie sÅ‚owo kluczowe <code>dyn</code>, a nastÄ™pnie okreÅ›lajÄ…c odpowiedniÄ… cechÄ™. (O powodzie, dla ktÃ³rego obiekty cech muszÄ… uÅ¼ywaÄ‡ wskaÅºnika, porozmawiamy w sekcji <a href="#dynamically-sized-types-and-the-sized-trait">â€Typy o dynamicznym rozmiarze i cecha <code>Sized</code>â€</a><!-- ignore --> w Rozdziale 20.) MoÅ¼emy uÅ¼ywaÄ‡ obiektÃ³w cech zamiast typu generycznego lub konkretnego. WszÄ™dzie, gdzie uÅ¼ywamy obiektu cechy, system typÃ³w Rust zapewni w czasie kompilacji, Å¼e kaÅ¼da wartoÅ›Ä‡ uÅ¼yta w tym kontekÅ›cie bÄ™dzie implementowaÄ‡ cechÄ™ obiektu cechy. W konsekwencji nie musimy znaÄ‡ wszystkich moÅ¼liwych typÃ³w w czasie kompilacji.</p>
<p>WspomnieliÅ›my, Å¼e w Rust powstrzymujemy siÄ™ od nazywania struktur i wyliczeÅ„ â€obiektamiâ€, aby odrÃ³Å¼niÄ‡ je od obiektÃ³w z innych jÄ™zykÃ³w. W strukturze lub wyliczeniu dane w polach struktury i zachowanie w blokach <code>impl</code> sÄ… oddzielone, podczas gdy w innych jÄ™zykach dane i zachowanie poÅ‚Ä…czone w jednÄ… koncepcjÄ™ sÄ… czÄ™sto nazywane obiektem. Obiekty cech rÃ³Å¼niÄ… siÄ™ od obiektÃ³w w innych jÄ™zykach tym, Å¼e nie moÅ¼emy dodawaÄ‡ danych do obiektu cechy. Obiekty cech nie sÄ… tak ogÃ³lnie uÅ¼yteczne jak obiekty w innych jÄ™zykach: ich specyficznym celem jest umoÅ¼liwienie abstrakcji nad wspÃ³lnym zachowaniem.</p>
<p>Lista 18-3 pokazuje, jak zdefiniowaÄ‡ cechÄ™ <code>Draw</code> z jednÄ… metodÄ… <code>draw</code>.</p>
<figure class="listing" id="listing-18-3">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub trait Draw {
    fn draw(&amp;self);
}</code></pre>
<figcaption><a href="#listing-18-3">Lista 18-3</a>: Definicja cechy <code>Draw</code></figcaption>
</figure>
<p>Ta skÅ‚adnia powinna byÄ‡ znana z naszych dyskusji na temat definiowania cech w Rozdziale 10. Dalej pojawia siÄ™ nowa skÅ‚adnia: Lista 18-4 definiuje strukturÄ™ o nazwie <code>Screen</code>, ktÃ³ra zawiera wektor o nazwie <code>components</code>. Ten wektor jest typu <code>Box&lt;dyn Draw&gt;</code>, czyli obiektu cechy; jest to zastÄ™pstwo dla dowolnego typu wewnÄ…trz <code>Box</code>, ktÃ³ry implementuje cechÄ™ <code>Draw</code>.</p>
<figure class="listing" id="listing-18-4">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}</code></pre>
<figcaption><a href="#listing-18-4">Lista 18-4</a>: Definicja struktury <code>Screen</code> z polem <code>components</code> zawierajÄ…cym wektor obiektÃ³w cech, ktÃ³re implementujÄ… cechÄ™ <code>Draw</code></figcaption>
</figure>
<p>W strukturze <code>Screen</code> zdefiniujemy metodÄ™ <code>run</code>, ktÃ³ra wywoÅ‚a metodÄ™ <code>draw</code> na kaÅ¼dym z jej <code>components</code>, jak pokazano na LiÅ›cie 18-5.</p>
<figure class="listing" id="listing-18-5">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}</code></pre>
<figcaption><a href="#listing-18-5">Lista 18-5</a>: Metoda <code>run</code> w <code>Screen</code>, ktÃ³ra wywoÅ‚uje metodÄ™ <code>draw</code> na kaÅ¼dym komponencie</figcaption>
</figure>
<p>DziaÅ‚a to inaczej niÅ¼ definiowanie struktury, ktÃ³ra uÅ¼ywa generycznego parametru typu z ograniczeniami cech. Generyczny parametr typu moÅ¼e byÄ‡ podstawiony tylko jednym konkretnym typem na raz, podczas gdy obiekty cech pozwalajÄ… na wypeÅ‚nienie obiektu cechy wieloma konkretnymi typami w czasie wykonania. Na przykÅ‚ad, moglibyÅ›my zdefiniowaÄ‡ strukturÄ™ <code>Screen</code> uÅ¼ywajÄ…c generycznego typu i ograniczenia cech, jak na LiÅ›cie 18-6.</p>
<figure class="listing" id="listing-18-6">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
where
    T: Draw,
{
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}</code></pre>
<figcaption><a href="#listing-18-6">Lista 18-6</a>: Alternatywna implementacja struktury <code>Screen</code> i jej metody <code>run</code> za pomocÄ… generykÃ³w i ograniczeÅ„ cech</figcaption>
</figure>
<p>To ogranicza nas do instancji <code>Screen</code>, ktÃ³ra ma listÄ™ komponentÃ³w wszystkich typu <code>Button</code> lub wszystkich typu <code>TextField</code>. JeÅ›li zawsze bÄ™dziesz mieÄ‡ tylko jednorodne kolekcje, uÅ¼ycie generykÃ³w i ograniczeÅ„ cech jest preferowane, poniewaÅ¼ definicje zostanÄ… zmonomorfizowane w czasie kompilacji, aby uÅ¼ywaÄ‡ konkretnych typÃ³w.</p>
<p>Z drugiej strony, w metodzie uÅ¼ywajÄ…cej obiektÃ³w cech, jedna instancja <code>Screen</code> moÅ¼e przechowywaÄ‡ <code>Vec&lt;T&gt;</code>, ktÃ³ry zawiera <code>Box&lt;Button&gt;</code> oraz <code>Box&lt;TextField&gt;</code>. Przyjrzyjmy siÄ™, jak to dziaÅ‚a, a nastÄ™pnie omÃ³wimy implikacje dla wydajnoÅ›ci w czasie wykonania.</p>
<h3 id="implementowanie-traitu"><a class="header" href="#implementowanie-traitu">Implementowanie Traitu</a></h3>
<p>Teraz dodamy kilka typÃ³w, ktÃ³re implementujÄ… cechÄ™ <code>Draw</code>. Zapewnimy typ <code>Button</code>. Ponownie, faktyczne zaimplementowanie biblioteki GUI wykracza poza zakres tej ksiÄ…Å¼ki, wiÄ™c metoda <code>draw</code> nie bÄ™dzie miaÅ‚a Å¼adnej uÅ¼ytecznej implementacji w swoim ciele. Aby wyobraziÄ‡ sobie, jak mogÅ‚aby wyglÄ…daÄ‡ implementacja, struktura <code>Button</code> mogÅ‚aby mieÄ‡ pola <code>width</code>, <code>height</code> i <code>label</code>, jak pokazano na LiÅ›cie 18-7.</p>
<figure class="listing" id="listing-18-7">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Screen {
</span><span class="boring">    pub fn run(&amp;self) {
</span><span class="boring">        for component in self.components.iter() {
</span><span class="boring">            component.draw();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // code to actually draw a button
    }
}</code></pre>
<figcaption><a href="#listing-18-7">Lista 18-7</a>: Struktura <code>Button</code>, ktÃ³ra implementuje cechÄ™ <code>Draw</code></figcaption>
</figure>
<p>Pola <code>width</code>, <code>height</code> i <code>label</code> w <code>Button</code> bÄ™dÄ… siÄ™ rÃ³Å¼niÄ‡ od pÃ³l w innych komponentach; na przykÅ‚ad, typ <code>TextField</code> mÃ³gÅ‚by mieÄ‡ te same pola plus pole <code>placeholder</code>. KaÅ¼dy z typÃ³w, ktÃ³re chcemy narysowaÄ‡ na ekranie, bÄ™dzie implementowaÅ‚ cechÄ™ <code>Draw</code>, ale uÅ¼yje innego kodu w metodzie <code>draw</code>, aby zdefiniowaÄ‡, jak narysowaÄ‡ dany typ, jak to ma miejsce w <code>Button</code> (bez faktycznego kodu GUI, jak wspomniano). Typ <code>Button</code>, na przykÅ‚ad, mÃ³gÅ‚by mieÄ‡ dodatkowy blok <code>impl</code> zawierajÄ…cy metody zwiÄ…zane z tym, co dzieje siÄ™, gdy uÅ¼ytkownik kliknie przycisk. Tego rodzaju metody nie bÄ™dÄ… miaÅ‚y zastosowania do typÃ³w takich jak <code>TextField</code>.</p>
<p>JeÅ›li ktoÅ› uÅ¼ywajÄ…cy naszej biblioteki zdecyduje siÄ™ zaimplementowaÄ‡ strukturÄ™ <code>SelectBox</code>, ktÃ³ra ma pola <code>width</code>, <code>height</code> i <code>options</code>, zaimplementuje rÃ³wnieÅ¼ cechÄ™ <code>Draw</code> dla typu <code>SelectBox</code>, jak pokazano na LiÅ›cie 18-8.</p>
<figure class="listing" id="listing-18-8">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore">use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // code to actually draw a select box
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<figcaption><a href="#listing-18-8">Lista 18-8</a>: Inny crate uÅ¼ywajÄ…cy <code>gui</code> i implementujÄ…cy cechÄ™ <code>Draw</code> na strukturze <code>SelectBox</code></figcaption>
</figure>
<p>UÅ¼ytkownik naszej biblioteki moÅ¼e teraz napisaÄ‡ swojÄ… funkcjÄ™ <code>main</code>, aby utworzyÄ‡ instancjÄ™ <code>Screen</code>. Do instancji <code>Screen</code> mogÄ… dodaÄ‡ <code>SelectBox</code> i <code>Button</code>, umieszczajÄ…c kaÅ¼dy w <code>Box&lt;T&gt;</code>, aby staÅ‚ siÄ™ obiektem cechy. NastÄ™pnie mogÄ… wywoÅ‚aÄ‡ metodÄ™ <code>run</code> na instancji <code>Screen</code>, ktÃ³ra wywoÅ‚a <code>draw</code> na kaÅ¼dym z komponentÃ³w. Lista 18-9 pokazuje tÄ™ implementacjÄ™.</p>
<figure class="listing" id="listing-18-9">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use gui::Draw;
</span><span class="boring">
</span><span class="boring">struct SelectBox {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">    options: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Draw for SelectBox {
</span><span class="boring">    fn draw(&amp;self) {
</span><span class="boring">        // code to actually draw a select box
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from("Yes"),
                    String::from("Maybe"),
                    String::from("No"),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from("OK"),
            }),
        ],
    };

    screen.run();
}</code></pre>
<figcaption><a href="#listing-18-9">Lista 18-9</a>: UÅ¼ywanie obiektÃ³w cech do przechowywania wartoÅ›ci rÃ³Å¼nych typÃ³w, ktÃ³re implementujÄ… tÄ™ samÄ… cechÄ™</figcaption>
</figure>
<p>Kiedy pisaliÅ›my bibliotekÄ™, nie wiedzieliÅ›my, Å¼e ktoÅ› moÅ¼e dodaÄ‡ typ <code>SelectBox</code>, ale nasza implementacja <code>Screen</code> byÅ‚a w stanie operowaÄ‡ na nowym typie i go rysowaÄ‡, poniewaÅ¼ <code>SelectBox</code> implementuje cechÄ™ <code>Draw</code>, co oznacza, Å¼e implementuje metodÄ™ <code>draw</code>.</p>
<p>Ta koncepcja â€” zajmowanie siÄ™ tylko wiadomoÅ›ciami, na ktÃ³re wartoÅ›Ä‡ odpowiada, a nie konkretnym typem wartoÅ›ci â€” jest podobna do koncepcji <em>duck typing</em> w jÄ™zykach z dynamicznym typowaniem: jeÅ›li chodzi jak kaczka i kwacze jak kaczka, to musi byÄ‡ kaczka! W implementacji <code>run</code> na <code>Screen</code> na LiÅ›cie 18-5, <code>run</code> nie musi wiedzieÄ‡, jaki jest konkretny typ kaÅ¼dego komponentu. Nie sprawdza, czy komponent jest instancjÄ… <code>Button</code> czy <code>SelectBox</code>, po prostu wywoÅ‚uje metodÄ™ <code>draw</code> na komponencie. Poprzez okreÅ›lenie <code>Box&lt;dyn Draw&gt;</code> jako typu wartoÅ›ci w wektorze <code>components</code>, zdefiniowaliÅ›my, Å¼e <code>Screen</code> potrzebuje wartoÅ›ci, na ktÃ³rych moÅ¼emy wywoÅ‚aÄ‡ metodÄ™ <code>draw</code>.</p>
<p>ZaletÄ… uÅ¼ywania obiektÃ³w cech i systemu typÃ³w Rust do pisania kodu podobnego do kodu uÅ¼ywajÄ…cego duck typingu jest to, Å¼e nigdy nie musimy sprawdzaÄ‡, czy wartoÅ›Ä‡ implementuje konkretnÄ… metodÄ™ w czasie wykonania, ani martwiÄ‡ siÄ™ o bÅ‚Ä™dy, jeÅ›li wartoÅ›Ä‡ nie implementuje metody, ale mimo to jÄ… wywoÅ‚ujemy. Rust nie skompiluje naszego kodu, jeÅ›li wartoÅ›ci nie implementujÄ… cech, ktÃ³rych potrzebujÄ… obiekty cech.</p>
<p>Na przykÅ‚ad, Lista 18-10 pokazuje, co siÄ™ dzieje, gdy prÃ³bujemy stworzyÄ‡ <code>Screen</code> ze <code>String</code> jako komponentem.</p>
<figure class="listing" id="listing-18-10">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![Box::new(String::from("Hi"))],
    };

    screen.run();
}</code></pre>
<figcaption><a href="#listing-18-10">Lista 18-10</a>: PrÃ³ba uÅ¼ycia typu, ktÃ³ry nie implementuje cechy obiektu cechy</figcaption>
</figure>
<p>Otrzymamy ten bÅ‚Ä…d, poniewaÅ¼ <code>String</code> nie implementuje cechy <code>Draw</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0277]: the trait bound `String: Draw` is not satisfied
 --&gt; src/main.rs:5:26
  |
5 |         components: vec![Box::new(String::from("Hi"))],
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not implemented for `String`
  |
  = help: the trait `Draw` is implemented for `Button`
  = note: required for the cast from `Box&lt;String&gt;` to `Box&lt;dyn Draw&gt;`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `gui` (bin "gui") due to 1 previous error
</code></pre>
<p>Ten bÅ‚Ä…d informuje nas, Å¼e albo przekazujemy coÅ› do <code>Screen</code>, czego nie zamierzaliÅ›my przekazaÄ‡ i dlatego powinniÅ›my przekazaÄ‡ inny typ, albo powinniÅ›my zaimplementowaÄ‡ <code>Draw</code> na <code>String</code>, aby <code>Screen</code> byÅ‚ w stanie wywoÅ‚aÄ‡ na nim <code>draw</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="trait-objects-perform-dynamic-dispatch"></a></p>
<h3 id="wykonywanie-dynamicznego-wysyÅ‚ania"><a class="header" href="#wykonywanie-dynamicznego-wysyÅ‚ania">Wykonywanie Dynamicznego WysyÅ‚ania</a></h3>
<p>Przypomnijmy sobie dyskusjÄ™ w sekcji <a href="#performance-of-code-using-generics">â€WydajnoÅ›Ä‡ kodu uÅ¼ywajÄ…cego generykÃ³wâ€</a><!-- ignore --> w Rozdziale 10 na temat procesu monomorfizacji wykonywanego przez kompilator dla generykÃ³w: kompilator generuje niegeneryczne implementacje funkcji i metod dla kaÅ¼dego konkretnego typu, ktÃ³ry uÅ¼ywamy w miejsce generycznego parametru typu. Kod, ktÃ³ry wynika z monomorfizacji, wykonuje <em>statyczne wysyÅ‚anie</em>, czyli sytuacjÄ™, w ktÃ³rej kompilator wie, ktÃ³rÄ… metodÄ™ wywoÅ‚ujesz w czasie kompilacji. Jest to przeciwieÅ„stwo <em>dynamicznego wysyÅ‚ania</em>, czyli sytuacji, w ktÃ³rej kompilator nie moÅ¼e w czasie kompilacji okreÅ›liÄ‡, ktÃ³rÄ… metodÄ™ wywoÅ‚ujesz. W przypadkach dynamicznego wysyÅ‚ania kompilator emituje kod, ktÃ³ry w czasie wykonania bÄ™dzie wiedziaÅ‚, ktÃ³rÄ… metodÄ™ wywoÅ‚aÄ‡.</p>
<p>Kiedy uÅ¼ywamy obiektÃ³w cech, Rust musi uÅ¼yÄ‡ dynamicznego wysyÅ‚ania. Kompilator nie zna wszystkich typÃ³w, ktÃ³re mogÄ… byÄ‡ uÅ¼yte z kodem uÅ¼ywajÄ…cym obiektÃ³w cech, wiÄ™c nie wie, ktÃ³ra metoda zaimplementowana na ktÃ³rym typie ma byÄ‡ wywoÅ‚ana. Zamiast tego, w czasie wykonania, Rust uÅ¼ywa wskaÅºnikÃ³w w obiekcie cechy, aby wiedzieÄ‡, ktÃ³rÄ… metodÄ™ wywoÅ‚aÄ‡. To wyszukiwanie wiÄ…Å¼e siÄ™ z kosztem wykonania, ktÃ³ry nie wystÄ™puje przy statycznym wysyÅ‚aniu. Dynamiczne wysyÅ‚anie uniemoÅ¼liwia rÃ³wnieÅ¼ kompilatorowi wstawienie kodu metody, co z kolei uniemoÅ¼liwia niektÃ³re optymalizacje, a Rust ma pewne zasady dotyczÄ…ce tego, gdzie moÅ¼na, a gdzie nie moÅ¼na uÅ¼ywaÄ‡ dynamicznego wysyÅ‚ania, zwane <em>kompatybilnoÅ›ciÄ… dyn</em>. Te zasady wykraczajÄ… poza zakres tej dyskusji, ale moÅ¼esz przeczytaÄ‡ o nich wiÄ™cej <a href="https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility">w referencji</a><!-- ignore -->. JednakÅ¼e uzyskaliÅ›my dodatkowÄ… elastycznoÅ›Ä‡ w kodzie, ktÃ³ry napisaliÅ›my na LiÅ›cie 18-5 i byliÅ›my w stanie obsÅ‚ugiwaÄ‡ na LiÅ›cie 18-9, wiÄ™c jest to kompromis do rozwaÅ¼enia.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="implementacja-obiektowo-zorientowanego-wzorca-projektowego-1"><a href="#implementacja-obiektowo-zorientowanego-wzorca-projektowego-1" class="header">Implementacja Obiektowo Zorientowanego Wzorca Projektowego</a></h1>
<h2 id="implementacja-obiektowo-zorientowanego-wzorca-projektowego"><a class="header" href="#implementacja-obiektowo-zorientowanego-wzorca-projektowego">Implementacja Obiektowo Zorientowanego Wzorca Projektowego</a></h2>
<p><em>Wzorzec stanu</em> to obiektowo zorientowany wzorzec projektowy. IstotÄ… wzorca jest to, Å¼e definiujemy zestaw stanÃ³w, ktÃ³re wartoÅ›Ä‡ moÅ¼e mieÄ‡ wewnÄ™trznie. Stany sÄ… reprezentowane przez zestaw <em>obiektÃ³w stanu</em>, a zachowanie wartoÅ›ci zmienia siÄ™ w zaleÅ¼noÅ›ci od jej stanu. Przejdziemy przez przykÅ‚ad struktury wpisu na blogu, ktÃ³ra ma pole do przechowywania swojego stanu, ktÃ³ry bÄ™dzie obiektem stanu z zestawu â€szkicâ€, â€do recenzjiâ€ lub â€opublikowanyâ€.</p>
<p>Obiekty stanu dzielÄ… funkcjonalnoÅ›Ä‡: w Rust, oczywiÅ›cie, uÅ¼ywamy struktur i cech zamiast obiektÃ³w i dziedziczenia. KaÅ¼dy obiekt stanu jest odpowiedzialny za wÅ‚asne zachowanie i za to, kiedy powinien zmieniÄ‡ siÄ™ w inny stan. WartoÅ›Ä‡, ktÃ³ra przechowuje obiekt stanu, nic nie wie o rÃ³Å¼nych zachowaniach stanÃ³w ani o tym, kiedy przechodziÄ‡ miÄ™dzy stanami.</p>
<p>ZaletÄ… stosowania wzorca stanu jest to, Å¼e gdy zmieniÄ… siÄ™ wymagania biznesowe programu, nie bÄ™dziemy musieli zmieniaÄ‡ kodu wartoÅ›ci przechowujÄ…cej stan ani kodu, ktÃ³ry uÅ¼ywa tej wartoÅ›ci. BÄ™dziemy musieli jedynie zaktualizowaÄ‡ kod wewnÄ…trz jednego z obiektÃ³w stanu, aby zmieniÄ‡ jego zasady lub ewentualnie dodaÄ‡ wiÄ™cej obiektÃ³w stanu.</p>
<p>Najpierw zaimplementujemy wzorzec stanu w bardziej tradycyjny, obiektowy sposÃ³b. NastÄ™pnie uÅ¼yjemy podejÅ›cia, ktÃ³re jest nieco bardziej naturalne w Rust. ZagÅ‚Ä™bimy siÄ™ w stopniowÄ… implementacjÄ™ przepÅ‚ywu pracy wpisu na blogu, uÅ¼ywajÄ…c wzorca stanu.</p>
<p>KoÅ„cowa funkcjonalnoÅ›Ä‡ bÄ™dzie wyglÄ…daÄ‡ tak:</p>
<ol>
<li>Wpis na blogu zaczyna siÄ™ jako pusty szkic.</li>
<li>Po zakoÅ„czeniu szkicu, prosi siÄ™ o jego recenzjÄ™.</li>
<li>Po zatwierdzeniu wpis zostaje opublikowany.</li>
<li>Tylko opublikowane wpisy na blogu zwracajÄ… treÅ›Ä‡ do wydrukowania, aby niezaprobowane wpisy nie mogÅ‚y zostaÄ‡ przypadkowo opublikowane.</li>
</ol>
<p>Wszelkie inne prÃ³by zmian we wpisie nie powinny mieÄ‡ Å¼adnego efektu. Na przykÅ‚ad, jeÅ›li sprÃ³bujemy zatwierdziÄ‡ szkic wpisu na blogu, zanim poprosimy o recenzjÄ™, wpis powinien pozostaÄ‡ nieopublikowanym szkicem.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="a-traditional-object-oriented-attempt"></a></p>
<h3 id="prÃ³ba-w-tradycyjnym-stylu-obiektowym"><a class="header" href="#prÃ³ba-w-tradycyjnym-stylu-obiektowym">PrÃ³ba w Tradycyjnym Stylu Obiektowym</a></h3>
<p>Istnieje nieskoÅ„czenie wiele sposobÃ³w strukturyzowania kodu w celu rozwiÄ…zania tego samego problemu, kaÅ¼dy z rÃ³Å¼nymi kompromisami. Implementacja w tej sekcji jest bardziej tradycyjnym stylem obiektowym, ktÃ³ry jest moÅ¼liwy do napisania w Rust, ale nie wykorzystuje niektÃ³rych mocnych stron Rust. PÃ³Åºniej zademonstrujemy inne rozwiÄ…zanie, ktÃ³re nadal uÅ¼ywa wzorca projektowego zorientowanego obiektowo, ale jest skonstruowane w sposÃ³b, ktÃ³ry moÅ¼e wydawaÄ‡ siÄ™ mniej znajomy programistom z doÅ›wiadczeniem w programowaniu obiektowym. PorÃ³wnamy oba rozwiÄ…zania, aby doÅ›wiadczyÄ‡ kompromisÃ³w zwiÄ…zanych z projektowaniem kodu Rust inaczej niÅ¼ w innych jÄ™zykach.</p>
<p>Lista 18-11 pokazuje ten przepÅ‚yw pracy w formie kodu: jest to przykÅ‚ad uÅ¼ycia API, ktÃ³re zaimplementujemy w bibliotece o nazwie <code>blog</code>. To siÄ™ jeszcze nie skompiluje, poniewaÅ¼ nie zaimplementowaliÅ›my crate <code>blog</code>.</p>
<figure class="listing" id="listing-18-11">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("I ate a salad for lunch today", post.content());
}</code></pre>
<figcaption><a href="#listing-18-11">Lista 18-11</a>: Kod demonstrujÄ…cy poÅ¼Ä…dane zachowanie, ktÃ³re chcemy, aby posiadaÅ‚a nasza biblioteka <code>blog</code></figcaption>
</figure>
<p>Chcemy umoÅ¼liwiÄ‡ uÅ¼ytkownikowi utworzenie nowego szkicu wpisu na blogu za pomocÄ… <code>Post::new</code>. Chcemy umoÅ¼liwiÄ‡ dodawanie tekstu do wpisu na blogu. JeÅ›li sprÃ³bujemy natychmiast uzyskaÄ‡ treÅ›Ä‡ wpisu, przed zatwierdzeniem, nie powinniÅ›my otrzymaÄ‡ Å¼adnego tekstu, poniewaÅ¼ wpis jest nadal szkicem. DodaliÅ›my <code>assert_eq!</code> w kodzie w celach demonstracyjnych. DoskonaÅ‚ym testem jednostkowym byÅ‚oby sprawdzenie, czy szkic wpisu na blogu zwraca pusty ciÄ…g z metody <code>content</code>, ale nie bÄ™dziemy pisaÄ‡ testÃ³w dla tego przykÅ‚adu.</p>
<p>NastÄ™pnie chcemy umoÅ¼liwiÄ‡ proÅ›bÄ™ o recenzjÄ™ wpisu i chcemy, aby <code>content</code> zwracaÅ‚o pusty ciÄ…g, podczas gdy czekamy na recenzjÄ™. Kiedy wpis zostanie zatwierdzony, powinien zostaÄ‡ opublikowany, co oznacza, Å¼e tekst wpisu zostanie zwrÃ³cony, gdy wywoÅ‚ana zostanie metoda <code>content</code>.</p>
<p>ZauwaÅ¼, Å¼e jedynym typem, z ktÃ³rym wchodzimy w interakcjÄ™ z biblioteki, jest typ <code>Post</code>. Ten typ bÄ™dzie uÅ¼ywaÅ‚ wzorca stanu i bÄ™dzie przechowywaÅ‚ wartoÅ›Ä‡, ktÃ³ra bÄ™dzie jednym z trzech obiektÃ³w stanu reprezentujÄ…cych rÃ³Å¼ne stany, w jakich moÅ¼e znajdowaÄ‡ siÄ™ wpis â€” szkic, do recenzji lub opublikowany. Zmiana z jednego stanu na drugi bÄ™dzie zarzÄ…dzana wewnÄ™trznie w typie <code>Post</code>. Stany zmieniajÄ… siÄ™ w odpowiedzi na metody wywoÅ‚ywane przez uÅ¼ytkownikÃ³w naszej biblioteki na instancji <code>Post</code>, ale nie muszÄ… oni bezpoÅ›rednio zarzÄ…dzaÄ‡ zmianami stanu. Ponadto uÅ¼ytkownicy nie mogÄ… popeÅ‚niÄ‡ bÅ‚Ä™du ze stanami, na przykÅ‚ad publikujÄ…c wpis przed jego zrecenzowaniem.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="defining-post-and-creating-a-new-instance-in-the-draft-state"></a></p>
<h4 id="definiowanie-post-i-tworzenie-nowej-instancji"><a class="header" href="#definiowanie-post-i-tworzenie-nowej-instancji">Definiowanie <code>Post</code> i Tworzenie Nowej Instancji</a></h4>
<p>Rozpocznijmy implementacjÄ™ biblioteki! Wiemy, Å¼e potrzebujemy publicznej struktury <code>Post</code>, ktÃ³ra przechowuje pewnÄ… zawartoÅ›Ä‡, wiÄ™c zaczniemy od definicji struktury i powiÄ…zanej publicznej funkcji <code>new</code> do tworzenia instancji <code>Post</code>, jak pokazano na LiÅ›cie 18-12. Stworzymy rÃ³wnieÅ¼ prywatnÄ… cechÄ™ <code>State</code>, ktÃ³ra zdefiniuje zachowanie, ktÃ³re muszÄ… mieÄ‡ wszystkie obiekty stanu dla <code>Post</code>.</p>
<p>NastÄ™pnie <code>Post</code> bÄ™dzie przechowywaÄ‡ obiekt cechy <code>Box&lt;dyn State&gt;</code> wewnÄ…trz <code>Option&lt;T&gt;</code> w prywatnym polu o nazwie <code>state</code>, aby przechowywaÄ‡ obiekt stanu. Za chwilÄ™ zobaczysz, dlaczego <code>Option&lt;T&gt;</code> jest konieczny.</p>
<figure class="listing" id="listing-18-12">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}</code></pre>
<figcaption><a href="#listing-18-12">Lista 18-12</a>: Definicja struktury <code>Post</code> i funkcji <code>new</code>, ktÃ³ra tworzy nowÄ… instancjÄ™ <code>Post</code>, cechy <code>State</code> i struktury <code>Draft</code></figcaption>
</figure>
<p>Cecha <code>State</code> definiuje zachowanie dzielone przez rÃ³Å¼ne stany wpisu. Obiekty stanu to <code>Draft</code>, <code>PendingReview</code> i <code>Published</code>, i wszystkie one bÄ™dÄ… implementowaÄ‡ cechÄ™ <code>State</code>. Na razie cecha nie ma Å¼adnych metod, a zaczniemy od zdefiniowania tylko stanu <code>Draft</code>, poniewaÅ¼ to jest stan, w ktÃ³rym chcemy, aby wpis zaczynaÅ‚ siÄ™.</p>
<p>Kiedy tworzymy nowy <code>Post</code>, ustawiamy jego pole <code>state</code> na wartoÅ›Ä‡ <code>Some</code>, ktÃ³ra zawiera <code>Box</code>. Ten <code>Box</code> wskazuje na nowÄ… instancjÄ™ struktury <code>Draft</code>. To zapewnia, Å¼e za kaÅ¼dym razem, gdy tworzymy nowÄ… instancjÄ™ <code>Post</code>, zaczyna ona jako szkic. PoniewaÅ¼ pole <code>state</code> w <code>Post</code> jest prywatne, nie ma moÅ¼liwoÅ›ci utworzenia <code>Post</code> w Å¼adnym innym stanie! W funkcji <code>Post::new</code> ustawiamy pole <code>content</code> na nowy, pusty <code>String</code>.</p>
<h4 id="przechowywanie-tekstu-treÅ›ci-wpisu"><a class="header" href="#przechowywanie-tekstu-treÅ›ci-wpisu">Przechowywanie Tekstu TreÅ›ci Wpisu</a></h4>
<p>WidzieliÅ›my w LiÅ›cie 18-11, Å¼e chcemy mieÄ‡ moÅ¼liwoÅ›Ä‡ wywoÅ‚ania metody <code>add_text</code> i przekazania jej <code>&amp;str</code>, ktÃ³ry jest nastÄ™pnie dodawany jako tekstowa zawartoÅ›Ä‡ wpisu na blogu. Implementujemy to jako metodÄ™, zamiast udostÄ™pniaÄ‡ pole <code>content</code> jako <code>pub</code>, aby pÃ³Åºniej mÃ³c zaimplementowaÄ‡ metodÄ™, ktÃ³ra bÄ™dzie kontrolowaÄ‡, w jaki sposÃ³b odczytywane sÄ… dane pola <code>content</code>. Metoda <code>add_text</code> jest doÅ›Ä‡ prosta, wiÄ™c dodajmy implementacjÄ™ z Listy 18-13 do bloku <code>impl Post</code>.</p>
<figure class="listing" id="listing-18-13">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
<figcaption><a href="#listing-18-13">Lista 18-13</a>: Implementacja metody <code>add_text</code> do dodawania tekstu do <code>content</code> wpisu</figcaption>
</figure>
<p>Metoda <code>add_text</code> przyjmuje zmiennÄ… referencjÄ™ do <code>self</code>, poniewaÅ¼ zmieniamy instancjÄ™ <code>Post</code>, na ktÃ³rej wywoÅ‚ujemy <code>add_text</code>. NastÄ™pnie wywoÅ‚ujemy <code>push_str</code> na <code>String</code> w <code>content</code> i przekazujemy argument <code>text</code>, aby dodaÄ‡ go do zapisanej <code>content</code>. To zachowanie nie zaleÅ¼y od stanu, w jakim znajduje siÄ™ wpis, wiÄ™c nie jest czÄ™Å›ciÄ… wzorca stanu. Metoda <code>add_text</code> w ogÃ³le nie wchodzi w interakcje z polem <code>state</code>, ale jest czÄ™Å›ciÄ… zachowania, ktÃ³re chcemy wspieraÄ‡.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="ensuring-the-content-of-a-draft-post-is-empty"></a></p>
<h4 id="zapewnienie-Å¼e-zawartoÅ›Ä‡-szkicu-wpisu-jest-pusta"><a class="header" href="#zapewnienie-Å¼e-zawartoÅ›Ä‡-szkicu-wpisu-jest-pusta">Zapewnienie, Å¼e ZawartoÅ›Ä‡ Szkicu Wpisu Jest Pusta</a></h4>
<p>Nawet po wywoÅ‚aniu <code>add_text</code> i dodaniu treÅ›ci do naszego wpisu, nadal chcemy, aby metoda <code>content</code> zwracaÅ‚a pusty fragment ciÄ…gu, poniewaÅ¼ wpis jest nadal w stanie szkicu, jak pokazano przez pierwsze <code>assert_eq!</code> na LiÅ›cie 18-11. Na razie zaimplementujmy metodÄ™ <code>content</code> w najprostszy sposÃ³b, ktÃ³ry speÅ‚ni to wymaganie: zawsze zwracajÄ…c pusty fragment ciÄ…gu. Zmienimy to pÃ³Åºniej, gdy zaimplementujemy moÅ¼liwoÅ›Ä‡ zmiany stanu wpisu, tak aby mÃ³gÅ‚ zostaÄ‡ opublikowany. Do tej pory wpisy mogÄ… byÄ‡ tylko w stanie szkicu, wiÄ™c zawartoÅ›Ä‡ wpisu powinna byÄ‡ zawsze pusta. Lista 18-14 pokazuje tÄ™ implementacjÄ™ zastÄ™pczÄ….</p>
<figure class="listing" id="listing-18-14">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        ""
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
<figcaption><a href="#listing-18-14">Lista 18-14</a>: Dodanie implementacji zastÄ™pczej dla metody <code>content</code> w <code>Post</code>, ktÃ³ra zawsze zwraca pusty fragment ciÄ…gu</figcaption>
</figure>
<p>DziÄ™ki tej dodanej metodzie <code>content</code> wszystko z Listy 18-11 aÅ¼ do pierwszego <code>assert_eq!</code> dziaÅ‚a zgodnie z przeznaczeniem.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="requesting-a-review-of-the-post-changes-its-state"></a>
<a id="requesting-a-review-changes-the-posts-state"></a></p>
<h4 id="zlecenie-recenzji-ktÃ³ra-zmienia-stan-wpisu"><a class="header" href="#zlecenie-recenzji-ktÃ³ra-zmienia-stan-wpisu">Zlecenie recenzji, ktÃ³ra zmienia stan wpisu</a></h4>
<p>NastÄ™pnie musimy dodaÄ‡ funkcjonalnoÅ›Ä‡ do Å¼Ä…dania recenzji wpisu, co powinno zmieniÄ‡ jego stan ze <code>Draft</code> na <code>PendingReview</code>. Lista 18-15 pokazuje ten kod.</p>
<figure class="listing" id="listing-18-15">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
<figcaption><a href="#listing-18-15">Lista 18-15</a>: Implementacja metod <code>request_review</code> w <code>Post</code> i cechy <code>State</code></figcaption>
</figure>
<p>Dajemy <code>Post</code> publicznÄ… metodÄ™ <code>request_review</code>, ktÃ³ra przyjmuje zmiennÄ… referencjÄ™ do <code>self</code>. NastÄ™pnie wywoÅ‚ujemy wewnÄ™trznÄ… metodÄ™ <code>request_review</code> na bieÅ¼Ä…cym stanie <code>Post</code>, a ta druga metoda <code>request_review</code> konsumuje bieÅ¼Ä…cy stan i zwraca nowy stan.</p>
<p>Dodajemy metodÄ™ <code>request_review</code> do cechy <code>State</code>; wszystkie typy, ktÃ³re implementujÄ… tÄ™ cechÄ™, bÄ™dÄ… teraz musiaÅ‚y zaimplementowaÄ‡ metodÄ™ <code>request_review</code>. ZauwaÅ¼, Å¼e zamiast <code>self</code>, <code>&amp;self</code> lub <code>&amp;mut self</code> jako pierwszego parametru metody, mamy <code>self: Box&lt;Self&gt;</code>. Ta skÅ‚adnia oznacza, Å¼e metoda jest prawidÅ‚owa tylko wtedy, gdy jest wywoÅ‚ywana na <code>Box</code> zawierajÄ…cym ten typ. Ta skÅ‚adnia przejmuje wÅ‚asnoÅ›Ä‡ <code>Box&lt;Self&gt;</code>, uniewaÅ¼niajÄ…c stary stan, tak aby wartoÅ›Ä‡ stanu <code>Post</code> mogÅ‚a przeksztaÅ‚ciÄ‡ siÄ™ w nowy stan.</p>
<p>Aby skonsumowaÄ‡ stary stan, metoda <code>request_review</code> musi przejÄ…Ä‡ wÅ‚asnoÅ›Ä‡ wartoÅ›ci stanu. To tutaj wchodzi w grÄ™ <code>Option</code> w polu <code>state</code> struktury <code>Post</code>: wywoÅ‚ujemy metodÄ™ <code>take</code>, aby pobraÄ‡ wartoÅ›Ä‡ <code>Some</code> z pola <code>state</code> i pozostawiÄ‡ <code>None</code> na jej miejscu, poniewaÅ¼ Rust nie pozwala nam mieÄ‡ niezapelnionych pÃ³l w strukturach. To pozwala nam przenieÅ›Ä‡ wartoÅ›Ä‡ <code>state</code> z <code>Post</code>, zamiast jej poÅ¼yczaÄ‡. NastÄ™pnie ustawimy wartoÅ›Ä‡ <code>state</code> wpisu na wynik tej operacji.</p>
<p>Musimy tymczasowo ustawiÄ‡ <code>state</code> na <code>None</code>, zamiast ustawiaÄ‡ go bezpoÅ›rednio kodem takim jak <code>self.state = self.state.request_review();</code>, aby uzyskaÄ‡ wÅ‚asnoÅ›Ä‡ wartoÅ›ci <code>state</code>. Zapewnia to, Å¼e <code>Post</code> nie moÅ¼e uÅ¼ywaÄ‡ starej wartoÅ›ci <code>state</code> po tym, jak przeksztaÅ‚ciliÅ›my jÄ… w nowy stan.</p>
<p>Metoda <code>request_review</code> w <code>Draft</code> zwraca nowÄ…, opakowanÄ… instancjÄ™ nowej struktury <code>PendingReview</code>, ktÃ³ra reprezentuje stan, gdy wpis oczekuje na recenzjÄ™. Struktura <code>PendingReview</code> rÃ³wnieÅ¼ implementuje metodÄ™ <code>request_review</code>, ale nie wykonuje Å¼adnych transformacji. Zamiast tego zwraca siebie, poniewaÅ¼ gdy prosimy o recenzjÄ™ wpisu, ktÃ³ry jest juÅ¼ w stanie <code>PendingReview</code>, powinien on pozostaÄ‡ w stanie <code>PendingReview</code>.</p>
<p>Teraz moÅ¼emy zaczÄ…Ä‡ dostrzegaÄ‡ zalety wzorca stanu: metoda <code>request_review</code> w <code>Post</code> jest taka sama niezaleÅ¼nie od jej wartoÅ›ci <code>state</code>. KaÅ¼dy stan jest odpowiedzialny za wÅ‚asne reguÅ‚y.</p>
<p>Pozostawimy metodÄ™ <code>content</code> w <code>Post</code> w niezmienionej postaci, zwracajÄ…c pusty fragment ciÄ…gu. MoÅ¼emy teraz mieÄ‡ <code>Post</code> w stanie <code>PendingReview</code>, a takÅ¼e w stanie <code>Draft</code>, ale chcemy tego samego zachowania w stanie <code>PendingReview</code>. Lista 18-11 dziaÅ‚a teraz aÅ¼ do drugiego wywoÅ‚ania <code>assert_eq!</code>!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="adding-the-approve-method-that-changes-the-behavior-of-content"></a>
<a id="adding-approve-to-change-the-behavior-of-content"></a></p>
<h4 id="dodawanie-approve-w-celu-zmiany-zachowania-content"><a class="header" href="#dodawanie-approve-w-celu-zmiany-zachowania-content">Dodawanie <code>approve</code> w celu zmiany zachowania <code>content</code></a></h4>
<p>Metoda <code>approve</code> bÄ™dzie podobna do metody <code>request_review</code>: ustawi <code>state</code> na wartoÅ›Ä‡, ktÃ³rÄ… bieÅ¼Ä…cy stan powinien mieÄ‡ po zatwierdzeniu, jak pokazano na LiÅ›cie 18-16.</p>
<figure class="listing" id="listing-18-16">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
<figcaption><a href="#listing-18-16">Lista 18-16</a>: Implementacja metody <code>approve</code> w <code>Post</code> i cechy <code>State</code></figcaption>
</figure>
<p>Dodajemy metodÄ™ <code>approve</code> do cechy <code>State</code> i nowÄ… strukturÄ™, ktÃ³ra implementuje <code>State</code>, czyli stan <code>Published</code>.</p>
<p>Podobnie jak dziaÅ‚a <code>request_review</code> w <code>PendingReview</code>, jeÅ›li wywoÅ‚amy metodÄ™ <code>approve</code> na <code>Draft</code>, nie bÄ™dzie to miaÅ‚o Å¼adnego efektu, poniewaÅ¼ <code>approve</code> zwrÃ³ci <code>self</code>. Kiedy wywoÅ‚amy <code>approve</code> na <code>PendingReview</code>, zwrÃ³ci nowÄ…, spakowanÄ… instancjÄ™ struktury <code>Published</code>. Struktura <code>Published</code> implementuje cechÄ™ <code>State</code>, a dla obu metod <code>request_review</code> i <code>approve</code> zwraca siebie, poniewaÅ¼ w tych przypadkach wpis powinien pozostaÄ‡ w stanie <code>Published</code>.</p>
<p>Teraz musimy zaktualizowaÄ‡ metodÄ™ <code>content</code> w <code>Post</code>. Chcemy, aby wartoÅ›Ä‡ zwracana przez <code>content</code> zaleÅ¼aÅ‚a od bieÅ¼Ä…cego stanu <code>Post</code>, dlatego <code>Post</code> bÄ™dzie delegowaÄ‡ do metody <code>content</code> zdefiniowanej na swoim <code>state</code>, jak pokazano na LiÅ›cie 18-17.</p>
<figure class="listing" id="listing-18-17">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait State {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Published {}
</span><span class="boring">
</span><span class="boring">impl State for Published {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-18-17">Lista 18-17</a>: Aktualizacja metody <code>content</code> w <code>Post</code> w celu delegowania do metody <code>content</code> w <code>State</code></figcaption>
</figure>
<p>PoniewaÅ¼ celem jest utrzymanie wszystkich tych zasad wewnÄ…trz struktur implementujÄ…cych <code>State</code>, wywoÅ‚ujemy metodÄ™ <code>content</code> na wartoÅ›ci w <code>state</code> i przekazujemy instancjÄ™ wpisu (czyli <code>self</code>) jako argument. NastÄ™pnie zwracamy wartoÅ›Ä‡ zwrÃ³conÄ… przez uÅ¼ycie metody <code>content</code> na wartoÅ›ci <code>state</code>.</p>
<p>WywoÅ‚ujemy metodÄ™ <code>as_ref</code> na <code>Option</code>, poniewaÅ¼ chcemy referencjÄ™ do wartoÅ›ci wewnÄ…trz <code>Option</code>, a nie wÅ‚asnoÅ›ci wartoÅ›ci. PoniewaÅ¼ <code>state</code> jest <code>Option&lt;Box&lt;dyn State&gt;&gt;</code>, po wywoÅ‚aniu <code>as_ref</code> zwracane jest <code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code>. GdybyÅ›my nie wywoÅ‚ali <code>as_ref</code>, otrzymalibyÅ›my bÅ‚Ä…d, poniewaÅ¼ nie moÅ¼emy przenieÅ›Ä‡ <code>state</code> poza poÅ¼yczone <code>&amp;self</code> z parametru funkcji.</p>
<p>NastÄ™pnie wywoÅ‚ujemy metodÄ™ <code>unwrap</code>, o ktÃ³rej wiemy, Å¼e nigdy nie spowoduje paniki, poniewaÅ¼ wiemy, Å¼e metody w <code>Post</code> zapewniajÄ…, Å¼e <code>state</code> zawsze bÄ™dzie zawieraÄ‡ wartoÅ›Ä‡ <code>Some</code> po zakoÅ„czeniu tych metod. Jest to jeden z przypadkÃ³w, o ktÃ³rych mÃ³wiliÅ›my w sekcji <a href="#cases-in-which-you-have-more-information-than-the-compiler">â€Kiedy masz wiÄ™cej informacji niÅ¼ kompilatorâ€</a><!-- ignore --> w Rozdziale 9, kiedy wiemy, Å¼e wartoÅ›Ä‡ <code>None</code> nigdy nie jest moÅ¼liwa, mimo Å¼e kompilator nie jest w stanie tego zrozumieÄ‡.</p>
<p>W tym momencie, gdy wywoÅ‚amy <code>content</code> na <code>&amp;Box&lt;dyn State&gt;</code>, nastÄ…pi koercja dereferencji na <code>&amp;</code> i <code>Box</code>, tak Å¼e metoda <code>content</code> zostanie ostatecznie wywoÅ‚ana na typie, ktÃ³ry implementuje cechÄ™ <code>State</code>. Oznacza to, Å¼e musimy dodaÄ‡ <code>content</code> do definicji cechy <code>State</code>, i to tam umieÅ›cimy logikÄ™ dotyczÄ…cÄ… tego, jakÄ… zawartoÅ›Ä‡ zwrÃ³ciÄ‡ w zaleÅ¼noÅ›ci od posiadanego stanu, jak pokazano na LiÅ›cie 18-18.</p>
<figure class="listing" id="listing-18-18">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.state.as_ref().unwrap().content(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait State {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        ""
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Published {}

impl State for Published {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}</code></pre>
<figcaption><a href="#listing-18-18">Lista 18-18</a>: Dodanie metody <code>content</code> do cechy <code>State</code></figcaption>
</figure>
<p>Dodajemy domyÅ›lnÄ… implementacjÄ™ metody <code>content</code>, ktÃ³ra zwraca pusty fragment ciÄ…gu. Oznacza to, Å¼e nie musimy implementowaÄ‡ <code>content</code> w strukturach <code>Draft</code> i <code>PendingReview</code>. Struktura <code>Published</code> nadpisze metodÄ™ <code>content</code> i zwrÃ³ci wartoÅ›Ä‡ z <code>post.content</code>. ChoÄ‡ wygodne, posiadanie metody <code>content</code> w <code>State</code>, ktÃ³ra okreÅ›la zawartoÅ›Ä‡ <code>Post</code>, zaciera granice miÄ™dzy odpowiedzialnoÅ›ciÄ… <code>State</code> a odpowiedzialnoÅ›ciÄ… <code>Post</code>.</p>
<p>ZauwaÅ¼, Å¼e potrzebujemy adnotacji dotyczÄ…cych czasu Å¼ycia w tej metodzie, jak omÃ³wiliÅ›my w Rozdziale 10. Przyjmujemy referencjÄ™ do <code>post</code> jako argument i zwracamy referencjÄ™ do czÄ™Å›ci tego <code>post</code>, wiÄ™c czas Å¼ycia zwrÃ³conej referencji jest zwiÄ…zany z czasem Å¼ycia argumentu <code>post</code>.</p>
<p>I gotowe â€” caÅ‚a Lista 18-11 dziaÅ‚a! ZaimplementowaliÅ›my wzorzec stanu z zasadami przepÅ‚ywu pracy wpisu na blogu. Logika zwiÄ…zana z zasadami znajduje siÄ™ w obiektach stanu, a nie jest rozproszona po <code>Post</code>.</p>
<section class="note" aria-role="note">
<h3 id="dlaczego-nie-wyliczenie-enum"><a class="header" href="#dlaczego-nie-wyliczenie-enum">Dlaczego Nie Wyliczenie (Enum)?</a></h3>
<p>ByÄ‡ moÅ¼e zastanawiaÅ‚eÅ› siÄ™, dlaczego nie uÅ¼yliÅ›my wyliczenia (enum) z rÃ³Å¼nymi moÅ¼liwymi stanami wpisu jako wariantami. To z pewnoÅ›ciÄ… moÅ¼liwe rozwiÄ…zanie; sprÃ³buj go i porÃ³wnaj ostateczne wyniki, aby zobaczyÄ‡, ktÃ³re wolisz! JednÄ… z wad uÅ¼ywania wyliczenia jest to, Å¼e kaÅ¼de miejsce, ktÃ³re sprawdza wartoÅ›Ä‡ wyliczenia, bÄ™dzie potrzebowaÅ‚o wyraÅ¼enia <code>match</code> lub podobnego, aby obsÅ‚uÅ¼yÄ‡ kaÅ¼dy moÅ¼liwy wariant. To mogÅ‚oby staÄ‡ siÄ™ bardziej powtarzalne niÅ¼ to rozwiÄ…zanie z obiektem cechy.</p>
</section>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="trade-offs-of-the-state-pattern"></a></p>
<h4 id="ocena-wzorca-stanu"><a class="header" href="#ocena-wzorca-stanu">Ocena Wzorca Stanu</a></h4>
<p>PokazaliÅ›my, Å¼e Rust jest zdolny do implementacji obiektowo zorientowanego wzorca stanu w celu hermetyzacji rÃ³Å¼nych rodzajÃ³w zachowaÅ„, jakie powinien mieÄ‡ wpis w kaÅ¼dym stanie. Metody w <code>Post</code> nic nie wiedzÄ… o rÃ³Å¼nych zachowaniach. DziÄ™ki temu, jak zorganizowaliÅ›my kod, musimy patrzeÄ‡ tylko w jedno miejsce, aby poznaÄ‡ rÃ³Å¼ne sposoby zachowania opublikowanego wpisu: implementacjÄ™ cechy <code>State</code> na strukturze <code>Published</code>.</p>
<p>GdybyÅ›my stworzyli alternatywnÄ… implementacjÄ™, ktÃ³ra nie uÅ¼ywaÅ‚aby wzorca stanu, moglibyÅ›my zamiast tego uÅ¼yÄ‡ wyraÅ¼eÅ„ <code>match</code> w metodach w <code>Post</code> lub nawet w kodzie <code>main</code>, ktÃ³ry sprawdza stan wpisu i zmienia zachowanie w tych miejscach. OznaczaÅ‚oby to, Å¼e musielibyÅ›my patrzeÄ‡ w kilku miejscach, aby zrozumieÄ‡ wszystkie implikacje bycia w stanie opublikowanym.</p>
<p>Przy uÅ¼yciu wzorca stanu, metody <code>Post</code> i miejsca, w ktÃ³rych uÅ¼ywamy <code>Post</code>, nie potrzebujÄ… wyraÅ¼eÅ„ <code>match</code>, a aby dodaÄ‡ nowy stan, wystarczyÅ‚oby dodaÄ‡ nowÄ… strukturÄ™ i zaimplementowaÄ‡ metody cech na tej jednej strukturze w jednym miejscu.</p>
<p>Implementacja wykorzystujÄ…ca wzorzec stanu jest Å‚atwa do rozszerzenia o dodatkowÄ… funkcjonalnoÅ›Ä‡. Aby zobaczyÄ‡ prostotÄ™ utrzymywania kodu, ktÃ³ry uÅ¼ywa wzorca stanu, wyprÃ³buj kilka z tych sugestii:</p>
<ul>
<li>Dodaj metodÄ™ <code>reject</code>, ktÃ³ra zmienia stan wpisu z <code>PendingReview</code> z powrotem na <code>Draft</code>.</li>
<li>Wymagaj dwÃ³ch wywoÅ‚aÅ„ <code>approve</code>, zanim stan bÄ™dzie mÃ³gÅ‚ zostaÄ‡ zmieniony na <code>Published</code>.</li>
<li>Zezwalaj uÅ¼ytkownikom na dodawanie treÅ›ci tekstowej tylko wtedy, gdy wpis jest w stanie <code>Draft</code>.
WskazÃ³wka: niech obiekt stanu bÄ™dzie odpowiedzialny za to, co moÅ¼e siÄ™ zmieniÄ‡ w treÅ›ci, ale nie za modyfikowanie <code>Post</code>.</li>
</ul>
<p>JednÄ… z wad wzorca stanu jest to, Å¼e poniewaÅ¼ stany implementujÄ… przejÅ›cia miÄ™dzy stanami, niektÃ³re stany sÄ… ze sobÄ… powiÄ…zane. GdybyÅ›my dodali inny stan miÄ™dzy <code>PendingReview</code> a <code>Published</code>, taki jak <code>Scheduled</code>, musielibyÅ›my zmieniÄ‡ kod w <code>PendingReview</code>, aby przejÅ›Ä‡ do <code>Scheduled</code>. ByÅ‚oby to mniej pracy, gdyby <code>PendingReview</code> nie wymagaÅ‚o zmian wraz z dodaniem nowego stanu, ale to oznaczaÅ‚oby przejÅ›cie na inny wzorzec projektowy.</p>
<p>InnÄ… wadÄ… jest to, Å¼e powieliliÅ›my trochÄ™ logiki. Aby wyeliminowaÄ‡ czÄ™Å›Ä‡ powtÃ³rzeÅ„, moglibyÅ›my sprÃ³bowaÄ‡ stworzyÄ‡ domyÅ›lne implementacje dla metod <code>request_review</code> i <code>approve</code> w cechy <code>State</code>, ktÃ³re zwracajÄ… <code>self</code>. Jednak to by nie zadziaÅ‚aÅ‚o: uÅ¼ywajÄ…c <code>State</code> jako obiektu cechy, cecha nie wie dokÅ‚adnie, czym bÄ™dzie konkretny <code>self</code>, wiÄ™c typ zwracany nie jest znany w czasie kompilacji. (To jedna z wczeÅ›niej wspomnianych reguÅ‚ kompatybilnoÅ›ci <code>dyn</code>).</p>
<p>Inne powtÃ³rzenia obejmujÄ… podobne implementacje metod <code>request_review</code> i <code>approve</code> w <code>Post</code>. Obie metody uÅ¼ywajÄ… <code>Option::take</code> z polem <code>state</code> z <code>Post</code>, a jeÅ›li <code>state</code> jest <code>Some</code>, delegujÄ… do implementacji tej samej metody przez owiniÄ™tÄ… wartoÅ›Ä‡ i ustawiajÄ… nowÄ… wartoÅ›Ä‡ pola <code>state</code> na wynik. GdybyÅ›my mieli wiele metod w <code>Post</code>, ktÃ³re postÄ™powaÅ‚yby zgodnie z tym wzorcem, moglibyÅ›my rozwaÅ¼yÄ‡ zdefiniowanie makra, aby wyeliminowaÄ‡ powtÃ³rzenia (patrz sekcja <a href="#macros">â€Makrodefinicjeâ€</a><!-- ignore --> w Rozdziale 20).</p>
<p>ImplementujÄ…c wzorzec stanu dokÅ‚adnie tak, jak jest zdefiniowany dla jÄ™zykÃ³w zorientowanych obiektowo, nie wykorzystujemy w peÅ‚ni mocnych stron Rust. Przyjrzyjmy siÄ™ kilku zmianom, ktÃ³re moÅ¼emy wprowadziÄ‡ w bibliotece <code>blog</code>, aby nieprawidÅ‚owe stany i przejÅ›cia staÅ‚y siÄ™ bÅ‚Ä™dami w czasie kompilacji.</p>
<h3 id="kodowanie-stanÃ³w-i-zachowania-jako-typy"><a class="header" href="#kodowanie-stanÃ³w-i-zachowania-jako-typy">Kodowanie StanÃ³w i Zachowania jako Typy</a></h3>
<p>PokaÅ¼emy, jak przemyÅ›leÄ‡ wzorzec stanu, aby uzyskaÄ‡ inny zestaw kompromisÃ³w. Zamiast caÅ‚kowicie hermetyzowaÄ‡ stany i przejÅ›cia, tak aby zewnÄ™trzny kod nie miaÅ‚ o nich wiedzy, zakodujemy stany w rÃ³Å¼nych typach. W konsekwencji system sprawdzania typÃ³w Rust zapobiegnie prÃ³bom uÅ¼ycia szkicÃ³w wpisÃ³w tam, gdzie dozwolone sÄ… tylko opublikowane wpisy, zgÅ‚aszajÄ…c bÅ‚Ä…d kompilacji.</p>
<p>RozwaÅ¼my pierwszÄ… czÄ™Å›Ä‡ <code>main</code> na LiÅ›cie 18-11:</p>
<figure class="listing">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use blog::Post;
</span><span class="boring">
</span>fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());
<span class="boring">
</span><span class="boring">    post.request_review();
</span><span class="boring">    assert_eq!("", post.content());
</span><span class="boring">
</span><span class="boring">    post.approve();
</span><span class="boring">    assert_eq!("I ate a salad for lunch today", post.content());
</span>}</code></pre>
</figure>
<p>Dalej umoÅ¼liwiamy tworzenie nowych wpisÃ³w w stanie szkicu za pomocÄ… <code>Post::new</code> oraz moÅ¼liwoÅ›Ä‡ dodawania tekstu do treÅ›ci wpisu. Ale zamiast mieÄ‡ metodÄ™ <code>content</code> w szkicu wpisu, ktÃ³ra zwraca pusty ciÄ…g, sprawimy, Å¼e szkice wpisÃ³w w ogÃ³le nie bÄ™dÄ… miaÅ‚y metody <code>content</code>. W ten sposÃ³b, jeÅ›li sprÃ³bujemy uzyskaÄ‡ treÅ›Ä‡ szkicu wpisu, otrzymamy bÅ‚Ä…d kompilatora informujÄ…cy nas, Å¼e metoda nie istnieje. W rezultacie niemoÅ¼liwe bÄ™dzie przypadkowe wyÅ›wietlenie treÅ›ci szkicu wpisu w produkcji, poniewaÅ¼ ten kod nawet siÄ™ nie skompiluje. Lista 18-19 pokazuje definicjÄ™ struktury <code>Post</code> i struktury <code>DraftPost</code>, a takÅ¼e metody na kaÅ¼dej z nich.</p>
<figure class="listing" id="listing-18-19">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}</code></pre>
<figcaption><a href="#listing-18-19">Lista 18-19</a>: <code>Post</code> z metodÄ… <code>content</code> i <code>DraftPost</code> bez metody <code>content</code></figcaption>
</figure>
<p>ZarÃ³wno struktury <code>Post</code>, jak i <code>DraftPost</code> majÄ… prywatne pole <code>content</code>, ktÃ³re przechowuje tekst wpisu na blogu. Struktury nie majÄ… juÅ¼ pola <code>state</code>, poniewaÅ¼ przenosimy kodowanie stanu do typÃ³w struktur. Struktura <code>Post</code> bÄ™dzie reprezentowaÄ‡ opublikowany wpis i ma metodÄ™ <code>content</code>, ktÃ³ra zwraca <code>content</code>.</p>
<p>Dalej mamy funkcjÄ™ <code>Post::new</code>, ale zamiast zwracaÄ‡ instancjÄ™ <code>Post</code>, zwraca instancjÄ™ <code>DraftPost</code>. PoniewaÅ¼ <code>content</code> jest prywatne i nie ma Å¼adnych funkcji zwracajÄ…cych <code>Post</code>, obecnie nie jest moÅ¼liwe utworzenie instancji <code>Post</code>.</p>
<p>Struktura <code>DraftPost</code> posiada metodÄ™ <code>add_text</code>, wiÄ™c moÅ¼emy dodawaÄ‡ tekst do <code>content</code> tak jak wczeÅ›niej, ale zauwaÅ¼, Å¼e <code>DraftPost</code> nie ma zdefiniowanej metody <code>content</code>! Teraz program zapewnia, Å¼e wszystkie wpisy zaczynajÄ… siÄ™ jako szkice wpisÃ³w, a szkice wpisÃ³w nie majÄ… dostÄ™pnej treÅ›ci do wyÅ›wietlenia. KaÅ¼da prÃ³ba obejÅ›cia tych ograniczeÅ„ spowoduje bÅ‚Ä…d kompilatora.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="implementing-transitions-as-transformations-into-different-types"></a></p>
<p>WiÄ™c jak zdobyÄ‡ opublikowany wpis? Chcemy wymusiÄ‡ zasadÄ™, Å¼e szkic wpisu musi zostaÄ‡ zrecenzowany i zatwierdzony, zanim zostanie opublikowany. Wpis w stanie oczekiwania na recenzjÄ™ nadal nie powinien wyÅ›wietlaÄ‡ Å¼adnej treÅ›ci. Zaimplementujmy te ograniczenia, dodajÄ…c kolejnÄ… strukturÄ™, <code>PendingReviewPost</code>, definiujÄ…c metodÄ™ <code>request_review</code> w <code>DraftPost</code>, aby zwracaÅ‚a <code>PendingReviewPost</code>, i definiujÄ…c metodÄ™ <code>approve</code> w <code>PendingReviewPost</code>, aby zwracaÅ‚a <code>Post</code>, jak pokazano na LiÅ›cie 18-20.</p>
<figure class="listing" id="listing-18-20">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; DraftPost {
</span><span class="boring">        DraftPost {
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.content
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --snip--
<span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}</code></pre>
<figcaption><a href="#listing-18-20">Lista 18-20</a>: Struktura <code>PendingReviewPost</code>, ktÃ³ra jest tworzona poprzez wywoÅ‚anie <code>request_review</code> na <code>DraftPost</code>, oraz metoda <code>approve</code>, ktÃ³ra zamienia <code>PendingReviewPost</code> w opublikowany <code>Post</code></figcaption>
</figure>
<p>Metody <code>request_review</code> i <code>approve</code> przejmujÄ… wÅ‚asnoÅ›Ä‡ <code>self</code>, konsumujÄ…c w ten sposÃ³b instancje <code>DraftPost</code> i <code>PendingReviewPost</code> i przeksztaÅ‚cajÄ…c je odpowiednio w <code>PendingReviewPost</code> i opublikowany <code>Post</code>. W ten sposÃ³b nie bÄ™dziemy mieÄ‡ Å¼adnych pozostaÅ‚ych instancji <code>DraftPost</code> po wywoÅ‚aniu na nich <code>request_review</code> i tak dalej. Struktura <code>PendingReviewPost</code> nie ma zdefiniowanej metody <code>content</code>, wiÄ™c prÃ³ba odczytania jej treÅ›ci skutkuje bÅ‚Ä™dem kompilacji, podobnie jak w przypadku <code>DraftPost</code>. PoniewaÅ¼ jedynym sposobem na uzyskanie opublikowanej instancji <code>Post</code>, ktÃ³ra ma zdefiniowanÄ… metodÄ™ <code>content</code>, jest wywoÅ‚anie metody <code>approve</code> na <code>PendingReviewPost</code>, a jedynym sposobem na uzyskanie <code>PendingReviewPost</code> jest wywoÅ‚anie metody <code>request_review</code> na <code>DraftPost</code>, zakodowaliÅ›my teraz przepÅ‚yw pracy wpisu na blogu w systemie typÃ³w.</p>
<p>Musimy jednak wprowadziÄ‡ rÃ³wnieÅ¼ niewielkie zmiany w <code>main</code>. Metody <code>request_review</code> i <code>approve</code> zwracajÄ… nowe instancje zamiast modyfikowaÄ‡ strukturÄ™, na ktÃ³rej sÄ… wywoÅ‚ywane, wiÄ™c musimy dodaÄ‡ wiÄ™cej przypisaÅ„ <code>let post =</code> w celu zapisania zwrÃ³conych instancji. Nie moÅ¼emy teÅ¼ mieÄ‡ asercji dotyczÄ…cych pustych ciÄ…gÃ³w w treÅ›ci szkicÃ³w i wpisÃ³w oczekujÄ…cych na recenzjÄ™, ani ich nie potrzebujemy: nie moÅ¼emy juÅ¼ skompilowaÄ‡ kodu, ktÃ³ry prÃ³buje uÅ¼yÄ‡ treÅ›ci wpisÃ³w w tych stanach. Zaktualizowany kod w <code>main</code> pokazano na LiÅ›cie 18-21.</p>
<figure class="listing" id="listing-18-21">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("I ate a salad for lunch today", post.content());
}</code></pre>
<figcaption><a href="#listing-18-21">Lista 18-21</a>: Modyfikacje w <code>main</code> w celu uÅ¼ycia nowej implementacji przepÅ‚ywu pracy wpisu na blogu</figcaption>
</figure>
<p>Zmiany, ktÃ³re musieliÅ›my wprowadziÄ‡ w <code>main</code>, aby ponownie przypisaÄ‡ <code>post</code>, oznaczajÄ…, Å¼e ta implementacja nie do koÅ„ca juÅ¼ odpowiada wzorcowi stanu zorientowanemu obiektowo: transformacje miÄ™dzy stanami nie sÄ… juÅ¼ w peÅ‚ni hermetyzowane w implementacji <code>Post</code>. Jednak naszym zyskiem jest to, Å¼e nieprawidÅ‚owe stany sÄ… teraz niemoÅ¼liwe dziÄ™ki systemowi typÃ³w i sprawdzaniu typÃ³w, ktÃ³re odbywa siÄ™ w czasie kompilacji! To zapewnia, Å¼e pewne bÅ‚Ä™dy, takie jak wyÅ›wietlanie treÅ›ci nieopublikowanego wpisu, zostanÄ… wykryte, zanim trafiÄ… do produkcji.</p>
<p>WyprÃ³buj zadania sugerowane na poczÄ…tku tej sekcji na bibliotece <code>blog</code> w stanie po LiÅ›cie 18-21, aby zobaczyÄ‡, co myÅ›lisz o projekcie tej wersji kodu. ZauwaÅ¼, Å¼e niektÃ³re zadania mogÄ… byÄ‡ juÅ¼ ukoÅ„czone w tym projekcie.</p>
<p>WidzieliÅ›my, Å¼e chociaÅ¼ Rust jest w stanie implementowaÄ‡ obiektowo zorientowane wzorce projektowe, inne wzorce, takie jak kodowanie stanu w systemie typÃ³w, sÄ… rÃ³wnieÅ¼ dostÄ™pne w Rust. Te wzorce majÄ… rÃ³Å¼ne kompromisy. ChociaÅ¼ moÅ¼esz byÄ‡ bardzo zaznajomiony z obiektowo zorientowanymi wzorcami, ponowne przemyÅ›lenie problemu w celu wykorzystania funkcji Rust moÅ¼e przynieÅ›Ä‡ korzyÅ›ci, takie jak zapobieganie niektÃ³rym bÅ‚Ä™dom w czasie kompilacji. Wzorce obiektowo zorientowane nie zawsze bÄ™dÄ… najlepszym rozwiÄ…zaniem w Rust ze wzglÄ™du na pewne cechy, takie jak wÅ‚asnoÅ›Ä‡, ktÃ³rych jÄ™zyki obiektowo zorientowane nie posiadajÄ….</p>
<h2 id="podsumowanie-17"><a class="header" href="#podsumowanie-17">Podsumowanie</a></h2>
<p>NiezaleÅ¼nie od tego, czy uwaÅ¼asz Rust za jÄ™zyk obiektowy po przeczytaniu tego rozdziaÅ‚u, wiesz juÅ¼, Å¼e moÅ¼esz uÅ¼ywaÄ‡ obiektÃ³w cech, aby uzyskaÄ‡ niektÃ³re cechy obiektowe w Rust. Dynamiczne wysyÅ‚anie moÅ¼e zapewniÄ‡ Twojemu kodowi pewnÄ… elastycznoÅ›Ä‡ w zamian za niewielki koszt wydajnoÅ›ci w czasie wykonania. MoÅ¼esz wykorzystaÄ‡ tÄ™ elastycznoÅ›Ä‡ do implementacji obiektowych wzorcÃ³w, ktÃ³re mogÄ… pomÃ³c w utrzymaniu kodu. Rust ma rÃ³wnieÅ¼ inne cechy, takie jak wÅ‚asnoÅ›Ä‡, ktÃ³rych jÄ™zyki obiektowe nie majÄ…. Wzorzec obiektowy nie zawsze bÄ™dzie najlepszym sposobem na wykorzystanie mocnych stron Rust, ale jest to dostÄ™pna opcja.</p>
<p>NastÄ™pnie przyjrzymy siÄ™ wzorcom, ktÃ³re sÄ… kolejnÄ… z funkcji Rust, ktÃ³re umoÅ¼liwiajÄ… duÅ¼Ä… elastycznoÅ›Ä‡. PrzyglÄ…daliÅ›my siÄ™ im krÃ³tko w caÅ‚ej ksiÄ…Å¼ce, ale nie widzieliÅ›my jeszcze ich peÅ‚nych moÅ¼liwoÅ›ci. Zacznijmy!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wzorce-i-dopasowywanie"><a class="header" href="#wzorce-i-dopasowywanie">Wzorce i Dopasowywanie</a></h1>
<p>Wzorce to specjalna skÅ‚adnia w Rust sÅ‚uÅ¼Ä…ca do dopasowywania struktury typÃ³w, zarÃ³wno zÅ‚oÅ¼onych, jak i prostych. UÅ¼ywanie wzorcÃ³w w poÅ‚Ä…czeniu z wyraÅ¼eniami <code>match</code> i innymi konstrukcjami daje wiÄ™kszÄ… kontrolÄ™ nad przepÅ‚ywem sterowania programu. Wzorzec skÅ‚ada siÄ™ z pewnej kombinacji nastÄ™pujÄ…cych elementÃ³w:</p>
<ul>
<li>LiteraÅ‚y</li>
<li>Zdekonstruowane tablice, wyliczenia, struktury lub krotki</li>
<li>Zmienne</li>
<li>Symbole wieloznaczne</li>
<li>ZastÄ™pcze miejsca</li>
</ul>
<p>PrzykÅ‚adowe wzorce to <code>x</code>, <code>(a, 3)</code> i <code>Some(Color::Red)</code>. W kontekstach, w ktÃ³rych wzorce sÄ… prawidÅ‚owe, te komponenty opisujÄ… ksztaÅ‚t danych. Nasz program dopasowuje wartoÅ›ci do wzorcÃ³w, aby okreÅ›liÄ‡, czy ma prawidÅ‚owy ksztaÅ‚t danych do kontynuowania wykonywania okreÅ›lonego fragmentu kodu.</p>
<p>Aby uÅ¼yÄ‡ wzorca, porÃ³wnujemy go z pewnÄ… wartoÅ›ciÄ…. JeÅ›li wzorzec pasuje do wartoÅ›ci, uÅ¼ywamy czÄ™Å›ci wartoÅ›ci w naszym kodzie. Przypomnij sobie wyraÅ¼enia <code>match</code> z RozdziaÅ‚u 6, ktÃ³re uÅ¼ywaÅ‚y wzorcÃ³w, takie jak przykÅ‚ad maszyny do sortowania monet. JeÅ›li wartoÅ›Ä‡ pasuje do ksztaÅ‚tu wzorca, moÅ¼emy uÅ¼yÄ‡ nazwanych elementÃ³w. JeÅ›li nie, kod powiÄ…zany ze wzorcem nie zostanie uruchomiony.</p>
<p>Ten rozdziaÅ‚ jest referencjÄ… do wszystkiego, co zwiÄ…zane ze wzorcami. OmÃ³wimy prawidÅ‚owe miejsca uÅ¼ycia wzorcÃ³w, rÃ³Å¼nicÄ™ miÄ™dzy wzorcami odrzucalnymi i nieodrzucalnymi oraz rÃ³Å¼ne rodzaje skÅ‚adni wzorcÃ³w, ktÃ³re moÅ¼esz zobaczyÄ‡. Pod koniec rozdziaÅ‚u bÄ™dziesz wiedzieÄ‡, jak uÅ¼ywaÄ‡ wzorcÃ³w do wyraÅ¼ania wielu koncepcji w jasny sposÃ³b.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wszystkie-miejsca-w-ktÃ³rych-moÅ¼na-uÅ¼ywaÄ‡-wzorcÃ³w-1"><a href="#wszystkie-miejsca-w-ktÃ³rych-moÅ¼na-uÅ¼ywaÄ‡-wzorcÃ³w-1" class="header">Wszystkie Miejsca, w KtÃ³rych MoÅ¼na UÅ¼ywaÄ‡ WzorcÃ³w</a></h1>
<h2 id="wszystkie-miejsca-w-ktÃ³rych-moÅ¼na-uÅ¼ywaÄ‡-wzorcÃ³w"><a class="header" href="#wszystkie-miejsca-w-ktÃ³rych-moÅ¼na-uÅ¼ywaÄ‡-wzorcÃ³w">Wszystkie Miejsca, w KtÃ³rych MoÅ¼na UÅ¼ywaÄ‡ WzorcÃ³w</a></h2>
<p>Wzorce pojawiajÄ… siÄ™ w wielu miejscach w Rust, a Ty uÅ¼ywaÅ‚eÅ› ich wiele razy, nie zdajÄ…c sobie z tego sprawy! Ta sekcja omawia wszystkie miejsca, w ktÃ³rych wzorce sÄ… prawidÅ‚owe.</p>
<h3 id="ramiona-match"><a class="header" href="#ramiona-match">Ramiona <code>match</code></a></h3>
<p>Jak omÃ³wiono w Rozdziale 6, uÅ¼ywamy wzorcÃ³w w ramionach wyraÅ¼eÅ„ <code>match</code>. Formalnie wyraÅ¼enia <code>match</code> sÄ… definiowane jako sÅ‚owo kluczowe <code>match</code>, wartoÅ›Ä‡ do dopasowania i jedno lub wiÄ™cej ramion dopasowania, ktÃ³re skÅ‚adajÄ… siÄ™ ze wzorca i wyraÅ¼enia do uruchomienia, jeÅ›li wartoÅ›Ä‡ pasuje do wzorca tego ramienia, w ten sposÃ³b:</p>
<!--
  Manually formatted rather than using Markdown intentionally: Markdown does not
  support italicizing code in the body of a block like this!
-->
<pre><code>match <em>WARTOÅšÄ†</em> {
    <em>WZORZEC</em> =&gt; <em>WYRAÅ»ENIE</em>,
    <em>WZORZEC</em> =&gt; <em>WYRAÅ»ENIE</em>,
    <em>WZORZEC</em> =&gt; <em>WYRAÅ»ENIE</em>,
}</code></pre>

<p>Na przykÅ‚ad, oto wyraÅ¼enie <code>match</code> z Listy 6-5, ktÃ³re dopasowuje wartoÅ›Ä‡ <code>Option&lt;i32&gt;</code> w zmiennej <code>x</code>:</p>
<pre><code class="language-rust ignore">match x {
    None =&gt; None,
    Some(i) =&gt; Some(i + 1),
}</code></pre>
<p>Wzorce w tym wyraÅ¼eniu <code>match</code> to <code>None</code> i <code>Some(i)</code> po lewej stronie kaÅ¼dej strzaÅ‚ki.</p>
<p>Jednym z wymagaÅ„ dla wyraÅ¼eÅ„ <code>match</code> jest to, Å¼e muszÄ… byÄ‡ wyczerpujÄ…ce w tym sensie, Å¼e wszystkie moÅ¼liwoÅ›ci dla wartoÅ›ci w wyraÅ¼eniu <code>match</code> muszÄ… byÄ‡ uwzglÄ™dnione. Jednym ze sposobÃ³w zapewnienia, Å¼e pokryÅ‚eÅ› kaÅ¼dÄ… moÅ¼liwoÅ›Ä‡, jest posiadanie wzorca catch-all dla ostatniego ramienia: na przykÅ‚ad nazwa zmiennej pasujÄ…ca do dowolnej wartoÅ›ci nigdy nie moÅ¼e siÄ™ nie powieÅ›Ä‡ i tym samym pokrywa kaÅ¼dy pozostaÅ‚y przypadek.</p>
<p>Konkretny wzorzec <code>_</code> pasuje do wszystkiego, ale nigdy nie wiÄ…Å¼e siÄ™ ze zmiennÄ…, wiÄ™c czÄ™sto jest uÅ¼ywany w ostatnim ramieniu <code>match</code>. Wzorzec <code>_</code> moÅ¼e byÄ‡ uÅ¼yteczny, gdy chcesz zignorowaÄ‡ dowolnÄ… nieokreÅ›lonÄ… wartoÅ›Ä‡, na przykÅ‚ad. OmÃ³wimy wzorzec <code>_</code> bardziej szczegÃ³Å‚owo w sekcji <a href="#ignoring-values-in-a-pattern">â€Ignorowanie wartoÅ›ci we wzorcuâ€</a><!-- ignore --> w dalszej czÄ™Å›ci tego rozdziaÅ‚u.</p>
<h3 id="instrukcje-let"><a class="header" href="#instrukcje-let">Instrukcje <code>let</code></a></h3>
<p>Przed tym rozdziaÅ‚em jawnie omawialiÅ›my uÅ¼ywanie wzorcÃ³w tylko z <code>match</code> i <code>if let</code>, ale w rzeczywistoÅ›ci uÅ¼ywaliÅ›my wzorcÃ³w rÃ³wnieÅ¼ w innych miejscach, w tym w instrukcjach <code>let</code>. Na przykÅ‚ad, rozwaÅ¼ to proste przypisanie zmiennej za pomocÄ… <code>let</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre>
<p>Za kaÅ¼dym razem, gdy uÅ¼ywaÅ‚eÅ› instrukcji <code>let</code> w ten sposÃ³b, uÅ¼ywaÅ‚eÅ› wzorcÃ³w, chociaÅ¼ mogÅ‚eÅ› tego nie zdawaÄ‡ sobie sprawy! Bardziej formalnie, instrukcja <code>let</code> wyglÄ…da tak:</p>
<!--
  Manually formatted rather than using Markdown intentionally: Markdown does not
  support italicizing code in the body of a block like this!
-->
<pre>
<code>let <em>WZORZEC</em> = <em>WYRAÅ»ENIE</em>;</code>
</pre>

<p>W instrukcjach takich jak <code>let x = 5;</code> z nazwÄ… zmiennej w miejscu PATTERN, nazwa zmiennej jest po prostu szczegÃ³lnie prostÄ… formÄ… wzorca. Rust porÃ³wnuje wyraÅ¼enie ze wzorcem i przypisuje wszystkie znalezione nazwy. Tak wiÄ™c, w przykÅ‚adzie <code>let x = 5;</code>, <code>x</code> jest wzorcem, ktÃ³ry oznacza â€zwiÄ…Å¼ to, co pasuje tutaj, ze zmiennÄ… <code>x</code>â€. PoniewaÅ¼ nazwa <code>x</code> jest caÅ‚ym wzorcem, ten wzorzec skutecznie oznacza â€zwiÄ…Å¼ wszystko ze zmiennÄ… <code>x</code>, niezaleÅ¼nie od wartoÅ›ciâ€.</p>
<p>Aby wyraÅºniej zobaczyÄ‡ aspekt dopasowywania wzorcÃ³w w <code>let</code>, rozwaÅ¼ ListÄ™ 19-1, ktÃ³ra uÅ¼ywa wzorca z <code>let</code> do dekonstrukcji krotki.</p>
<figure class="listing" id="listing-19-1">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let (x, y, z) = (1, 2, 3);
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-1">Lista 19-1</a>: UÅ¼ycie wzorca do dekonstrukcji krotki i jednoczesnego utworzenia trzech zmiennych</figcaption>
</figure>
<p>Tutaj dopasowujemy krotkÄ™ do wzorca. Rust porÃ³wnuje wartoÅ›Ä‡ <code>(1, 2, 3)</code> ze wzorcem <code>(x, y, z)</code> i widzi, Å¼e wartoÅ›Ä‡ pasuje do wzorca â€” to znaczy, widzi, Å¼e liczba elementÃ³w jest taka sama w obu â€” wiÄ™c Rust wiÄ…Å¼e <code>1</code> z <code>x</code>, <code>2</code> z <code>y</code> i <code>3</code> z <code>z</code>. MoÅ¼esz myÅ›leÄ‡ o tym wzorcu krotki jako o zagnieÅ¼dÅ¼eniu w nim trzech pojedynczych wzorcÃ³w zmiennych.</p>
<p>JeÅ›li liczba elementÃ³w we wzorcu nie odpowiada liczbie elementÃ³w w krotce, ogÃ³lny typ nie bÄ™dzie pasowaÅ‚ i otrzymamy bÅ‚Ä…d kompilacji. Na przykÅ‚ad, Lista 19-2 pokazuje prÃ³bÄ™ dekompozycji krotki z trzema elementami na dwie zmienne, co nie zadziaÅ‚a.</p>
<figure class="listing" id="listing-19-2">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let (x, y) = (1, 2, 3);
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-2">Lista 19-2</a>: NieprawidÅ‚owe konstruowanie wzorca, ktÃ³rego zmienne nie pasujÄ… do liczby elementÃ³w w krotce</figcaption>
</figure>
<p>PrÃ³ba skompilowania tego kodu skutkuje bÅ‚Ä™dem typu:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`
  |         |
  |         expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>Aby naprawiÄ‡ bÅ‚Ä…d, moglibyÅ›my zignorowaÄ‡ jednÄ… lub wiÄ™cej wartoÅ›ci w krotce za pomocÄ… <code>_</code> lub <code>..</code>, jak zobaczysz w sekcji <a href="#ignoring-values-in-a-pattern">â€Ignorowanie wartoÅ›ci we wzorcuâ€</a><!-- ignore -->. JeÅ›li problem polega na tym, Å¼e mamy zbyt wiele zmiennych we wzorcu, rozwiÄ…zaniem jest dopasowanie typÃ³w poprzez usuniÄ™cie zmiennych, tak aby liczba zmiennych byÅ‚a rÃ³wna liczbie elementÃ³w w krotce.</p>
<h3 id="warunkowe-wyraÅ¼enia-if-let"><a class="header" href="#warunkowe-wyraÅ¼enia-if-let">Warunkowe WyraÅ¼enia <code>if let</code></a></h3>
<p>W Rozdziale 6 omÃ³wiliÅ›my, jak uÅ¼ywaÄ‡ wyraÅ¼eÅ„ <code>if let</code> gÅ‚Ã³wnie jako krÃ³tszego sposobu na zapisanie odpowiednika <code>match</code>, ktÃ³ry pasuje tylko do jednego przypadku. Opcjonalnie, <code>if let</code> moÅ¼e mieÄ‡ odpowiadajÄ…cy mu <code>else</code> zawierajÄ…cy kod do uruchomienia, jeÅ›li wzorzec w <code>if let</code> nie pasuje.</p>
<p>Lista 19-3 pokazuje, Å¼e moÅ¼liwe jest rÃ³wnieÅ¼ mieszanie i dopasowywanie wyraÅ¼eÅ„ <code>if let</code>, <code>else if</code> i <code>else if let</code>. DziaÅ‚anie to daje nam wiÄ™kszÄ… elastycznoÅ›Ä‡ niÅ¼ wyraÅ¼enie <code>match</code>, w ktÃ³rym moÅ¼emy wyraziÄ‡ tylko jednÄ… wartoÅ›Ä‡ do porÃ³wnania ze wzorcami. Ponadto Rust nie wymaga, aby warunki w serii ramion <code>if let</code>, <code>else if</code> i <code>else if let</code> byÅ‚y ze sobÄ… powiÄ…zane.</p>
<p>Kod na LiÅ›cie 19-3 okreÅ›la kolor tÅ‚a na podstawie serii sprawdzeÅ„ kilku warunkÃ³w. W tym przykÅ‚adzie stworzyliÅ›my zmienne z zakodowanymi na staÅ‚e wartoÅ›ciami, ktÃ³re w rzeczywistym programie mogÅ‚yby pochodziÄ‡ z danych wejÅ›ciowych uÅ¼ytkownika.</p>
<figure class="listing" id="listing-19-3">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = "34".parse();

    if let Some(color) = favorite_color {
        println!("Using your favorite color, {color}, as the background");
    } else if is_tuesday {
        println!("Tuesday is green day!");
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!("Using purple as the background color");
        } else {
            println!("Using orange as the background color");
        }
    } else {
        println!("Using blue as the background color");
    }
}</code></pre>
<figcaption><a href="#listing-19-3">Lista 19-3</a>: Mieszanie <code>if let</code>, <code>else if</code>, <code>else if let</code> i <code>else</code></figcaption>
</figure>
<p>JeÅ›li uÅ¼ytkownik okreÅ›li ulubiony kolor, ten kolor zostanie uÅ¼yty jako tÅ‚o. JeÅ›li nie okreÅ›lono ulubionego koloru i dziÅ› jest wtorek, kolor tÅ‚a jest zielony. W przeciwnym razie, jeÅ›li uÅ¼ytkownik poda swÃ³j wiek jako ciÄ…g znakÃ³w i uda nam siÄ™ go poprawnie sparsowaÄ‡ jako liczbÄ™, kolor bÄ™dzie fioletowy lub pomaraÅ„czowy w zaleÅ¼noÅ›ci od wartoÅ›ci liczby. JeÅ›li Å¼aden z tych warunkÃ³w nie zostanie speÅ‚niony, kolor tÅ‚a bÄ™dzie niebieski.</p>
<p>Ta struktura warunkowa pozwala nam obsÅ‚ugiwaÄ‡ zÅ‚oÅ¼one wymagania. Z zakodowanymi na staÅ‚e wartoÅ›ciami, ten przykÅ‚ad wydrukuje <code>Using purple as the background color</code>.</p>
<p>Widzisz, Å¼e <code>if let</code> moÅ¼e rÃ³wnieÅ¼ wprowadzaÄ‡ nowe zmienne, ktÃ³re zacieniajÄ… istniejÄ…ce zmienne w taki sam sposÃ³b, jak ramiona <code>match</code>: linia <code>if let Ok(age) = age</code> wprowadza nowÄ… zmiennÄ… <code>age</code>, ktÃ³ra zawiera wartoÅ›Ä‡ wewnÄ…trz wariantu <code>Ok</code>, zacieniajÄ…c istniejÄ…cÄ… zmiennÄ… <code>age</code>. Oznacza to, Å¼e musimy umieÅ›ciÄ‡ warunek <code>if age &gt; 30</code> w tym bloku: nie moÅ¼emy poÅ‚Ä…czyÄ‡ tych dwÃ³ch warunkÃ³w w <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>. Nowa zmienna <code>age</code>, ktÃ³rÄ… chcemy porÃ³wnaÄ‡ z 30, nie jest prawidÅ‚owa, dopÃ³ki nowy zakres nie zacznie siÄ™ od nawiasu klamrowego.</p>
<p>WadÄ… stosowania wyraÅ¼eÅ„ <code>if let</code> jest to, Å¼e kompilator nie sprawdza wyczerpujÄ…co wszystkich moÅ¼liwoÅ›ci, w przeciwieÅ„stwie do wyraÅ¼eÅ„ <code>match</code>. GdybyÅ›my pominÄ™li ostatni blok <code>else</code>, a tym samym nie obsÅ‚uÅ¼yli niektÃ³rych przypadkÃ³w, kompilator nie ostrzegÅ‚by nas o moÅ¼liwym bÅ‚Ä™dzie logicznym.</p>
<h3 id="pÄ™tle-warunkowe-while-let"><a class="header" href="#pÄ™tle-warunkowe-while-let">PÄ™tle Warunkowe <code>while let</code></a></h3>
<p>Podobnie jak w przypadku <code>if let</code>, pÄ™tla warunkowa <code>while let</code> pozwala na dziaÅ‚anie pÄ™tli <code>while</code> tak dÅ‚ugo, jak wzorzec pasuje. Na LiÅ›cie 19-4 pokazujemy pÄ™tlÄ™ <code>while let</code>, ktÃ³ra czeka na wiadomoÅ›ci wysyÅ‚ane miÄ™dzy wÄ…tkami, ale w tym przypadku sprawdza <code>Result</code> zamiast <code>Option</code>.</p>
<figure class="listing" id="listing-19-4">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let (tx, rx) = std::sync::mpsc::channel();
    std::thread::spawn(move || {
        for val in [1, 2, 3] {
            tx.send(val).unwrap();
        }
    });

    while let Ok(value) = rx.recv() {
        println!("{value}");
    }
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-4">Lista 19-4</a>: UÅ¼ycie pÄ™tli <code>while let</code> do drukowania wartoÅ›ci tak dÅ‚ugo, jak <code>rx.recv()</code> zwraca <code>Ok</code></figcaption>
</figure>
<p>Ten przykÅ‚ad wypisuje <code>1</code>, <code>2</code>, a nastÄ™pnie <code>3</code>. Metoda <code>recv</code> pobiera pierwszÄ… wiadomoÅ›Ä‡ z odbiornika kanaÅ‚u i zwraca <code>Ok(value)</code>. Kiedy po raz pierwszy widzieliÅ›my <code>recv</code> w Rozdziale 16, bezpoÅ›rednio rozpakowaliÅ›my bÅ‚Ä…d lub wchodziliÅ›my z nim w interakcjÄ™ jako z iteratorem za pomocÄ… pÄ™tli <code>for</code>. Jak pokazuje Lista 19-4, moÅ¼emy jednak rÃ³wnieÅ¼ uÅ¼yÄ‡ <code>while let</code>, poniewaÅ¼ metoda <code>recv</code> zwraca <code>Ok</code> za kaÅ¼dym razem, gdy nadejdzie wiadomoÅ›Ä‡, dopÃ³ki nadawca istnieje, a nastÄ™pnie generuje <code>Err</code>, gdy strona nadawcy siÄ™ rozÅ‚Ä…czy.</p>
<h3 id="pÄ™tle-for"><a class="header" href="#pÄ™tle-for">PÄ™tle <code>for</code></a></h3>
<p>W pÄ™tli <code>for</code> wartoÅ›Ä‡, ktÃ³ra bezpoÅ›rednio nastÄ™puje po sÅ‚owie kluczowym <code>for</code>, jest wzorcem. Na przykÅ‚ad w <code>for x in y</code>, <code>x</code> jest wzorcem. Lista 19-5 demonstruje, jak uÅ¼yÄ‡ wzorca w pÄ™tli <code>for</code> do dekonstrukcji, czyli rozÅ‚oÅ¼enia, krotki jako czÄ™Å›Ä‡ pÄ™tli <code>for</code>.</p>
<figure class="listing" id="listing-19-5">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!("{value} is at index {index}");
    }
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-5">Lista 19-5</a>: UÅ¼ycie wzorca w pÄ™tli <code>for</code> do dekonstrukcji krotki</figcaption>
</figure>
<p>Kod na LiÅ›cie 19-5 wypisze nastÄ™pujÄ…ce informacje:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a is at index 0
b is at index 1
c is at index 2
</code></pre>
<p>Adaptujemy iterator za pomocÄ… metody <code>enumerate</code> tak, aby produkowaÅ‚a ona wartoÅ›Ä‡ i indeks dla tej wartoÅ›ci, umieszczone w krotce. Pierwsza wyprodukowana wartoÅ›Ä‡ to krotka <code>(0, 'a')</code>. Gdy ta wartoÅ›Ä‡ zostanie dopasowana do wzorca <code>(index, value)</code>, <code>index</code> bÄ™dzie <code>0</code>, a <code>value</code> bÄ™dzie <code>'a'</code>, drukujÄ…c pierwszÄ… liniÄ™ wyjÅ›cia.</p>
<h3 id="parametry-funkcji"><a class="header" href="#parametry-funkcji">Parametry Funkcji</a></h3>
<p>Parametry funkcji rÃ³wnieÅ¼ mogÄ… byÄ‡ wzorcami. Kod z Listy 19-6, ktÃ³ry deklaruje funkcjÄ™ <code>foo</code> przyjmujÄ…cÄ… jeden parametr <code>x</code> typu <code>i32</code>, powinien byÄ‡ juÅ¼ znany.</p>
<figure class="listing" id="listing-19-6">
<pre class="playground"><code class="language-rust edition2024">fn foo(x: i32) {
    // code goes here
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<figcaption><a href="#listing-19-6">Lista 19-6</a>: Sygnatura funkcji uÅ¼ywajÄ…ca wzorcÃ³w w parametrach</figcaption>
</figure>
<p>CzÄ™Å›Ä‡ <code>x</code> to wzorzec! Tak jak w przypadku <code>let</code>, moglibyÅ›my dopasowaÄ‡ krotkÄ™ w argumentach funkcji do wzorca. Lista 19-7 rozdziela wartoÅ›ci w krotce, gdy przekazujemy jÄ… do funkcji.</p>
<figure class="listing" id="listing-19-7">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!("Current location: ({x}, {y})");
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}</code></pre>
<figcaption><a href="#listing-19-7">Lista 19-7</a>: Funkcja z parametrami, ktÃ³re dekonstruujÄ… krotkÄ™</figcaption>
</figure>
<p>Ten kod wypisuje <code>Current location: (3, 5)</code>. WartoÅ›ci <code>&amp;(3, 5)</code> pasujÄ… do wzorca <code>&amp;(x, y)</code>, wiÄ™c <code>x</code> ma wartoÅ›Ä‡ <code>3</code>, a <code>y</code> ma wartoÅ›Ä‡ <code>5</code>.</p>
<p>MoÅ¼emy rÃ³wnieÅ¼ uÅ¼ywaÄ‡ wzorcÃ³w w listach parametrÃ³w domkniÄ™Ä‡ w taki sam sposÃ³b, jak w listach parametrÃ³w funkcji, poniewaÅ¼ domkniÄ™cia sÄ… podobne do funkcji, jak omÃ³wiono w Rozdziale 13.</p>
<p>Do tej pory widziaÅ‚eÅ› kilka sposobÃ³w uÅ¼ycia wzorcÃ³w, ale wzorce nie dziaÅ‚ajÄ… tak samo w kaÅ¼dym miejscu, w ktÃ³rym moÅ¼emy ich uÅ¼yÄ‡. W niektÃ³rych miejscach wzorce muszÄ… byÄ‡ nieodrzucalne; w innych okolicznoÅ›ciach mogÄ… byÄ‡ odrzucalne. NastÄ™pnie omÃ³wimy te dwie koncepcje.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="odrzucalnoÅ›Ä‡-czy-wzorzec-moÅ¼e-nie-pasowaÄ‡-1"><a href="#odrzucalnoÅ›Ä‡-czy-wzorzec-moÅ¼e-nie-pasowaÄ‡-1" class="header">OdrzucalnoÅ›Ä‡: Czy Wzorzec MoÅ¼e Nie PasowaÄ‡</a></h1>
<h2 id="odrzucalnoÅ›Ä‡-czy-wzorzec-moÅ¼e-nie-pasowaÄ‡"><a class="header" href="#odrzucalnoÅ›Ä‡-czy-wzorzec-moÅ¼e-nie-pasowaÄ‡">OdrzucalnoÅ›Ä‡: Czy Wzorzec MoÅ¼e Nie PasowaÄ‡</a></h2>
<p>Wzorce wystÄ™pujÄ… w dwÃ³ch formach: odrzucalne i nieodrzucalne. Wzorce, ktÃ³re pasujÄ… do kaÅ¼dej moÅ¼liwej przekazanej wartoÅ›ci, sÄ… <em>nieodrzucalne</em>. PrzykÅ‚adem moÅ¼e byÄ‡ <code>x</code> w instrukcji <code>let x = 5;</code>, poniewaÅ¼ <code>x</code> pasuje do wszystkiego i dlatego nie moÅ¼e siÄ™ nie dopasowaÄ‡. Wzorce, ktÃ³re mogÄ… nie pasowaÄ‡ do pewnej moÅ¼liwej wartoÅ›ci, sÄ… <em>odrzucalne</em>. PrzykÅ‚adem moÅ¼e byÄ‡ <code>Some(x)</code> w wyraÅ¼eniu <code>if let Some(x) = a_value</code>, poniewaÅ¼ jeÅ›li wartoÅ›Ä‡ w zmiennej <code>a_value</code> to <code>None</code>, a nie <code>Some</code>, wzorzec <code>Some(x)</code> nie zostanie dopasowany.</p>
<p>Parametry funkcji, instrukcje <code>let</code> i pÄ™tle <code>for</code> mogÄ… akceptowaÄ‡ tylko wzorce nieodrzucalne, poniewaÅ¼ program nie moÅ¼e nic znaczÄ…cego zrobiÄ‡, gdy wartoÅ›ci nie pasujÄ…. WyraÅ¼enia <code>if let</code> i <code>while let</code> oraz instrukcja <code>let...else</code> akceptujÄ… wzorce odrzucalne i nieodrzucalne, ale kompilator ostrzega przed wzorcami nieodrzucalnymi, poniewaÅ¼ z definicji sÄ… przeznaczone do obsÅ‚ugi moÅ¼liwych bÅ‚Ä™dÃ³w: funkcjonalnoÅ›Ä‡ warunku polega na jego zdolnoÅ›ci do dziaÅ‚ania inaczej w zaleÅ¼noÅ›ci od sukcesu lub poraÅ¼ki.</p>
<p>OgÃ³lnie rzecz biorÄ…c, nie powinieneÅ› martwiÄ‡ siÄ™ rozrÃ³Å¼nieniem miÄ™dzy wzorcami odrzucalnymi i nieodrzucalnymi; jednak musisz byÄ‡ zaznajomiony z koncepcjÄ… odrzucalnoÅ›ci, aby mÃ³c reagowaÄ‡, gdy zobaczysz jÄ… w komunikacie o bÅ‚Ä™dzie. W takich przypadkach bÄ™dziesz musiaÅ‚ zmieniÄ‡ albo wzorzec, albo konstrukcjÄ™, z ktÃ³rÄ… uÅ¼ywasz wzorca, w zaleÅ¼noÅ›ci od zamierzonego zachowania kodu.</p>
<p>Przyjrzyjmy siÄ™ przykÅ‚adowi, co siÄ™ dzieje, gdy prÃ³bujemy uÅ¼yÄ‡ wzorca odrzucalnego tam, gdzie Rust wymaga wzorca nieodrzucalnego, i odwrotnie. Lista 19-8 pokazuje instrukcjÄ™ <code>let</code>, ale dla wzorca okreÅ›liliÅ›my <code>Some(x)</code>, wzorzec odrzucalny. Jak moÅ¼na siÄ™ spodziewaÄ‡, ten kod siÄ™ nie skompiluje.</p>
<figure class="listing" id="listing-19-8">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    let Some(x) = some_option_value;
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-8">Lista 19-8</a>: PrÃ³ba uÅ¼ycia wzorca odrzucalnego z <code>let</code></figcaption>
</figure>
<p>Gdyby <code>some_option_value</code> miaÅ‚o wartoÅ›Ä‡ <code>None</code>, nie pasowaÅ‚oby do wzorca <code>Some(x)</code>, co oznacza, Å¼e wzorzec jest odrzucalny. Jednak instrukcja <code>let</code> moÅ¼e przyjmowaÄ‡ tylko wzorzec nieodrzucalny, poniewaÅ¼ nie ma niczego waÅ¼nego, co kod mÃ³gÅ‚by zrobiÄ‡ z wartoÅ›ciÄ… <code>None</code>. W czasie kompilacji Rust skarÅ¼y siÄ™, Å¼e prÃ³bowaliÅ›my uÅ¼yÄ‡ wzorca odrzucalnego tam, gdzie wymagany jest wzorzec nieodrzucalny:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding
 --&gt; src/main.rs:3:9
  |
3 |     let Some(x) = some_option_value;
  |         ^^^^^^^ pattern `None` not covered
  |
  = note: `let` bindings require an "irrefutable pattern", like a `struct` or an `enum` with only one variant
  = note: for more information, visit https://doc.rust-lang.org/book/ch19-02-refutability.html
  = note: the matched value is of type `Option&lt;i32&gt;`
help: you might want to use `let else` to handle the variant that isn't matched
  |
3 |     let Some(x) = some_option_value else { todo!() };
  |                                     ++++++++++++++++

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>PoniewaÅ¼ nie pokryliÅ›my (i nie mogliÅ›my pokryÄ‡!) kaÅ¼dej prawidÅ‚owej wartoÅ›ci wzorcem <code>Some(x)</code>, Rust sÅ‚usznie zwraca bÅ‚Ä…d kompilacji.</p>
<p>JeÅ›li mamy wzorzec odrzucalny tam, gdzie potrzebny jest wzorzec nieodrzucalny, moÅ¼emy to naprawiÄ‡, zmieniajÄ…c kod, ktÃ³ry uÅ¼ywa wzorca: zamiast uÅ¼ywaÄ‡ <code>let</code>, moÅ¼emy uÅ¼yÄ‡ <code>let...else</code>. Wtedy, jeÅ›li wzorzec nie pasuje, kod w nawiasach klamrowych obsÅ‚uÅ¼y wartoÅ›Ä‡. Lista 19-9 pokazuje, jak naprawiÄ‡ kod z Listy 19-8.</p>
<figure class="listing" id="listing-19-9">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    let Some(x) = some_option_value else {
        return;
    };
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-9">Lista 19-9</a>: UÅ¼ycie <code>let...else</code> i bloku z wzorcami odrzucalnymi zamiast <code>let</code></figcaption>
</figure>
<p>DaliÅ›my kodowi wyjÅ›cie! Ten kod jest caÅ‚kowicie poprawny, chociaÅ¼ oznacza to, Å¼e nie moÅ¼emy uÅ¼yÄ‡ wzorca nieodrzucalnego bez otrzymywania ostrzeÅ¼enia. JeÅ›li damy <code>let...else</code> wzorzec, ktÃ³ry zawsze bÄ™dzie pasowaÅ‚, taki jak <code>x</code>, jak pokazano na LiÅ›cie 19-10, kompilator wyÅ›wietli ostrzeÅ¼enie.</p>
<figure class="listing" id="listing-19-10">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 5 else {
        return;
    };
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-10">Lista 19-10</a>: PrÃ³ba uÅ¼ycia wzorca nieodrzucalnego z <code>let...else</code></figcaption>
</figure>
<p>Rust skarÅ¼y siÄ™, Å¼e uÅ¼ycie <code>let...else</code> z wzorcem nieodrzucalnym nie ma sensu:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable `let...else` pattern
 --&gt; src/main.rs:2:5
  |
2 |     let x = 5 else {
  |     ^^^^^^^^^
  |
  = note: this pattern will always match, so the `else` clause is useless
  = help: consider removing the `else` clause
  = note: `#[warn(irrefutable_let_patterns)]` on by default

warning: `patterns` (bin "patterns") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
</code></pre>
<p>Z tego powodu ramiona <code>match</code> muszÄ… uÅ¼ywaÄ‡ wzorcÃ³w odrzucalnych, z wyjÄ…tkiem ostatniego ramienia, ktÃ³re powinno pasowaÄ‡ do wszystkich pozostaÅ‚ych wartoÅ›ci za pomocÄ… wzorca nieodrzucalnego. Rust pozwala nam uÅ¼ywaÄ‡ wzorca nieodrzucalnego w <code>match</code> z tylko jednym ramieniem, ale ta skÅ‚adnia nie jest szczegÃ³lnie uÅ¼yteczna i mogÅ‚aby byÄ‡ zastÄ…piona prostszÄ… instrukcjÄ… <code>let</code>.</p>
<p>Teraz, gdy wiesz, gdzie uÅ¼ywaÄ‡ wzorcÃ³w i jaka jest rÃ³Å¼nica miÄ™dzy wzorcami odrzucalnymi i nieodrzucalnymi, przejdÅºmy do omÃ³wienia caÅ‚ej skÅ‚adni, ktÃ³rej moÅ¼emy uÅ¼yÄ‡ do tworzenia wzorcÃ³w.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="skÅ‚adnia-wzorcÃ³w-1"><a href="#skÅ‚adnia-wzorcÃ³w-1" class="header">SkÅ‚adnia WzorcÃ³w</a></h1>
<h2 id="skÅ‚adnia-wzorcÃ³w"><a class="header" href="#skÅ‚adnia-wzorcÃ³w">SkÅ‚adnia WzorcÃ³w</a></h2>
<p>W tej sekcji zbieramy caÅ‚Ä… skÅ‚adniÄ™, ktÃ³ra jest prawidÅ‚owa we wzorcach, i omawiamy, dlaczego i kiedy warto uÅ¼ywaÄ‡ kaÅ¼dej z nich.</p>
<h3 id="dopasowywanie-literaÅ‚Ã³w"><a class="header" href="#dopasowywanie-literaÅ‚Ã³w">Dopasowywanie LiteraÅ‚Ã³w</a></h3>
<p>Jak widziaÅ‚eÅ› w Rozdziale 6, moÅ¼esz dopasowywaÄ‡ wzorce bezpoÅ›rednio do literaÅ‚Ã³w. PoniÅ¼szy kod przedstawia kilka przykÅ‚adÃ³w:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!("one"),
        2 =&gt; println!("two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
<span class="boring">}</span></code></pre>
<p>Ten kod wypisuje <code>one</code>, poniewaÅ¼ wartoÅ›Ä‡ w <code>x</code> wynosi <code>1</code>. Ta skÅ‚adnia jest uÅ¼yteczna, gdy chcesz, aby TwÃ³j kod podjÄ…Å‚ dziaÅ‚anie, jeÅ›li otrzyma konkretnÄ… wartoÅ›Ä‡.</p>
<h3 id="dopasowywanie-nazwanych-zmiennych"><a class="header" href="#dopasowywanie-nazwanych-zmiennych">Dopasowywanie Nazwanych Zmiennych</a></h3>
<p>Nazwane zmienne to nieodrzucalne wzorce, ktÃ³re pasujÄ… do dowolnej wartoÅ›ci, i uÅ¼ywaliÅ›my ich wiele razy w tej ksiÄ…Å¼ce. JednakÅ¼e, pojawia siÄ™ komplikacja, gdy uÅ¼ywasz nazwanych zmiennych w wyraÅ¼eniach <code>match</code>, <code>if let</code> lub <code>while let</code>. PoniewaÅ¼ kaÅ¼dy z tych rodzajÃ³w wyraÅ¼eÅ„ rozpoczyna nowy zakres, zmienne zadeklarowane jako czÄ™Å›Ä‡ wzorca wewnÄ…trz tych wyraÅ¼eÅ„ bÄ™dÄ… zasÅ‚aniaÄ‡ te o tej samej nazwie poza konstrukcjami, tak jak to ma miejsce w przypadku wszystkich zmiennych. Na LiÅ›cie 19-11 deklarujemy zmiennÄ… <code>x</code> o wartoÅ›ci <code>Some(5)</code> i zmiennÄ… <code>y</code> o wartoÅ›ci <code>10</code>. NastÄ™pnie tworzymy wyraÅ¼enie <code>match</code> na wartoÅ›ci <code>x</code>. SpÃ³jrz na wzorce w ramionach <code>match</code> i <code>println!</code> na koÅ„cu, a sprÃ³buj odgadnÄ…Ä‡, co kod wydrukuje, zanim uruchomisz ten kod lub przeczytasz dalej.</p>
<figure class="listing" id="listing-19-11">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(y) =&gt; println!("Matched, y = {y}"),
        _ =&gt; println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-11">Lista 19-11</a>: WyraÅ¼enie <code>match</code> z ramieniem, ktÃ³re wprowadza nowÄ… zmiennÄ…, ktÃ³ra zasÅ‚ania istniejÄ…cÄ… zmiennÄ… <code>y</code></figcaption>
</figure>
<p>Przeanalizujmy, co dzieje siÄ™, gdy uruchamia siÄ™ wyraÅ¼enie <code>match</code>. Wzorzec w pierwszym ramieniu <code>match</code> nie pasuje do zdefiniowanej wartoÅ›ci <code>x</code>, wiÄ™c kod kontynuuje dziaÅ‚anie.</p>
<p>Wzorzec w drugim ramieniu <code>match</code> wprowadza nowÄ… zmiennÄ… o nazwie <code>y</code>, ktÃ³ra bÄ™dzie pasowaÄ‡ do dowolnej wartoÅ›ci wewnÄ…trz wartoÅ›ci <code>Some</code>. PoniewaÅ¼ jesteÅ›my w nowym zakresie wewnÄ…trz wyraÅ¼enia <code>match</code>, jest to nowa zmienna <code>y</code>, a nie <code>y</code>, ktÃ³rÄ… zadeklarowaliÅ›my na poczÄ…tku z wartoÅ›ciÄ… <code>10</code>. To nowe powiÄ…zanie <code>y</code> bÄ™dzie pasowaÄ‡ do wewnÄ™trznej wartoÅ›ci <code>Some</code> w <code>x</code>. Ta wartoÅ›Ä‡ to <code>5</code>, wiÄ™c wyraÅ¼enie dla tego ramienia wykonuje siÄ™ i wypisuje <code>Matched, y = 5</code>.</p>
<p>Gdyby <code>x</code> byÅ‚o wartoÅ›ciÄ… <code>None</code> zamiast <code>Some(5)</code>, wzorce w dwÃ³ch pierwszych ramionach nie pasowaÅ‚yby, wiÄ™c wartoÅ›Ä‡ pasowaÅ‚aby do podkreÅ›lenia. Nie wprowadziliÅ›my zmiennej <code>x</code> do wzorca ramienia podkreÅ›lenia, wiÄ™c <code>x</code> w wyraÅ¼eniu jest nadal zewnÄ™trznym <code>x</code>, ktÃ³re nie zostaÅ‚o zacienione. W tym hipotetycznym przypadku <code>match</code> wypisaÅ‚by <code>Default case, x = None</code>.</p>
<p>Po zakoÅ„czeniu wyraÅ¼enia <code>match</code>, jego zakres siÄ™ koÅ„czy, podobnie jak zakres wewnÄ™trznego <code>y</code>. Ostatnie <code>println!</code> wypisuje <code>at the end: x = Some(5), y = 10</code>.</p>
<p>Aby stworzyÄ‡ wyraÅ¼enie <code>match</code>, ktÃ³re porÃ³wnuje wartoÅ›ci zewnÄ™trznych <code>x</code> i <code>y</code>, zamiast wprowadzaÄ‡ nowÄ… zmiennÄ…, ktÃ³ra zasÅ‚ania istniejÄ…cÄ… zmiennÄ… <code>y</code>, musielibyÅ›my uÅ¼yÄ‡ warunkowego ograniczenia dopasowania. O match guardach porozmawiamy pÃ³Åºniej w sekcji <a href="#adding-conditionals-with-match-guards">â€Dodawanie warunkÃ³w za pomocÄ… match guardÃ³wâ€</a><!-- ignore -->.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="multiple-patterns"></a></p>
<h3 id="dopasowywanie-wielu-wzorcÃ³w"><a class="header" href="#dopasowywanie-wielu-wzorcÃ³w">Dopasowywanie Wielu WzorcÃ³w</a></h3>
<p>W wyraÅ¼eniach <code>match</code> moÅ¼esz dopasowywaÄ‡ wiele wzorcÃ³w za pomocÄ… skÅ‚adni <code>|</code>, ktÃ³ra jest operatorem <em>lub</em> wzorca. Na przykÅ‚ad, w poniÅ¼szym kodzie dopasowujemy wartoÅ›Ä‡ <code>x</code> do ramion <code>match</code>, z ktÃ³rych pierwsze ma opcjÄ™ <em>lub</em>, co oznacza, Å¼e jeÅ›li wartoÅ›Ä‡ <code>x</code> pasuje do ktÃ³rejkolwiek z wartoÅ›ci w tym ramieniu, kod tego ramienia zostanie uruchomiony:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!("one or two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
<span class="boring">}</span></code></pre>
<p>Ten kod wypisuje <code>one or two</code>.</p>
<h3 id="dopasowywanie-zakresÃ³w-wartoÅ›ci-za-pomocÄ…-"><a class="header" href="#dopasowywanie-zakresÃ³w-wartoÅ›ci-za-pomocÄ…-">Dopasowywanie ZakresÃ³w WartoÅ›ci za pomocÄ… <code>..=</code></a></h3>
<p>SkÅ‚adnia <code>..=</code> pozwala nam dopasowywaÄ‡ do wÅ‚Ä…cznie zakresu wartoÅ›ci. W poniÅ¼szym kodzie, gdy wzorzec pasuje do ktÃ³rejkolwiek z wartoÅ›ci w danym zakresie, to ramiÄ™ zostanie wykonane:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!("one through five"),
        _ =&gt; println!("something else"),
    }
<span class="boring">}</span></code></pre>
<p>JeÅ›li <code>x</code> wynosi <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code> lub <code>5</code>, pierwsze ramiÄ™ zostanie dopasowane. Ta skÅ‚adnia jest wygodniejsza dla wielu wartoÅ›ci dopasowania niÅ¼ uÅ¼ywanie operatora <code>|</code> do wyraÅ¼enia tej samej idei; gdybyÅ›my mieli uÅ¼yÄ‡ <code>|</code>, musielibyÅ›my okreÅ›liÄ‡ <code>1 | 2 | 3 | 4 | 5</code>. OkreÅ›lanie zakresu jest znacznie krÃ³tsze, zwÅ‚aszcza jeÅ›li chcemy dopasowaÄ‡, powiedzmy, dowolnÄ… liczbÄ™ od 1 do 1000!</p>
<p>Kompilator sprawdza w czasie kompilacji, czy zakres nie jest pusty, a poniewaÅ¼ jedynymi typami, dla ktÃ³rych Rust moÅ¼e stwierdziÄ‡, czy zakres jest pusty, sÄ… <code>char</code> i wartoÅ›ci liczbowe, zakresy sÄ… dozwolone tylko z wartoÅ›ciami liczbowymi lub <code>char</code>.</p>
<p>Oto przykÅ‚ad uÅ¼ycia zakresÃ³w wartoÅ›ci <code>char</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!("early ASCII letter"),
        'k'..='z' =&gt; println!("late ASCII letter"),
        _ =&gt; println!("something else"),
    }
<span class="boring">}</span></code></pre>
<p>Rust moÅ¼e stwierdziÄ‡, Å¼e <code>'c'</code> znajduje siÄ™ w zakresie pierwszego wzorca i wypisuje <code>early ASCII letter</code>.</p>
<h3 id="dekonstrukcja-w-celu-rozbicia-wartoÅ›ci"><a class="header" href="#dekonstrukcja-w-celu-rozbicia-wartoÅ›ci">Dekonstrukcja w Celu Rozbicia WartoÅ›ci</a></h3>
<p>MoÅ¼emy rÃ³wnieÅ¼ uÅ¼ywaÄ‡ wzorcÃ³w do dekonstrukcji struktur, wyliczeÅ„ i krotek, aby uÅ¼ywaÄ‡ rÃ³Å¼nych czÄ™Å›ci tych wartoÅ›ci. PrzejdÅºmy przez kaÅ¼dÄ… wartoÅ›Ä‡.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="destructuring-structs"></a></p>
<h4 id="struktury"><a class="header" href="#struktury">Struktury</a></h4>
<p>Lista 19-12 pokazuje strukturÄ™ <code>Point</code> z dwoma polami, <code>x</code> i <code>y</code>, ktÃ³re moÅ¼emy rozdzieliÄ‡ za pomocÄ… wzorca z instrukcjÄ… <code>let</code>.</p>
<figure class="listing" id="listing-19-12">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}</code></pre>
<figcaption><a href="#listing-19-12">Lista 19-12</a>: Dekonstrukcja pÃ³l struktury na osobne zmienne</figcaption>
</figure>
<p>Ten kod tworzy zmienne <code>a</code> i <code>b</code>, ktÃ³re odpowiadajÄ… wartoÅ›ciom pÃ³l <code>x</code> i <code>y</code> struktury <code>p</code>. Ten przykÅ‚ad pokazuje, Å¼e nazwy zmiennych we wzorcu nie muszÄ… odpowiadaÄ‡ nazwom pÃ³l struktury. Jednak czÄ™sto dopasowuje siÄ™ nazwy zmiennych do nazw pÃ³l, aby Å‚atwiej byÅ‚o zapamiÄ™taÄ‡, ktÃ³re zmienne pochodzÄ… z ktÃ³rych pÃ³l. Z powodu tego powszechnego uÅ¼ycia i poniewaÅ¼ pisanie <code>let Point { x: x, y: y } = p;</code> zawiera wiele powtÃ³rzeÅ„, Rust ma skrÃ³t dla wzorcÃ³w, ktÃ³re dopasowujÄ… pola struktury: wystarczy wymieniÄ‡ nazwÄ™ pola struktury, a zmienne utworzone na podstawie wzorca bÄ™dÄ… miaÅ‚y te same nazwy. Lista 19-13 dziaÅ‚a tak samo jak kod z Listy 19-12, ale zmienne utworzone we wzorcu <code>let</code> to <code>x</code> i <code>y</code> zamiast <code>a</code> i <code>b</code>.</p>
<figure class="listing" id="listing-19-13">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}</code></pre>
<figcaption><a href="#listing-19-13">Lista 19-13</a>: Dekonstrukcja pÃ³l struktury za pomocÄ… skrÃ³tu pÃ³l struktury</figcaption>
</figure>
<p>Ten kod tworzy zmienne <code>x</code> i <code>y</code>, ktÃ³re pasujÄ… do pÃ³l <code>x</code> i <code>y</code> zmiennej <code>p</code>. Wynikiem jest to, Å¼e zmienne <code>x</code> i <code>y</code> zawierajÄ… wartoÅ›ci ze struktury <code>p</code>.</p>
<p>MoÅ¼emy rÃ³wnieÅ¼ dokonywaÄ‡ dekonstrukcji z uÅ¼yciem wartoÅ›ci literaÅ‚owych jako czÄ™Å›ci wzorca struktury, zamiast tworzyÄ‡ zmienne dla wszystkich pÃ³l. Pozwala nam to testowaÄ‡ niektÃ³re pola pod kÄ…tem okreÅ›lonych wartoÅ›ci, jednoczeÅ›nie tworzÄ…c zmienne do dekonstrukcji pozostaÅ‚ych pÃ³l.</p>
<p>Na LiÅ›cie 19-14 mamy wyraÅ¼enie <code>match</code>, ktÃ³re dzieli wartoÅ›ci <code>Point</code> na trzy przypadki: punkty leÅ¼Ä…ce bezpoÅ›rednio na osi <code>x</code> (co jest prawdÄ…, gdy <code>y = 0</code>), na osi <code>y</code> (<code>x = 0</code>) lub na Å¼adnej z osi.</p>
<figure class="listing" id="listing-19-14">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!("On the x axis at {x}"),
        Point { x: 0, y } =&gt; println!("On the y axis at {y}"),
        Point { x, y } =&gt; {
            println!("On neither axis: ({x}, {y})");
        }
    }
}</code></pre>
<figcaption><a href="#listing-19-14">Lista 19-14</a>: Dekonstrukcja i dopasowywanie wartoÅ›ci literaÅ‚owych w jednym wzorcu</figcaption>
</figure>
<p>Pierwsze ramiÄ™ dopasuje kaÅ¼dy punkt leÅ¼Ä…cy na osi <code>x</code>, okreÅ›lajÄ…c, Å¼e pole <code>y</code> pasuje, jeÅ›li jego wartoÅ›Ä‡ odpowiada literaÅ‚owi <code>0</code>. Wzorzec nadal tworzy zmiennÄ… <code>x</code>, ktÃ³rej moÅ¼emy uÅ¼yÄ‡ w kodzie dla tego ramienia.</p>
<p>Podobnie, drugie ramiÄ™ pasuje do kaÅ¼dego punktu na osi <code>y</code>, okreÅ›lajÄ…c, Å¼e pole <code>x</code> pasuje, jeÅ›li jego wartoÅ›Ä‡ wynosi <code>0</code>, i tworzy zmiennÄ… <code>y</code> dla wartoÅ›ci pola <code>y</code>. Trzecie ramiÄ™ nie okreÅ›la Å¼adnych literaÅ‚Ã³w, wiÄ™c pasuje do kaÅ¼dego innego <code>Point</code> i tworzy zmienne dla pÃ³l <code>x</code> i <code>y</code>.</p>
<p>W tym przykÅ‚adzie wartoÅ›Ä‡ <code>p</code> pasuje do drugiego ramienia dziÄ™ki temu, Å¼e <code>x</code> zawiera <code>0</code>, wiÄ™c ten kod wypisze <code>On the y axis at 7</code>.</p>
<p>PamiÄ™taj, Å¼e wyraÅ¼enie <code>match</code> przestaje sprawdzaÄ‡ ramiona, gdy tylko znajdzie pierwszy pasujÄ…cy wzorzec, wiÄ™c nawet jeÅ›li <code>Point { x: 0, y: 0 }</code> znajduje siÄ™ na osi <code>x</code> i osi <code>y</code>, ten kod wydrukowaÅ‚by tylko <code>On the x axis at 0</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="destructuring-enums"></a></p>
<h4 id="wyliczenia-enums"><a class="header" href="#wyliczenia-enums">Wyliczenia (Enums)</a></h4>
<p>DekonstruowaliÅ›my wyliczenia w tej ksiÄ…Å¼ce (na przykÅ‚ad Lista 6-5 w Rozdziale 6), ale nie omÃ³wiliÅ›my jeszcze wyraÅºnie, Å¼e wzorzec do dekonstrukcji wyliczenia odpowiada sposobowi definiowania danych przechowywanych w wyliczeniu. Jako przykÅ‚ad, na LiÅ›cie 19-15 uÅ¼ywamy wyliczenia <code>Message</code> z Listy 6-2 i piszemy <code>match</code> z wzorcami, ktÃ³re dekonstruujÄ… kaÅ¼dÄ… wewnÄ™trznÄ… wartoÅ›Ä‡.</p>
<figure class="listing" id="listing-19-15">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!("The Quit variant has no data to destructure.");
        }
        Message::Move { x, y } =&gt; {
            println!("Move in the x direction {x} and in the y direction {y}");
        }
        Message::Write(text) =&gt; {
            println!("Text message: {text}");
        }
        Message::ChangeColor(r, g, b) =&gt; {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
    }
}</code></pre>
<figcaption><a href="#listing-19-15">Lista 19-15</a>: Dekonstrukcja wariantÃ³w wyliczenia, ktÃ³re zawierajÄ… rÃ³Å¼ne rodzaje wartoÅ›ci</figcaption>
</figure>
<p>Ten kod wypisze <code>Change color to red 0, green 160, and blue 255</code>. SprÃ³buj zmieniÄ‡ wartoÅ›Ä‡ <code>msg</code>, aby zobaczyÄ‡, jak dziaÅ‚a kod z innych ramion.</p>
<p>Dla wariantÃ³w wyliczeniowych bez Å¼adnych danych, takich jak <code>Message::Quit</code>, nie moÅ¼emy dalej dekonstruowaÄ‡ wartoÅ›ci. MoÅ¼emy dopasowaÄ‡ tylko literaÅ‚ <code>Message::Quit</code>, a w tym wzorcu nie ma Å¼adnych zmiennych.</p>
<p>Dla wariantÃ³w wyliczeÅ„ podobnych do struktur, takich jak <code>Message::Move</code>, moÅ¼emy uÅ¼yÄ‡ wzorca podobnego do wzorca, ktÃ³ry okreÅ›lamy w celu dopasowania struktur. Po nazwie wariantu umieszczamy nawiasy klamrowe, a nastÄ™pnie wymieniamy pola ze zmiennymi, tak abyÅ›my rozdzielili elementy do uÅ¼ycia w kodzie dla tego ramienia. Tutaj uÅ¼ywamy skrÃ³conej formy, tak jak na LiÅ›cie 19-13.</p>
<p>Dla wariantÃ³w wyliczeniowych typu krotka, takich jak <code>Message::Write</code>, ktÃ³re przechowuje krotkÄ™ z jednym elementem, oraz <code>Message::ChangeColor</code>, ktÃ³re przechowuje krotkÄ™ z trzema elementami, wzorzec jest podobny do wzorca, ktÃ³ry okreÅ›lamy, aby dopasowaÄ‡ krotki. Liczba zmiennych we wzorcu musi odpowiadaÄ‡ liczbie elementÃ³w w wariancie, ktÃ³ry dopasowujemy.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="destructuring-nested-structs-and-enums"></a></p>
<h4 id="zagnieÅ¼dÅ¼one-struktury-i-wyliczenia"><a class="header" href="#zagnieÅ¼dÅ¼one-struktury-i-wyliczenia">ZagnieÅ¼dÅ¼one Struktury i Wyliczenia</a></h4>
<p>Do tej pory wszystkie nasze przykÅ‚ady dotyczyÅ‚y dopasowywania struktur lub wyliczeÅ„ na jednym poziomie, ale dopasowywanie moÅ¼e dziaÅ‚aÄ‡ rÃ³wnieÅ¼ na zagnieÅ¼dÅ¼onych elementach! Na przykÅ‚ad, moÅ¼emy refaktoryzowaÄ‡ kod z Listy 19-15, aby obsÅ‚ugiwaÅ‚ kolory RGB i HSV w wiadomoÅ›ci <code>ChangeColor</code>, jak pokazano na LiÅ›cie 19-16.</p>
<figure class="listing" id="listing-19-16">
<pre class="playground"><code class="language-rust edition2024">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!("Change color to hue {h}, saturation {s}, value {v}");
        }
        _ =&gt; (),
    }
}</code></pre>
<figcaption><a href="#listing-19-16">Lista 19-16</a>: Dopasowywanie zagnieÅ¼dÅ¼onych wyliczeÅ„</figcaption>
</figure>
<p>Wzorzec pierwszego ramienia w wyraÅ¼eniu <code>match</code> pasuje do wariantu wyliczeniowego <code>Message::ChangeColor</code>, ktÃ³ry zawiera wariant <code>Color::Rgb</code>; nastÄ™pnie wzorzec wiÄ…Å¼e siÄ™ z trzema wewnÄ™trznymi wartoÅ›ciami <code>i32</code>. Wzorzec drugiego ramienia rÃ³wnieÅ¼ pasuje do wariantu wyliczeniowego <code>Message::ChangeColor</code>, ale wewnÄ™trzne wyliczenie pasuje zamiast tego do <code>Color::Hsv</code>. MoÅ¼emy okreÅ›liÄ‡ te zÅ‚oÅ¼one warunki w jednym wyraÅ¼eniu <code>match</code>, mimo Å¼e biorÄ… w nim udziaÅ‚ dwa wyliczenia.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="destructuring-structs-and-tuples"></a></p>
<h4 id="struktury-i-krotki"><a class="header" href="#struktury-i-krotki">Struktury i Krotki</a></h4>
<p>MoÅ¼emy mieszaÄ‡, dopasowywaÄ‡ i zagnieÅ¼dÅ¼aÄ‡ wzorce dekonstrukcji na jeszcze bardziej zÅ‚oÅ¼one sposoby. PoniÅ¼szy przykÅ‚ad pokazuje skomplikowanÄ… dekonstrukcjÄ™, w ktÃ³rej zagnieÅ¼dÅ¼amy struktury i krotki wewnÄ…trz krotki i dekonstruujemy wszystkie wartoÅ›ci pierwotne:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}</span></code></pre>
<p>Ten kod pozwala nam rozbiÄ‡ zÅ‚oÅ¼one typy na ich czÄ™Å›ci skÅ‚adowe, abyÅ›my mogli osobno uÅ¼ywaÄ‡ wartoÅ›ci, ktÃ³re nas interesujÄ….</p>
<p>Dekonstrukcja za pomocÄ… wzorcÃ³w to wygodny sposÃ³b na uÅ¼ywanie czÄ™Å›ci wartoÅ›ci, takich jak wartoÅ›Ä‡ z kaÅ¼dego pola w strukturze, oddzielnie od siebie.</p>
<h3 id="ignorowanie-wartoÅ›ci-we-wzorcu"><a class="header" href="#ignorowanie-wartoÅ›ci-we-wzorcu">Ignorowanie WartoÅ›ci we Wzorcu</a></h3>
<p>WidziaÅ‚eÅ›, Å¼e czasami przydatne jest ignorowanie wartoÅ›ci we wzorcu, na przykÅ‚ad w ostatnim ramieniu <code>match</code>, aby uzyskaÄ‡ catch-all, ktÃ³ry faktycznie nic nie robi, ale uwzglÄ™dnia wszystkie pozostaÅ‚e moÅ¼liwe wartoÅ›ci. Istnieje kilka sposobÃ³w ignorowania caÅ‚ych wartoÅ›ci lub czÄ™Å›ci wartoÅ›ci we wzorcu: uÅ¼ycie wzorca <code>_</code> (ktÃ³ry juÅ¼ widziaÅ‚eÅ›), uÅ¼ycie wzorca <code>_</code> w innym wzorcu, uÅ¼ycie nazwy zaczynajÄ…cej siÄ™ od podkreÅ›lenia lub uÅ¼ycie <code>..</code>, aby zignorowaÄ‡ pozostaÅ‚e czÄ™Å›ci wartoÅ›ci. Przyjrzyjmy siÄ™, jak i dlaczego uÅ¼ywaÄ‡ kaÅ¼dego z tych wzorcÃ³w.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="ignoring-an-entire-value-with-_"></a></p>
<h4 id="caÅ‚a-wartoÅ›Ä‡-za-pomocÄ…-_"><a class="header" href="#caÅ‚a-wartoÅ›Ä‡-za-pomocÄ…-_">CaÅ‚a WartoÅ›Ä‡ za pomocÄ… <code>_</code></a></h4>
<p>UÅ¼ywaliÅ›my podkreÅ›lenia jako wzorca wieloznacznego, ktÃ³ry bÄ™dzie pasowaÅ‚ do dowolnej wartoÅ›ci, ale nie bÄ™dzie wiÄ…zaÅ‚ siÄ™ z wartoÅ›ciÄ…. Jest to szczegÃ³lnie przydatne jako ostatnie ramiÄ™ w wyraÅ¼eniu <code>match</code>, ale moÅ¼emy go rÃ³wnieÅ¼ uÅ¼ywaÄ‡ w dowolnym wzorcu, w tym w parametrach funkcji, jak pokazano na LiÅ›cie 19-17.</p>
<figure class="listing" id="listing-19-17">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {y}");
}

fn main() {
    foo(3, 4);
}</code></pre>
<figcaption><a href="#listing-19-17">Lista 19-17</a>: UÅ¼ycie <code>_</code> w sygnaturze funkcji</figcaption>
</figure>
<p>Ten kod caÅ‚kowicie zignoruje wartoÅ›Ä‡ <code>3</code> przekazanÄ… jako pierwszy argument i wydrukuje <code>This code only uses the y parameter: 4</code>.</p>
<p>W wiÄ™kszoÅ›ci przypadkÃ³w, gdy nie potrzebujesz juÅ¼ konkretnego parametru funkcji, zmieniÅ‚byÅ› sygnaturÄ™ tak, aby nie zawieraÅ‚a nieuÅ¼ywanego parametru. Ignorowanie parametru funkcji moÅ¼e byÄ‡ szczegÃ³lnie przydatne w przypadkach, gdy na przykÅ‚ad implementujesz cechÄ™, gdy potrzebujesz okreÅ›lonej sygnatury typu, ale ciaÅ‚o funkcji w Twojej implementacji nie potrzebuje jednego z parametrÃ³w. Wtedy unikasz ostrzeÅ¼enia kompilatora o nieuÅ¼ywanych parametrach funkcji, tak jakbyÅ› uÅ¼yÅ‚ nazwy zamiast.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="ignoring-parts-of-a-value-with-a-nested-_"></a></p>
<h4 id="fragmenty-wartoÅ›ci-z-zagnieÅ¼dÅ¼onym-_"><a class="header" href="#fragmenty-wartoÅ›ci-z-zagnieÅ¼dÅ¼onym-_">Fragmenty WartoÅ›ci z ZagnieÅ¼dÅ¼onym <code>_</code></a></h4>
<p>MoÅ¼emy rÃ³wnieÅ¼ uÅ¼ywaÄ‡ <code>_</code> wewnÄ…trz innego wzorca, aby zignorowaÄ‡ tylko czÄ™Å›Ä‡ wartoÅ›ci, na przykÅ‚ad, gdy chcemy przetestowaÄ‡ tylko czÄ™Å›Ä‡ wartoÅ›ci, ale nie mamy zastosowania dla pozostaÅ‚ych czÄ™Å›ci w odpowiadajÄ…cym kodzie, ktÃ³ry chcemy uruchomiÄ‡. Lista 19-18 pokazuje kod odpowiedzialny za zarzÄ…dzanie wartoÅ›ciÄ… ustawienia. Wymagania biznesowe sÄ… takie, Å¼e uÅ¼ytkownikowi nie wolno nadpisywaÄ‡ istniejÄ…cej dostosowanej wartoÅ›ci ustawienia, ale moÅ¼e anulowaÄ‡ ustawienie i nadaÄ‡ mu wartoÅ›Ä‡, jeÅ›li jest ono obecnie niezdefiniowane.</p>
<figure class="listing" id="listing-19-18">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!("Can't overwrite an existing customized value");
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!("setting is {setting_value:?}");
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-18">Lista 19-18</a>: UÅ¼ycie podkreÅ›lenia w wzorcach pasujÄ…cych do wariantÃ³w <code>Some</code>, gdy nie musimy uÅ¼ywaÄ‡ wartoÅ›ci wewnÄ…trz <code>Some</code></figcaption>
</figure>
<p>Ten kod wypisze <code>Can't overwrite an existing customized value</code>, a nastÄ™pnie <code>setting is Some(5)</code>. W pierwszym ramieniu <code>match</code> nie musimy dopasowywaÄ‡ ani uÅ¼ywaÄ‡ wartoÅ›ci wewnÄ…trz Å¼adnego z wariantÃ³w <code>Some</code>, ale musimy sprawdziÄ‡ przypadek, gdy <code>setting_value</code> i <code>new_setting_value</code> sÄ… wariantem <code>Some</code>. W takim przypadku wypisujemy powÃ³d, dla ktÃ³rego <code>setting_value</code> nie zostanie zmienione, i nie zostanie ono zmienione.</p>
<p>We wszystkich innych przypadkach (jeÅ›li <code>setting_value</code> lub <code>new_setting_value</code> jest <code>None</code>), wyraÅ¼onych wzorcem <code>_</code> w drugim ramieniu, chcemy, aby <code>new_setting_value</code> staÅ‚o siÄ™ <code>setting_value</code>.</p>
<p>MoÅ¼emy rÃ³wnieÅ¼ uÅ¼ywaÄ‡ podkreÅ›leÅ„ w wielu miejscach w jednym wzorcu, aby ignorowaÄ‡ okreÅ›lone wartoÅ›ci. Lista 19-19 pokazuje przykÅ‚ad ignorowania drugiej i czwartej wartoÅ›ci w krotce piÄ™ciu elementÃ³w.</p>
<figure class="listing" id="listing-19-19">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!("Some numbers: {first}, {third}, {fifth}");
        }
    }
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-19">Lista 19-19</a>: Ignorowanie wielu czÄ™Å›ci krotki</figcaption>
</figure>
<p>Ten kod wypisze <code>Some numbers: 2, 8, 32</code>, a wartoÅ›ci <code>4</code> i <code>16</code> zostanÄ… zignorowane.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="ignoring-an-unused-variable-by-starting-its-name-with-_"></a></p>
<h4 id="nieuÅ¼ywana-zmienna-zaczynajÄ…ca-siÄ™-od-_"><a class="header" href="#nieuÅ¼ywana-zmienna-zaczynajÄ…ca-siÄ™-od-_">NieuÅ¼ywana Zmienna, ZaczynajÄ…ca SiÄ™ od <code>_</code></a></h4>
<p>JeÅ›li utworzysz zmiennÄ…, ale nie uÅ¼yjesz jej nigdzie, Rust zazwyczaj wyÅ›wietli ostrzeÅ¼enie, poniewaÅ¼ nieuÅ¼ywana zmienna moÅ¼e byÄ‡ bÅ‚Ä™dem. Czasami jednak przydatne jest stworzenie zmiennej, ktÃ³rej jeszcze nie uÅ¼yjesz, na przykÅ‚ad podczas prototypowania lub rozpoczynania projektu. W tej sytuacji moÅ¼esz powiedzieÄ‡ Rust, aby nie ostrzegaÅ‚ CiÄ™ o nieuÅ¼ywanej zmiennej, zaczynajÄ…c nazwÄ™ zmiennej od podkreÅ›lenia. Na LiÅ›cie 19-20 tworzymy dwie nieuÅ¼ywane zmienne, ale po skompilowaniu tego kodu powinniÅ›my otrzymaÄ‡ ostrzeÅ¼enie tylko o jednej z nich.</p>
<figure class="listing" id="listing-19-20">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let _x = 5;
    let y = 10;
}</code></pre>
<figcaption><a href="#listing-19-20">Lista 19-20</a>: Rozpoczynanie nazwy zmiennej od podkreÅ›lenia w celu unikniÄ™cia ostrzeÅ¼eÅ„ o nieuÅ¼ywanych zmiennych</figcaption>
</figure>
<p>Tutaj otrzymujemy ostrzeÅ¼enie o nieuÅ¼ywaniu zmiennej <code>y</code>, ale nie otrzymujemy ostrzeÅ¼enia o nieuÅ¼ywaniu <code>_x</code>.</p>
<p>ZauwaÅ¼, Å¼e istnieje subtelna rÃ³Å¼nica miÄ™dzy uÅ¼ywaniem samego <code>_</code> a uÅ¼ywaniem nazwy zaczynajÄ…cej siÄ™ od podkreÅ›lenia. SkÅ‚adnia <code>_x</code> nadal wiÄ…Å¼e wartoÅ›Ä‡ ze zmiennÄ…, podczas gdy <code>_</code> w ogÃ³le nie wiÄ…Å¼e. Aby pokazaÄ‡ przypadek, w ktÃ³rym ta rÃ³Å¼nica ma znaczenie, Lista 19-21 dostarczy nam bÅ‚Ä™du.</p>
<figure class="listing" id="listing-19-21">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_s) = s {
        println!("found a string");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-21">Lista 19-21</a>: NieuÅ¼ywana zmienna zaczynajÄ…ca siÄ™ od podkreÅ›lenia nadal wiÄ…Å¼e wartoÅ›Ä‡, co moÅ¼e przejÄ…Ä‡ wÅ‚asnoÅ›Ä‡ wartoÅ›ci.</figcaption>
</figure>
<p>Otrzymamy bÅ‚Ä…d, poniewaÅ¼ wartoÅ›Ä‡ <code>s</code> zostanie nadal przeniesiona do <code>_s</code>, co uniemoÅ¼liwi nam ponowne uÅ¼ycie <code>s</code>. Jednak uÅ¼ycie samego podkreÅ›lenia nigdy nie wiÄ…Å¼e siÄ™ z wartoÅ›ciÄ…. Lista 19-22 skompiluje siÄ™ bez bÅ‚Ä™dÃ³w, poniewaÅ¼ <code>s</code> nie zostanie przeniesione do <code>_</code>.</p>
<figure class="listing" id="listing-19-22">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_) = s {
        println!("found a string");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-22">Lista 19-22</a>: UÅ¼ycie podkreÅ›lenia nie wiÄ…Å¼e wartoÅ›ci.</figcaption>
</figure>
<p>Ten kod dziaÅ‚a bez zarzutu, poniewaÅ¼ nigdy nie wiÄ…Å¼emy <code>s</code> z niczym; nie zostaje przeniesione.</p>
<p><a id="ignoring-remaining-parts-of-a-value-with-"></a></p>
<h4 id="pozostaÅ‚e-czÄ™Å›ci-wartoÅ›ci-za-pomocÄ…-"><a class="header" href="#pozostaÅ‚e-czÄ™Å›ci-wartoÅ›ci-za-pomocÄ…-">PozostaÅ‚e CzÄ™Å›ci WartoÅ›ci za pomocÄ… <code>..</code></a></h4>
<p>W przypadku wartoÅ›ci, ktÃ³re majÄ… wiele czÄ™Å›ci, moÅ¼emy uÅ¼yÄ‡ skÅ‚adni <code>..</code>, aby uÅ¼yÄ‡ konkretnych czÄ™Å›ci i zignorowaÄ‡ resztÄ™, unikajÄ…c koniecznoÅ›ci wymieniania podkreÅ›leÅ„ dla kaÅ¼dej ignorowanej wartoÅ›ci. Wzorzec <code>..</code> ignoruje wszystkie czÄ™Å›ci wartoÅ›ci, ktÃ³rych nie dopasowaliÅ›my jawnie w pozostaÅ‚ej czÄ™Å›ci wzorca. Na LiÅ›cie 19-23 mamy strukturÄ™ <code>Point</code>, ktÃ³ra przechowuje wspÃ³Å‚rzÄ™dnÄ… w trÃ³jwymiarowej przestrzeni. W wyraÅ¼eniu <code>match</code> chcemy operowaÄ‡ tylko na wspÃ³Å‚rzÄ™dnej <code>x</code> i ignorowaÄ‡ wartoÅ›ci w polach <code>y</code> i <code>z</code>.</p>
<figure class="listing" id="listing-19-23">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!("x is {x}"),
    }
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-23">Lista 19-23</a>: Ignorowanie wszystkich pÃ³l <code>Point</code> oprÃ³cz <code>x</code> za pomocÄ… <code>..</code></figcaption>
</figure>
<p>Wypisujemy wartoÅ›Ä‡ <code>x</code>, a nastÄ™pnie po prostu dodajemy wzorzec <code>..</code>. Jest to szybsze niÅ¼ koniecznoÅ›Ä‡ wypisywania <code>y: _</code> i <code>z: _</code>, szczegÃ³lnie gdy pracujemy ze strukturami, ktÃ³re majÄ… wiele pÃ³l w sytuacjach, gdy tylko jedno lub dwa pola sÄ… istotne.</p>
<p>SkÅ‚adnia <code>..</code> rozszerzy siÄ™ do tylu wartoÅ›ci, ile potrzebuje. Lista 19-24 pokazuje, jak uÅ¼ywaÄ‡ <code>..</code> z krotkÄ….</p>
<figure class="listing" id="listing-19-24">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!("Some numbers: {first}, {last}");
        }
    }
}</code></pre>
<figcaption><a href="#listing-19-24">Lista 19-24</a>: Dopasowywanie tylko pierwszej i ostatniej wartoÅ›ci w krotce i ignorowanie wszystkich pozostaÅ‚ych wartoÅ›ci</figcaption>
</figure>
<p>W tym kodzie pierwsza i ostatnia wartoÅ›Ä‡ sÄ… dopasowywane do <code>first</code> i <code>last</code>. <code>..</code> dopasuje i zignoruje wszystko poÅ›rodku.</p>
<p>JednakÅ¼e, uÅ¼ywanie <code>..</code> musi byÄ‡ jednoznaczne. JeÅ›li nie jest jasne, ktÃ³re wartoÅ›ci sÄ… przeznaczone do dopasowania, a ktÃ³re powinny zostaÄ‡ zignorowane, Rust zgÅ‚osi bÅ‚Ä…d. Lista 19-25 pokazuje przykÅ‚ad niejednoznacznego uÅ¼ycia <code>..</code>, dlatego nie skompiluje siÄ™.</p>
<figure class="listing" id="listing-19-25">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!("Some numbers: {second}")
        },
    }
}</code></pre>
<figcaption><a href="#listing-19-25">Lista 19-25</a>: PrÃ³ba uÅ¼ycia <code>..</code> w sposÃ³b niejednoznaczny</figcaption>
</figure>
<p>Kiedy skompilujemy ten przykÅ‚ad, otrzymamy ten bÅ‚Ä…d:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>Rust nie jest w stanie okreÅ›liÄ‡, ile wartoÅ›ci w krotce naleÅ¼y zignorowaÄ‡ przed dopasowaniem wartoÅ›ci do <code>second</code>, a nastÄ™pnie ile dalszych wartoÅ›ci naleÅ¼y zignorowaÄ‡. Ten kod mÃ³gÅ‚by oznaczaÄ‡, Å¼e chcemy zignorowaÄ‡ <code>2</code>, powiÄ…zaÄ‡ <code>second</code> z <code>4</code>, a nastÄ™pnie zignorowaÄ‡ <code>8</code>, <code>16</code> i <code>32</code>; albo Å¼e chcemy zignorowaÄ‡ <code>2</code> i <code>4</code>, powiÄ…zaÄ‡ <code>second</code> z <code>8</code>, a nastÄ™pnie zignorowaÄ‡ <code>16</code> i <code>32</code>; i tak dalej. Nazwa zmiennej <code>second</code> nie oznacza niczego specjalnego dla Rust, wiÄ™c otrzymujemy bÅ‚Ä…d kompilatora, poniewaÅ¼ uÅ¼ycie <code>..</code> w dwÃ³ch miejscach w ten sposÃ³b jest niejednoznaczne.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="extra-conditionals-with-match-guards"></a></p>
<h3 id="dodawanie-warunkÃ³w-za-pomocÄ…-match-guardÃ³w"><a class="header" href="#dodawanie-warunkÃ³w-za-pomocÄ…-match-guardÃ³w">Dodawanie WarunkÃ³w za pomocÄ… Match GuardÃ³w</a></h3>
<p><em>Match guard</em> to dodatkowy warunek <code>if</code>, okreÅ›lony po wzorcu w ramieniu <code>match</code>, ktÃ³ry rÃ³wnieÅ¼ musi zostaÄ‡ speÅ‚niony, aby to ramiÄ™ zostaÅ‚o wybrane. Match guardy sÄ… przydatne do wyraÅ¼ania bardziej zÅ‚oÅ¼onych idei niÅ¼ sam wzorzec. ZauwaÅ¼ jednak, Å¼e sÄ… one dostÄ™pne tylko w wyraÅ¼eniach <code>match</code>, a nie w wyraÅ¼eniach <code>if let</code> ani <code>while let</code>.</p>
<p>Warunek moÅ¼e uÅ¼ywaÄ‡ zmiennych utworzonych we wzorcu. Lista 19-26 pokazuje <code>match</code>, gdzie pierwsze ramiÄ™ ma wzorzec <code>Some(x)</code> i dodatkowo match guard <code>if x % 2 == 0</code> (ktÃ³ry bÄ™dzie <code>true</code>, jeÅ›li liczba jest parzysta).</p>
<figure class="listing" id="listing-19-26">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!("The number {x} is even"),
        Some(x) =&gt; println!("The number {x} is odd"),
        None =&gt; (),
    }
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-26">Lista 19-26</a>: Dodawanie match guarda do wzorca</figcaption>
</figure>
<p>Ten przykÅ‚ad wypisze <code>The number 4 is even</code>. Gdy <code>num</code> jest porÃ³wnywane z wzorcem w pierwszym ramieniu, pasuje, poniewaÅ¼ <code>Some(4)</code> pasuje do <code>Some(x)</code>. NastÄ™pnie match guard sprawdza, czy reszta z dzielenia <code>x</code> przez 2 jest rÃ³wna 0, a poniewaÅ¼ tak jest, wybrane zostaje pierwsze ramiÄ™.</p>
<p>Gdyby <code>num</code> byÅ‚o <code>Some(5)</code> zamiast tego, match guard w pierwszym ramieniu byÅ‚by <code>false</code>, poniewaÅ¼ reszta z dzielenia 5 przez 2 wynosi 1, co nie jest rÃ³wne 0. Rust nastÄ™pnie przeszedÅ‚by do drugiego ramienia, ktÃ³re by pasowaÅ‚o, poniewaÅ¼ drugie ramiÄ™ nie ma match guarda i dlatego pasuje do dowolnego wariantu <code>Some</code>.</p>
<p>Nie ma sposobu, aby wyraziÄ‡ warunek <code>if x % 2 == 0</code> w ramach wzorca, wiÄ™c match guard daje nam moÅ¼liwoÅ›Ä‡ wyraÅ¼enia tej logiki. WadÄ… tej dodatkowej ekspresywnoÅ›ci jest to, Å¼e kompilator nie prÃ³buje sprawdzaÄ‡ kompletnoÅ›ci, gdy w grÄ™ wchodzÄ… wyraÅ¼enia match guard.</p>
<p>Podczas omawiania Listy 19-11, wspomnieliÅ›my, Å¼e moglibyÅ›my uÅ¼yÄ‡ match guardÃ³w do rozwiÄ…zania naszego problemu z zasÅ‚anianiem wzorcÃ³w. Przypomnijmy, Å¼e stworzyliÅ›my nowÄ… zmiennÄ… wewnÄ…trz wzorca w wyraÅ¼eniu <code>match</code> zamiast uÅ¼ywaÄ‡ zmiennej poza <code>match</code>. Ta nowa zmienna oznaczaÅ‚a, Å¼e nie mogliÅ›my testowaÄ‡ wartoÅ›ci zmiennej zewnÄ™trznej. Lista 19-27 pokazuje, jak moÅ¼emy uÅ¼yÄ‡ match guarda, aby naprawiÄ‡ ten problem.</p>
<figure class="listing" id="listing-19-27">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(n) if n == y =&gt; println!("Matched, n = {n}"),
        _ =&gt; println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
}</code></pre>
<figcaption><a href="#listing-19-27">Lista 19-27</a>: UÅ¼ycie match guarda do testowania rÃ³wnoÅ›ci z zewnÄ™trznÄ… zmiennÄ…</figcaption>
</figure>
<p>Ten kod wydrukuje teraz <code>Default case, x = Some(5)</code>. Wzorzec w drugim ramieniu <code>match</code> nie wprowadza nowej zmiennej <code>y</code>, ktÃ³ra zasÅ‚aniaÅ‚aby zewnÄ™trznÄ… <code>y</code>, co oznacza, Å¼e moÅ¼emy uÅ¼yÄ‡ zewnÄ™trznej <code>y</code> w match guardzie. Zamiast okreÅ›laÄ‡ wzorzec jako <code>Some(y)</code>, co zasÅ‚oniÅ‚oby zewnÄ™trznÄ… <code>y</code>, okreÅ›lamy <code>Some(n)</code>. Tworzy to nowÄ… zmiennÄ… <code>n</code>, ktÃ³ra niczego nie zasÅ‚ania, poniewaÅ¼ poza <code>match</code> nie ma zmiennej <code>n</code>.</p>
<p>Match guard <code>if n == y</code> nie jest wzorcem i dlatego nie wprowadza nowych zmiennych. To <code>y</code> <em>jest</em> zewnÄ™trznym <code>y</code>, a nie nowym <code>y</code> je zasÅ‚aniajÄ…cym, i moÅ¼emy szukaÄ‡ wartoÅ›ci, ktÃ³ra ma takÄ… samÄ… wartoÅ›Ä‡ jak zewnÄ™trzne <code>y</code>, porÃ³wnujÄ…c <code>n</code> z <code>y</code>.</p>
<p>MoÅ¼esz rÃ³wnieÅ¼ uÅ¼yÄ‡ operatora <em>lub</em> <code>|</code> w match guardzie, aby okreÅ›liÄ‡ wiele wzorcÃ³w; warunek match guarda bÄ™dzie miaÅ‚ zastosowanie do wszystkich wzorcÃ³w. Lista 19-28 pokazuje pierwszeÅ„stwo przy Å‚Ä…czeniu wzorca uÅ¼ywajÄ…cego <code>|</code> z match guardem. WaÅ¼nÄ… czÄ™Å›ciÄ… tego przykÅ‚adu jest to, Å¼e match guard <code>if y</code> ma zastosowanie do <code>4</code>, <code>5</code> <em>i</em> <code>6</code>, mimo Å¼e moÅ¼e wydawaÄ‡ siÄ™, Å¼e <code>if y</code> ma zastosowanie tylko do <code>6</code>.</p>
<figure class="listing" id="listing-19-28">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!("yes"),
        _ =&gt; println!("no"),
    }
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-28">Lista 19-28</a>: ÅÄ…czenie wielu wzorcÃ³w z match guardem</figcaption>
</figure>
<p>Warunek dopasowania stwierdza, Å¼e ramiÄ™ pasuje tylko wtedy, gdy wartoÅ›Ä‡ <code>x</code> jest rÃ³wna <code>4</code>, <code>5</code> lub <code>6</code> <em>i</em> jeÅ›li <code>y</code> jest <code>true</code>. Kiedy ten kod siÄ™ uruchamia, wzorzec pierwszego ramienia pasuje, poniewaÅ¼ <code>x</code> wynosi <code>4</code>, ale match guard <code>if y</code> jest <code>false</code>, wiÄ™c pierwsze ramiÄ™ nie zostaje wybrane. Kod przechodzi do drugiego ramienia, ktÃ³re pasuje, a program wypisuje <code>no</code>. Powodem jest to, Å¼e warunek <code>if</code> ma zastosowanie do caÅ‚ego wzorca <code>4 | 5 | 6</code>, a nie tylko do ostatniej wartoÅ›ci <code>6</code>. Innymi sÅ‚owy, pierwszeÅ„stwo match guarda w stosunku do wzorca zachowuje siÄ™ w ten sposÃ³b:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>zamiast tego:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>Po uruchomieniu kodu zachowanie pierwszeÅ„stwa jest oczywiste: gdyby match guard byÅ‚ stosowany tylko do ostatniej wartoÅ›ci na liÅ›cie wartoÅ›ci okreÅ›lonych za pomocÄ… operatora <code>|</code>, ramiÄ™ pasowaÅ‚oby, a program wydrukowaÅ‚by <code>yes</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="-bindings"></a></p>
<h3 id="uÅ¼ywanie-wiÄ…zaÅ„-"><a class="header" href="#uÅ¼ywanie-wiÄ…zaÅ„-">UÅ¼ywanie WiÄ…zaÅ„ <code>@</code></a></h3>
<p>Operator <em>at</em> <code>@</code> pozwala nam utworzyÄ‡ zmiennÄ…, ktÃ³ra przechowuje wartoÅ›Ä‡ w tym samym czasie, gdy testujemy tÄ™ wartoÅ›Ä‡ pod kÄ…tem dopasowania wzorca. Na LiÅ›cie 19-29 chcemy sprawdziÄ‡, czy pole <code>id</code> w <code>Message::Hello</code> mieÅ›ci siÄ™ w zakresie <code>3..=7</code>. Chcemy rÃ³wnieÅ¼ powiÄ…zaÄ‡ wartoÅ›Ä‡ ze zmiennÄ… <code>id</code>, aby mÃ³c jej uÅ¼yÄ‡ w kodzie skojarzonym z ramieniem.</p>
<figure class="listing" id="listing-19-29">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello { id: id @ 3..=7 } =&gt; {
            println!("Found an id in range: {id}")
        }
        Message::Hello { id: 10..=12 } =&gt; {
            println!("Found an id in another range")
        }
        Message::Hello { id } =&gt; println!("Found some other id: {id}"),
    }
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-29">Lista 19-29</a>: UÅ¼ycie <code>@</code> do zwiÄ…zania siÄ™ z wartoÅ›ciÄ… we wzorcu, jednoczeÅ›nie jÄ… testujÄ…c</figcaption>
</figure>
<p>Ten przykÅ‚ad wydrukuje <code>Found an id in range: 5</code>. OkreÅ›lajÄ…c <code>id @</code> przed zakresem <code>3..=7</code>, przechwytujemy dowolnÄ… wartoÅ›Ä‡, ktÃ³ra pasuje do zakresu, w zmiennej nazwanej <code>id</code>, jednoczeÅ›nie testujÄ…c, czy wartoÅ›Ä‡ pasuje do wzorca zakresu.</p>
<p>W drugim ramieniu, gdzie we wzorcu mamy okreÅ›lony tylko zakres, kod skojarzony z ramieniem nie ma zmiennej zawierajÄ…cej faktycznÄ… wartoÅ›Ä‡ pola <code>id</code>. WartoÅ›Ä‡ pola <code>id</code> mogÅ‚a wynosiÄ‡ 10, 11 lub 12, ale kod, ktÃ³ry towarzyszy temu wzorcowi, nie wie, ktÃ³ra to jest. Kod wzorca nie jest w stanie uÅ¼yÄ‡ wartoÅ›ci z pola <code>id</code>, poniewaÅ¼ nie zapisaliÅ›my wartoÅ›ci <code>id</code> w zmiennej.</p>
<p>W ostatnim ramieniu, gdzie okreÅ›liliÅ›my zmiennÄ… bez zakresu, mamy dostÄ™pnÄ… wartoÅ›Ä‡ do uÅ¼ycia w kodzie ramienia w zmiennej o nazwie <code>id</code>. Powodem jest to, Å¼e uÅ¼yliÅ›my skrÃ³conej skÅ‚adni pÃ³l struktury. Ale w tym ramieniu nie zastosowaliÅ›my Å¼adnego testu do wartoÅ›ci w polu <code>id</code>, tak jak zrobiliÅ›my to w dwÃ³ch pierwszych ramionach: dowolna wartoÅ›Ä‡ pasowaÅ‚aby do tego wzorca.</p>
<p>UÅ¼ywanie <code>@</code> pozwala nam testowaÄ‡ wartoÅ›Ä‡ i zapisywaÄ‡ jÄ… w zmiennej w ramach jednego wzorca.</p>
<h2 id="podsumowanie-18"><a class="header" href="#podsumowanie-18">Podsumowanie</a></h2>
<p>Wzorce Rust sÄ… bardzo przydatne w rozrÃ³Å¼nianiu rÃ³Å¼nych rodzajÃ³w danych. UÅ¼ywane w wyraÅ¼eniach <code>match</code>, Rust zapewnia, Å¼e Twoje wzorce obejmujÄ… kaÅ¼dÄ… moÅ¼liwÄ… wartoÅ›Ä‡, w przeciwnym razie TwÃ³j program siÄ™ nie skompiluje. Wzorce w instrukcjach <code>let</code> i parametrach funkcji czyniÄ… te konstrukcje bardziej uÅ¼ytecznymi, umoÅ¼liwiajÄ…c dekonstrukcjÄ™ wartoÅ›ci na mniejsze czÄ™Å›ci i przypisywanie tych czÄ™Å›ci do zmiennych. MoÅ¼emy tworzyÄ‡ proste lub zÅ‚oÅ¼one wzorce, aby sprostaÄ‡ naszym potrzebom.</p>
<p>NastÄ™pnie, w przedostatnim rozdziale ksiÄ…Å¼ki, przyjrzymy siÄ™ niektÃ³rym zaawansowanym aspektom rÃ³Å¼nych funkcji Rust.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="zaawansowane-funkcje"><a class="header" href="#zaawansowane-funkcje">Zaawansowane Funkcje</a></h1>
<p>Do tej pory poznaÅ‚eÅ› najczÄ™Å›ciej uÅ¼ywane czÄ™Å›ci jÄ™zyka programowania Rust. Zanim przejdziemy do kolejnego projektu w Rozdziale 21, przyjrzymy siÄ™ kilku aspektom jÄ™zyka, z ktÃ³rymi moÅ¼esz siÄ™ od czasu do czasu spotkaÄ‡, ale ktÃ³rych byÄ‡ moÅ¼e nie bÄ™dziesz uÅ¼ywaÄ‡ na co dzieÅ„. MoÅ¼esz uÅ¼ywaÄ‡ tego rozdziaÅ‚u jako odniesienia, gdy napotkasz jakieÅ› niewiadome. Funkcje omÃ³wione tutaj sÄ… przydatne w bardzo specyficznych sytuacjach. ChociaÅ¼ moÅ¼esz nie siÄ™gaÄ‡ po nie czÄ™sto, chcemy upewniÄ‡ siÄ™, Å¼e rozumiesz wszystkie funkcje, ktÃ³re Rust ma do zaoferowania.</p>
<p>W tym rozdziale omÃ³wimy:</p>
<ul>
<li>Niebezpieczny Rust: Jak zrezygnowaÄ‡ z niektÃ³rych gwarancji Rust i wziÄ…Ä‡ odpowiedzialnoÅ›Ä‡ za rÄ™czne ich utrzymanie</li>
<li>Zaawansowane traity: Typy stowarzyszone, domyÅ›lne parametry typÃ³w, w peÅ‚ni kwalifikowana skÅ‚adnia, supertraity i wzorzec newtype w odniesieniu do traitÃ³w</li>
<li>Zaawansowane typy: WiÄ™cej o wzorcu newtype, aliasach typÃ³w, typie nigdy i typach o dynamicznym rozmiarze</li>
<li>Zaawansowane funkcje i domkniÄ™cia: WskaÅºniki funkcji i zwracanie domkniÄ™Ä‡</li>
<li>Makrodefinicje: Sposoby definiowania kodu, ktÃ³ry definiuje wiÄ™cej kodu w czasie kompilacji</li>
</ul>
<p>To prawdziwa paleta funkcji Rust, w ktÃ³rej kaÅ¼dy znajdzie coÅ› dla siebie! Zanurzmy siÄ™!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="niebezpieczny-rust-1"><a href="#niebezpieczny-rust-1" class="header">Niebezpieczny Rust</a></h1>
<h2 id="niebezpieczny-rust"><a class="header" href="#niebezpieczny-rust">Niebezpieczny Rust</a></h2>
<p>Wszystkie omawiane do tej pory kody miaÅ‚y gwarancje bezpieczeÅ„stwa pamiÄ™ci Rust egzekwowane w czasie kompilacji. Jednak Rust ma w sobie drugi, ukryty jÄ™zyk, ktÃ³ry nie egzekwuje tych gwarancji bezpieczeÅ„stwa pamiÄ™ci: nazywa siÄ™ go <em>niebezpiecznym Rustem</em> i dziaÅ‚a dokÅ‚adnie tak samo jak zwykÅ‚y Rust, ale daje nam dodatkowe supermoce.</p>
<p>Niebezpieczny Rust istnieje, poniewaÅ¼ z natury analiza statyczna jest konserwatywna. Kiedy kompilator prÃ³buje okreÅ›liÄ‡, czy kod speÅ‚nia gwarancje, lepiej jest, aby odrzuciÅ‚ niektÃ³re prawidÅ‚owe programy, niÅ¼ zaakceptowaÅ‚ niektÃ³re nieprawidÅ‚owe programy. ChociaÅ¼ kod <em>moÅ¼e</em> byÄ‡ w porzÄ…dku, jeÅ›li kompilator Rust nie ma wystarczajÄ…cych informacji, aby byÄ‡ pewnym, odrzuci kod. W takich przypadkach moÅ¼esz uÅ¼yÄ‡ kodu niebezpiecznego, aby powiedzieÄ‡ kompilatorowi: â€Zaufaj mi, wiem, co robiÄ™â€. Ostrzegamy jednak, Å¼e uÅ¼ywasz niebezpiecznego Rust na wÅ‚asne ryzyko: jeÅ›li uÅ¼yjesz kodu niebezpiecznego niepoprawnie, mogÄ… wystÄ…piÄ‡ problemy z powodu niebezpieczeÅ„stwa pamiÄ™ci, takie jak dereferencja wskaÅºnika null.</p>
<p>Innym powodem, dla ktÃ³rego Rust ma swoje niebezpieczne alter ego, jest to, Å¼e podstawowy sprzÄ™t komputerowy jest z natury niebezpieczny. Gdyby Rust nie pozwalaÅ‚ na wykonywanie niebezpiecznych operacji, nie moÅ¼na by wykonywaÄ‡ pewnych zadaÅ„. Rust musi pozwalaÄ‡ na programowanie systemÃ³w niskiego poziomu, takie jak bezpoÅ›rednia interakcja z systemem operacyjnym, a nawet pisanie wÅ‚asnego systemu operacyjnego. Praca z programowaniem systemÃ³w niskiego poziomu jest jednym z celÃ³w jÄ™zyka. Przyjrzyjmy siÄ™, co moÅ¼emy zrobiÄ‡ z niebezpiecznym Rust i jak to zrobiÄ‡.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="unsafe-superpowers"></a></p>
<h3 id="wykonywanie-niebezpiecznych-supermocy"><a class="header" href="#wykonywanie-niebezpiecznych-supermocy">Wykonywanie Niebezpiecznych Supermocy</a></h3>
<p>Aby przeÅ‚Ä…czyÄ‡ siÄ™ na niebezpieczny Rust, uÅ¼yj sÅ‚owa kluczowego <code>unsafe</code>, a nastÄ™pnie rozpocznij nowy blok, ktÃ³ry zawiera niebezpieczny kod. W niebezpiecznym Rust moÅ¼esz wykonaÄ‡ piÄ™Ä‡ akcji, ktÃ³rych nie moÅ¼esz w bezpiecznym Rust, ktÃ³re nazywamy <em>niebezpiecznymi supermocami</em>. Te supermoce obejmujÄ… zdolnoÅ›Ä‡ do:</p>
<ol>
<li>Dereferencji surowego wskaÅºnika.</li>
<li>WywoÅ‚ania niebezpiecznej funkcji lub metody.</li>
<li>DostÄ™pu lub modyfikacji zmiennej statycznej zmiennej.</li>
<li>Implementacji niebezpiecznej cechy.</li>
<li>DostÄ™pu do pÃ³l <code>union</code>Ã³w.</li>
</ol>
<p>WaÅ¼ne jest, aby zrozumieÄ‡, Å¼e <code>unsafe</code> nie wyÅ‚Ä…cza sprawdzania poÅ¼yczania (borrow checker) ani nie wyÅ‚Ä…cza Å¼adnych innych kontroli bezpieczeÅ„stwa Rust: jeÅ›li uÅ¼yjesz referencji w kodzie niebezpiecznym, nadal bÄ™dzie ona sprawdzana. SÅ‚owo kluczowe <code>unsafe</code> daje jedynie dostÄ™p do tych piÄ™ciu funkcji, ktÃ³re nastÄ™pnie nie sÄ… sprawdzane przez kompilator pod kÄ…tem bezpieczeÅ„stwa pamiÄ™ci. Nadal uzyskasz pewien stopieÅ„ bezpieczeÅ„stwa wewnÄ…trz bloku <code>unsafe</code>.</p>
<p>Ponadto, <code>unsafe</code> nie oznacza, Å¼e kod wewnÄ…trz bloku jest koniecznie niebezpieczny lub Å¼e na pewno bÄ™dzie miaÅ‚ problemy z bezpieczeÅ„stwem pamiÄ™ci: intencjÄ… jest, aby jako programista zapewniÅ‚, Å¼e kod wewnÄ…trz bloku <code>unsafe</code> bÄ™dzie miaÅ‚ dostÄ™p do pamiÄ™ci w prawidÅ‚owy sposÃ³b.</p>
<p>Ludzie sÄ… omylni i bÅ‚Ä™dy siÄ™ zdarzÄ…, ale wymagajÄ…c, aby te piÄ™Ä‡ niebezpiecznych operacji znajdowaÅ‚o siÄ™ w blokach opatrzonych adnotacjÄ… <code>unsafe</code>, bÄ™dziesz wiedzieÄ‡, Å¼e wszelkie bÅ‚Ä™dy zwiÄ…zane z bezpieczeÅ„stwem pamiÄ™ci muszÄ… znajdowaÄ‡ siÄ™ w bloku <code>unsafe</code>. PamiÄ™taj, aby bloki <code>unsafe</code> byÅ‚y maÅ‚e; bÄ™dziesz za to wdziÄ™czny pÃ³Åºniej, gdy bÄ™dziesz badaÄ‡ bÅ‚Ä™dy pamiÄ™ci.</p>
<p>Aby jak najbardziej izolowaÄ‡ niebezpieczny kod, najlepiej jest umieÅ›ciÄ‡ go w bezpiecznej abstrakcji i udostÄ™pniÄ‡ bezpieczne API, co omÃ³wimy pÃ³Åºniej w rozdziale, gdy bÄ™dziemy badaÄ‡ niebezpieczne funkcje i metody. CzÄ™Å›ci biblioteki standardowej sÄ… implementowane jako bezpieczne abstrakcje nad niebezpiecznym kodem, ktÃ³ry zostaÅ‚ poddany audytowi. Opakowanie niebezpiecznego kodu w bezpiecznÄ… abstrakcjÄ™ zapobiega wyciekaniu uÅ¼ycia <code>unsafe</code> do wszystkich miejsc, w ktÃ³rych Ty lub Twoi uÅ¼ytkownicy moglibyÅ›cie chcieÄ‡ uÅ¼yÄ‡ funkcjonalnoÅ›ci zaimplementowanej za pomocÄ… kodu <code>unsafe</code>, poniewaÅ¼ uÅ¼ycie bezpiecznej abstrakcji jest bezpieczne.</p>
<p>Przyjrzyjmy siÄ™ z kolei kaÅ¼dej z piÄ™ciu niebezpiecznych supermocy. Przyjrzymy siÄ™ rÃ³wnieÅ¼ niektÃ³rym abstrakcjom, ktÃ³re zapewniajÄ… bezpieczny interfejs do niebezpiecznego kodu.</p>
<h3 id="dereferencja-surowego-wskaÅºnika"><a class="header" href="#dereferencja-surowego-wskaÅºnika">Dereferencja Surowego WskaÅºnika</a></h3>
<p>W Rozdziale 4, w sekcji <a href="#dangling-references">â€WiszÄ…ce referencjeâ€</a><!-- ignore -->, wspomnieliÅ›my, Å¼e kompilator zapewnia, Å¼e referencje sÄ… zawsze prawidÅ‚owe. Niebezpieczny Rust ma dwa nowe typy zwane <em>surowymi wskaÅºnikami</em>, ktÃ³re sÄ… podobne do referencji. Podobnie jak referencje, surowe wskaÅºniki mogÄ… byÄ‡ niemodyfikowalne lub modyfikowalne i sÄ… zapisywane odpowiednio jako <code>*const T</code> i <code>*mut T</code>. Gwiazdka nie jest operatorem dereferencji; jest czÄ™Å›ciÄ… nazwy typu. W kontekÅ›cie surowych wskaÅºnikÃ³w, <em>niemodyfikowalne</em> oznacza, Å¼e wskaÅºnik nie moÅ¼e byÄ‡ bezpoÅ›rednio przypisany po dereferencji.</p>
<p>RÃ³Å¼niÄ…ce siÄ™ od referencji i inteligentnych wskaÅºnikÃ³w, surowe wskaÅºniki:</p>
<ul>
<li>MogÄ… ignorowaÄ‡ zasady poÅ¼yczania, posiadajÄ…c zarÃ³wno niemodyfikowalne, jak i modyfikowalne wskaÅºniki, lub wiele modyfikowalnych wskaÅºnikÃ³w do tej samej lokalizacji</li>
<li>Nie majÄ… gwarancji, Å¼e wskazujÄ… na prawidÅ‚owÄ… pamiÄ™Ä‡</li>
<li>MogÄ… byÄ‡ null</li>
<li>Nie implementujÄ… Å¼adnego automatycznego czyszczenia</li>
</ul>
<p>RezygnujÄ…c z egzekwowania tych gwarancji przez Rust, moÅ¼esz zrezygnowaÄ‡ z gwarantowanego bezpieczeÅ„stwa w zamian za wiÄ™kszÄ… wydajnoÅ›Ä‡ lub moÅ¼liwoÅ›Ä‡ wspÃ³Å‚pracy z innym jÄ™zykiem lub sprzÄ™tem, gdzie gwarancje Rust nie majÄ… zastosowania.</p>
<p>Lista 20-1 pokazuje, jak utworzyÄ‡ niemodyfikowalny i modyfikowalny surowy wskaÅºnik.</p>
<figure class="listing" id="listing-20-1">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;raw const num;
    let r2 = &amp;raw mut num;
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-20-1">Lista 20-1</a>: Tworzenie surowych wskaÅºnikÃ³w za pomocÄ… operatorÃ³w surowego poÅ¼yczania</figcaption>
</figure>
<p>ZauwaÅ¼, Å¼e w tym kodzie nie uÅ¼ywamy sÅ‚owa kluczowego <code>unsafe</code>. MoÅ¼emy tworzyÄ‡ surowe wskaÅºniki w bezpiecznym kodzie; po prostu nie moÅ¼emy dereferencjonowaÄ‡ surowych wskaÅºnikÃ³w poza blokiem unsafe, jak zobaczysz za chwilÄ™.</p>
<p>StworzyliÅ›my surowe wskaÅºniki za pomocÄ… operatorÃ³w surowego poÅ¼yczania: <code>&amp;raw const num</code> tworzy niemodyfikowalny surowy wskaÅºnik <code>*const i32</code>, a <code>&amp;raw mut num</code> tworzy modyfikowalny surowy wskaÅºnik <code>*mut i32</code>. PoniewaÅ¼ stworzyliÅ›my je bezpoÅ›rednio ze zmiennej lokalnej, wiemy, Å¼e te konkretne surowe wskaÅºniki sÄ… prawidÅ‚owe, ale nie moÅ¼emy zakÅ‚adaÄ‡ tego samego o kaÅ¼dym surowym wskaÅºniku.</p>
<p>Aby to zademonstrowaÄ‡, nastÄ™pnie stworzymy surowy wskaÅºnik, ktÃ³rego waÅ¼noÅ›ci nie moÅ¼emy byÄ‡ tak pewni, uÅ¼ywajÄ…c sÅ‚owa kluczowego <code>as</code> do rzutowania wartoÅ›ci zamiast operatora surowego poÅ¼yczenia. Lista 20-2 pokazuje, jak stworzyÄ‡ surowy wskaÅºnik do dowolnej lokalizacji w pamiÄ™ci. PrÃ³ba uÅ¼ycia dowolnej pamiÄ™ci jest niezdefiniowana: pod tym adresem mogÄ… byÄ‡ dane lub nie, kompilator moÅ¼e zoptymalizowaÄ‡ kod tak, Å¼e nie ma dostÄ™pu do pamiÄ™ci, lub program moÅ¼e zakoÅ„czyÄ‡ siÄ™ bÅ‚Ä™dem segmentacji. Zazwyczaj nie ma dobrego powodu do pisania takiego kodu, zwÅ‚aszcza w przypadkach, gdy zamiast tego moÅ¼na uÅ¼yÄ‡ operatora surowego poÅ¼yczenia, ale jest to moÅ¼liwe.</p>
<figure class="listing" id="listing-20-2">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let address = 0x012345usize;
    let r = address as *const i32;
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-20-2">Lista 20-2</a>: Tworzenie surowego wskaÅºnika do dowolnego adresu pamiÄ™ci</figcaption>
</figure>
<p>Przypomnij sobie, Å¼e moÅ¼emy tworzyÄ‡ surowe wskaÅºniki w bezpiecznym kodzie, ale nie moÅ¼emy ich dereferencjonowaÄ‡ i odczytywaÄ‡ wskazywanych danych. Na LiÅ›cie 20-3 uÅ¼ywamy operatora dereferencji <code>*</code> na surowym wskaÅºniku, co wymaga bloku <code>unsafe</code>.</p>
<figure class="listing" id="listing-20-3">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;raw const num;
    let r2 = &amp;raw mut num;

    unsafe {
        println!("r1 is: {}", *r1);
        println!("r2 is: {}", *r2);
    }
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-20-3">Lista 20-3</a>: Dereferencja surowych wskaÅºnikÃ³w wewnÄ…trz bloku <code>unsafe</code></figcaption>
</figure>
<p>Tworzenie wskaÅºnika nie szkodzi; dopiero gdy prÃ³bujemy uzyskaÄ‡ dostÄ™p do wartoÅ›ci, na ktÃ³rÄ… wskazuje, moÅ¼emy skoÅ„czyÄ‡ z nieprawidÅ‚owÄ… wartoÅ›ciÄ….</p>
<p>ZauwaÅ¼ rÃ³wnieÅ¼, Å¼e na LiÅ›cie 20-1 i 20-3 stworzyliÅ›my surowe wskaÅºniki <code>*const i32</code> i <code>*mut i32</code>, ktÃ³re oba wskazywaÅ‚y na tÄ™ samÄ… lokalizacjÄ™ w pamiÄ™ci, gdzie przechowywany jest <code>num</code>. GdybyÅ›my zamiast tego sprÃ³bowali stworzyÄ‡ niemodyfikowalnÄ… i modyfikowalnÄ… referencjÄ™ do <code>num</code>, kod nie skompilowaÅ‚by siÄ™, poniewaÅ¼ zasady wÅ‚asnoÅ›ci Rust nie pozwalajÄ… na jednoczesne istnienie modyfikowalnej referencji i niemodyfikowalnych referencji. Z surowymi wskaÅºnikami moÅ¼emy stworzyÄ‡ modyfikowalny wskaÅºnik i niemodyfikowalny wskaÅºnik do tej samej lokalizacji i zmieniaÄ‡ dane za pomocÄ… modyfikowalnego wskaÅºnika, potencjalnie tworzÄ…c wyÅ›cig danych. BÄ…dÅº ostroÅ¼ny!</p>
<p>Przy wszystkich tych niebezpieczeÅ„stwach, dlaczego w ogÃ³le miaÅ‚byÅ› uÅ¼ywaÄ‡ surowych wskaÅºnikÃ³w? Jednym z gÅ‚Ã³wnych przypadkÃ³w uÅ¼ycia jest interakcja z kodem C, jak zobaczysz w nastÄ™pnej sekcji. Innym przypadkiem jest budowanie bezpiecznych abstrakcji, ktÃ³rych sprawdzajÄ…cy poÅ¼yczanie nie rozumie. Przedstawimy niebezpieczne funkcje, a nastÄ™pnie przyjrzymy siÄ™ przykÅ‚adowi bezpiecznej abstrakcji, ktÃ³ra uÅ¼ywa niebezpiecznego kodu.</p>
<h3 id="wywoÅ‚ywanie-niebezpiecznej-funkcji-lub-metody"><a class="header" href="#wywoÅ‚ywanie-niebezpiecznej-funkcji-lub-metody">WywoÅ‚ywanie Niebezpiecznej Funkcji lub Metody</a></h3>
<p>Drugi rodzaj operacji, ktÃ³rÄ… moÅ¼na wykonaÄ‡ w bloku unsafe, to wywoÅ‚anie niebezpiecznych funkcji. Niebezpieczne funkcje i metody wyglÄ…dajÄ… dokÅ‚adnie tak samo jak zwykÅ‚e funkcje i metody, ale majÄ… dodatkowe <code>unsafe</code> przed resztÄ… definicji. SÅ‚owo kluczowe <code>unsafe</code> w tym kontekÅ›cie wskazuje, Å¼e funkcja ma wymagania, ktÃ³re musimy speÅ‚niÄ‡, gdy jÄ… wywoÅ‚ujemy, poniewaÅ¼ Rust nie moÅ¼e zagwarantowaÄ‡, Å¼e speÅ‚niliÅ›my te wymagania. WywoÅ‚ujÄ…c niebezpiecznÄ… funkcjÄ™ w bloku <code>unsafe</code>, mÃ³wimy, Å¼e przeczytaliÅ›my dokumentacjÄ™ tej funkcji i bierzemy odpowiedzialnoÅ›Ä‡ za przestrzeganie jej kontraktÃ³w.</p>
<p>Oto niebezpieczna funkcja o nazwie <code>dangerous</code>, ktÃ³ra nic nie robi w swoim ciele:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
<span class="boring">}</span></code></pre>
<p>Musimy wywoÅ‚aÄ‡ funkcjÄ™ <code>dangerous</code> w osobnym bloku <code>unsafe</code>. JeÅ›li sprÃ³bujemy wywoÅ‚aÄ‡ <code>dangerous</code> bez bloku <code>unsafe</code>, otrzymamy bÅ‚Ä…d:</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function `dangerous` is unsafe and requires unsafe block
 --&gt; src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
</code></pre>
<p>DziÄ™ki blokowi <code>unsafe</code> zapewniamy Rust, Å¼e przeczytaliÅ›my dokumentacjÄ™ funkcji, rozumiemy, jak jej wÅ‚aÅ›ciwie uÅ¼ywaÄ‡, i zweryfikowaliÅ›my, Å¼e speÅ‚niamy kontrakt funkcji.</p>
<p>Aby wykonywaÄ‡ niebezpieczne operacje w ciele funkcji <code>unsafe</code>, nadal musisz uÅ¼yÄ‡ bloku <code>unsafe</code>, tak jak w zwykÅ‚ej funkcji, a kompilator ostrzeÅ¼e CiÄ™, jeÅ›li zapomnisz. Pomaga to nam utrzymywaÄ‡ bloki <code>unsafe</code> tak maÅ‚e, jak to moÅ¼liwe, poniewaÅ¼ operacje niebezpieczne mogÄ… nie byÄ‡ potrzebne w caÅ‚ym ciele funkcji.</p>
<h4 id="tworzenie-bezpiecznej-abstrakcji-nad-niebezpiecznym-kodem"><a class="header" href="#tworzenie-bezpiecznej-abstrakcji-nad-niebezpiecznym-kodem">Tworzenie Bezpiecznej Abstrakcji nad Niebezpiecznym Kodem</a></h4>
<p>To, Å¼e funkcja zawiera niebezpieczny kod, nie oznacza, Å¼e musimy oznaczyÄ‡ caÅ‚Ä… funkcjÄ™ jako niebezpiecznÄ…. W rzeczywistoÅ›ci, opakowywanie niebezpiecznego kodu w bezpiecznÄ… funkcjÄ™ jest powszechnÄ… abstrakcjÄ…. Jako przykÅ‚ad, przeanalizujmy funkcjÄ™ <code>split_at_mut</code> z biblioteki standardowej, ktÃ³ra wymaga pewnego niebezpiecznego kodu. Zbadamy, jak moglibyÅ›my jÄ… zaimplementowaÄ‡. Ta bezpieczna metoda jest zdefiniowana dla zmiennych wycinkÃ³w: bierze jeden wycinek i tworzy z niego dwa, dzielÄ…c wycinek na indeksie podanym jako argument. Lista 20-4 pokazuje, jak uÅ¼ywaÄ‡ <code>split_at_mut</code>.</p>
<figure class="listing" id="listing-20-4">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-20-4">Lista 20-4</a>: UÅ¼ycie bezpiecznej funkcji <code>split_at_mut</code></figcaption>
</figure>
<p>Nie moÅ¼emy zaimplementowaÄ‡ tej funkcji uÅ¼ywajÄ…c wyÅ‚Ä…cznie bezpiecznego Rust. PrÃ³ba mogÅ‚aby wyglÄ…daÄ‡ mniej wiÄ™cej jak Lista 20-5, ktÃ³ra siÄ™ nie skompiluje. Dla uproszczenia, zaimplementujemy <code>split_at_mut</code> jako funkcjÄ™, a nie metodÄ™, i tylko dla wycinkÃ³w wartoÅ›ci <code>i32</code>, a nie dla generycznego typu <code>T</code>.</p>
<figure class="listing" id="listing-20-5">
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();

    assert!(mid &lt;= len);

    (&amp;mut values[..mid], &amp;mut values[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-20-5">Lista 20-5</a>: PrÃ³ba implementacji <code>split_at_mut</code> uÅ¼ywajÄ…c wyÅ‚Ä…cznie bezpiecznego Rust</figcaption>
</figure>
<p>Ta funkcja najpierw pobiera caÅ‚kowitÄ… dÅ‚ugoÅ›Ä‡ wycinka. NastÄ™pnie sprawdza, czy indeks podany jako parametr mieÅ›ci siÄ™ w wycinku, sprawdzajÄ…c, czy jest mniejszy lub rÃ³wny dÅ‚ugoÅ›ci. Asercja oznacza, Å¼e jeÅ›li przekaÅ¼emy indeks wiÄ™kszy niÅ¼ dÅ‚ugoÅ›Ä‡ do podziaÅ‚u wycinka, funkcja spanikuje, zanim sprÃ³buje uÅ¼yÄ‡ tego indeksu.</p>
<p>NastÄ™pnie zwracamy dwa modyfikowalne wycinki w krotce: jeden od poczÄ…tku oryginalnego wycinka do indeksu <code>mid</code> i drugi od <code>mid</code> do koÅ„ca wycinka.</p>
<p>Kiedy sprÃ³bujemy skompilowaÄ‡ kod z Listy 20-5, otrzymamy bÅ‚Ä…d:</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 --&gt; src/main.rs:6:31
  |
1 | fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                         - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut values[..mid], &amp;mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`
  |
  = help: use `.split_at_mut(position)` to obtain two mutable non-overlapping sub-slices

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
</code></pre>
<p>SprawdzajÄ…cy poÅ¼yczanie Rust nie moÅ¼e zrozumieÄ‡, Å¼e poÅ¼yczamy rÃ³Å¼ne czÄ™Å›ci wycinka; wie tylko, Å¼e poÅ¼yczamy z tego samego wycinka dwa razy. PoÅ¼yczanie rÃ³Å¼nych czÄ™Å›ci wycinka jest zasadniczo w porzÄ…dku, poniewaÅ¼ te dwa wycinki nie nakÅ‚adajÄ… siÄ™ na siebie, ale Rust nie jest na tyle sprytny, aby to wiedzieÄ‡. Kiedy wiemy, Å¼e kod jest w porzÄ…dku, ale Rust nie, nadszedÅ‚ czas, aby siÄ™gnÄ…Ä‡ po niebezpieczny kod.</p>
<p>Lista 20-6 pokazuje, jak uÅ¼yÄ‡ bloku <code>unsafe</code>, surowego wskaÅºnika i kilku wywoÅ‚aÅ„ niebezpiecznych funkcji, aby implementacja <code>split_at_mut</code> dziaÅ‚aÅ‚a.</p>
<figure class="listing" id="listing-20-6">
<pre class="playground"><code class="language-rust edition2024">use std::slice;

fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-20-6">Lista 20-6</a>: UÅ¼ycie niebezpiecznego kodu w implementacji funkcji <code>split_at_mut</code></figcaption>
</figure>
<p>Przypomnij sobie z sekcji <a href="#the-slice-type">â€Typ wycinkaâ€</a><!-- ignore --> w Rozdziale 4, Å¼e wycinek jest wskaÅºnikiem do pewnych danych i dÅ‚ugoÅ›ciÄ… wycinka. UÅ¼ywamy metody <code>len</code>, aby uzyskaÄ‡ dÅ‚ugoÅ›Ä‡ wycinka, i metody <code>as_mut_ptr</code>, aby uzyskaÄ‡ dostÄ™p do surowego wskaÅºnika wycinka. W tym przypadku, poniewaÅ¼ mamy modyfikowalny wycinek wartoÅ›ci <code>i32</code>, <code>as_mut_ptr</code> zwraca surowy wskaÅºnik typu <code>*mut i32</code>, ktÃ³ry zapisaliÅ›my w zmiennej <code>ptr</code>.</p>
<p>Utrzymujemy asercjÄ™, Å¼e indeks <code>mid</code> znajduje siÄ™ w zakresie wycinka. NastÄ™pnie przechodzimy do kodu niebezpiecznego: funkcja <code>slice::from_raw_parts_mut</code> przyjmuje surowy wskaÅºnik i dÅ‚ugoÅ›Ä‡ i tworzy wycinek. UÅ¼ywamy tej funkcji do stworzenia wycinka, ktÃ³ry zaczyna siÄ™ od <code>ptr</code> i ma dÅ‚ugoÅ›Ä‡ <code>mid</code> elementÃ³w. NastÄ™pnie wywoÅ‚ujemy metodÄ™ <code>add</code> na <code>ptr</code> z <code>mid</code> jako argumentem, aby uzyskaÄ‡ surowy wskaÅºnik, ktÃ³ry zaczyna siÄ™ na <code>mid</code>, i tworzymy wycinek uÅ¼ywajÄ…c tego wskaÅºnika i pozostaÅ‚ej liczby elementÃ³w po <code>mid</code> jako dÅ‚ugoÅ›ci.</p>
<p>Funkcja <code>slice::from_raw_parts_mut</code> jest niebezpieczna, poniewaÅ¼ przyjmuje surowy wskaÅºnik i musi ufaÄ‡, Å¼e ten wskaÅºnik jest prawidÅ‚owy. Metoda <code>add</code> na surowych wskaÅºnikach jest rÃ³wnieÅ¼ niebezpieczna, poniewaÅ¼ musi ufaÄ‡, Å¼e lokalizacja offsetu jest rÃ³wnieÅ¼ prawidÅ‚owym wskaÅºnikiem. Dlatego musieliÅ›my umieÅ›ciÄ‡ blok <code>unsafe</code> wokÃ³Å‚ naszych wywoÅ‚aÅ„ <code>slice::from_raw_parts_mut</code> i <code>add</code>, aby mÃ³c je wywoÅ‚aÄ‡. PatrzÄ…c na kod i dodajÄ…c asercjÄ™, Å¼e <code>mid</code> musi byÄ‡ mniejsze lub rÃ³wne <code>len</code>, moÅ¼emy stwierdziÄ‡, Å¼e wszystkie surowe wskaÅºniki uÅ¼yte w bloku <code>unsafe</code> bÄ™dÄ… prawidÅ‚owe i bÄ™dÄ… wskazywaÄ‡ na dane wewnÄ…trz wycinka. Jest to dopuszczalne i odpowiednie uÅ¼ycie <code>unsafe</code>.</p>
<p>ZauwaÅ¼, Å¼e nie musimy oznaczaÄ‡ wynikowej funkcji <code>split_at_mut</code> jako <code>unsafe</code>, a moÅ¼emy wywoÅ‚aÄ‡ tÄ™ funkcjÄ™ z bezpiecznego Rust. StworzyliÅ›my bezpiecznÄ… abstrakcjÄ™ dla niebezpiecznego kodu z implementacjÄ… funkcji, ktÃ³ra uÅ¼ywa kodu <code>unsafe</code> w bezpieczny sposÃ³b, poniewaÅ¼ tworzy tylko prawidÅ‚owe wskaÅºniki z danych, do ktÃ³rych ta funkcja ma dostÄ™p.</p>
<p>W przeciwieÅ„stwie do tego, uÅ¼ycie <code>slice::from_raw_parts_mut</code> na LiÅ›cie 20-7 prawdopodobnie spowodowaÅ‚oby awariÄ™ programu, gdy wycinek zostaÅ‚by uÅ¼yty. Ten kod pobiera dowolnÄ… lokalizacjÄ™ w pamiÄ™ci i tworzy wycinek o dÅ‚ugoÅ›ci 10 000 elementÃ³w.</p>
<figure class="listing" id="listing-20-7">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-20-7">Lista 20-7</a>: Tworzenie wycinka z dowolnej lokalizacji w pamiÄ™ci</figcaption>
</figure>
<p>Nie posiadamy pamiÄ™ci w tej dowolnej lokalizacji i nie ma gwarancji, Å¼e wycinek, ktÃ³ry ten kod tworzy, zawiera prawidÅ‚owe wartoÅ›ci <code>i32</code>. PrÃ³ba uÅ¼ycia <code>values</code> tak, jakby byÅ‚ to prawidÅ‚owy wycinek, prowadzi do niezdefiniowanego zachowania.</p>
<h4 id="uÅ¼ywanie-funkcji-extern-do-wywoÅ‚ywania-zewnÄ™trznego-kodu"><a class="header" href="#uÅ¼ywanie-funkcji-extern-do-wywoÅ‚ywania-zewnÄ™trznego-kodu">UÅ¼ywanie funkcji <code>extern</code> do wywoÅ‚ywania zewnÄ™trznego kodu</a></h4>
<p>Czasami kod w Rust moÅ¼e potrzebowaÄ‡ interakcji z kodem napisanym w innym jÄ™zyku. W tym celu Rust posiada sÅ‚owo kluczowe <code>extern</code>, ktÃ³re uÅ‚atwia tworzenie i uÅ¼ywanie <em>interfejsu funkcji obcych (FFI)</em>, czyli sposobu, w jaki jÄ™zyk programowania moÅ¼e definiowaÄ‡ funkcje i umoÅ¼liwiaÄ‡ innemu (obcemu) jÄ™zykowi programowania wywoÅ‚ywanie tych funkcji.</p>
<p>Lista 20-8 demonstruje, jak skonfigurowaÄ‡ integracjÄ™ z funkcjÄ… <code>abs</code> z biblioteki standardowej C. Funkcje zadeklarowane w blokach <code>extern</code> sÄ… zazwyczaj niebezpieczne do wywoÅ‚ywania z kodu Rust, dlatego bloki <code>extern</code> muszÄ… byÄ‡ rÃ³wnieÅ¼ oznaczone jako <code>unsafe</code>. Powodem jest to, Å¼e inne jÄ™zyki nie egzekwujÄ… zasad i gwarancji Rust, a Rust nie moÅ¼e ich sprawdziÄ‡, wiÄ™c odpowiedzialnoÅ›Ä‡ za zapewnienie bezpieczeÅ„stwa spoczywa na programiÅ›cie.</p>
<figure class="listing" id="listing-20-8">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">unsafe extern "C" {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}</code></pre>
<figcaption><a href="#listing-20-8">Lista 20-8</a>: Deklarowanie i wywoÅ‚ywanie funkcji <code>extern</code> zdefiniowanej w innym jÄ™zyku</figcaption>
</figure>
<p>W bloku <code>unsafe extern "C"</code> wymieniamy nazwy i sygnatury funkcji zewnÄ™trznych z innego jÄ™zyka, ktÃ³re chcemy wywoÅ‚aÄ‡. CzÄ™Å›Ä‡ <code>"C"</code> definiuje, ktÃ³ry <em>interfejs binarny aplikacji (ABI)</em> uÅ¼ywa funkcja zewnÄ™trzna: ABI definiuje, jak wywoÅ‚aÄ‡ funkcjÄ™ na poziomie asemblera. ABI <code>"C"</code> jest najpopularniejsze i jest zgodne z ABI jÄ™zyka programowania C. Informacje o wszystkich ABI obsÅ‚ugiwanych przez Rust sÄ… dostÄ™pne w <a href="../reference/items/external-blocks.html#abi">referencji Rust</a>.</p>
<p>KaÅ¼dy element zadeklarowany w bloku <code>unsafe extern</code> jest domyÅ›lnie niebezpieczny. Jednak niektÃ³re funkcje FFI <em>sÄ…</em> bezpieczne do wywoÅ‚ania. Na przykÅ‚ad funkcja <code>abs</code> z biblioteki standardowej C nie ma Å¼adnych ograniczeÅ„ bezpieczeÅ„stwa pamiÄ™ci i wiemy, Å¼e moÅ¼na jÄ… wywoÅ‚aÄ‡ z dowolnÄ… <code>i32</code>. W takich przypadkach moÅ¼emy uÅ¼yÄ‡ sÅ‚owa kluczowego <code>safe</code>, aby powiedzieÄ‡, Å¼e ta konkretna funkcja jest bezpieczna do wywoÅ‚ania, nawet jeÅ›li znajduje siÄ™ w bloku <code>unsafe extern</code>. Po dokonaniu tej zmiany, wywoÅ‚anie jej nie wymaga juÅ¼ bloku <code>unsafe</code>, jak pokazano na LiÅ›cie 20-9.</p>
<figure class="listing" id="listing-20-9">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">unsafe extern "C" {
    safe fn abs(input: i32) -&gt; i32;
}

fn main() {
    println!("Absolute value of -3 according to C: {}", abs(-3));
}</code></pre>
<figcaption><a href="#listing-20-9">Lista 20-9</a>: Jawne oznaczanie funkcji jako <code>safe</code> w bloku <code>unsafe extern</code> i bezpieczne jej wywoÅ‚ywanie</figcaption>
</figure>
<p>Oznaczenie funkcji jako <code>safe</code> nie czyni jej z natury bezpiecznÄ…! Zamiast tego, jest to obietnica, ktÃ³rÄ… skÅ‚adasz Rust, Å¼e jest bezpieczna. Nadal Twoim obowiÄ…zkiem jest upewnienie siÄ™, Å¼e ta obietnica jest dotrzymana!</p>
<h4 id="wywoÅ‚ywanie-funkcji-rust-z-innych-jÄ™zykÃ³w"><a class="header" href="#wywoÅ‚ywanie-funkcji-rust-z-innych-jÄ™zykÃ³w">WywoÅ‚ywanie funkcji Rust z innych jÄ™zykÃ³w</a></h4>
<p>MoÅ¼emy rÃ³wnieÅ¼ uÅ¼yÄ‡ <code>extern</code> do stworzenia interfejsu, ktÃ³ry pozwala innym jÄ™zykom wywoÅ‚ywaÄ‡ funkcje Rust. Zamiast tworzyÄ‡ caÅ‚y blok <code>extern</code>, dodajemy sÅ‚owo kluczowe <code>extern</code> i okreÅ›lamy ABI do uÅ¼ycia tuÅ¼ przed sÅ‚owem kluczowym <code>fn</code> dla odpowiedniej funkcji. Musimy rÃ³wnieÅ¼ dodaÄ‡ adnotacjÄ™ <code>#[unsafe(no_mangle)]</code>, aby powiedzieÄ‡ kompilatorowi Rust, aby nie zmieniaÅ‚ nazwy tej funkcji. <em>Mangling</em> to proces, w ktÃ³rym kompilator zmienia nazwÄ™, ktÃ³rÄ… nadaliÅ›my funkcji, na innÄ… nazwÄ™, ktÃ³ra zawiera wiÄ™cej informacji dla innych czÄ™Å›ci procesu kompilacji, ale jest mniej czytelna dla czÅ‚owieka. KaÅ¼dy kompilator jÄ™zyka programowania nieco inaczej znieksztaÅ‚ca nazwy, wiÄ™c aby funkcja Rust mogÅ‚a byÄ‡ nazwana przez inne jÄ™zyki, musimy wyÅ‚Ä…czyÄ‡ znieksztaÅ‚canie nazw przez kompilator Rust. Jest to niebezpieczne, poniewaÅ¼ bez wbudowanego znieksztaÅ‚cania mogÄ… wystÄ™powaÄ‡ kolizje nazw w bibliotekach, wiÄ™c naszym obowiÄ…zkiem jest upewnienie siÄ™, Å¼e wybrana nazwa jest bezpieczna do eksportu bez znieksztaÅ‚cania.</p>
<p>W poniÅ¼szym przykÅ‚adzie udostÄ™pniamy funkcjÄ™ <code>call_from_c</code> z kodu C, po skompilowaniu jej do biblioteki wspÃ³Å‚dzielonej i poÅ‚Ä…czeniu z C:</p>
<pre><code>#[unsafe(no_mangle)]
pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
}
</code></pre>
<p>To uÅ¼ycie <code>extern</code> wymaga <code>unsafe</code> tylko w atrybucie, a nie w bloku <code>extern</code>.</p>
<h3 id="dostÄ™p-do-zmiennej-statycznej-modyfikowalnej-lub-jej-modyfikowanie"><a class="header" href="#dostÄ™p-do-zmiennej-statycznej-modyfikowalnej-lub-jej-modyfikowanie">DostÄ™p do Zmiennej Statycznej Modyfikowalnej lub Jej Modyfikowanie</a></h3>
<p>W tej ksiÄ…Å¼ce nie mÃ³wiliÅ›my jeszcze o zmiennych globalnych, ktÃ³re Rust obsÅ‚uguje, ale ktÃ³re mogÄ… byÄ‡ problematyczne z zasadami wÅ‚asnoÅ›ci Rust. JeÅ›li dwa wÄ…tki uzyskujÄ… dostÄ™p do tej samej zmiennej globalnej, moÅ¼e to spowodowaÄ‡ wyÅ›cig danych.</p>
<p>W Rust zmienne globalne nazywane sÄ… zmiennymi <em>statycznymi</em>. Lista 20-10 pokazuje przykÅ‚ad deklaracji i uÅ¼ycia zmiennej statycznej z fragmentem ciÄ…gu jako wartoÅ›ciÄ….</p>
<figure class="listing" id="listing-20-10">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">static HELLO_WORLD: &amp;str = "Hello, world!";

fn main() {
    println!("value is: {HELLO_WORLD}");
}</code></pre>
<figcaption><a href="#listing-20-10">Lista 20-10</a>: Definiowanie i uÅ¼ywanie niemodyfikowalnej zmiennej statycznej</figcaption>
</figure>
<p>Zmienne statyczne sÄ… podobne do staÅ‚ych, ktÃ³re omÃ³wiliÅ›my w sekcji <a href="#declaring-constants">â€Deklarowanie staÅ‚ychâ€</a><!-- ignore --> w Rozdziale 3. Nazwy zmiennych statycznych sÄ… konwencjonalnie zapisywane w formacie <code>SCREAMING_SNAKE_CASE</code>. Zmienne statyczne mogÄ… przechowywaÄ‡ tylko referencje z czasem Å¼ycia <code>'static</code>, co oznacza, Å¼e kompilator Rust moÅ¼e okreÅ›liÄ‡ czas Å¼ycia i nie musimy go jawnie adnotowaÄ‡. DostÄ™p do niemodyfikowalnej zmiennej statycznej jest bezpieczny.</p>
<p>Subtelna rÃ³Å¼nica miÄ™dzy staÅ‚ymi a niemodyfikowalnymi zmiennymi statycznymi polega na tym, Å¼e wartoÅ›ci w zmiennej statycznej majÄ… staÅ‚y adres w pamiÄ™ci. UÅ¼ycie wartoÅ›ci zawsze bÄ™dzie odwoÅ‚ywaÄ‡ siÄ™ do tych samych danych. StaÅ‚e natomiast mogÄ… duplikowaÄ‡ swoje dane za kaÅ¼dym razem, gdy sÄ… uÅ¼ywane. InnÄ… rÃ³Å¼nicÄ… jest to, Å¼e zmienne statyczne mogÄ… byÄ‡ zmienne. DostÄ™p i modyfikacja zmiennych statycznych zmiennych jest <em>niebezpieczna</em>. Lista 20-11 pokazuje, jak zadeklarowaÄ‡, uzyskaÄ‡ dostÄ™p i zmodyfikowaÄ‡ zmiennÄ… statycznÄ… zmiennÄ… o nazwie <code>COUNTER</code>.</p>
<figure class="listing" id="listing-20-11">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">static mut COUNTER: u32 = 0;

/// SAFETY: Calling this from more than a single thread at a time is undefined
/// behavior, so you *must* guarantee you only call it from a single thread at
/// a time.
unsafe fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    unsafe {
        // SAFETY: This is only called from a single thread in `main`.
        add_to_count(3);
        println!("COUNTER: {}", *(&amp;raw const COUNTER));
    }
}</code></pre>
<figcaption><a href="#listing-20-11">Lista 20-11</a>: Odczytywanie lub zapisywanie do zmiennej statycznej zmiennej jest niebezpieczne.</figcaption>
</figure>
<p>Podobnie jak w przypadku zwykÅ‚ych zmiennych, mutowalnoÅ›Ä‡ okreÅ›lamy za pomocÄ… sÅ‚owa kluczowego <code>mut</code>. KaÅ¼dy kod, ktÃ³ry odczytuje lub zapisuje z <code>COUNTER</code>, musi znajdowaÄ‡ siÄ™ w bloku <code>unsafe</code>. Kod z Listy 20-11 kompiluje siÄ™ i wypisuje <code>COUNTER: 3</code>, tak jak byÅ›my siÄ™ spodziewali, poniewaÅ¼ jest jednowÄ…tkowy. DostÄ™p do <code>COUNTER</code> z wielu wÄ…tkÃ³w prawdopodobnie skutkowaÅ‚by wyÅ›cigami danych, wiÄ™c jest to niezdefiniowane zachowanie. Dlatego musimy oznaczyÄ‡ caÅ‚Ä… funkcjÄ™ jako <code>unsafe</code> i udokumentowaÄ‡ ograniczenie bezpieczeÅ„stwa, aby kaÅ¼dy, kto wywoÅ‚uje funkcjÄ™, wiedziaÅ‚, co mu wolno, a czego nie wolno bezpiecznie robiÄ‡.</p>
<p>Zawsze, gdy piszemy funkcjÄ™ <code>unsafe</code>, idiomatyczne jest umieszczenie komentarza zaczynajÄ…cego siÄ™ od <code>SAFETY</code> i wyjaÅ›niajÄ…cego, co wywoÅ‚ujÄ…cy musi zrobiÄ‡, aby bezpiecznie wywoÅ‚aÄ‡ funkcjÄ™. Podobnie, zawsze, gdy wykonujemy operacjÄ™ <code>unsafe</code>, idiomatyczne jest umieszczenie komentarza zaczynajÄ…cego siÄ™ od <code>SAFETY</code>, aby wyjaÅ›niÄ‡, w jaki sposÃ³b zasady bezpieczeÅ„stwa sÄ… przestrzegane.</p>
<p>Ponadto, kompilator domyÅ›lnie odrzuci wszelkie prÃ³by tworzenia referencji do zmiennej statycznej zmiennej za pomocÄ… lintu kompilatora. Musisz albo jawnie zrezygnowaÄ‡ z ochrony tego lintu, dodajÄ…c adnotacjÄ™ <code>#[allow(static_mut_refs)]</code>, albo uzyskaÄ‡ dostÄ™p do zmiennej statycznej zmiennej za poÅ›rednictwem surowego wskaÅºnika utworzonego za pomocÄ… jednego z operatorÃ³w surowego poÅ¼yczania. Obejmuje to przypadki, w ktÃ³rych referencja jest tworzona niewidocznie, jak w przypadku jej uÅ¼ycia w <code>println!</code> w tej liÅ›cie kodu. Wymaganie, aby referencje do zmiennych statycznych zmiennych byÅ‚y tworzone za poÅ›rednictwem surowych wskaÅºnikÃ³w, pomaga uczyniÄ‡ wymagania bezpieczeÅ„stwa ich uÅ¼ycia bardziej oczywistymi.</p>
<p>Przy zmiennych danych, ktÃ³re sÄ… globalnie dostÄ™pne, trudno jest zapewniÄ‡, Å¼e nie ma wyÅ›cigÃ³w danych, dlatego Rust uwaÅ¼a zmienne statyczne zmienne za niebezpieczne. Tam, gdzie to moÅ¼liwe, lepiej jest uÅ¼ywaÄ‡ technik wspÃ³Å‚bieÅ¼noÅ›ci i inteligentnych wskaÅºnikÃ³w bezpiecznych dla wÄ…tkÃ³w, ktÃ³re omÃ³wiliÅ›my w Rozdziale 16, aby kompilator sprawdzaÅ‚, czy dostÄ™p do danych z rÃ³Å¼nych wÄ…tkÃ³w odbywa siÄ™ bezpiecznie.</p>
<h3 id="implementowanie-niebezpiecznej-cechy"><a class="header" href="#implementowanie-niebezpiecznej-cechy">Implementowanie Niebezpiecznej Cechy</a></h3>
<p>MoÅ¼emy uÅ¼yÄ‡ <code>unsafe</code> do zaimplementowania niebezpiecznej cechy. Cecha jest niebezpieczna, gdy co najmniej jedna z jej metod ma jakÄ…Å› niezmiennÄ…, ktÃ³rej kompilator nie moÅ¼e zweryfikowaÄ‡. Deklarujemy, Å¼e cecha jest <code>unsafe</code>, dodajÄ…c sÅ‚owo kluczowe <code>unsafe</code> przed <code>trait</code> i oznaczajÄ…c implementacjÄ™ cechy jako <code>unsafe</code>, jak pokazano na LiÅ›cie 20-12.</p>
<figure class="listing" id="listing-20-12">
<pre class="playground"><code class="language-rust edition2024">unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<figcaption><a href="#listing-20-12">Lista 20-12</a>: Definiowanie i implementacja niebezpiecznej cechy</figcaption>
</figure>
<p>UÅ¼ywajÄ…c <code>unsafe impl</code>, obiecujemy, Å¼e bÄ™dziemy przestrzegaÄ‡ niezmiennych, ktÃ³rych kompilator nie moÅ¼e zweryfikowaÄ‡.</p>
<p>Jako przykÅ‚ad, przypomnijmy cechy znacznikÃ³w <code>Send</code> i <code>Sync</code>, ktÃ³re omÃ³wiliÅ›my w sekcji <a href="#rozszerzalna-wspÃ³Å‚bieÅ¼noÅ›Ä‡-dziÄ™ki-cechom-send-i-sync-1">â€Rozszerzalna wspÃ³Å‚bieÅ¼noÅ›Ä‡ z <code>Send</code> i <code>Sync</code>â€</a><!-- ignore --> w Rozdziale 16: kompilator implementuje te cechy automatycznie, jeÅ›li nasze typy skÅ‚adajÄ… siÄ™ wyÅ‚Ä…cznie z innych typÃ³w, ktÃ³re implementujÄ… <code>Send</code> i <code>Sync</code>. JeÅ›li zaimplementujemy typ zawierajÄ…cy typ, ktÃ³ry nie implementuje <code>Send</code> lub <code>Sync</code>, taki jak surowe wskaÅºniki, i chcemy oznaczyÄ‡ ten typ jako <code>Send</code> lub <code>Sync</code>, musimy uÅ¼yÄ‡ <code>unsafe</code>. Rust nie moÅ¼e zweryfikowaÄ‡, czy nasz typ speÅ‚nia gwarancje, Å¼e moÅ¼e byÄ‡ bezpiecznie przesyÅ‚any miÄ™dzy wÄ…tkami lub dostÄ™pny z wielu wÄ…tkÃ³w; dlatego musimy rÄ™cznie wykonaÄ‡ te sprawdzenia i wskazaÄ‡ to za pomocÄ… <code>unsafe</code>.</p>
<h3 id="dostÄ™p-do-pÃ³l-unii"><a class="header" href="#dostÄ™p-do-pÃ³l-unii">DostÄ™p do PÃ³l Unii</a></h3>
<p>OstatniÄ… akcjÄ…, ktÃ³ra dziaÅ‚a tylko z <code>unsafe</code>, jest dostÄ™p do pÃ³l unii. <em>Unia</em> jest podobna do <code>struct</code>, ale tylko jedno zadeklarowane pole jest uÅ¼ywane w danej instancji w danym momencie. Unie sÄ… uÅ¼ywane gÅ‚Ã³wnie do interfejsu z uniami w kodzie C. DostÄ™p do pÃ³l unii jest niebezpieczny, poniewaÅ¼ Rust nie moÅ¼e zagwarantowaÄ‡ typu danych aktualnie przechowywanych w instancji unii. MoÅ¼esz dowiedzieÄ‡ siÄ™ wiÄ™cej o uniach w <a href="../reference/items/unions.html">referencji Rust</a>.</p>
<h3 id="uÅ¼ywanie-miri-do-sprawdzania-niebezpiecznego-kodu"><a class="header" href="#uÅ¼ywanie-miri-do-sprawdzania-niebezpiecznego-kodu">UÅ¼ywanie Miri do Sprawdzania Niebezpiecznego Kodu</a></h3>
<p>Podczas pisania kodu niebezpiecznego, moÅ¼esz chcieÄ‡ sprawdziÄ‡, czy to, co napisaÅ‚eÅ›, jest faktycznie bezpieczne i poprawne. Jednym z najlepszych sposobÃ³w na to jest uÅ¼ycie Miri, oficjalnego narzÄ™dzia Rust do wykrywania niezdefiniowanego zachowania. Podczas gdy sprawdzajÄ…cy poÅ¼yczanie (borrow checker) jest narzÄ™dziem <em>statycznym</em>, ktÃ³re dziaÅ‚a w czasie kompilacji, Miri jest narzÄ™dziem <em>dynamicznym</em>, ktÃ³re dziaÅ‚a w czasie wykonania. Sprawdza TwÃ³j kod, uruchamiajÄ…c TwÃ³j program lub jego pakiet testowy i wykrywajÄ…c, kiedy naruszasz zasady, ktÃ³re rozumie, jak Rust powinien dziaÅ‚aÄ‡.</p>
<p>UÅ¼ywanie Miri wymaga nocnej (nightly) wersji Rust (o ktÃ³rej wiÄ™cej mÃ³wimy w <a href="#g---jak-powstaje-rust-i-nightly-rust">Dodatku G: Jak powstaje Rust i â€Nocny Rustâ€</a><!-- ignore -->). MoÅ¼esz zainstalowaÄ‡ zarÃ³wno nocnÄ… wersjÄ™ Rust, jak i narzÄ™dzie Miri, wpisujÄ…c <code>rustup +nightly component add miri</code>. Nie zmienia to wersji Rust uÅ¼ywanej w Twoim projekcie; dodaje tylko narzÄ™dzie do Twojego systemu, abyÅ› mÃ³gÅ‚ go uÅ¼ywaÄ‡, kiedy zechcesz. Miri moÅ¼esz uruchomiÄ‡ na projekcie, wpisujÄ…c <code>cargo +nightly miri run</code> lub <code>cargo +nightly miri test</code>.</p>
<p>Na przykÅ‚adzie, jak bardzo to moÅ¼e byÄ‡ pomocne, rozwaÅ¼my, co siÄ™ dzieje, gdy uruchomimy go na LiÅ›cie 20-7.</p>
<pre><code class="language-console">$ cargo +nightly miri run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.01s
     Running `file:///home/.rustup/toolchains/nightly/bin/cargo-miri runner target/miri/debug/unsafe-example`
warning: integer-to-pointer cast
 --&gt; src/main.rs:5:13
  |
5 |     let r = address as *mut i32;
  |             ^^^^^^^^^^^^^^^^^^^ integer-to-pointer cast
  |
  = help: this program is using integer-to-pointer casts or (equivalently) `ptr::with_exposed_provenance`, which means that Miri might miss pointer bugs in this program
  = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.with_exposed_provenance.html for more details on that operation
  = help: to ensure that Miri does not miss bugs in your program, use Strict Provenance APIs (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance, https://crates.io/crates/sptr) instead
  = help: you can then set `MIRIFLAGS=-Zmiri-strict-provenance` to ensure you are not relying on `with_exposed_provenance` semantics
  = help: alternatively, `MIRIFLAGS=-Zmiri-permissive-provenance` disables this warning
  = note: BACKTRACE:
  = note: inside `main` at src/main.rs:5:13: 5:32

error: Undefined Behavior: pointer not dereferenceable: pointer must be dereferenceable for 40000 bytes, but got 0x1234[noalloc] which is a dangling pointer (it has no provenance)
 --&gt; src/main.rs:7:35
  |
7 |     let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Undefined Behavior occurred here
  |
  = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior
  = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information
  = note: BACKTRACE:
  = note: inside `main` at src/main.rs:7:35: 7:70

note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace

error: aborting due to 1 previous error; 1 warning emitted

</code></pre>
<p>Miri poprawnie ostrzega nas, Å¼e rzutujemy liczbÄ™ caÅ‚kowitÄ… na wskaÅºnik, co moÅ¼e byÄ‡ problemem, ale Miri nie moÅ¼e ustaliÄ‡, czy problem istnieje, poniewaÅ¼ nie wie, skÄ…d pochodzi wskaÅºnik. NastÄ™pnie Miri zwraca bÅ‚Ä…d, gdzie Lista 20-7 ma niezdefiniowane zachowanie, poniewaÅ¼ mamy wiszÄ…cy wskaÅºnik. DziÄ™ki Miri wiemy teraz, Å¼e istnieje ryzyko niezdefiniowanego zachowania i moÅ¼emy zastanowiÄ‡ siÄ™, jak uczyniÄ‡ kod bezpiecznym. W niektÃ³rych przypadkach Miri moÅ¼e nawet zaleciÄ‡, jak naprawiÄ‡ bÅ‚Ä™dy.</p>
<p>Miri nie wychwytuje wszystkiego, co moÅ¼esz zrobiÄ‡ Åºle podczas pisania niebezpiecznego kodu. Miri to narzÄ™dzie do analizy dynamicznej, wiÄ™c wykrywa problemy tylko w kodzie, ktÃ³ry faktycznie zostaje uruchomiony. Oznacza to, Å¼e bÄ™dziesz musiaÅ‚ uÅ¼ywaÄ‡ go w poÅ‚Ä…czeniu z dobrymi technikami testowania, aby zwiÄ™kszyÄ‡ swojÄ… pewnoÅ›Ä‡ co do napisanego niebezpiecznego kodu. Miri nie obejmuje rÃ³wnieÅ¼ wszystkich moÅ¼liwych sposobÃ³w, w jaki TwÃ³j kod moÅ¼e byÄ‡ niestabilny.</p>
<p>Inaczej mÃ³wiÄ…c: jeÅ›li Miri <em>znajdzie</em> problem, wiesz, Å¼e jest bÅ‚Ä…d, ale to, Å¼e Miri <em>nie znajdzie</em> bÅ‚Ä™du, nie oznacza, Å¼e problemu nie ma. MoÅ¼e jednak wychwyciÄ‡ wiele. SprÃ³buj uruchomiÄ‡ go na innych przykÅ‚adach niebezpiecznego kodu w tym rozdziale i zobacz, co powie!</p>
<p>WiÄ™cej o Miri dowiesz siÄ™ w <a href="https://github.com/rust-lang/miri">repozytorium GitHub</a>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="when-to-use-unsafe-code"></a></p>
<h3 id="poprawne-uÅ¼ycie-kodu-niebezpiecznego"><a class="header" href="#poprawne-uÅ¼ycie-kodu-niebezpiecznego">Poprawne UÅ¼ycie Kodu Niebezpiecznego</a></h3>
<p>UÅ¼ycie <code>unsafe</code> do wykorzystania jednej z piÄ™ciu omÃ³wionych wÅ‚aÅ›nie supermocy nie jest bÅ‚Ä™dem ani nawet czymÅ›, na co patrzy siÄ™ krzywo, ale poprawne napisanie kodu <code>unsafe</code> jest trudniejsze, poniewaÅ¼ kompilator nie moÅ¼e pomÃ³c w utrzymaniu bezpieczeÅ„stwa pamiÄ™ci. Kiedy masz powÃ³d, aby uÅ¼yÄ‡ kodu <code>unsafe</code>, moÅ¼esz to zrobiÄ‡, a jawna adnotacja <code>unsafe</code> uÅ‚atwia Å›ledzenie ÅºrÃ³dÅ‚a problemÃ³w, gdy siÄ™ pojawiÄ…. Zawsze, gdy piszesz kod <code>unsafe</code>, moÅ¼esz uÅ¼yÄ‡ Miri, aby zwiÄ™kszyÄ‡ pewnoÅ›Ä‡, Å¼e napisany kod przestrzega zasad Rust.</p>
<p>Aby uzyskaÄ‡ znacznie gÅ‚Ä™bsze poznanie, jak efektywnie pracowaÄ‡ z niebezpiecznym Rust, przeczytaj oficjalny przewodnik Rust dotyczÄ…cy <code>unsafe</code>, <a href="https://doc.rust-lang.org/nomicon/">The Rustonomicon</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="zaawansowane-traity-1"><a href="#zaawansowane-traity-1" class="header">Zaawansowane Traity</a></h1>
<h2 id="zaawansowane-traity"><a class="header" href="#zaawansowane-traity">Zaawansowane Traity</a></h2>
<p>Po raz pierwszy omÃ³wiliÅ›my traity w sekcji <a href="#definiowanie-wspÃ³lnego-zachowania-za-pomocÄ…-cech-1">â€Definiowanie wspÃ³lnego zachowania za pomocÄ… traitÃ³wâ€</a><!-- ignore --> w Rozdziale 10, ale nie omÃ³wiliÅ›my bardziej zaawansowanych szczegÃ³Å‚Ã³w. Teraz, gdy wiesz wiÄ™cej o Rust, moÅ¼emy przejÅ›Ä‡ do sedna.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="specifying-placeholder-types-in-trait-definitions-with-associated-types"></a>
<a id="associated-types"></a></p>
<h3 id="definiowanie-traitÃ³w-z-typami-stowarzyszonymi"><a class="header" href="#definiowanie-traitÃ³w-z-typami-stowarzyszonymi">Definiowanie TraitÃ³w z Typami Stowarzyszonymi</a></h3>
<p><em>Typy stowarzyszone</em> Å‚Ä…czÄ… typ zastÄ™pczy z traitem w taki sposÃ³b, Å¼e definicje metod traitÃ³w mogÄ… uÅ¼ywaÄ‡ tych typÃ³w zastÄ™pczych w swoich sygnaturach. Implementator traitu okreÅ›li konkretny typ, ktÃ³ry ma byÄ‡ uÅ¼yty zamiast typu zastÄ™pczego dla konkretnej implementacji. W ten sposÃ³b moÅ¼emy zdefiniowaÄ‡ trait, ktÃ³ry uÅ¼ywa pewnych typÃ³w, bez koniecznoÅ›ci dokÅ‚adnego poznania tych typÃ³w, dopÃ³ki trait nie zostanie zaimplementowany.</p>
<p>WiÄ™kszoÅ›Ä‡ zaawansowanych funkcji w tym rozdziale opisaliÅ›my jako rzadko potrzebne. Typy stowarzyszone znajdujÄ… siÄ™ gdzieÅ› poÅ›rodku: sÄ… uÅ¼ywane rzadziej niÅ¼ funkcje wyjaÅ›nione w pozostaÅ‚ej czÄ™Å›ci ksiÄ…Å¼ki, ale czÄ™Å›ciej niÅ¼ wiele innych funkcji omÃ³wionych w tym rozdziale.</p>
<p>Jednym z przykÅ‚adÃ³w traitu z typem stowarzyszonym jest trait <code>Iterator</code>, ktÃ³ry udostÄ™pnia biblioteka standardowa. Typ stowarzyszony nazywa siÄ™ <code>Item</code> i zastÄ™puje typ wartoÅ›ci, po ktÃ³rych iteruje typ implementujÄ…cy trait <code>Iterator</code>. Definicja traitu <code>Iterator</code> jest pokazana na LiÅ›cie 20-13.</p>
<figure class="listing" id="listing-20-13">
<pre><code class="language-rust noplayground">pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}</code></pre>
<figcaption><a href="#listing-20-13">Lista 20-13</a>: Definicja traitu <code>Iterator</code>, ktÃ³ry ma stowarzyszony typ <code>Item</code></figcaption>
</figure>
<p>Typ <code>Item</code> jest zastÄ™pczy, a definicja metody <code>next</code> pokazuje, Å¼e zwrÃ³ci ona wartoÅ›ci typu <code>Option&lt;Self::Item&gt;</code>. Implementatorzy traitu <code>Iterator</code> okreÅ›lÄ… konkretny typ dla <code>Item</code>, a metoda <code>next</code> zwrÃ³ci <code>Option</code> zawierajÄ…cy wartoÅ›Ä‡ tego konkretnego typu.</p>
<p>Typy stowarzyszone mogÄ… wydawaÄ‡ siÄ™ podobnÄ… koncepcjÄ… do generykÃ³w, w tym sensie, Å¼e te ostatnie pozwalajÄ… nam zdefiniowaÄ‡ funkcjÄ™ bez okreÅ›lania, jakie typy moÅ¼e obsÅ‚ugiwaÄ‡. Aby zbadaÄ‡ rÃ³Å¼nicÄ™ miÄ™dzy tymi dwoma koncepcjami, przyjrzymy siÄ™ implementacji traitu <code>Iterator</code> na typie o nazwie <code>Counter</code>, ktÃ³ry okreÅ›la, Å¼e typ <code>Item</code> to <code>u32</code>:</p>
<figure class="listing">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust ignore"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
<span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</figure>
<p>Ta skÅ‚adnia wydaje siÄ™ porÃ³wnywalna do skÅ‚adni generykÃ³w. WiÄ™c dlaczego nie zdefiniowaÄ‡ cechy <code>Iterator</code> za pomocÄ… generykÃ³w, jak pokazano na LiÅ›cie 20-14?</p>
<figure class="listing" id="listing-20-14">
<pre><code class="language-rust noplayground">pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}</code></pre>
<figcaption><a href="#listing-20-14">Lista 20-14</a>: Hipotetyczna definicja traitu <code>Iterator</code> uÅ¼ywajÄ…cego generykÃ³w</figcaption>
</figure>
<p>RÃ³Å¼nica polega na tym, Å¼e uÅ¼ywajÄ…c generykÃ³w, jak na LiÅ›cie 20-14, musimy adnotowaÄ‡ typy w kaÅ¼dej implementacji; poniewaÅ¼ moÅ¼emy rÃ³wnieÅ¼ zaimplementowaÄ‡ <code>Iterator&lt;String&gt; for Counter</code> lub dowolny inny typ, moglibyÅ›my mieÄ‡ wiele implementacji <code>Iterator</code> dla <code>Counter</code>. Innymi sÅ‚owy, gdy trait ma parametr generyczny, moÅ¼e byÄ‡ implementowany dla typu wiele razy, zmieniajÄ…c konkretne typy generycznych parametrÃ³w typu za kaÅ¼dym razem. Kiedy uÅ¼ywamy metody <code>next</code> na <code>Counter</code>, musielibyÅ›my podaÄ‡ adnotacje typÃ³w, aby wskazaÄ‡, ktÃ³rÄ… implementacjÄ™ <code>Iterator</code> chcemy uÅ¼yÄ‡.</p>
<p>Z typami stowarzyszonymi nie musimy adnotowaÄ‡ typÃ³w, poniewaÅ¼ nie moÅ¼emy zaimplementowaÄ‡ traitu na typie wiele razy. Na LiÅ›cie 20-13 z definicjÄ… uÅ¼ywajÄ…cÄ… typÃ³w stowarzyszonych, moÅ¼emy wybraÄ‡ typ <code>Item</code> tylko raz, poniewaÅ¼ moÅ¼e istnieÄ‡ tylko jedna <code>impl Iterator for Counter</code>. Nie musimy okreÅ›laÄ‡, Å¼e chcemy iteratora wartoÅ›ci <code>u32</code> wszÄ™dzie tam, gdzie wywoÅ‚ujemy <code>next</code> na <code>Counter</code>.</p>
<p>Typy stowarzyszone stajÄ… siÄ™ rÃ³wnieÅ¼ czÄ™Å›ciÄ… kontraktu traitu: Implementatorzy traitu muszÄ… dostarczyÄ‡ typ, ktÃ³ry zastÄ…pi symbol zastÄ™pczy typu stowarzyszonego. Typy stowarzyszone czÄ™sto majÄ… nazwÄ™ opisujÄ…cÄ… sposÃ³b uÅ¼ycia typu, a dokumentowanie typu stowarzyszonego w dokumentacji API jest dobrÄ… praktykÄ….</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="default-generic-type-parameters-and-operator-overloading"></a></p>
<h3 id="uÅ¼ywanie-domyÅ›lnych-parametrÃ³w-typÃ³w-generycznych-i-przeciÄ…Å¼anie-operatorÃ³w"><a class="header" href="#uÅ¼ywanie-domyÅ›lnych-parametrÃ³w-typÃ³w-generycznych-i-przeciÄ…Å¼anie-operatorÃ³w">UÅ¼ywanie DomyÅ›lnych ParametrÃ³w TypÃ³w Generycznych i PrzeciÄ…Å¼anie OperatorÃ³w</a></h3>
<p>Kiedy uÅ¼ywamy generycznych parametrÃ³w typu, moÅ¼emy okreÅ›liÄ‡ domyÅ›lny konkretny typ dla typu generycznego. Eliminuje to potrzebÄ™ okreÅ›lania konkretnego typu przez implementatorÃ³w cechy, jeÅ›li domyÅ›lny typ dziaÅ‚a. DomyÅ›lny typ okreÅ›la siÄ™ podczas deklarowania typu generycznego za pomocÄ… skÅ‚adni <code>&lt;PlaceholderType=ConcreteType&gt;</code>.</p>
<p>Åšwietnym przykÅ‚adem sytuacji, w ktÃ³rej ta technika jest przydatna, jest <em>przeciÄ…Å¼anie operatorÃ³w</em>, w ktÃ³rym dostosowujesz zachowanie operatora (takiego jak <code>+</code>) w okreÅ›lonych sytuacjach.</p>
<p>Rust nie pozwala na tworzenie wÅ‚asnych operatorÃ³w ani na przeciÄ…Å¼anie dowolnych operatorÃ³w. MoÅ¼esz jednak przeciÄ…Å¼aÄ‡ operacje i odpowiadajÄ…ce im traity wymienione w <code>std::ops</code>, implementujÄ…c traity powiÄ…zane z operatorem. Na przykÅ‚ad, na LiÅ›cie 20-15 przeciÄ…Å¼amy operator <code>+</code>, aby dodawaÄ‡ dwie instancje <code>Point</code>. Robimy to, implementujÄ…c trait <code>Add</code> na strukturze <code>Point</code>.</p>
<figure class="listing" id="listing-20-15">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}</code></pre>
<figcaption><a href="#listing-20-15">Lista 20-15</a>: Implementacja traitu <code>Add</code> w celu przeciÄ…Å¼enia operatora <code>+</code> dla instancji <code>Point</code></figcaption>
</figure>
<p>Metoda <code>add</code> dodaje wartoÅ›ci <code>x</code> dwÃ³ch instancji <code>Point</code> i wartoÅ›ci <code>y</code> dwÃ³ch instancji <code>Point</code>, aby stworzyÄ‡ nowÄ… <code>Point</code>. Trait <code>Add</code> ma stowarzyszony typ o nazwie <code>Output</code>, ktÃ³ry okreÅ›la typ zwracany przez metodÄ™ <code>add</code>.</p>
<p>DomyÅ›lny typ generyczny w tym kodzie znajduje siÄ™ wewnÄ…trz traitu <code>Add</code>. Oto jego definicja:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre>
<p>Ten kod powinien byÄ‡ ogÃ³lnie znany: trait z jednÄ… metodÄ… i stowarzyszonym typem. Nowa czÄ™Å›Ä‡ to <code>Rhs=Self</code>: ta skÅ‚adnia nazywa siÄ™ <em>domyÅ›lnymi parametrami typu</em>. Generyczny parametr typu <code>Rhs</code> (skrÃ³t od â€right-hand sideâ€ â€“ prawa strona) definiuje typ parametru <code>rhs</code> w metodzie <code>add</code>. JeÅ›li nie okreÅ›limy konkretnego typu dla <code>Rhs</code> podczas implementacji traitu <code>Add</code>, typ <code>Rhs</code> domyÅ›lnie przyjmie <code>Self</code>, czyli typ, na ktÃ³rym implementujemy <code>Add</code>.</p>
<p>Kiedy implementowaliÅ›my <code>Add</code> dla <code>Point</code>, uÅ¼yliÅ›my domyÅ›lnego <code>Rhs</code>, poniewaÅ¼ chcieliÅ›my dodaÄ‡ dwie instancje <code>Point</code>. Przyjrzyjmy siÄ™ przykÅ‚adowi implementacji traitu <code>Add</code>, gdzie chcemy dostosowaÄ‡ typ <code>Rhs</code>, zamiast uÅ¼ywaÄ‡ wartoÅ›ci domyÅ›lnej.</p>
<p>Mamy dwie struktury, <code>Millimeters</code> i <code>Meters</code>, przechowujÄ…ce wartoÅ›ci w rÃ³Å¼nych jednostkach. To cienkie opakowanie istniejÄ…cego typu w innÄ… strukturÄ™ jest znane jako <em>wzorzec newtype</em>, ktÃ³ry szczegÃ³Å‚owo opisujemy w sekcji <a href="#implementing-external-traits-with-the-newtype-pattern">â€Implementowanie zewnÄ™trznych traitÃ³w za pomocÄ… wzorca newtypeâ€</a><!-- ignore -->. Chcemy dodawaÄ‡ wartoÅ›ci w milimetrach do wartoÅ›ci w metrach i chcemy, aby implementacja <code>Add</code> poprawnie wykonywaÅ‚a konwersjÄ™. MoÅ¼emy zaimplementowaÄ‡ <code>Add</code> dla <code>Millimeters</code> z <code>Meters</code> jako <code>Rhs</code>, jak pokazano na LiÅ›cie 20-16.</p>
<figure class="listing" id="listing-20-16">
<span class="file-name">Nazwa pliku: src/lib.rs</span>
<pre><code class="language-rust noplayground">use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}</code></pre>
<figcaption><a href="#listing-20-16">Lista 20-16</a>: Implementacja traitu <code>Add</code> na <code>Millimeters</code> w celu dodawania <code>Millimeters</code> i <code>Meters</code></figcaption>
</figure>
<p>Aby dodaÄ‡ <code>Millimeters</code> i <code>Meters</code>, okreÅ›lamy <code>impl Add&lt;Meters&gt;</code>, aby ustawiÄ‡ wartoÅ›Ä‡ parametru typu <code>Rhs</code> zamiast uÅ¼ywaÄ‡ domyÅ›lnego <code>Self</code>.</p>
<p>Parametry typu domyÅ›lnego bÄ™dziesz uÅ¼ywaÄ‡ na dwa gÅ‚Ã³wne sposoby:</p>
<ol>
<li>Aby rozszerzyÄ‡ typ bez naruszania istniejÄ…cego kodu</li>
<li>Aby umoÅ¼liwiÄ‡ dostosowanie w konkretnych przypadkach, ktÃ³rych wiÄ™kszoÅ›Ä‡ uÅ¼ytkownikÃ³w nie bÄ™dzie potrzebowaÄ‡</li>
</ol>
<p>Trait <code>Add</code> z biblioteki standardowej jest przykÅ‚adem drugiego celu: zazwyczaj dodajesz dwa podobne typy, ale trait <code>Add</code> zapewnia moÅ¼liwoÅ›Ä‡ dostosowania wykraczajÄ…cego poza to. UÅ¼ycie domyÅ›lnego parametru typu w definicji traitu <code>Add</code> oznacza, Å¼e nie musisz okreÅ›laÄ‡ dodatkowego parametru przez wiÄ™kszoÅ›Ä‡ czasu. Innymi sÅ‚owy, nie jest potrzebna pewna iloÅ›Ä‡ kodu boilerplate, co uÅ‚atwia uÅ¼ywanie traitu.</p>
<p>Pierwszy cel jest podobny do drugiego, ale odwrotnie: jeÅ›li chcesz dodaÄ‡ parametr typu do istniejÄ…cego traitu, moÅ¼esz nadaÄ‡ mu wartoÅ›Ä‡ domyÅ›lnÄ…, aby umoÅ¼liwiÄ‡ rozszerzenie funkcjonalnoÅ›ci traitu bez naruszania istniejÄ…cego kodu implementacji.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name"></a>
<a id="disambiguating-between-methods-with-the-same-name"></a></p>
<h3 id="rozrÃ³Å¼nianie-metod-o-identycznych-nazwach"><a class="header" href="#rozrÃ³Å¼nianie-metod-o-identycznych-nazwach">RozrÃ³Å¼nianie Metod o Identycznych Nazwach</a></h3>
<p>Nic w Rust nie zapobiega temu, aby trait miaÅ‚ metodÄ™ o tej samej nazwie co metoda innego traitu, ani Rust nie zapobiega implementowaniu obu traitÃ³w na jednym typie. MoÅ¼liwe jest rÃ³wnieÅ¼ zaimplementowanie metody bezpoÅ›rednio na typie z tÄ… samÄ… nazwÄ… co metody z traitÃ³w.</p>
<p>Podczas wywoÅ‚ywania metod o tej samej nazwie, bÄ™dziesz musiaÅ‚ powiedzieÄ‡ Rust, ktÃ³rej chcesz uÅ¼yÄ‡. RozwaÅ¼ kod na LiÅ›cie 20-17, gdzie zdefiniowaliÅ›my dwa traity, <code>Pilot</code> i <code>Wizard</code>, ktÃ³re oba majÄ… metodÄ™ <code>fly</code>. NastÄ™pnie implementujemy oba traity na typie <code>Human</code>, ktÃ³ry juÅ¼ ma zaimplementowanÄ… metodÄ™ <code>fly</code>. KaÅ¼da metoda <code>fly</code> robi coÅ› innego.</p>
<figure class="listing" id="listing-20-17">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&amp;self) {
        println!("*waving arms furiously*");
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<figcaption><a href="#listing-20-17">Lista 20-17</a>: Dwa traity zdefiniowane jako posiadajÄ…ce metodÄ™ <code>fly</code> i zaimplementowane na typie <code>Human</code>, oraz metoda <code>fly</code> zaimplementowana bezpoÅ›rednio na <code>Human</code>.</figcaption>
</figure>
<p>Kiedy wywoÅ‚ujemy <code>fly</code> na instancji <code>Human</code>, kompilator domyÅ›lnie wywoÅ‚uje metodÄ™, ktÃ³ra jest bezpoÅ›rednio zaimplementowana na typie, jak pokazano na LiÅ›cie 20-18.</p>
<figure class="listing" id="listing-20-18">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("This is your captain speaking.");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("Up!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("*waving arms furiously*");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    person.fly();
}</code></pre>
<figcaption><a href="#listing-20-18">Lista 20-18</a>: WywoÅ‚ywanie <code>fly</code> na instancji <code>Human</code></figcaption>
</figure>
<p>Uruchomienie tego kodu wydrukuje <code>*waving arms furiously*</code>, pokazujÄ…c, Å¼e Rust wywoÅ‚aÅ‚ metodÄ™ <code>fly</code> zaimplementowanÄ… bezpoÅ›rednio na <code>Human</code>.</p>
<p>Aby wywoÅ‚aÄ‡ metody <code>fly</code> z traitu <code>Pilot</code> lub traitu <code>Wizard</code>, musimy uÅ¼yÄ‡ bardziej jawnej skÅ‚adni, aby okreÅ›liÄ‡, ktÃ³rÄ… metodÄ™ <code>fly</code> mamy na myÅ›li. Lista 20-19 demonstruje tÄ™ skÅ‚adniÄ™.</p>
<figure class="listing" id="listing-20-19">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("This is your captain speaking.");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("Up!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("*waving arms furiously*");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}</code></pre>
<figcaption><a href="#listing-20-19">Lista 20-19</a>: OkreÅ›lanie, ktÃ³rÄ… metodÄ™ <code>fly</code> z traitu chcemy wywoÅ‚aÄ‡</figcaption>
</figure>
<p>OkreÅ›lenie nazwy traitu przed nazwÄ… metody wyjaÅ›nia Rust, ktÃ³rÄ… implementacjÄ™ <code>fly</code> chcemy wywoÅ‚aÄ‡. MoglibyÅ›my rÃ³wnieÅ¼ napisaÄ‡ <code>Human::fly(&amp;person)</code>, co jest rÃ³wnowaÅ¼ne <code>person.fly()</code>, ktÃ³rego uÅ¼yliÅ›my na LiÅ›cie 20-19, ale jest to nieco dÅ‚uÅ¼sze do napisania, jeÅ›li nie musimy rozrÃ³Å¼niaÄ‡.</p>
<p>Uruchomienie tego kodu wypisuje nastÄ™pujÄ…ce informacje:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
This is your captain speaking.
Up!
*waving arms furiously*
</code></pre>
<p>PoniewaÅ¼ metoda <code>fly</code> przyjmuje parametr <code>self</code>, gdybyÅ›my mieli dwa <em>typy</em>, ktÃ³re oba implementujÄ… jeden <em>trait</em>, Rust mÃ³gÅ‚by ustaliÄ‡, ktÃ³rÄ… implementacjÄ™ traitu uÅ¼yÄ‡ na podstawie typu <code>self</code>.</p>
<p>Jednak funkcje stowarzyszone, ktÃ³re nie sÄ… metodami, nie majÄ… parametru <code>self</code>. Gdy istnieje wiele typÃ³w lub cech, ktÃ³re definiujÄ… funkcje niestowarzyszone z tÄ… samÄ… nazwÄ… funkcji, Rust nie zawsze wie, o ktÃ³ry typ chodzi, chyba Å¼e uÅ¼yjesz w peÅ‚ni kwalifikowanej skÅ‚adni. Na przykÅ‚ad na LiÅ›cie 20-20 tworzymy cechÄ™ dla schroniska dla zwierzÄ…t, ktÃ³re chce nazwaÄ‡ wszystkie szczeniÄ™ta Spot. Tworzymy cechÄ™ <code>Animal</code> z powiÄ…zanÄ… funkcjÄ… niestowarzyszonÄ… <code>baby_name</code>. Cecha <code>Animal</code> jest zaimplementowana dla struktury <code>Dog</code>, dla ktÃ³rej rÃ³wnieÅ¼ udostÄ™pniamy bezpoÅ›rednio powiÄ…zanÄ… funkcjÄ™ niestowarzyszonÄ… <code>baby_name</code>.</p>
<figure class="listing" id="listing-20-20">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from("puppy")
    }
}

fn main() {
    println!("A baby dog is called a {}", Dog::baby_name());
}</code></pre>
<figcaption><a href="#listing-20-20">Lista 20-20</a>: Trait z funkcjÄ… stowarzyszonÄ… i typ z funkcjÄ… stowarzyszonÄ… o tej samej nazwie, ktÃ³ra rÃ³wnieÅ¼ implementuje trait</figcaption>
</figure>
<p>Implementujemy kod do nazywania wszystkich szczeniÄ…t Spot w funkcji stowarzyszonej <code>baby_name</code>, ktÃ³ra jest zdefiniowana na <code>Dog</code>. Typ <code>Dog</code> implementuje rÃ³wnieÅ¼ trait <code>Animal</code>, ktÃ³ry opisuje cechy, ktÃ³re majÄ… wszystkie zwierzÄ™ta. MÅ‚ode psy nazywane sÄ… szczeniÄ™tami, co jest wyraÅ¼one w implementacji traitu <code>Animal</code> na <code>Dog</code> w funkcji <code>baby_name</code> stowarzyszonej z traitem <code>Animal</code>.</p>
<p>W <code>main</code> wywoÅ‚ujemy funkcjÄ™ <code>Dog::baby_name</code>, ktÃ³ra wywoÅ‚uje bezpoÅ›rednio funkcjÄ™ stowarzyszonÄ… zdefiniowanÄ… na <code>Dog</code>. Ten kod wypisuje nastÄ™pujÄ…ce informacje:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
A baby dog is called a Spot
</code></pre>
<p>Ten wynik nie jest tym, czego chcieliÅ›my. Chcemy wywoÅ‚aÄ‡ funkcjÄ™ <code>baby_name</code>, ktÃ³ra jest czÄ™Å›ciÄ… cechy <code>Animal</code>, ktÃ³rÄ… zaimplementowaliÅ›my na <code>Dog</code>, tak aby kod wypisywaÅ‚ <code>A baby dog is called a puppy</code>. Technika okreÅ›lania nazwy cechy, ktÃ³rej uÅ¼yliÅ›my na LiÅ›cie 20-19, nie pomaga tutaj; jeÅ›li zmienimy <code>main</code> na kod z Listy 20-21, otrzymamy bÅ‚Ä…d kompilacji.</p>
<figure class="listing" id="listing-20-21">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Spot")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("puppy")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!("A baby dog is called a {}", Animal::baby_name());
}</code></pre>
<figcaption><a href="#listing-20-21">Lista 20-21</a>: PrÃ³ba wywoÅ‚ania funkcji <code>baby_name</code> z traitu <code>Animal</code>, ale Rust nie wie, ktÃ³rej implementacji uÅ¼yÄ‡</figcaption>
</figure>
<p>PoniewaÅ¼ <code>Animal::baby_name</code> nie ma parametru <code>self</code>, a mogÄ… istnieÄ‡ inne typy, ktÃ³re implementujÄ… cechÄ™ <code>Animal</code>, Rust nie moÅ¼e ustaliÄ‡, ktÃ³rÄ… implementacjÄ™ <code>Animal::baby_name</code> chcemy. Otrzymamy ten bÅ‚Ä…d kompilacji:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type
  --&gt; src/main.rs:20:43
   |
 2 |     fn baby_name() -&gt; String;
   |     ------------------------- `Animal::baby_name` defined here
...
20 |     println!("A baby dog is called a {}", Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^^^ cannot call associated function of trait
   |
help: use the fully-qualified path to the only available implementation
   |
20 |     println!("A baby dog is called a {}", &lt;Dog as Animal&gt;::baby_name());
   |                                           +++++++       +

For more information about this error, try `rustc --explain E0790`.
error: could not compile `traits-example` (bin "traits-example") due to 1 previous error
</code></pre>
<p>Aby rozrÃ³Å¼niÄ‡ i powiedzieÄ‡ Rust, Å¼e chcemy uÅ¼yÄ‡ implementacji <code>Animal</code> dla <code>Dog</code> w przeciwieÅ„stwie do implementacji <code>Animal</code> dla jakiegoÅ› innego typu, musimy uÅ¼yÄ‡ w peÅ‚ni kwalifikowanej skÅ‚adni. Lista 20-22 demonstruje, jak uÅ¼ywaÄ‡ w peÅ‚ni kwalifikowanej skÅ‚adni.</p>
<figure class="listing" id="listing-20-22">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Spot")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("puppy")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!("A baby dog is called a {}", &lt;Dog as Animal&gt;::baby_name());
}</code></pre>
<figcaption><a href="#listing-20-22">Lista 20-22</a>: UÅ¼ycie w peÅ‚ni kwalifikowanej skÅ‚adni, aby okreÅ›liÄ‡, Å¼e chcemy wywoÅ‚aÄ‡ funkcjÄ™ <code>baby_name</code> z traitu <code>Animal</code> zaimplementowanego na <code>Dog</code></figcaption>
</figure>
<p>Dostarczamy Rust adnotacjÄ™ typu w nawiasach ostrych, ktÃ³ra wskazuje, Å¼e chcemy wywoÅ‚aÄ‡ metodÄ™ <code>baby_name</code> z cechy <code>Animal</code> zaimplementowanej na <code>Dog</code>, mÃ³wiÄ…c, Å¼e chcemy traktowaÄ‡ typ <code>Dog</code> jako <code>Animal</code> dla tego wywoÅ‚ania funkcji. Ten kod wydrukuje teraz to, czego chcemy:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
A baby dog is called a puppy
</code></pre>
<p>OgÃ³lnie, w peÅ‚ni kwalifikowana skÅ‚adnia jest zdefiniowana nastÄ™pujÄ…co:</p>
<pre><code class="language-rust ignore">&lt;Typ jako Trait&gt;::funkcja(odbiorca_jeÅ›li_metoda, nastÄ™pny_argument, ...);</code></pre>
<p>Dla funkcji stowarzyszonych, ktÃ³re nie sÄ… metodami, nie byÅ‚oby <code>odbiorcy</code>: byÅ‚aby tylko lista innych argumentÃ³w. MoÅ¼na by uÅ¼ywaÄ‡ w peÅ‚ni kwalifikowanej skÅ‚adni wszÄ™dzie tam, gdzie wywoÅ‚uje siÄ™ funkcje lub metody. JednakÅ¼e, moÅ¼na pominÄ…Ä‡ dowolnÄ… czÄ™Å›Ä‡ tej skÅ‚adni, ktÃ³rÄ… Rust moÅ¼e ustaliÄ‡ na podstawie innych informacji w programie. TÄ™ bardziej rozbudowanÄ… skÅ‚adniÄ™ trzeba uÅ¼ywaÄ‡ tylko w przypadkach, gdy istnieje wiele implementacji, ktÃ³re uÅ¼ywajÄ… tej samej nazwy, a Rust potrzebuje pomocy w zidentyfikowaniu, ktÃ³rÄ… implementacjÄ™ chcesz wywoÅ‚aÄ‡.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="using-supertraits-to-require-one-traits-functionality-within-another-trait"></a></p>
<h3 id="uÅ¼ywanie-supertraitÃ³w"><a class="header" href="#uÅ¼ywanie-supertraitÃ³w">UÅ¼ywanie SupertraitÃ³w</a></h3>
<p>Czasami moÅ¼esz napisaÄ‡ definicjÄ™ traitu, ktÃ³ra zaleÅ¼y od innego traitu: Aby typ implementowaÅ‚ pierwszy trait, chcesz wymagaÄ‡, aby ten typ rÃ³wnieÅ¼ implementowaÅ‚ drugi trait. Robisz to po to, aby Twoja definicja traitu mogÅ‚a korzystaÄ‡ ze stowarzyszonych elementÃ³w drugiego traitu. Trait, na ktÃ³rym opiera siÄ™ Twoja definicja traitu, nazywany jest <em>supertraitem</em> Twojego traitu.</p>
<p>Na przykÅ‚ad, powiedzmy, Å¼e chcemy stworzyÄ‡ cechÄ™ <code>OutlinePrint</code> z metodÄ… <code>outline_print</code>, ktÃ³ra bÄ™dzie drukowaÄ‡ podanÄ… wartoÅ›Ä‡ sformatowanÄ… tak, aby byÅ‚a obramowana gwiazdkami. Oznacza to, Å¼e biorÄ…c pod uwagÄ™ strukturÄ™ <code>Point</code>, ktÃ³ra implementuje standardowÄ… cechÄ™ <code>Display</code>, aby uzyskaÄ‡ <code>(x, y)</code>, gdy wywoÅ‚amy <code>outline_print</code> na instancji <code>Point</code>, ktÃ³ra ma <code>1</code> dla <code>x</code> i <code>3</code> dla <code>y</code>, powinna ona wydrukowaÄ‡ nastÄ™pujÄ…ce:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>W implementacji metody <code>outline_print</code> chcemy uÅ¼yÄ‡ funkcjonalnoÅ›ci cechy <code>Display</code>. Dlatego musimy okreÅ›liÄ‡, Å¼e cecha <code>OutlinePrint</code> bÄ™dzie dziaÅ‚aÄ‡ tylko dla typÃ³w, ktÃ³re rÃ³wnieÅ¼ implementujÄ… <code>Display</code> i dostarczajÄ… funkcjonalnoÅ›Ä‡, ktÃ³rej potrzebuje <code>OutlinePrint</code>. MoÅ¼emy to zrobiÄ‡ w definicji cechy, okreÅ›lajÄ…c <code>OutlinePrint: Display</code>. Ta technika jest podobna do dodawania ograniczenia cechy do cechy. Lista 20-23 pokazuje implementacjÄ™ cechy <code>OutlinePrint</code>.</p>
<figure class="listing" id="listing-20-23">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {output} *");
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<figcaption><a href="#listing-20-23">Lista 20-23</a>: Implementacja traitu <code>OutlinePrint</code>, ktÃ³ry wymaga funkcjonalnoÅ›ci z <code>Display</code></figcaption>
</figure>
<p>PoniewaÅ¼ okreÅ›liliÅ›my, Å¼e <code>OutlinePrint</code> wymaga traitu <code>Display</code>, moÅ¼emy uÅ¼yÄ‡ funkcji <code>to_string</code>, ktÃ³ra jest automatycznie implementowana dla kaÅ¼dego typu, ktÃ³ry implementuje <code>Display</code>. GdybyÅ›my sprÃ³bowali uÅ¼yÄ‡ <code>to_string</code> bez dodania dwukropka i okreÅ›lenia traitu <code>Display</code> po nazwie traitu, otrzymalibyÅ›my bÅ‚Ä…d mÃ³wiÄ…cy, Å¼e w bieÅ¼Ä…cym zakresie nie znaleziono metody o nazwie <code>to_string</code> dla typu <code>&amp;Self</code>.</p>
<p>Zobaczmy, co siÄ™ stanie, gdy sprÃ³bujemy zaimplementowaÄ‡ <code>OutlinePrint</code> na typie, ktÃ³ry nie implementuje <code>Display</code>, takim jak struktura <code>Point</code>:</p>
<figure class="listing">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("* {output} *");
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre>
</figure>
<p>Otrzymujemy bÅ‚Ä…d mÃ³wiÄ…cy, Å¼e <code>Display</code> jest wymagane, ale nie zaimplementowane:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:20:23
   |
20 | impl OutlinePrint for Point {}
   |                       ^^^^^ the trait `std::fmt::Display` is not implemented for `Point`
   |
note: required by a bound in `OutlinePrint`
  --&gt; src/main.rs:3:21
   |
 3 | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`

error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:24:7
   |
24 |     p.outline_print();
   |       ^^^^^^^^^^^^^ the trait `std::fmt::Display` is not implemented for `Point`
   |
note: required by a bound in `OutlinePrint::outline_print`
  --&gt; src/main.rs:3:21
   |
 3 | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint::outline_print`
 4 |     fn outline_print(&amp;self) {
   |        ------------- required by a bound in this associated function

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example` (bin "traits-example") due to 2 previous errors
</code></pre>
<p>Aby to naprawiÄ‡, implementujemy <code>Display</code> na <code>Point</code> i speÅ‚niamy ograniczenie, ktÃ³rego wymaga <code>OutlinePrint</code>, w ten sposÃ³b:</p>
<figure class="listing">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("* {output} *");
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl OutlinePrint for Point {}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre>
</figure>
<p>Wtedy implementacja cechy <code>OutlinePrint</code> na <code>Point</code> skompiluje siÄ™ pomyÅ›lnie, i bÄ™dziemy mogli wywoÅ‚aÄ‡ <code>outline_print</code> na instancji <code>Point</code>, aby wyÅ›wietliÄ‡ jÄ… w obramowaniu z gwiazdek.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="using-the-newtype-pattern-to-implement-external-traits-on-external-types"></a>
<a id="using-the-newtype-pattern-to-implement-external-traits"></a></p>
<h3 id="implementowanie-zewnÄ™trznych-traitÃ³w-za-pomocÄ…-wzorca-newtype"><a class="header" href="#implementowanie-zewnÄ™trznych-traitÃ³w-za-pomocÄ…-wzorca-newtype">Implementowanie ZewnÄ™trznych TraitÃ³w za pomocÄ… Wzorca Newtype</a></h3>
<p>W sekcji <a href="#implementing-a-trait-on-a-type">â€Implementowanie traitu na typieâ€</a><!-- ignore --> w Rozdziale 10 wspomnieliÅ›my o regule sieroty, ktÃ³ra stanowi, Å¼e moÅ¼emy implementowaÄ‡ trait na typie tylko wtedy, gdy albo trait, albo typ, albo oba, sÄ… lokalne dla naszego crateâ€™u. MoÅ¼liwe jest obejÅ›cie tego ograniczenia za pomocÄ… wzorca newtype, ktÃ³ry polega na utworzeniu nowego typu w strukturze krotkowej. (Struktury krotkowe omÃ³wiliÅ›my w sekcji <a href="#creating-different-types-with-tuple-structs">â€Tworzenie rÃ³Å¼nych typÃ³w za pomocÄ… struktur krotkowychâ€</a><!-- ignore --> w Rozdziale 5.) Struktura krotkowa bÄ™dzie miaÅ‚a jedno pole i bÄ™dzie cienkim opakowaniem wokÃ³Å‚ typu, dla ktÃ³rego chcemy zaimplementowaÄ‡ trait. Wtedy typ opakowujÄ…cy jest lokalny dla naszego crateâ€™u, i moÅ¼emy zaimplementowaÄ‡ trait na opakowaniu. <em>Newtype</em> to termin, ktÃ³ry pochodzi z jÄ™zyka programowania Haskell. Nie ma kary za wydajnoÅ›Ä‡ w czasie wykonania za uÅ¼ycie tego wzorca, a typ opakowujÄ…cy jest pomijany w czasie kompilacji.</p>
<p>Na przykÅ‚ad, zaÅ‚Ã³Å¼my, Å¼e chcemy zaimplementowaÄ‡ <code>Display</code> na <code>Vec&lt;T&gt;</code>, czego reguÅ‚a sieroty uniemoÅ¼liwia nam bezpoÅ›rednio, poniewaÅ¼ trait <code>Display</code> i typ <code>Vec&lt;T&gt;</code> sÄ… zdefiniowane poza naszym crate. MoÅ¼emy stworzyÄ‡ strukturÄ™ <code>Wrapper</code>, ktÃ³ra przechowuje instancjÄ™ <code>Vec&lt;T&gt;</code>; nastÄ™pnie moÅ¼emy zaimplementowaÄ‡ <code>Display</code> na <code>Wrapper</code> i uÅ¼yÄ‡ wartoÅ›ci <code>Vec&lt;T&gt;</code>, jak pokazano na LiÅ›cie 20-24.</p>
<figure class="listing" id="listing-20-24">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {w}");
}</code></pre>
<figcaption><a href="#listing-20-24">Lista 20-24</a>: Tworzenie typu <code>Wrapper</code> wokÃ³Å‚ <code>Vec&lt;String&gt;</code> w celu implementacji <code>Display</code></figcaption>
</figure>
<p>Implementacja <code>Display</code> uÅ¼ywa <code>self.0</code> do dostÄ™pu do wewnÄ™trznego <code>Vec&lt;T&gt;</code>, poniewaÅ¼ <code>Wrapper</code> jest strukturÄ… krotkowÄ…, a <code>Vec&lt;T&gt;</code> jest elementem o indeksie 0 w krotce. NastÄ™pnie moÅ¼emy uÅ¼yÄ‡ funkcjonalnoÅ›ci cechy <code>Display</code> na <code>Wrapper</code>.</p>
<p>WadÄ… stosowania tej techniki jest to, Å¼e <code>Wrapper</code> jest nowym typem, wiÄ™c nie ma metod wartoÅ›ci, ktÃ³rÄ… przechowuje. MusielibyÅ›my zaimplementowaÄ‡ wszystkie metody <code>Vec&lt;T&gt;</code> bezpoÅ›rednio na <code>Wrapper</code>, tak aby metody delegowaÅ‚y do <code>self.0</code>, co pozwoliÅ‚oby nam traktowaÄ‡ <code>Wrapper</code> dokÅ‚adnie tak jak <code>Vec&lt;T&gt;</code>. GdybyÅ›my chcieli, aby nowy typ miaÅ‚ kaÅ¼dÄ… metodÄ™, ktÃ³rÄ… ma typ wewnÄ™trzny, zaimplementowanie cechy <code>Deref</code> na <code>Wrapper</code>, aby zwracaÅ‚a typ wewnÄ™trzny, byÅ‚oby rozwiÄ…zaniem (omÃ³wiliÅ›my implementacjÄ™ cechy <code>Deref</code> w sekcji <a href="#treating-smart-pointers-like-regular-references">â€Traktowanie inteligentnych wskaÅºnikÃ³w jak zwykÅ‚ych referencjiâ€</a><!-- ignore --> w Rozdziale 15). GdybyÅ›my nie chcieli, aby typ <code>Wrapper</code> miaÅ‚ wszystkie metody typu wewnÄ™trznego â€” na przykÅ‚ad, aby ograniczyÄ‡ zachowanie typu <code>Wrapper</code> â€” musielibyÅ›my rÄ™cznie zaimplementowaÄ‡ tylko te metody, ktÃ³re chcemy.</p>
<p>Ten wzorzec newtype jest rÃ³wnieÅ¼ uÅ¼yteczny nawet wtedy, gdy traity nie sÄ… zaangaÅ¼owane. ZmieÅ„my fokus i przyjrzyjmy siÄ™ niektÃ³rym zaawansowanym sposobom interakcji z systemem typÃ³w Rust.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="zaawansowane-typy-1"><a href="#zaawansowane-typy-1" class="header">Zaawansowane Typy</a></h1>
<h2 id="zaawansowane-typy"><a class="header" href="#zaawansowane-typy">Zaawansowane Typy</a></h2>
<p>System typÃ³w Rust posiada pewne funkcje, o ktÃ³rych wspominaliÅ›my, ale jeszcze
nie omawialiÅ›my. Zaczniemy od omÃ³wienia ogÃ³lnych â€œnowych typÃ³wâ€ (newtypes),
badajÄ…c, dlaczego sÄ… one przydatne jako typy. NastÄ™pnie przejdziemy do aliasÃ³w
typÃ³w, funkcji podobnej do â€œnowych typÃ³wâ€, ale z nieco odmiennÄ… semantykÄ….
OmÃ³wimy takÅ¼e typ <code>!</code> oraz typy o dynamicznym rozmiarze.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="using-the-newtype-pattern-for-type-safety-and-abstraction"></a></p>
<h3 id="bezpieczeÅ„stwo-typÃ³w-i-abstrakcja-z-wzorcem-nowego-typu"><a class="header" href="#bezpieczeÅ„stwo-typÃ³w-i-abstrakcja-z-wzorcem-nowego-typu">BezpieczeÅ„stwo typÃ³w i abstrakcja z wzorcem nowego typu</a></h3>
<p>Ta sekcja zakÅ‚ada, Å¼e przeczytaÅ‚eÅ› wczeÅ›niejszÄ… sekcjÄ™ <a href="#implementing-external-traits-with-the-newtype-pattern">â€Implementowanie cech
zewnÄ™trznych za pomocÄ… wzorca nowego typuâ€</a><!-- ignore -->. Wzorzec
nowego typu jest rÃ³wnieÅ¼ przydatny do zadaÅ„ wykraczajÄ…cych poza te, ktÃ³re
omÃ³wiliÅ›my do tej pory, w tym do statycznego egzekwowania, aby wartoÅ›ci nigdy
nie byÅ‚y mylone, oraz do wskazywania jednostek wartoÅ›ci. PrzykÅ‚ad uÅ¼ycia
nowych typÃ³w do wskazywania jednostek widziaÅ‚eÅ› w Listing 20-16: Przypomnij
sobie, Å¼e struktury <code>Millimeters</code> i <code>Meters</code> opakowywaÅ‚y wartoÅ›ci <code>u32</code> w nowy
typ. GdybyÅ›my napisali funkcjÄ™ z parametrem typu <code>Millimeters</code>, nie bylibyÅ›my
w stanie skompilowaÄ‡ programu, ktÃ³ry przypadkowo prÃ³bowaÅ‚by wywoÅ‚aÄ‡ tÄ™ funkcjÄ™
z wartoÅ›ciÄ… typu <code>Meters</code> lub zwykÅ‚ym <code>u32</code>.</p>
<p>MoÅ¼emy rÃ³wnieÅ¼ uÅ¼yÄ‡ wzorca nowego typu, aby odseparowaÄ‡ niektÃ³re szczegÃ³Å‚y
implementacji typu: Nowy typ moÅ¼e ujawniaÄ‡ publiczne API, ktÃ³re rÃ³Å¼ni siÄ™ od
API prywatnego typu wewnÄ™trznego.</p>
<p>Nowe typy mogÄ… rÃ³wnieÅ¼ ukrywaÄ‡ wewnÄ™trznÄ… implementacjÄ™. Na przykÅ‚ad, moglibyÅ›my
dostarczyÄ‡ typ <code>People</code>, aby opakowaÄ‡ <code>HashMap&lt;i32, String&gt;</code>, ktÃ³ry przechowuje
ID osoby skojarzone z jej imieniem. Kod uÅ¼ywajÄ…cy <code>People</code> wchodziÅ‚by w
interakcjÄ™ tylko z publicznym API, ktÃ³re dostarczamy, takim jak metoda
dodawania ciÄ…gu znakÃ³w z imieniem do kolekcji <code>People</code>; ten kod nie musiaÅ‚by
wiedzieÄ‡, Å¼e wewnÄ™trznie przypisujemy imionom ID typu <code>i32</code>. Wzorzec nowego
typu to lekki sposÃ³b na osiÄ…gniÄ™cie hermetyzacji w celu ukrycia szczegÃ³Å‚Ã³w
implementacji, co omÃ³wiliÅ›my w sekcji <a href="#encapsulation-that-hides-implementation-details">â€Hermetyzacja ukrywajÄ…ca szczegÃ³Å‚y
implementacjiâ€</a><!-- ignore -->
w Rozdziale 18.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-type-synonyms-with-type-aliases"></a></p>
<h3 id="synonimy-typÃ³w-i-aliasy-typÃ³w"><a class="header" href="#synonimy-typÃ³w-i-aliasy-typÃ³w">Synonimy typÃ³w i aliasy typÃ³w</a></h3>
<p>Rust umoÅ¼liwia deklarowanie <em>aliasu typu</em>, aby nadaÄ‡ istniejÄ…cemu typowi
inne imiÄ™. UÅ¼ywamy do tego sÅ‚owa kluczowego <code>type</code>. Na przykÅ‚ad, moÅ¼emy
utworzyÄ‡ alias <code>Kilometers</code> dla <code>i32</code> w nastÄ™pujÄ…cy sposÃ³b:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    type Kilometers = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometers = 5;
</span><span class="boring">
</span><span class="boring">    println!("x + y = {}", x + y);
</span><span class="boring">}</span></code></pre>
<p>Teraz alias <code>Kilometers</code> jest <em>synonimem</em> dla <code>i32</code>; w przeciwieÅ„stwie do
typÃ³w <code>Millimeters</code> i <code>Meters</code>, ktÃ³re stworzyliÅ›my w Listing 20-16,
<code>Kilometers</code> nie jest osobnym, nowym typem. WartoÅ›ci, ktÃ³re majÄ… typ
<code>Kilometers</code>, bÄ™dÄ… traktowane tak samo jak wartoÅ›ci typu <code>i32</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!("x + y = {}", x + y);
<span class="boring">}</span></code></pre>
<p>PoniewaÅ¼ <code>Kilometers</code> i <code>i32</code> sÄ… tego samego typu, moÅ¼emy dodawaÄ‡ wartoÅ›ci obu
typÃ³w i przekazywaÄ‡ wartoÅ›ci <code>Kilometers</code> do funkcji, ktÃ³re przyjmujÄ…
parametry <code>i32</code>. JednakÅ¼e, uÅ¼ywajÄ…c tej metody, nie uzyskujemy korzyÅ›ci z
kontroli typÃ³w, ktÃ³re daje wzorzec nowego typu omÃ³wiony wczeÅ›niej. Innymi
sÅ‚owy, jeÅ›li gdzieÅ› pomylimy wartoÅ›ci <code>Kilometers</code> i <code>i32</code>, kompilator nie
zgÅ‚osi nam bÅ‚Ä™du.</p>
<p>GÅ‚Ã³wnym przypadkiem uÅ¼ycia synonimÃ³w typÃ³w jest zmniejszenie powtÃ³rzeÅ„. Na
przykÅ‚ad, moÅ¼emy mieÄ‡ dÅ‚ugi typ, taki jak ten:</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;</code></pre>
<p>Pisanie tego dÅ‚ugiego typu w sygnaturach funkcji i jako adnotacji typÃ³w w
caÅ‚ym kodzie moÅ¼e byÄ‡ mÄ™czÄ…ce i podatne na bÅ‚Ä™dy. WyobraÅº sobie projekt
peÅ‚en kodu takiego jak w Listing 20-25.</p>
<figure class="listing" id="listing-20-25">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!("hi"));

    fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // --snip--
    }

    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-20-25">Listing 20-25</a>: UÅ¼ycie dÅ‚ugiego typu w wielu miejscach</figcaption>
</figure>
<p>Alias typu sprawia, Å¼e ten kod jest Å‚atwiejszy do zarzÄ…dzania, redukujÄ…c
powtÃ³rzenia. W Listing 20-26 wprowadziliÅ›my alias nazwany <code>Thunk</code> dla
obszernego typu i moÅ¼emy zastÄ…piÄ‡ wszystkie uÅ¼ycia typu krÃ³tszym aliasem
<code>Thunk</code>.</p>
<figure class="listing" id="listing-20-26">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!("hi"));

    fn takes_long_type(f: Thunk) {
        // --snip--
    }

    fn returns_long_type() -&gt; Thunk {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-20-26">Listing 20-26</a>: Wprowadzenie aliasu typu, <code>Thunk</code>, w celu zmniejszenia powtÃ³rzeÅ„</figcaption>
</figure>
<p>Ten kod jest znacznie Å‚atwiejszy do czytania i pisania! Wybranie znaczÄ…cej
nazwy dla aliasu typu moÅ¼e pomÃ³c w komunikowaniu intencji (<em>thunk</em> to sÅ‚owo
opisujÄ…ce kod, ktÃ³ry ma byÄ‡ ewaluowany w pÃ³Åºniejszym czasie, wiÄ™c jest to
odpowiednia nazwa dla przechowywanego domkniÄ™cia).</p>
<p>Aliasy typÃ³w sÄ… rÃ³wnieÅ¼ powszechnie uÅ¼ywane z typem <code>Result&lt;T, E&gt;</code> w celu
zmniejszenia powtÃ³rzeÅ„. RozwaÅ¼ moduÅ‚ <code>std::io</code> w standardowej bibliotece.
Operacje wejÅ›cia/wyjÅ›cia czÄ™sto zwracajÄ… <code>Result&lt;T, E&gt;</code>, aby obsÅ‚ugiwaÄ‡
sytuacje, gdy operacje koÅ„czÄ… siÄ™ niepowodzeniem. Ta biblioteka posiada
strukturÄ™ <code>std::io::Error</code>, ktÃ³ra reprezentuje wszystkie moÅ¼liwe bÅ‚Ä™dy I/O.
Wiele funkcji w <code>std::io</code> bÄ™dzie zwracaÄ‡ <code>Result&lt;T, E&gt;</code>, gdzie <code>E</code> to
<code>std::io::Error</code>, takie jak te funkcje w cesze <code>Write</code>:</p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}</code></pre>
<p><code>Result&lt;..., Error&gt;</code> powtarza siÄ™ czÄ™sto. W zwiÄ…zku z tym <code>std::io</code> ma tÄ™
deklaracjÄ™ aliasu typu:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}</span></code></pre>
<p>PoniewaÅ¼ ta deklaracja znajduje siÄ™ w module <code>std::io</code>, moÅ¼emy uÅ¼yÄ‡ w peÅ‚ni
kwalifikowanego aliasu <code>std::io::Result&lt;T&gt;</code>; to znaczy <code>Result&lt;T, E&gt;</code>, gdzie
<code>E</code> jest wypeÅ‚nione jako <code>std::io::Error</code>. Sygnatury funkcji cechy <code>Write</code>
wyglÄ…dajÄ… tak:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}</code></pre>
<p>Alias typu pomaga na dwa sposoby: uÅ‚atwia pisanie kodu <em>i</em> zapewnia nam
spÃ³jny interfejs w caÅ‚ym <code>std::io</code>. PoniewaÅ¼ jest to alias, jest to po
prostu kolejny <code>Result&lt;T, E&gt;</code>, co oznacza, Å¼e moÅ¼emy z nim uÅ¼ywaÄ‡ dowolnych
metod dziaÅ‚ajÄ…cych na <code>Result&lt;T, E&gt;</code>, a takÅ¼e specjalnej skÅ‚adni, takiej jak
operator <code>?</code>.</p>
<h3 id="typ-nigdy-ktÃ³ry-nigdy-nie-zwraca"><a class="header" href="#typ-nigdy-ktÃ³ry-nigdy-nie-zwraca">Typ Nigdy, ktÃ³ry nigdy nie zwraca</a></h3>
<p>Rust posiada specjalny typ nazwany <code>!</code>, ktÃ³ry w terminologii teorii typÃ³w
nazywany jest <em>typem pustym</em>, poniewaÅ¼ nie posiada Å¼adnych wartoÅ›ci. My
wolimy nazywaÄ‡ go <em>typem nigdy</em>, poniewaÅ¼ zajmuje on miejsce typu zwracanego,
gdy funkcja nigdy nie zwraca wartoÅ›ci. Oto przykÅ‚ad:</p>
<pre><code class="language-rust noplayground">fn bar() -&gt; ! {
    // --snip--
<span class="boring">    panic!();
</span>}</code></pre>
<p>Ten kod czytamy jako â€funkcja <code>bar</code> nigdy nie zwracaâ€. Funkcje, ktÃ³re nigdy nie
zwracajÄ…, nazywane sÄ… <em>funkcjami rozbieÅ¼nymi</em>. Nie moÅ¼emy tworzyÄ‡ wartoÅ›ci
typu <code>!</code>, wiÄ™c <code>bar</code> nigdy nie moÅ¼e zwrÃ³ciÄ‡ wartoÅ›ci.</p>
<p>Ale jakie jest zastosowanie typu, dla ktÃ³rego nigdy nie moÅ¼na stworzyÄ‡ wartoÅ›ci?
Przypomnijmy kod z Listing 2-5, czÄ™Å›Ä‡ gry w zgadywanie liczb; odtworzyliÅ›my
jego fragment tutaj w Listing 20-27.</p>
<figure class="listing" id="listing-20-27">
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Guess the number!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("The secret number is: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Please input your guess.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Failed to read line");
</span><span class="boring">
</span>        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!("You guessed: {guess}");
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("Too small!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Too big!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("You win!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<figcaption><a href="#listing-20-27">Listing 20-27</a>: <code>match</code> z ramieniem, ktÃ³re koÅ„czy siÄ™ na <code>continue</code></figcaption>
</figure>
<p>WÃ³wczas pominÄ™liÅ›my pewne szczegÃ³Å‚y tego kodu. W sekcji <a href="#the-match-control-flow-construct">â€Konstrukcja przepÅ‚ywu
sterowania <code>match</code>â€</a><!-- ignore --> w
Rozdziale 6 omÃ³wiliÅ›my, Å¼e ramiona <code>match</code> muszÄ… zwracaÄ‡ ten sam typ. Na
przykÅ‚ad, poniÅ¼szy kod nie dziaÅ‚a:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let guess = "3";
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; "hello",
    };
<span class="boring">}</span></code></pre>
<p>Typ <code>guess</code> w tym kodzie musiaÅ‚by byÄ‡ liczbÄ… caÅ‚kowitÄ… <em>i</em> ciÄ…giem znakÃ³w,
a Rust wymaga, aby <code>guess</code> miaÅ‚ tylko jeden typ. Zatem, co zwraca <code>continue</code>?
Jak mogliÅ›my zwrÃ³ciÄ‡ <code>u32</code> z jednego ramienia i mieÄ‡ drugie ramiÄ™, ktÃ³re koÅ„czy
siÄ™ na <code>continue</code> w Listing 20-27?</p>
<p>Jak siÄ™ domyÅ›lasz, <code>continue</code> ma wartoÅ›Ä‡ <code>!</code>. Oznacza to, Å¼e gdy Rust
oblicza typ <code>guess</code>, patrzy na oba ramiona <code>match</code>, pierwsze z wartoÅ›ciÄ… <code>u32</code>
i drugie z wartoÅ›ciÄ… <code>!</code>. PoniewaÅ¼ <code>!</code> nigdy nie moÅ¼e mieÄ‡ wartoÅ›ci, Rust
przyjmuje, Å¼e typ <code>guess</code> to <code>u32</code>.</p>
<p>Formalny sposÃ³b opisu tego zachowania jest taki, Å¼e wyraÅ¼enia typu <code>!</code> mogÄ…
byÄ‡ konwertowane na dowolny inny typ. MoÅ¼emy zakoÅ„czyÄ‡ to ramiÄ™ <code>match</code> za
pomocÄ… <code>continue</code>, poniewaÅ¼ <code>continue</code> nie zwraca wartoÅ›ci; zamiast tego
przenosi sterowanie na poczÄ…tek pÄ™tli, wiÄ™c w przypadku <code>Err</code> nigdy nie
przypisujemy wartoÅ›ci do <code>guess</code>.</p>
<p>Typ nigdy jest rÃ³wnieÅ¼ przydatny z makrem <code>panic!</code>. Przypomnij sobie funkcjÄ™
<code>unwrap</code>, ktÃ³rÄ… wywoÅ‚ujemy na wartoÅ›ciach <code>Option&lt;T&gt;</code>, aby wyprodukowaÄ‡
wartoÅ›Ä‡ lub wywoÅ‚aÄ‡ panikÄ™, z nastÄ™pujÄ…cÄ… definicjÄ…:</p>
<pre><code class="language-rust ignore"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!("called `Option::unwrap()` on a `None` value"),
        }
    }
}</code></pre>
<p>W tym kodzie dzieje siÄ™ to samo, co w <code>match</code> w Listing 20-27: Rust widzi,
Å¼e <code>val</code> ma typ <code>T</code>, a <code>panic!</code> ma typ <code>!</code>, wiÄ™c wynikiem caÅ‚ego wyraÅ¼enia
<code>match</code> jest <code>T</code>. Ten kod dziaÅ‚a, poniewaÅ¼ <code>panic!</code> nie produkuje wartoÅ›ci;
koÅ„czy program. W przypadku <code>None</code> nie zwrÃ³cimy wartoÅ›ci z <code>unwrap</code>, wiÄ™c ten
kod jest poprawny.</p>
<p>Ostatnie wyraÅ¼enie, ktÃ³re ma typ <code>!</code>, to pÄ™tla:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    print!("forever ");

    loop {
        print!("and ever ");
    }
<span class="boring">}</span></code></pre>
<p>Tutaj pÄ™tla nigdy siÄ™ nie koÅ„czy, wiÄ™c <code>!</code> jest wartoÅ›ciÄ… wyraÅ¼enia. JednakÅ¼e,
nie byÅ‚oby to prawdÄ…, gdybyÅ›my dodali <code>break</code>, poniewaÅ¼ pÄ™tla zakoÅ„czyÅ‚aby siÄ™
wtedy, gdy doszÅ‚aby do <code>break</code>.</p>
<h3 id="typy-o-dynamicznym-rozmiarze-i-cecha-sized"><a class="header" href="#typy-o-dynamicznym-rozmiarze-i-cecha-sized">Typy o dynamicznym rozmiarze i cecha <code>Sized</code></a></h3>
<p>Rust musi znaÄ‡ pewne szczegÃ³Å‚y dotyczÄ…ce swoich typÃ³w, takie jak ile miejsca
przydzieliÄ‡ dla wartoÅ›ci konkretnego typu. To pozostawia jeden zakÄ…tek jego
systemu typÃ³w na poczÄ…tku nieco mylÄ…cy: koncepcjÄ™ <em>typÃ³w o dynamicznym
rozmiarze</em>. Czasami nazywane <em>DST</em> lub <em>typami bez rozmiaru</em>, te typy
umoÅ¼liwiajÄ… pisanie kodu z uÅ¼yciem wartoÅ›ci, ktÃ³rych rozmiar moÅ¼emy poznaÄ‡
tylko w czasie wykonania.</p>
<p>ZagÅ‚Ä™bmy siÄ™ w szczegÃ³Å‚y typu o dynamicznym rozmiarze o nazwie <code>str</code>, ktÃ³rego
uÅ¼ywaliÅ›my w caÅ‚ej ksiÄ…Å¼ce. Zgadza siÄ™, nie <code>&amp;str</code>, ale <code>str</code> sam w sobie,
jest DST. W wielu przypadkach, takich jak przechowywanie tekstu wprowadzonego
przez uÅ¼ytkownika, nie moÅ¼emy wiedzieÄ‡, jak dÅ‚ugi jest ciÄ…g, dopÃ³ki program
siÄ™ nie uruchomi. Oznacza to, Å¼e nie moÅ¼emy utworzyÄ‡ zmiennej typu <code>str</code>,
ani przyjÄ…Ä‡ argumentu typu <code>str</code>. RozwaÅ¼ poniÅ¼szy kod, ktÃ³ry nie dziaÅ‚a:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1: str = "Hello there!";
    let s2: str = "How's it going?";
<span class="boring">}</span></code></pre>
<p>Rust musi wiedzieÄ‡, ile pamiÄ™ci przydzieliÄ‡ dla kaÅ¼dej wartoÅ›ci danego typu,
i wszystkie wartoÅ›ci danego typu muszÄ… uÅ¼ywaÄ‡ tej samej iloÅ›ci pamiÄ™ci. Gdyby
Rust pozwoliÅ‚ nam napisaÄ‡ ten kod, te dwie wartoÅ›ci <code>str</code> musiaÅ‚yby zajmowaÄ‡
tÄ™ samÄ… iloÅ›Ä‡ miejsca. Ale majÄ… one rÃ³Å¼ne dÅ‚ugoÅ›ci: <code>s1</code> potrzebuje 12 bajtÃ³w
pamiÄ™ci, a <code>s2</code> potrzebuje 15. Dlatego nie jest moÅ¼liwe utworzenie zmiennej
przechowujÄ…cej typ o dynamicznym rozmiarze.</p>
<p>WiÄ™c co robimy? W tym przypadku znasz juÅ¼ odpowiedÅº: Zmieniamy typ <code>s1</code> i <code>s2</code>
na wycinek ciÄ…gu znakÃ³w (<code>&amp;str</code>), a nie <code>str</code>. Przypomnij sobie z sekcji
<a href="#string-slices">â€Wycinki ciÄ…gÃ³w znakÃ³wâ€</a><!-- ignore --> w Rozdziale 4,
Å¼e struktura danych wycinka przechowuje tylko pozycjÄ™ poczÄ…tkowÄ… i dÅ‚ugoÅ›Ä‡
wycinka. Zatem, chociaÅ¼ <code>&amp;T</code> jest pojedynczÄ… wartoÅ›ciÄ…, ktÃ³ra przechowuje
adres pamiÄ™ci, gdzie znajduje siÄ™ <code>T</code>, wycinek ciÄ…gu znakÃ³w to <em>dwie</em> wartoÅ›ci:
adres <code>str</code> i jego dÅ‚ugoÅ›Ä‡. W zwiÄ…zku z tym moÅ¼emy znaÄ‡ rozmiar wartoÅ›ci
wycinka ciÄ…gu znakÃ³w w czasie kompilacji: Jest to dwukrotnoÅ›Ä‡ dÅ‚ugoÅ›ci <code>usize</code>.
Oznacza to, Å¼e zawsze znamy rozmiar wycinka ciÄ…gu znakÃ³w, niezaleÅ¼nie od tego,
jak dÅ‚ugi jest ciÄ…g, do ktÃ³rego siÄ™ odnosi. OgÃ³lnie rzecz biorÄ…c, w ten sposÃ³b
uÅ¼ywa siÄ™ typÃ³w o dynamicznym rozmiarze w Rust: PosiadajÄ… dodatkowy bit
metadanych, ktÃ³ry przechowuje rozmiar dynamicznych informacji. ZÅ‚otÄ… zasadÄ…
typÃ³w o dynamicznym rozmiarze jest to, Å¼e zawsze musimy umieszczaÄ‡ wartoÅ›ci
typÃ³w o dynamicznym rozmiarze za wskaÅºnikiem jakiegoÅ› rodzaju.</p>
<p>MoÅ¼emy Å‚Ä…czyÄ‡ <code>str</code> z rÃ³Å¼nymi rodzajami wskaÅºnikÃ³w: na przykÅ‚ad <code>Box&lt;str&gt;</code> lub
<code>Rc&lt;str&gt;</code>. W rzeczywistoÅ›ci widziaÅ‚eÅ› to juÅ¼ wczeÅ›niej, ale z innym typem
o dynamicznym rozmiarze: cechami. KaÅ¼da cecha jest typem o dynamicznym
rozmiarze, do ktÃ³rego moÅ¼emy siÄ™ odwoÅ‚ywaÄ‡, uÅ¼ywajÄ…c nazwy cechy. W sekcji
<a href="#using-trait-objects-to-abstract-over-shared-behavior">â€UÅ¼ywanie obiektÃ³w cech do abstrakcji nad wspÃ³lnym
zachowaniemâ€</a><!--
ignore --> w Rozdziale 18 wspomnieliÅ›my, Å¼e aby uÅ¼ywaÄ‡ cech jako obiektÃ³w
cech, musimy umieÅ›ciÄ‡ je za wskaÅºnikiem, takim jak <code>&amp;dyn Trait</code> lub <code>Box&lt;dyn Trait&gt;</code>
(<code>Rc&lt;dyn Trait&gt;</code> rÃ³wnieÅ¼ by dziaÅ‚aÅ‚o).</p>
<p>Aby pracowaÄ‡ z DST, Rust udostÄ™pnia cechÄ™ <code>Sized</code>, aby okreÅ›liÄ‡, czy rozmiar
typu jest znany w czasie kompilacji. Ta cecha jest automatycznie
implementowana dla wszystkiego, czego rozmiar jest znany w czasie kompilacji.
Dodatkowo, Rust niejawnie dodaje ograniczenie na <code>Sized</code> do kaÅ¼dej funkcji
generycznej. Oznacza to, Å¼e definicja funkcji generycznej, taka jak ta:</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --snip--
}</code></pre>
<p>jest w rzeczywistoÅ›ci traktowana tak, jakbyÅ›my napisali to:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}</code></pre>
<p>DomyÅ›lnie funkcje generyczne bÄ™dÄ… dziaÅ‚aÄ‡ tylko na typach, ktÃ³re majÄ… znany
rozmiar w czasie kompilacji. MoÅ¼esz jednak uÅ¼yÄ‡ nastÄ™pujÄ…cej specjalnej
skÅ‚adni, aby zÅ‚agodziÄ‡ to ograniczenie:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}</code></pre>
<p>Ograniczenie cechy na <code>?Sized</code> oznacza â€<code>T</code> moÅ¼e, ale nie musi byÄ‡ <code>Sized</code>â€,
a ta notacja zastÄ™puje domyÅ›lnÄ… zasadÄ™, Å¼e typy generyczne muszÄ… mieÄ‡ znany
rozmiar w czasie kompilacji. SkÅ‚adnia <code>?Trait</code> z tym znaczeniem jest dostÄ™pna
tylko dla <code>Sized</code>, a nie dla Å¼adnych innych cech.</p>
<p>ZauwaÅ¼ rÃ³wnieÅ¼, Å¼e zmieniliÅ›my typ parametru <code>t</code> z <code>T</code> na <code>&amp;T</code>. PoniewaÅ¼ typ
moÅ¼e nie byÄ‡ <code>Sized</code>, musimy uÅ¼ywaÄ‡ go za wskaÅºnikiem jakiegoÅ› rodzaju. W tym
przypadku wybraliÅ›my referencjÄ™.</p>
<p>NastÄ™pnie porozmawiamy o funkcjach i domkniÄ™ciach!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="zaawansowane-funkcje-i-domkniÄ™cia-1"><a href="#zaawansowane-funkcje-i-domkniÄ™cia-1" class="header">Zaawansowane Funkcje i DomkniÄ™cia</a></h1>
<h2 id="zaawansowane-funkcje-i-domkniÄ™cia"><a class="header" href="#zaawansowane-funkcje-i-domkniÄ™cia">Zaawansowane Funkcje i DomkniÄ™cia</a></h2>
<p>Ta sekcja omawia niektÃ³re zaawansowane funkcje zwiÄ…zane z funkcjami i
domkniÄ™ciami, w tym wskaÅºniki na funkcje i zwracanie domkniÄ™Ä‡.</p>
<h3 id="wskaÅºniki-na-funkcje"><a class="header" href="#wskaÅºniki-na-funkcje">WskaÅºniki na Funkcje</a></h3>
<p>MÃ³wiliÅ›my o tym, jak przekazywaÄ‡ domkniÄ™cia do funkcji; moÅ¼esz rÃ³wnieÅ¼
przekazywaÄ‡ do funkcji zwykÅ‚e funkcje! Ta technika jest przydatna, gdy chcesz
przekazaÄ‡ funkcjÄ™, ktÃ³rÄ… juÅ¼ zdefiniowaÅ‚eÅ›, zamiast definiowaÄ‡ nowe domkniÄ™cie.
Funkcje konwertujÄ… siÄ™ do typu <code>fn</code> (z maÅ‚Ä… literÄ… <em>f</em>), nie myliÄ‡ z cechÄ…
domkniÄ™cia <code>Fn</code>. Typ <code>fn</code> nazywany jest <em>wskaÅºnikiem na funkcjÄ™</em>. Przekazywanie
funkcji za pomocÄ… wskaÅºnikÃ³w na funkcje umoÅ¼liwi ci uÅ¼ywanie funkcji jako
argumentÃ³w dla innych funkcji.</p>
<p>SkÅ‚adnia okreÅ›lania, Å¼e parametr jest wskaÅºnikiem na funkcjÄ™, jest podobna do
tej dla domkniÄ™Ä‡, jak pokazano w Listing 20-28, gdzie zdefiniowaliÅ›my funkcjÄ™
<code>add_one</code>, ktÃ³ra dodaje 1 do swojego parametru. Funkcja <code>do_twice</code> przyjmuje
dwa parametry: wskaÅºnik na funkcjÄ™ do dowolnej funkcji, ktÃ³ra przyjmuje
parametr <code>i32</code> i zwraca <code>i32</code>, oraz jednÄ… wartoÅ›Ä‡ <code>i32</code>. Funkcja <code>do_twice</code>
wywoÅ‚uje funkcjÄ™ <code>f</code> dwukrotnie, przekazujÄ…c jej wartoÅ›Ä‡ <code>arg</code>, a nastÄ™pnie
dodaje do siebie wyniki dwÃ³ch wywoÅ‚aÅ„ funkcji. Funkcja <code>main</code> wywoÅ‚uje
<code>do_twice</code> z argumentami <code>add_one</code> i <code>5</code>.</p>
<figure class="listing" id="listing-20-28">
<span class="file-name">Filename: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {answer}");
}</code></pre>
<figcaption><a href="#listing-20-28">Listing 20-28</a>: UÅ¼ycie typu <code>fn</code> do przyjÄ™cia wskaÅºnika na funkcjÄ™ jako argumentu</figcaption>
</figure>
<p>Ten kod wyÅ›wietla <code>The answer is: 12</code>. OkreÅ›lamy, Å¼e parametr <code>f</code> w <code>do_twice</code>
jest typu <code>fn</code>, ktÃ³ry przyjmuje jeden parametr typu <code>i32</code> i zwraca <code>i32</code>.
NastÄ™pnie moÅ¼emy wywoÅ‚aÄ‡ <code>f</code> w ciele <code>do_twice</code>. W <code>main</code> moÅ¼emy przekazaÄ‡
nazwÄ™ funkcji <code>add_one</code> jako pierwszy argument do <code>do_twice</code>.</p>
<p>W przeciwieÅ„stwie do domkniÄ™Ä‡, <code>fn</code> jest typem, a nie cechÄ…, wiÄ™c okreÅ›lamy <code>fn</code>
jako typ parametru bezpoÅ›rednio, zamiast deklarowaÄ‡ parametr typu generycznego
z jednÄ… z cech domkniÄ™Ä‡ jako ograniczeniem cechy.</p>
<p>WskaÅºniki na funkcje implementujÄ… wszystkie trzy cechy domkniÄ™Ä‡ (<code>Fn</code>, <code>FnMut</code>
i <code>FnOnce</code>), co oznacza, Å¼e zawsze moÅ¼esz przekazaÄ‡ wskaÅºnik na funkcjÄ™ jako
argument do funkcji, ktÃ³ra oczekuje domkniÄ™cia. Najlepiej jest pisaÄ‡ funkcje,
uÅ¼ywajÄ…c typu generycznego i jednej z cech domkniÄ™Ä‡, aby twoje funkcje mogÅ‚y
przyjmowaÄ‡ zarÃ³wno funkcje, jak i domkniÄ™cia.</p>
<p>JednakÅ¼e, jednym z przykÅ‚adÃ³w, gdzie chciaÅ‚byÅ› akceptowaÄ‡ tylko <code>fn</code>, a nie
domkniÄ™cia, jest interakcja z zewnÄ™trznym kodem, ktÃ³ry nie ma domkniÄ™Ä‡: Funkcje
w C mogÄ… przyjmowaÄ‡ funkcje jako argumenty, ale C nie ma domkniÄ™Ä‡.</p>
<p>Jako przykÅ‚ad, gdzie moÅ¼na by uÅ¼yÄ‡ zarÃ³wno domkniÄ™cia zdefiniowanego inline,
jak i nazwanej funkcji, przyjrzyjmy siÄ™ zastosowaniu metody <code>map</code> dostarczonej
przez cechÄ™ <code>Iterator</code> w standardowej bibliotece. Aby uÅ¼yÄ‡ metody <code>map</code> do
przeksztaÅ‚cenia wektora liczb w wektor ciÄ…gÃ³w znakÃ³w, moglibyÅ›my uÅ¼yÄ‡
domkniÄ™cia, jak w Listing 20-29.</p>
<figure class="listing" id="listing-20-29">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-20-29">Listing 20-29</a>: UÅ¼ycie domkniÄ™cia z metodÄ… <code>map</code> do konwersji liczb na ciÄ…gi znakÃ³w</figcaption>
</figure>
<p>Albo moglibyÅ›my nazwaÄ‡ funkcjÄ™ jako argument do <code>map</code> zamiast domkniÄ™cia.
Listing 20-30 pokazuje, jak by to wyglÄ…daÅ‚o.</p>
<figure class="listing" id="listing-20-30">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(ToString::to_string).collect();
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-20-30">Listing 20-30</a>: UÅ¼ycie funkcji <code>String::to_string</code> z metodÄ… <code>map</code> do konwersji liczb na ciÄ…gi znakÃ³w</figcaption>
</figure>
<p>ZauwaÅ¼, Å¼e musimy uÅ¼yÄ‡ w peÅ‚ni kwalifikowanej skÅ‚adni, o ktÃ³rej mÃ³wiliÅ›my w
sekcji <a href="#advanced-traits">â€Zaawansowane Cechyâ€</a><!-- ignore -->, poniewaÅ¼
istnieje wiele dostÄ™pnych funkcji o nazwie <code>to_string</code>.</p>
<p>Tutaj uÅ¼ywamy funkcji <code>to_string</code> zdefiniowanej w cesze <code>ToString</code>, ktÃ³rÄ…
standardowa biblioteka zaimplementowaÅ‚a dla kaÅ¼dego typu, ktÃ³ry implementuje
<code>Display</code>.</p>
<p>Przypomnij sobie z sekcji <a href="#enum-values">â€WartoÅ›ci enumâ€</a><!-- ignore --> w
Rozdziale 6, Å¼e nazwa kaÅ¼dego wariantu enum, ktÃ³ry definiujemy, staje siÄ™ takÅ¼e
funkcjÄ… inicjalizujÄ…cÄ…. MoÅ¼emy uÅ¼ywaÄ‡ tych funkcji inicjalizujÄ…cych jako
wskaÅºnikÃ³w na funkcje, ktÃ³re implementujÄ… cechy domkniÄ™Ä‡, co oznacza, Å¼e
moÅ¼emy okreÅ›laÄ‡ funkcje inicjalizujÄ…ce jako argumenty dla metod, ktÃ³re przyjmujÄ…
domkniÄ™cia, jak pokazano w Listing 20-31.</p>
<figure class="listing" id="listing-20-31">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-20-31">Listing 20-31</a>: UÅ¼ycie inicjalizatora enum z metodÄ… <code>map</code> do tworzenia instancji <code>Status</code> z liczb</figcaption>
</figure>
<p>Tutaj tworzymy instancje <code>Status::Value</code> uÅ¼ywajÄ…c kaÅ¼dej wartoÅ›ci <code>u32</code> w
zakresie, na ktÃ³rym wywoÅ‚ano <code>map</code>, poprzez uÅ¼ycie funkcji inicjalizujÄ…cej
<code>Status::Value</code>. NiektÃ³rzy wolÄ… ten styl, a inni wolÄ… uÅ¼ywaÄ‡ domkniÄ™Ä‡.
KompilujÄ… siÄ™ one do tego samego kodu, wiÄ™c uÅ¼ywaj stylu, ktÃ³ry jest dla ciebie
jaÅ›niejszy.</p>
<h3 id="zwracanie-domkniÄ™Ä‡"><a class="header" href="#zwracanie-domkniÄ™Ä‡">Zwracanie DomkniÄ™Ä‡</a></h3>
<p>DomkniÄ™cia sÄ… reprezentowane przez cechy, co oznacza, Å¼e nie moÅ¼na zwracaÄ‡
domkniÄ™Ä‡ bezpoÅ›rednio. W wiÄ™kszoÅ›ci przypadkÃ³w, gdy chcesz zwrÃ³ciÄ‡ cechÄ™,
moÅ¼esz zamiast tego uÅ¼yÄ‡ konkretnego typu, ktÃ³ry implementuje tÄ™ cechÄ™, jako
wartoÅ›ci zwracanej funkcji. JednakÅ¼e, zazwyczaj nie moÅ¼esz tego zrobiÄ‡ z
domkniÄ™ciami, poniewaÅ¼ nie majÄ… one konkretnego typu, ktÃ³ry moÅ¼na zwrÃ³ciÄ‡;
nie wolno uÅ¼ywaÄ‡ wskaÅºnika na funkcjÄ™ <code>fn</code> jako typu zwracanego, jeÅ›li
domkniÄ™cie przechwytuje jakiekolwiek wartoÅ›ci ze swojego zasiÄ™gu, na przykÅ‚ad.</p>
<p>Zamiast tego, zazwyczaj bÄ™dziesz uÅ¼ywaÄ‡ skÅ‚adni <code>impl Trait</code>, ktÃ³rÄ… poznaliÅ›my
w Rozdziale 10. MoÅ¼esz zwracaÄ‡ dowolny typ funkcji, uÅ¼ywajÄ…c <code>Fn</code>, <code>FnOnce</code>
i <code>FnMut</code>. Na przykÅ‚ad, kod z Listing 20-32 skompiluje siÄ™ bez problemu.</p>
<figure class="listing" id="listing-20-32">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-20-32">Listing 20-32</a>: Zwracanie domkniÄ™cia z funkcji przy uÅ¼yciu skÅ‚adni <code>impl Trait</code></figcaption>
</figure>
<p>JednakÅ¼e, jak zauwaÅ¼yliÅ›my w sekcji <a href="#closure-type-inference-and-annotation">â€Wnioskowanie i adnotacje typÃ³w
domkniÄ™Ä‡â€</a><!-- ignore --> w Rozdziale 13, kaÅ¼de domkniÄ™cie
jest rÃ³wnieÅ¼ swoim wÅ‚asnym, odrÄ™bnym typem. JeÅ›li musisz pracowaÄ‡ z wieloma
funkcjami, ktÃ³re majÄ… tÄ™ samÄ… sygnaturÄ™, ale rÃ³Å¼ne implementacje, bÄ™dziesz
musiaÅ‚ uÅ¼yÄ‡ dla nich obiektu cechy. RozwaÅ¼, co siÄ™ stanie, jeÅ›li napiszesz
kod taki jak pokazano w Listing 20-33.</p>
<figure class="listing" id="listing-20-33">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let handlers = vec![returns_closure(), returns_initialized_closure(123)];
    for handler in handlers {
        let output = handler(5);
        println!("{output}");
    }
}

fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}

fn returns_initialized_closure(init: i32) -&gt; impl Fn(i32) -&gt; i32 {
    move |x| x + init
}</code></pre>
<figcaption><a href="#listing-20-33">Listing 20-33</a>: Tworzenie <code>Vec&lt;T&gt;</code> domkniÄ™Ä‡ zdefiniowanych przez funkcje, ktÃ³re zwracajÄ… typy <code>impl Fn</code></figcaption>
</figure>
<p>W tym miejscu mamy dwie funkcje, <code>returns_closure</code> i <code>returns_initialized_closure</code>,
ktÃ³re obie zwracajÄ… <code>impl Fn(i32) -&gt; i32</code>. ZauwaÅ¼, Å¼e domkniÄ™cia, ktÃ³re zwracajÄ…,
sÄ… rÃ³Å¼ne, mimo Å¼e implementujÄ… tÄ™ samÄ… cechÄ™. JeÅ›li sprÃ³bujemy to skompilowaÄ‡,
Rust poinformuje nas, Å¼e to nie zadziaÅ‚a:</p>
<pre><code class="language-text">$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
error[E0308]: mismatched types
  --&gt; src/main.rs:2:44
   |
 2 |     let handlers = vec![returns_closure(), returns_initialized_closure(123)];
   |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected opaque type, found a different opaque type
...
 9 | fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
   |                         ------------------- the expected opaque type
...
13 | fn returns_initialized_closure(init: i32) -&gt; impl Fn(i32) -&gt; i32 {
   |                                              ------------------- the found opaque type
   |
   = note: expected opaque type `impl Fn(i32) -&gt; i32`
              found opaque type `impl Fn(i32) -&gt; i32`
   = note: distinct uses of `impl Trait` result in different opaque types

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions-example` (bin "functions-example") due to 1 previous error
</code></pre>
<p>Komunikat o bÅ‚Ä™dzie informuje nas, Å¼e za kaÅ¼dym razem, gdy zwracamy <code>impl Trait</code>,
Rust tworzy unikalny <em>typ nieprzezroczysty</em> â€“ typ, w ktÃ³rego szczegÃ³Å‚y tego,
co Rust dla nas konstruuje, nie moÅ¼emy wniknÄ…Ä‡, ani nie moÅ¼emy odgadnÄ…Ä‡
typu, ktÃ³ry Rust wygeneruje, aby samemu go napisaÄ‡. Zatem, mimo Å¼e te funkcje
zwracajÄ… domkniÄ™cia, ktÃ³re implementujÄ… tÄ™ samÄ… cechÄ™, <code>Fn(i32) -&gt; i32</code>,
nieprzezroczyste typy, ktÃ³re Rust generuje dla kaÅ¼dego z nich, sÄ… odrÄ™bne.
(Jest to podobne do tego, jak Rust produkuje rÃ³Å¼ne konkretne typy dla
rÃ³Å¼nych blokÃ³w async, nawet jeÅ›li majÄ… ten sam typ wyjÅ›ciowy, jak widzieliÅ›my
w <a href="#praca-z-dowolnÄ…-liczbÄ…-futures">â€Typ <code>Pin</code> i cecha <code>Unpin</code>â€</a><!-- ignore --> w Rozdziale 17.)
RozwiÄ…zanie tego problemu widzieliÅ›my juÅ¼ kilkakrotnie: MoÅ¼emy uÅ¼yÄ‡ obiektu
cechy, jak w Listing 20-34.</p>
<figure class="listing" id="listing-20-34">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let handlers = vec![returns_closure(), returns_initialized_closure(123)];
</span><span class="boring">    for handler in handlers {
</span><span class="boring">        let output = handler(5);
</span><span class="boring">        println!("{output}");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}

fn returns_initialized_closure(init: i32) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(move |x| x + init)
}</code></pre>
<figcaption><a href="#listing-20-34">Listing 20-34</a>: Tworzenie <code>Vec&lt;T&gt;</code> domkniÄ™Ä‡ zdefiniowanych przez funkcje, ktÃ³re zwracajÄ… <code>Box&lt;dyn Fn&gt;</code>, tak aby miaÅ‚y ten sam typ</figcaption>
</figure>
<p>Ten kod skompiluje siÄ™ bez problemu. WiÄ™cej informacji na temat obiektÃ³w
cech znajdziesz w sekcji <a href="#uÅ¼ywanie-obiektÃ³w-trait-do-abstrakcji-nad-wspÃ³lnym-zachowaniem-1">â€UÅ¼ywanie obiektÃ³w cech do abstrakcji nad wspÃ³lnym
zachowaniemâ€</a><!-- ignore --> w Rozdziale 18.</p>
<p>NastÄ™pnie przyjrzyjmy siÄ™ makrom!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="makra-1"><a href="#makra-1" class="header">Makra</a></h1>
<h2 id="makra"><a class="header" href="#makra">Makra</a></h2>
<p>Makr takich jak <code>println!</code> uÅ¼ywaliÅ›my w caÅ‚ej ksiÄ…Å¼ce, ale nie zbadaliÅ›my
jeszcze w peÅ‚ni, czym jest makro i jak dziaÅ‚a. Termin <em>makro</em> odnosi siÄ™ do
rodziny funkcji w Rustâ€”makra deklaratywne z <code>macro_rules!</code> oraz trzy rodzaje
makr proceduralnych:</p>
<ul>
<li>Niestandardowe makra <code>#[derive]</code>, ktÃ³re okreÅ›lajÄ… kod dodany za pomocÄ…
atrybutu <code>derive</code> uÅ¼ywanego w strukturach i enumach</li>
<li>Makra podobne do atrybutÃ³w, ktÃ³re definiujÄ… niestandardowe atrybuty moÅ¼liwe
do uÅ¼ycia z dowolnym elementem</li>
<li>Makra podobne do funkcji, ktÃ³re wyglÄ…dajÄ… jak wywoÅ‚ania funkcji, ale
operujÄ… na tokenach okreÅ›lonych jako ich argument</li>
</ul>
<p>BÄ™dziemy mÃ³wiÄ‡ o kaÅ¼dym z nich po kolei, ale najpierw przyjrzyjmy siÄ™,
dlaczego w ogÃ³le potrzebujemy makr, skoro mamy juÅ¼ funkcje.</p>
<h3 id="rÃ³Å¼nica-miÄ™dzy-makrami-a-funkcjami"><a class="header" href="#rÃ³Å¼nica-miÄ™dzy-makrami-a-funkcjami">RÃ³Å¼nica miÄ™dzy makrami a funkcjami</a></h3>
<p>Zasadniczo, makra to sposÃ³b pisania kodu, ktÃ³ry pisze inny kod, co jest znane
jako <em>metaprogramowanie</em>. W Dodatku C omawiamy atrybut <code>derive</code>, ktÃ³ry
generuje implementacjÄ™ rÃ³Å¼nych cech dla ciebie. UÅ¼ywaliÅ›my rÃ³wnieÅ¼ makr
<code>println!</code> i <code>vec!</code> w caÅ‚ej ksiÄ…Å¼ce. Wszystkie te makra <em>rozszerzajÄ… siÄ™</em>,
aby wyprodukowaÄ‡ wiÄ™cej kodu niÅ¼ ten, ktÃ³ry napisaÅ‚eÅ› rÄ™cznie.</p>
<p>Metaprogramowanie jest przydatne do zmniejszania iloÅ›ci kodu, ktÃ³ry musisz
napisaÄ‡ i utrzymaÄ‡, co jest rÃ³wnieÅ¼ jednÄ… z rÃ³l funkcji. Jednak makra majÄ…
pewne dodatkowe moce, ktÃ³rych funkcje nie majÄ….</p>
<p>Sygnatura funkcji musi deklarowaÄ‡ liczbÄ™ i typ parametrÃ³w, ktÃ³re funkcja
posiada. Makra natomiast mogÄ… przyjmowaÄ‡ zmiennÄ… liczbÄ™ parametrÃ³w: MoÅ¼emy
wywoÅ‚aÄ‡ <code>println!("hello")</code> z jednym argumentem lub <code>println!("hello {}", name)</code>
z dwoma argumentami. Ponadto, makra sÄ… rozszerzane zanim kompilator zinterpretuje
znaczenie kodu, wiÄ™c makro moÅ¼e na przykÅ‚ad zaimplementowaÄ‡ cechÄ™ na danym
typie. Funkcja tego nie moÅ¼e, poniewaÅ¼ jest wywoÅ‚ywana w czasie wykonania, a
cecha musi byÄ‡ zaimplementowana w czasie kompilacji.</p>
<p>WadÄ… implementacji makra zamiast funkcji jest to, Å¼e definicje makr sÄ…
bardziej zÅ‚oÅ¼one niÅ¼ definicje funkcji, poniewaÅ¼ piszesz kod Rust, ktÃ³ry
pisze kod Rust. Z powodu tej poÅ›rednioÅ›ci, definicje makr sÄ… zazwyczaj
trudniejsze do czytania, zrozumienia i utrzymania niÅ¼ definicje funkcji.</p>
<p>InnÄ… waÅ¼nÄ… rÃ³Å¼nicÄ… miÄ™dzy makrami a funkcjami jest to, Å¼e musisz definiowaÄ‡
makra lub wprowadzaÄ‡ je do zasiÄ™gu <em>przed</em> ich wywoÅ‚aniem w pliku, w
przeciwieÅ„stwie do funkcji, ktÃ³re moÅ¼esz zdefiniowaÄ‡ i wywoÅ‚aÄ‡ w dowolnym
miejscu.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="declarative-macros-with-macro_rules-for-general-metaprogramming"></a></p>
<h3 id="makra-deklaratywne-do-ogÃ³lnego-metaprogramowania"><a class="header" href="#makra-deklaratywne-do-ogÃ³lnego-metaprogramowania">Makra deklaratywne do ogÃ³lnego metaprogramowania</a></h3>
<p>NajczÄ™Å›ciej uÅ¼ywanÄ… formÄ… makr w Rust sÄ… <em>makra deklaratywne</em>. Czasami sÄ…
rÃ³wnieÅ¼ nazywane â€makrami na przykÅ‚adachâ€, â€makrami <code>macro_rules!</code>â€ lub po
prostu â€makramiâ€. W swej istocie makra deklaratywne pozwalajÄ… na pisanie
codÅ› podobnego do wyraÅ¼enia <code>match</code> w Rust. Jak omÃ³wiono w Rozdziale 6,
wyraÅ¼enia <code>match</code> sÄ… strukturami kontrolnymi, ktÃ³re przyjmujÄ… wyraÅ¼enie,
porÃ³wnujÄ… wynikowÄ… wartoÅ›Ä‡ wyraÅ¼enia z wzorcami, a nastÄ™pnie uruchamiajÄ… kod
skojarzony z pasujÄ…cym wzorcem. Makra rÃ³wnieÅ¼ porÃ³wnujÄ… wartoÅ›Ä‡ z wzorcami,
ktÃ³re sÄ… skojarzone z konkretnym kodem: w tej sytuacji wartoÅ›ciÄ… jest literaÅ‚
kodu ÅºrÃ³dÅ‚owego Rust przekazany do makra; wzorce sÄ… porÃ³wnywane ze strukturÄ…
tego kodu ÅºrÃ³dÅ‚owego; a kod skojarzony z kaÅ¼dym wzorcem, gdy zostanie dopasowany,
zastÄ™puje kod przekazany do makra. Wszystko to dzieje siÄ™ podczas kompilacji.</p>
<p>Aby zdefiniowaÄ‡ makro, uÅ¼ywasz konstrukcji <code>macro_rules!</code>. Zbadajmy, jak uÅ¼ywaÄ‡
<code>macro_rules!</code>, przyglÄ…dajÄ…c siÄ™, jak zdefiniowane jest makro <code>vec!</code>. RozdziaÅ‚ 8
omÃ³wiÅ‚, jak moÅ¼emy uÅ¼ywaÄ‡ makra <code>vec!</code> do tworzenia nowego wektora z
konkretnymi wartoÅ›ciami. Na przykÅ‚ad, poniÅ¼sze makro tworzy nowy wektor
zawierajÄ…cy trzy liczby caÅ‚kowite:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}</span></code></pre>
<p>MoglibyÅ›my rÃ³wnieÅ¼ uÅ¼yÄ‡ makra <code>vec!</code>, aby stworzyÄ‡ wektor dwÃ³ch liczb
caÅ‚kowitych lub wektor piÄ™ciu wycinkÃ³w ciÄ…gÃ³w znakÃ³w. Nie bylibyÅ›my w stanie
uÅ¼yÄ‡ funkcji do wykonania tego samego, poniewaÅ¼ nie znalibyÅ›my liczby ani
typu wartoÅ›ci z gÃ³ry.</p>
<p>Listing 20-35 pokazuje nieco uproszczonÄ… definicjÄ™ makra <code>vec!</code>.</p>
<figure class="listing" id="listing-20-35">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}</code></pre>
<figcaption><a href="#listing-20-35">Listing 20-35</a>: Uproszczona wersja definicji makra <code>vec!</code></figcaption>
</figure>
<section class="note" aria-role="note">
<p>Uwaga: Rzeczywista definicja makra <code>vec!</code> w standardowej bibliotece zawiera
kod do wczeÅ›niejszego przydzielania odpowiedniej iloÅ›ci pamiÄ™ci. Ten kod
jest optymalizacjÄ…, ktÃ³rej tutaj nie uwzglÄ™dniamy, aby przykÅ‚ad byÅ‚ prostszy.</p>
</section>
<p>Adnotacja <code>#[macro_export]</code> wskazuje, Å¼e to makro powinno byÄ‡ dostÄ™pne
zawsze, gdy pakiet, w ktÃ³rym makro jest zdefiniowane, zostanie wprowadzony do
zasiÄ™gu. Bez tej adnotacji makro nie moÅ¼e zostaÄ‡ wprowadzone do zasiÄ™gu.</p>
<p>NastÄ™pnie rozpoczynamy definicjÄ™ makra od <code>macro_rules!</code> i nazwy definiowanego
makra <em>bez</em> wykrzyknika. Nazwa, w tym przypadku <code>vec</code>, jest poprzedzona
nawiasami klamrowymi oznaczajÄ…cymi ciaÅ‚o definicji makra.</p>
<p>Struktura w ciele <code>vec!</code> jest podobna do struktury wyraÅ¼enia <code>match</code>. Tutaj
mamy jedno ramiÄ™ ze wzorcem <code>( $( $x:expr ),* )</code>, po ktÃ³rym nastÄ™puje <code>=&gt;</code>
i blok kodu skojarzony z tym wzorcem. JeÅ›li wzorzec pasuje, skojarzony blok
kodu zostanie wygenerowany. BiorÄ…c pod uwagÄ™, Å¼e jest to jedyny wzorzec w tym
makrze, istnieje tylko jeden prawidÅ‚owy sposÃ³b dopasowania; kaÅ¼dy inny wzorzec
spowoduje bÅ‚Ä…d. Bardziej zÅ‚oÅ¼one makra bÄ™dÄ… miaÅ‚y wiÄ™cej niÅ¼ jedno ramiÄ™.</p>
<p>Poprawna skÅ‚adnia wzorcÃ³w w definicjach makr rÃ³Å¼ni siÄ™ od skÅ‚adni wzorcÃ³w
omÃ³wionej w Rozdziale 19, poniewaÅ¼ wzorce makr sÄ… dopasowywane do struktury
kodu Rust, a nie do wartoÅ›ci. PrzejdÅºmy przez to, co oznaczajÄ… fragmenty wzorcÃ³w
w Listing 20-29; peÅ‚nÄ… skÅ‚adniÄ™ wzorcÃ³w makr znajdziesz w <a href="../reference/macros-by-example.html">Referencjach
Rust</a>.</p>
<p>Najpierw uÅ¼ywamy zestawu nawiasÃ³w do objÄ™cia caÅ‚ego wzorca. UÅ¼ywamy znaku
dolara (<code>$</code>), aby zadeklarowaÄ‡ zmiennÄ… w systemie makr, ktÃ³ra bÄ™dzie
zawieraÄ‡ kod Rust pasujÄ…cy do wzorca. Znak dolara jasno wskazuje, Å¼e jest to
zmienna makra, w przeciwieÅ„stwie do zwykÅ‚ej zmiennej Rust. NastÄ™pnie nastÄ™puje
zestaw nawiasÃ³w, ktÃ³ry przechwytuje wartoÅ›ci pasujÄ…ce do wzorca w nawiasach
do wykorzystania w kodzie zastÄ™pujÄ…cym. WewnÄ…trz <code>$()</code> znajduje siÄ™ <code>$x:expr</code>,
ktÃ³ry pasuje do dowolnego wyraÅ¼enia Rust i nadaje wyraÅ¼eniu nazwÄ™ <code>$x</code>.</p>
<p>Przecinek po <code>$()</code> wskazuje, Å¼e dosÅ‚owny znak separatora przecinka musi
powtarzaÄ‡ siÄ™ miÄ™dzy kaÅ¼dÄ… instancjÄ… kodu, ktÃ³ry pasuje do kodu w <code>$()</code>.
Gwiazdka <code>*</code> okreÅ›la, Å¼e wzorzec pasuje do zera lub wiÄ™cej elementÃ³w
poprzedzajÄ…cych <code>*</code>.</p>
<p>Kiedy wywoÅ‚ujemy to makro za pomocÄ… <code>vec![1, 2, 3];</code>, wzorzec <code>$x</code> pasuje
trzy razy do trzech wyraÅ¼eÅ„ <code>1</code>, <code>2</code> i <code>3</code>.</p>
<p>Teraz przyjrzyjmy siÄ™ wzorcowi w ciele kodu skojarzonego z tym ramieniem:
<code>temp_vec.push()</code> w <code>$()*</code> jest generowane dla kaÅ¼dej czÄ™Å›ci, ktÃ³ra pasuje
do <code>$()</code> we wzorcu zero lub wiÄ™cej razy, w zaleÅ¼noÅ›ci od tego, ile razy wzorzec
pasuje. <code>$x</code> jest zastÄ™powane kaÅ¼dym pasujÄ…cym wyraÅ¼eniem. Kiedy wywoÅ‚ujemy
to makro za pomocÄ… <code>vec![1, 2, 3];</code>, wygenerowany kod, ktÃ³ry zastÄ™puje to
wywoÅ‚anie makra, bÄ™dzie nastÄ™pujÄ…cy:</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}</code></pre>
<p>ZdefiniowaliÅ›my makro, ktÃ³re moÅ¼e przyjmowaÄ‡ dowolnÄ… liczbÄ™ argumentÃ³w dowolnego
typu i generowaÄ‡ kod do tworzenia wektora zawierajÄ…cego okreÅ›lone elementy.</p>
<p>Aby dowiedzieÄ‡ siÄ™ wiÄ™cej o tym, jak pisaÄ‡ makra, zajrzyj do dokumentacji
online lub innych zasobÃ³w, takich jak <a href="https://veykril.github.io/tlborm/">â€The Little Book of Rust Macrosâ€</a>
rozpoczÄ™ta przez Daniela Keepa i kontynuowana przez Lukasa Wirtha.</p>
<h3 id="makra-proceduralne-do-generowania-kodu-z-atrybutÃ³w"><a class="header" href="#makra-proceduralne-do-generowania-kodu-z-atrybutÃ³w">Makra proceduralne do generowania kodu z atrybutÃ³w</a></h3>
<p>Druga forma makr to makro proceduralne, ktÃ³re dziaÅ‚a bardziej jak funkcja
(i jest rodzajem procedury). <em>Makra proceduralne</em> przyjmujÄ… pewien kod jako
wejÅ›cie, operujÄ… na tym kodzie i produkujÄ… pewien kod jako wyjÅ›cie, zamiast
dopasowywaÄ‡ siÄ™ do wzorcÃ³w i zastÄ™powaÄ‡ kod innym kodem, jak to robiÄ… makra
deklaratywne. Trzy rodzaje makr proceduralnych to niestandardowe <code>derive</code>,
podobne do atrybutÃ³w i podobne do funkcji, a wszystkie dziaÅ‚ajÄ… w podobny
sposÃ³b.</p>
<p>Podczas tworzenia makr proceduralnych definicje muszÄ… znajdowaÄ‡ siÄ™ we
wÅ‚asnym pakiecie ze specjalnym typem pakietu. Wynika to ze zÅ‚oÅ¼onych przyczyn
technicznych, ktÃ³re mamy nadziejÄ™ wyeliminowaÄ‡ w przyszÅ‚oÅ›ci. W Listing 20-36
pokazujemy, jak zdefiniowaÄ‡ makro proceduralne, gdzie <code>some_attribute</code> jest
zastÄ™pcÄ… dla uÅ¼ycia konkretnej odmiany makra.</p>
<figure class="listing" id="listing-20-36">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust ignore">use proc_macro::TokenStream;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}</code></pre>
<figcaption><a href="#listing-20-36">Listing 20-36</a>: PrzykÅ‚ad definiowania makra proceduralnego</figcaption>
</figure>
<p>Funkcja, ktÃ³ra definiuje makro proceduralne, przyjmuje <code>TokenStream</code> jako
wejÅ›cie i produkuje <code>TokenStream</code> jako wyjÅ›cie. Typ <code>TokenStream</code> jest
zdefiniowany przez pakiet <code>proc_macro</code>, ktÃ³ry jest doÅ‚Ä…czony do Rust i
reprezentuje sekwencjÄ™ tokenÃ³w. To jest rdzeÅ„ makra: Kod ÅºrÃ³dÅ‚owy, na ktÃ³rym
makro operuje, tworzy wejÅ›ciowy <code>TokenStream</code>, a kod, ktÃ³ry makro produkuje,
jest wyjÅ›ciowym <code>TokenStream</code>. Funkcja posiada rÃ³wnieÅ¼ doÅ‚Ä…czony atrybut,
ktÃ³ry okreÅ›la, jaki rodzaj makra proceduralnego tworzymy. MoÅ¼emy mieÄ‡ wiele
rodzajÃ³w makr proceduralnych w tym samym pakiecie.</p>
<p>Przyjrzyjmy siÄ™ rÃ³Å¼nym rodzajom makr proceduralnych. Zaczniemy od niestandardowego
makra <code>derive</code>, a nastÄ™pnie wyjaÅ›nimy maÅ‚e rÃ³Å¼nice, ktÃ³re sprawiajÄ…, Å¼e
inne formy sÄ… odmienne.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="how-to-write-a-custom-derive-macro"></a></p>
<h3 id="niestandardowe-makra-derive"><a class="header" href="#niestandardowe-makra-derive">Niestandardowe makra <code>derive</code></a></h3>
<p>StwÃ³rzmy pakiet o nazwie <code>hello_macro</code>, ktÃ³ry definiuje cechÄ™ nazwanÄ…
<code>HelloMacro</code> z jednÄ… skojarzonÄ… funkcjÄ… nazwanÄ… <code>hello_macro</code>. Zamiast
wymagaÄ‡ od naszych uÅ¼ytkownikÃ³w implementowania cechy <code>HelloMacro</code> dla kaÅ¼dego
z ich typÃ³w, dostarczymy makro proceduralne, aby uÅ¼ytkownicy mogli opatrzyÄ‡
swÃ³j typ adnotacjÄ… <code>#[derive(HelloMacro)]</code>, aby uzyskaÄ‡ domyÅ›lnÄ…
implementacjÄ™ funkcji <code>hello_macro</code>. DomyÅ›lna implementacja wyÅ›wietli
<code>Hello, Macro! My name is TypeName!</code>, gdzie <code>TypeName</code> to nazwa typu, na
ktÃ³rym ta cecha zostaÅ‚a zdefiniowana. Innymi sÅ‚owy, napiszemy pakiet, ktÃ³ry
umoÅ¼liwi innemu programiÅ›cie napisanie kodu takiego jak w Listing 20-37
przy uÅ¼yciu naszego pakietu.</p>
<figure class="listing" id="listing-20-37">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<figcaption><a href="#listing-20-37">Listing 20-37</a>: Kod, ktÃ³ry uÅ¼ytkownik naszego pakietu bÄ™dzie mÃ³gÅ‚ napisaÄ‡, uÅ¼ywajÄ…c naszego makra proceduralnego</figcaption>
</figure>
<p>Ten kod wyÅ›wietli <code>Hello, Macro! My name is Pancakes!</code> po zakoÅ„czeniu. Pierwszym
krokiem jest stworzenie nowego pakietu bibliotecznego w ten sposÃ³b:</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<p>NastÄ™pnie, w Listing 20-38, zdefiniujemy cechÄ™ <code>HelloMacro</code> i jej skojarzonÄ…
funkcjÄ™.</p>
<figure class="listing" id="listing-20-38">
<span class="file-name">Filename: src/lib.rs</span>
<pre><code class="language-rust noplayground">pub trait HelloMacro {
    fn hello_macro();
}</code></pre>
<figcaption><a href="#listing-20-38">Listing 20-38</a>: Prosta cecha, ktÃ³rej bÄ™dziemy uÅ¼ywaÄ‡ z makrem <code>derive</code></figcaption>
</figure>
<p>Mamy cechÄ™ i jej funkcjÄ™. W tym momencie uÅ¼ytkownik naszego pakietu mÃ³gÅ‚by
implementowaÄ‡ cechÄ™, aby osiÄ…gnÄ…Ä‡ poÅ¼Ä…danÄ… funkcjonalnoÅ›Ä‡, jak w Listing 20-39.</p>
<figure class="listing" id="listing-20-39">
<span class="file-name">Filename: src/main.rs</span>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!("Hello, Macro! My name is Pancakes!");
    }
}

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<figcaption><a href="#listing-20-39">Listing 20-39</a>: Jak by to wyglÄ…daÅ‚o, gdyby uÅ¼ytkownicy napisali rÄ™cznÄ… implementacjÄ™ cechy <code>HelloMacro</code></figcaption>
</figure>
<p>Jednak musieliby napisaÄ‡ blok implementacji dla kaÅ¼dego typu, ktÃ³rego chcieliby
uÅ¼yÄ‡ z <code>hello_macro</code>; chcemy ich oszczÄ™dziÄ‡ tego wysiÅ‚ku.</p>
<p>Dodatkowo, nie moÅ¼emy jeszcze dostarczyÄ‡ funkcji <code>hello_macro</code> z domyÅ›lnÄ…
implementacjÄ…, ktÃ³ra wyÅ›wietli nazwÄ™ typu, na ktÃ³rym zaimplementowano cechÄ™:
Rust nie posiada moÅ¼liwoÅ›ci refleksji, wiÄ™c nie moÅ¼e odczytaÄ‡ nazwy typu w
czasie wykonania. Potrzebujemy makra do generowania kodu w czasie kompilacji.</p>
<p>NastÄ™pnym krokiem jest zdefiniowanie makra proceduralnego. W chwili pisania
tego tekstu makra proceduralne muszÄ… znajdowaÄ‡ siÄ™ we wÅ‚asnym pakiecie.
Ostatecznie to ograniczenie moÅ¼e zostaÄ‡ zniesione. Konwencja strukturyzowania
pakietÃ³w i pakietÃ³w makr jest nastÄ™pujÄ…ca: Dla pakietu o nazwie <code>foo</code>,
pakiet makra proceduralnego <code>derive</code> nazywa siÄ™ <code>foo_derive</code>. StwÃ³rzmy nowy
pakiet o nazwie <code>hello_macro_derive</code> w projekcie <code>hello_macro</code>:</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<p>Nasze dwa pakiety sÄ… Å›ciÅ›le powiÄ…zane, dlatego tworzymy pakiet makra
proceduralnego w katalogu naszego pakietu <code>hello_macro</code>. JeÅ›li zmienimy
definicjÄ™ cechy w <code>hello_macro</code>, bÄ™dziemy musieli rÃ³wnieÅ¼ zmieniÄ‡ implementacjÄ™
makra proceduralnego w <code>hello_macro_derive</code>. Oba pakiety bÄ™dÄ… musiaÅ‚y byÄ‡
publikowane oddzielnie, a programiÅ›ci uÅ¼ywajÄ…cy tych pakietÃ³w bÄ™dÄ… musieli
dodaÄ‡ je oba jako zaleÅ¼noÅ›ci i wprowadziÄ‡ je oba do zasiÄ™gu. MoglibyÅ›my zamiast
tego sprawiÄ‡, by pakiet <code>hello_macro</code> uÅ¼ywaÅ‚ <code>hello_macro_derive</code> jako zaleÅ¼noÅ›ci
i ponownie eksportowaÅ‚ kod makra proceduralnego. Jednak sposÃ³b, w jaki
strukturyzowaliÅ›my projekt, umoÅ¼liwia programistom uÅ¼ywanie <code>hello_macro</code>
nawet jeÅ›li nie chcÄ… funkcjonalnoÅ›ci <code>derive</code>.</p>
<p>Musimy zadeklarowaÄ‡ pakiet <code>hello_macro_derive</code> jako pakiet makra
proceduralnego. BÄ™dziemy rÃ³wnieÅ¼ potrzebowaÄ‡ funkcjonalnoÅ›ci z pakietÃ³w <code>syn</code>
i <code>quote</code>, jak zobaczysz za chwilÄ™, wiÄ™c musimy dodaÄ‡ je jako zaleÅ¼noÅ›ci.
Dodaj nastÄ™pujÄ…ce wiersze do pliku <em>Cargo.toml</em> dla <code>hello_macro_derive</code>:</p>
<figure class="listing">
<span class="file-name">Filename: hello_macro_derive/Cargo.toml</span>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = "2.0"
quote = "1.0"
</code></pre>
</figure>
<p>Aby rozpoczÄ…Ä‡ definiowanie makra proceduralnego, umieÅ›Ä‡ kod z Listing 20-40
w pliku <em>src/lib.rs</em> pakietu <code>hello_macro_derive</code>. ZauwaÅ¼, Å¼e ten kod nie
skompiluje siÄ™, dopÃ³ki nie dodamy definicji funkcji <code>impl_hello_macro</code>.</p>
<figure class="listing" id="listing-20-40">
<span class="file-name">Filename: hello_macro_derive/src/lib.rs</span>
<pre><code class="language-rust ignore does_not_compile">use proc_macro::TokenStream;
use quote::quote;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate.
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation.
    impl_hello_macro(&amp;ast)
}</code></pre>
<figcaption><a href="#listing-20-40">Listing 20-40</a>: Kod, ktÃ³ry wiÄ™kszoÅ›Ä‡ pakietÃ³w makr proceduralnych bÄ™dzie wymagaÄ‡ do przetwarzania kodu Rust</figcaption>
</figure>
<p>ZauwaÅ¼, Å¼e podzieliliÅ›my kod na funkcjÄ™ <code>hello_macro_derive</code>, ktÃ³ra jest
odpowiedzialna za parsowanie <code>TokenStream</code>, oraz funkcjÄ™ <code>impl_hello_macro</code>,
ktÃ³ra jest odpowiedzialna za przeksztaÅ‚canie drzewa skÅ‚adni: to sprawia,
Å¼e pisanie makra proceduralnego jest wygodniejsze. Kod w zewnÄ™trznej funkcji
(w tym przypadku <code>hello_macro_derive</code>) bÄ™dzie taki sam dla prawie kaÅ¼dego
pakietu makr proceduralnych, ktÃ³ry zobaczysz lub stworzysz. Kod, ktÃ³ry okreÅ›lisz
w ciele funkcji wewnÄ™trznej (w tym przypadku <code>impl_hello_macro</code>), bÄ™dzie
inny w zaleÅ¼noÅ›ci od celu twojego makra proceduralnego.</p>
<p>WprowadziliÅ›my trzy nowe pakiety: <code>proc_macro</code>, <a href="https://crates.io/crates/syn"><code>syn</code></a><!-- ignore -->,
oraz <a href="https://crates.io/crates/quote"><code>quote</code></a><!-- ignore -->. Pakiet <code>proc_macro</code> jest dostarczany
z Rust, wiÄ™c nie musieliÅ›my dodawaÄ‡ go do zaleÅ¼noÅ›ci w <em>Cargo.toml</em>. Pakiet
<code>proc_macro</code> to API kompilatora, ktÃ³re pozwala nam czytaÄ‡ i manipulowaÄ‡ kodem
Rust z naszego kodu.</p>
<p>Pakiet <code>syn</code> parsuje kod Rust ze stringa do struktury danych, na ktÃ³rej moÅ¼emy
wykonywaÄ‡ operacje. Pakiet <code>quote</code> przeksztaÅ‚ca struktury danych <code>syn</code> z
powrotem w kod Rust. Te pakiety znacznie upraszczajÄ… parsowanie wszelkiego
rodzaju kodu Rust, ktÃ³ry moÅ¼emy chcieÄ‡ obsÅ‚uÅ¼yÄ‡: Napisanie peÅ‚nego parsera dla
kodu Rust nie jest prostym zadaniem.</p>
<p>Funkcja <code>hello_macro_derive</code> zostanie wywoÅ‚ana, gdy uÅ¼ytkownik naszej
biblioteki okreÅ›li <code>#[derive(HelloMacro)]</code> dla typu. Jest to moÅ¼liwe, poniewaÅ¼
otagowaliÅ›my tutaj funkcjÄ™ <code>hello_macro_derive</code> za pomocÄ… <code>proc_macro_derive</code>
i okreÅ›liliÅ›my nazwÄ™ <code>HelloMacro</code>, ktÃ³ra pasuje do nazwy naszej cechy; jest
to konwencja, ktÃ³rej przestrzega wiÄ™kszoÅ›Ä‡ makr proceduralnych.</p>
<p>Funkcja <code>hello_macro_derive</code> najpierw konwertuje <code>input</code> z <code>TokenStream</code> na
strukturÄ™ danych, ktÃ³rÄ… moÅ¼emy nastÄ™pnie interpretowaÄ‡ i na ktÃ³rej wykonywaÄ‡
operacje. W tym miejscu do gry wkracza <code>syn</code>. Funkcja <code>parse</code> w <code>syn</code> pobiera
<code>TokenStream</code> i zwraca strukturÄ™ <code>DeriveInput</code> reprezentujÄ…cÄ… sparsowany kod
Rust. Listing 20-41 pokazuje odpowiednie czÄ™Å›ci struktury <code>DeriveInput</code>,
ktÃ³rÄ… otrzymujemy po sparsowaniu ciÄ…gu <code>struct Pancakes;</code>.</p>
<figure class="listing" id="listing-20-41">
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}</code></pre>
<figcaption><a href="#listing-20-41">Listing 20-41</a>: Instancja <code>DeriveInput</code>, ktÃ³rÄ… otrzymujemy podczas parsowania kodu posiadajÄ…cego atrybut makra w Listing 20-37</figcaption>
</figure>
<p>Pola tej struktury pokazujÄ…, Å¼e sparsowany kod Rust to struktura jednostkowa
z <code>ident</code> (<em>identyfikatorem</em>, czyli nazwÄ…) <code>Pancakes</code>. W tej strukturze jest
wiÄ™cej pÃ³l opisujÄ…cych wszelkiego rodzaju kod Rust; sprawdÅº <a href="https://docs.rs/syn/2.0/syn/struct.DeriveInput.html">dokumentacjÄ™
<code>syn</code> dla <code>DeriveInput</code></a> po wiÄ™cej informacji.</p>
<p>WkrÃ³tce zdefiniujemy funkcjÄ™ <code>impl_hello_macro</code>, w ktÃ³rej zbudujemy nowy kod
Rust, ktÃ³ry chcemy uwzglÄ™dniÄ‡. Ale zanim to zrobimy, zauwaÅ¼, Å¼e wyjÅ›cie dla
naszego makra <code>derive</code> jest rÃ³wnieÅ¼ <code>TokenStream</code>. ZwrÃ³cony <code>TokenStream</code> jest
dodawany do kodu, ktÃ³ry piszÄ… uÅ¼ytkownicy naszego pakietu, wiÄ™c kiedy skompilujÄ…
swÃ³j pakiet, uzyskajÄ… dodatkowÄ… funkcjonalnoÅ›Ä‡, ktÃ³rÄ… zapewniamy w zmodyfikowanym
<code>TokenStream</code>.</p>
<p>ByÄ‡ moÅ¼e zauwaÅ¼yÅ‚eÅ›, Å¼e wywoÅ‚ujemy <code>unwrap</code>, aby spowodowaÄ‡ panikÄ™ funkcji
<code>hello_macro_derive</code>, jeÅ›li wywoÅ‚anie funkcji <code>syn::parse</code> tutaj zakoÅ„czy siÄ™
niepowodzeniem. Konieczne jest, aby nasze makro proceduralne wywoÅ‚aÅ‚o panikÄ™
w przypadku bÅ‚Ä™dÃ³w, poniewaÅ¼ funkcje <code>proc_macro_derive</code> muszÄ… zwracaÄ‡
<code>TokenStream</code> zamiast <code>Result</code>, aby byÅ‚y zgodne z API makr proceduralnych.
UproÅ›ciliÅ›my ten przykÅ‚ad, uÅ¼ywajÄ…c <code>unwrap</code>; w kodzie produkcyjnym powinieneÅ›
dostarczyÄ‡ bardziej szczegÃ³Å‚owe komunikaty o bÅ‚Ä™dach, uÅ¼ywajÄ…c <code>panic!</code> lub
<code>expect</code>.</p>
<p>Teraz, gdy mamy kod do przeksztaÅ‚cenia adnotowanego kodu Rust z <code>TokenStream</code>
w instancjÄ™ <code>DeriveInput</code>, wygenerujmy kod, ktÃ³ry implementuje cechÄ™
<code>HelloMacro</code> na adnotowanym typie, jak pokazano w Listing 20-42.</p>
<figure class="listing" id="listing-20-42">
<span class="file-name">Filename: hello_macro_derive/src/lib.rs</span>
<pre><code class="language-rust ignore"><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // Construct a representation of Rust code as a syntax tree
</span><span class="boring">    // that we can manipulate
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // Build the trait implementation
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let generated = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    generated.into()
}</code></pre>
<figcaption><a href="#listing-20-42">Listing 20-42</a>: Implementacja cechy <code>HelloMacro</code> przy uÅ¼yciu sparsowanego kodu Rust</figcaption>
</figure>
<p>Uzyskujemy instancjÄ™ struktury <code>Ident</code> zawierajÄ…cÄ… nazwÄ™ (identyfikator)
adnotowanego typu za pomocÄ… <code>ast.ident</code>. Struktura w Listing 20-41 pokazuje,
Å¼e gdy uruchomimy funkcjÄ™ <code>impl_hello_macro</code> na kodzie z Listing 20-37,
<code>ident</code>, ktÃ³ry otrzymamy, bÄ™dzie miaÅ‚ pole <code>ident</code> z wartoÅ›ciÄ… <code>"Pancakes"</code>.
W ten sposÃ³b zmienna <code>name</code> w Listing 20-42 bÄ™dzie zawieraÄ‡ instancjÄ™
struktury <code>Ident</code>, ktÃ³ra po wydrukowaniu bÄ™dzie ciÄ…giem znakÃ³w <code>"Pancakes"</code>,
nazwÄ… struktury z Listing 20-37.</p>
<p>Makro <code>quote!</code> pozwala nam zdefiniowaÄ‡ kod Rust, ktÃ³ry chcemy zwrÃ³ciÄ‡.
Kompilator oczekuje czegoÅ› innego niÅ¼ bezpoÅ›redni wynik wykonania makra <code>quote!</code>,
wiÄ™c musimy przekonwertowaÄ‡ go na <code>TokenStream</code>. Robimy to, wywoÅ‚ujÄ…c metodÄ™
<code>into</code>, ktÃ³ra konsumuje tÄ™ poÅ›redniÄ… reprezentacjÄ™ i zwraca wartoÅ›Ä‡
wymaganego typu <code>TokenStream</code>.</p>
<p>Makro <code>quote!</code> zapewnia rÃ³wnieÅ¼ bardzo fajne mechanizmy szablonowania: MoÅ¼emy
wpisaÄ‡ <code>#name</code>, a <code>quote!</code> zastÄ…pi to wartoÅ›ciÄ… zmiennej <code>name</code>. MoÅ¼esz nawet
wykonywaÄ‡ pewne powtÃ³rzenia podobnie do tego, jak dziaÅ‚ajÄ… zwykÅ‚e makra.
SprawdÅº <a href="https://docs.rs/quote">dokumentacjÄ™ pakietu <code>quote</code></a> dla szczegÃ³Å‚owego
wprowadzenia.</p>
<p>Chcemy, aby nasze makro proceduralne generowaÅ‚o implementacjÄ™ naszej cechy
<code>HelloMacro</code> dla typu, ktÃ³ry uÅ¼ytkownik adnotowaÅ‚, co moÅ¼emy uzyskaÄ‡ za
pomocÄ… <code>#name</code>. Implementacja cechy ma jednÄ… funkcjÄ™ <code>hello_macro</code>, ktÃ³rej
ciaÅ‚o zawiera funkcjonalnoÅ›Ä‡, ktÃ³rÄ… chcemy zapewniÄ‡: wyÅ›wietlenie <code>Hello, Macro! My name is</code>,
a nastÄ™pnie nazwy adnotowanego typu.</p>
<p>UÅ¼ywane tutaj makro <code>stringify!</code> jest wbudowane w Rust. Przyjmuje ono wyraÅ¼enie
Rust, takie jak <code>1 + 2</code>, i w czasie kompilacji zamienia to wyraÅ¼enie w literaÅ‚
ciÄ…gu znakÃ³w, taki jak <code>"1 + 2"</code>. RÃ³Å¼ni siÄ™ to od <code>format!</code> lub <code>println!</code>,
ktÃ³re sÄ… makrami, ktÃ³re ewaluujÄ… wyraÅ¼enie, a nastÄ™pnie zamieniajÄ… wynik na
<code>String</code>. Istnieje moÅ¼liwoÅ›Ä‡, Å¼e wejÅ›cie <code>#name</code> moÅ¼e byÄ‡ wyraÅ¼eniem do
wydrukowania dosÅ‚ownie, dlatego uÅ¼ywamy <code>stringify!</code>. UÅ¼ycie <code>stringify!</code>
oszczÄ™dza rÃ³wnieÅ¼ alokacjÄ™, konwertujÄ…c <code>#name</code> na literaÅ‚ ciÄ…gu znakÃ³w w
czasie kompilacji.</p>
<p>W tym momencie <code>cargo build</code> powinno zakoÅ„czyÄ‡ siÄ™ pomyÅ›lnie zarÃ³wno w
<code>hello_macro</code>, jak i <code>hello_macro_derive</code>. PodÅ‚Ä…czmy te pakiety do kodu w
Listing 20-37, aby zobaczyÄ‡ makro proceduralne w akcji! UtwÃ³rz nowy projekt
binarny w katalogu <em>projects</em> za pomocÄ… <code>cargo new pancakes</code>. Musimy dodaÄ‡
<code>hello_macro</code> i <code>hello_macro_derive</code> jako zaleÅ¼noÅ›ci w pliku <em>Cargo.toml</em>
pakietu <code>pancakes</code>. JeÅ›li publikujesz swoje wersje <code>hello_macro</code> i
<code>hello_macro_derive</code> na <a href="https://crates.io/">crates.io</a><!-- ignore -->,
byÅ‚yby to zwykÅ‚e zaleÅ¼noÅ›ci; jeÅ›li nie, moÅ¼esz okreÅ›liÄ‡ je jako zaleÅ¼noÅ›ci
<code>path</code> w nastÄ™pujÄ…cy sposÃ³b:</p>
<pre><code class="language-toml">[dependencies]
hello_macro = { path = "../hello_macro" }
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" }
</code></pre>
<p>UmieÅ›Ä‡ kod z Listing 20-37 w pliku <em>src/main.rs</em> i uruchom <code>cargo run</code>:
powinien wyÅ›wietliÄ‡ <code>Hello, Macro! My name is Pancakes!</code>. Implementacja cechy
<code>HelloMacro</code> z makra proceduralnego zostaÅ‚a wÅ‚Ä…czona bez koniecznoÅ›ci
implementowania jej przez pakiet <code>pancakes</code>; <code>#[derive(HelloMacro)]</code> dodaÅ‚o
implementacjÄ™ cechy.</p>
<p>NastÄ™pnie zbadamy, jak inne rodzaje makr proceduralnych rÃ³Å¼niÄ… siÄ™ od
niestandardowych makr <code>derive</code>.</p>
<h3 id="makra-podobne-do-atrybutÃ³w"><a class="header" href="#makra-podobne-do-atrybutÃ³w">Makra podobne do atrybutÃ³w</a></h3>
<p>Makra podobne do atrybutÃ³w sÄ… podobne do niestandardowych makr <code>derive</code>, ale
zamiast generowaÄ‡ kod dla atrybutu <code>derive</code>, pozwalajÄ… tworzyÄ‡ nowe atrybuty.
SÄ… rÃ³wnieÅ¼ bardziej elastyczne: <code>derive</code> dziaÅ‚a tylko dla struktur i enumÃ³w;
atrybuty mogÄ… byÄ‡ stosowane rÃ³wnieÅ¼ do innych elementÃ³w, takich jak funkcje.
Oto przykÅ‚ad uÅ¼ycia makra podobnego do atrybutu. Powiedzmy, Å¼e masz atrybut o
nazwie <code>route</code>, ktÃ³ry adnotuje funkcje podczas uÅ¼ywania frameworka
aplikacji webowych:</p>
<pre><code class="language-rust ignore">#[route(GET, "/")]
fn index() {</code></pre>
<p>Ten atrybut <code>#[route]</code> byÅ‚by zdefiniowany przez framework jako makro
proceduralne. Sygnatura funkcji definicji makra wyglÄ…daÅ‚aby tak:</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {</code></pre>
<p>Tutaj mamy dwa parametry typu <code>TokenStream</code>. Pierwszy dotyczy zawartoÅ›ci
atrybutu: czÄ™Å›Ä‡ <code>GET, "/"</code>. Drugi to ciaÅ‚o elementu, do ktÃ³rego atrybut jest
doÅ‚Ä…czony: w tym przypadku <code>fn index() {}</code> i reszta ciaÅ‚a funkcji.</p>
<p>Poza tym, makra podobne do atrybutÃ³w dziaÅ‚ajÄ… tak samo jak niestandardowe
makra <code>derive</code>: Tworzysz pakiet z typem pakietu <code>proc-macro</code> i implementujesz
funkcjÄ™, ktÃ³ra generuje kod, ktÃ³rego potrzebujesz!</p>
<h3 id="makra-podobne-do-funkcji"><a class="header" href="#makra-podobne-do-funkcji">Makra podobne do funkcji</a></h3>
<p>Makra podobne do funkcji definiujÄ… makra, ktÃ³re wyglÄ…dajÄ… jak wywoÅ‚ania
funkcji. Podobnie jak makra <code>macro_rules!</code>, sÄ… bardziej elastyczne niÅ¼ funkcje;
na przykÅ‚ad mogÄ… przyjmowaÄ‡ nieznanÄ… liczbÄ™ argumentÃ³w. Jednak makra
<code>macro_rules!</code> mogÄ… byÄ‡ definiowane tylko za pomocÄ… skÅ‚adni podobnej do
<code>match</code>, ktÃ³rÄ… omÃ³wiliÅ›my wczeÅ›niej w sekcji <a href="#declarative-macros-with-macro_rules-for-general-metaprogramming">â€Makra deklaratywne do ogÃ³lnego
metaprogramowaniaâ€</a><!-- ignore -->. Makra podobne do funkcji przyjmujÄ…
parametr <code>TokenStream</code>, a ich definicja manipuluje tym <code>TokenStream</code> za pomocÄ…
kodu Rust, tak jak robiÄ… to inne dwa typy makr proceduralnych. PrzykÅ‚adem
makra podobnego do funkcji jest makro <code>sql!</code>, ktÃ³re moÅ¼e byÄ‡ wywoÅ‚ane w
nastÄ™pujÄ…cy sposÃ³b:</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);</code></pre>
<p>To makro parsowaÅ‚oby instrukcjÄ™ SQL wewnÄ…trz i sprawdzaÅ‚oby, czy jest
skÅ‚adniowo poprawna, co jest znacznie bardziej zÅ‚oÅ¼onym przetwarzaniem niÅ¼
to, co moÅ¼e wykonaÄ‡ makro <code>macro_rules!</code>. Makro <code>sql!</code> byÅ‚oby zdefiniowane tak:</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {</code></pre>
<p>Ta definicja jest podobna do sygnatury makra <code>derive</code>: Otrzymujemy tokeny,
ktÃ³re znajdujÄ… siÄ™ w nawiasach, i zwracamy kod, ktÃ³ry chcieliÅ›my wygenerowaÄ‡.</p>
<h2 id="podsumowanie-19"><a class="header" href="#podsumowanie-19">Podsumowanie</a></h2>
<p>Uff! Teraz masz w swoim zestawie narzÄ™dzi Rust kilka funkcji, ktÃ³rych
prawdopodobnie nie bÄ™dziesz czÄ™sto uÅ¼ywaÄ‡, ale bÄ™dziesz wiedzieÄ‡, Å¼e sÄ…
dostÄ™pne w bardzo szczegÃ³lnych okolicznoÅ›ciach. PrzedstawiliÅ›my kilka
zÅ‚oÅ¼onych tematÃ³w, abyÅ› mÃ³gÅ‚ rozpoznaÄ‡ te koncepcje i skÅ‚adniÄ™, gdy napotkasz
je w sugestiach komunikatÃ³w o bÅ‚Ä™dach lub w cudzym kodzie. UÅ¼yj tego rozdziaÅ‚u
jako odniesienia, ktÃ³re poprowadzi ciÄ™ do rozwiÄ…zaÅ„.</p>
<p>NastÄ™pnie wprowadzimy w Å¼ycie wszystko, co omÃ³wiliÅ›my w caÅ‚ej ksiÄ…Å¼ce, i
zrobimy jeszcze jeden projekt!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="projekt-koÅ„cowy-budowanie-wielowÄ…tkowego-serwera-www"><a class="header" href="#projekt-koÅ„cowy-budowanie-wielowÄ…tkowego-serwera-www">Projekt KoÅ„cowy: Budowanie WielowÄ…tkowego Serwera WWW</a></h1>
<p>To byÅ‚a dÅ‚uga podrÃ³Å¼, ale dotarliÅ›my do koÅ„ca ksiÄ…Å¼ki. W tym rozdziale
zbudujemy razem jeszcze jeden projekt, aby zademonstrowaÄ‡ niektÃ³re z
koncepcji, ktÃ³re omÃ³wiliÅ›my w ostatnich rozdziaÅ‚ach, a takÅ¼e podsumowaÄ‡
niektÃ³re wczeÅ›niejsze lekcje.</p>
<p>Na nasz koÅ„cowy projekt stworzymy serwer WWW, ktÃ³ry wyÅ›wietla â€Witaj!â€ i
wyglÄ…da jak na Rysunku 21-1 w przeglÄ…darce internetowej.</p>
<p>Oto nasz plan budowy serwera WWW:</p>
<ol>
<li>Naucz siÄ™ trochÄ™ o TCP i HTTP.</li>
<li>NasÅ‚uchuj poÅ‚Ä…czeÅ„ TCP na gnieÅºdzie.</li>
<li>Parsuj niewielkÄ… liczbÄ™ Å¼Ä…daÅ„ HTTP.</li>
<li>UtwÃ³rz poprawnÄ… odpowiedÅº HTTP.</li>
<li>Popraw przepustowoÅ›Ä‡ naszego serwera za pomocÄ… puli wÄ…tkÃ³w.</li>
</ol>
<img alt="Zrzut ekranu przeglÄ…darki internetowej odwiedzajÄ…cej adres 127.0.0.1:8080 wyÅ›wietlajÄ…cej stronÄ™ internetowÄ… z treÅ›ciÄ… tekstowÄ… â€Hello! Hi from Rustâ€" src="img/trpl21-01.png" class="center" style="width: 50%;" />
<p><span class="caption">Rysunek 21-1: Nasz koÅ„cowy wspÃ³lny projekt</span></p>
<p>Zanim zaczniemy, powinniÅ›my wspomnieÄ‡ o dwÃ³ch szczegÃ³Å‚ach. Po pierwsze, metoda,
ktÃ³rej uÅ¼yjemy, nie bÄ™dzie najlepszym sposobem na zbudowanie serwera WWW w Rust.
CzÅ‚onkowie spoÅ‚ecznoÅ›ci opublikowali wiele gotowych do produkcji pakietÃ³w
dostÄ™pnych na <a href="https://crates.io/">crates.io</a><!-- ignore -->, ktÃ³re
dostarczajÄ… bardziej kompletne implementacje serwera WWW i puli wÄ…tkÃ³w niÅ¼ te,
ktÃ³re zbudujemy. Jednak naszym zamiarem w tym rozdziale jest pomoc w nauce, a
nie wybieranie Å‚atwej drogi. PoniewaÅ¼ Rust jest jÄ™zykiem programowania
systemowego, moÅ¼emy wybraÄ‡ poziom abstrakcji, z ktÃ³rym chcemy pracowaÄ‡ i zejÅ›Ä‡
na niÅ¼szy poziom, niÅ¼ jest to moÅ¼liwe lub praktyczne w innych jÄ™zykach.</p>
<p>Po drugie, nie bÄ™dziemy tutaj uÅ¼ywaÄ‡ <code>async</code> i <code>await</code>. Budowanie puli wÄ…tkÃ³w
to wystarczajÄ…co duÅ¼e wyzwanie samo w sobie, bez dodawania budowania
Å›rodowiska wykonawczego <code>async</code>! JednakÅ¼e, zauwaÅ¼ymy, jak <code>async</code> i <code>await</code>
mogÄ… byÄ‡ stosowane do niektÃ³rych z tych samych problemÃ³w, ktÃ³re zobaczymy w
tym rozdziale. Ostatecznie, jak zauwaÅ¼yliÅ›my w Rozdziale 17, wiele Å›rodowisk
wykonawczych <code>async</code> uÅ¼ywa pul wÄ…tkÃ³w do zarzÄ…dzania swojÄ… pracÄ….</p>
<p>Dlatego napiszemy podstawowy serwer HTTP i pulÄ™ wÄ…tkÃ³w rÄ™cznie, abyÅ› mÃ³gÅ‚
poznaÄ‡ ogÃ³lne idee i techniki stojÄ…ce za pakietami, ktÃ³rych moÅ¼esz uÅ¼yÄ‡ w
przyszÅ‚oÅ›ci.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="budowanie-jednowÄ…tkowego-serwera-www-1"><a href="#budowanie-jednowÄ…tkowego-serwera-www-1" class="header">Budowanie jednowÄ…tkowego serwera WWW</a></h1>
<h2 id="budowanie-jednowÄ…tkowego-serwera-www"><a class="header" href="#budowanie-jednowÄ…tkowego-serwera-www">Budowanie jednowÄ…tkowego serwera WWW</a></h2>
<p>Zaczniemy od uruchomienia jednowÄ…tkowego serwera WWW. Zanim zaczniemy, spÃ³jrzmy na szybki przeglÄ…d protokoÅ‚Ã³w zaangaÅ¼owanych w budowanie serwerÃ³w WWW. SzczegÃ³Å‚y tych protokoÅ‚Ã³w wykraczajÄ… poza zakres tej ksiÄ…Å¼ki, ale krÃ³tki przeglÄ…d dostarczy ci niezbÄ™dnych informacji.</p>
<p>Dwa gÅ‚Ã³wne protokoÅ‚y zaangaÅ¼owane w serwery WWW to <em>Hypertext Transfer Protocol</em> <em>(HTTP)</em> i <em>Transmission Control Protocol</em> <em>(TCP)</em>. Oba protokoÅ‚y sÄ… protokoÅ‚ami typu <em>Å¼Ä…danie-odpowiedÅº</em>, co oznacza, Å¼e <em>klient</em> inicjuje Å¼Ä…dania, a <em>serwer</em> nasÅ‚uchuje Å¼Ä…daÅ„ i dostarcza klientowi odpowiedÅº. ZawartoÅ›Ä‡ tych Å¼Ä…daÅ„ i odpowiedzi jest definiowana przez protokoÅ‚y.</p>
<p>TCP to protokÃ³Å‚ niÅ¼szego poziomu, ktÃ³ry opisuje szczegÃ³Å‚y, jak informacje trafiajÄ… z jednego serwera do drugiego, ale nie precyzuje, czym sÄ… te informacje. HTTP buduje na TCP, definiujÄ…c zawartoÅ›Ä‡ Å¼Ä…daÅ„ i odpowiedzi. Technicznie moÅ¼liwe jest uÅ¼ywanie HTTP z innymi protokoÅ‚ami, ale w zdecydowanej wiÄ™kszoÅ›ci przypadkÃ³w HTTP wysyÅ‚a swoje dane przez TCP. BÄ™dziemy pracowaÄ‡ z surowymi bajtami Å¼Ä…daÅ„ i odpowiedzi TCP i HTTP.</p>
<h3 id="nasÅ‚uchiwanie-poÅ‚Ä…czeÅ„-tcp"><a class="header" href="#nasÅ‚uchiwanie-poÅ‚Ä…czeÅ„-tcp">NasÅ‚uchiwanie poÅ‚Ä…czeÅ„ TCP</a></h3>
<p>Nasz serwer WWW musi nasÅ‚uchiwaÄ‡ poÅ‚Ä…czeÅ„ TCP, wiÄ™c to jest pierwsza czÄ™Å›Ä‡, nad ktÃ³rÄ… bÄ™dziemy pracowaÄ‡. Biblioteka standardowa oferuje moduÅ‚ <code>std::net</code>, ktÃ³ry nam to umoÅ¼liwia. StwÃ³rzmy nowy projekt w zwykÅ‚y sposÃ³b:</p>
<pre><code class="language-console">$ cargo new hello
     Utworzono projekt binarny (aplikacja) `hello`
$ cd hello
</code></pre>
<p>Teraz wprowadÅº kod z Listingu 21-1 do <em>src/main.rs</em>, aby rozpoczÄ…Ä‡. Ten kod bÄ™dzie nasÅ‚uchiwaÅ‚ przy lokalnym adresie <code>127.0.0.1:7878</code> na przychodzÄ…ce strumienie TCP. Kiedy otrzyma przychodzÄ…cy strumieÅ„, wydrukuje <code>Connection established!</code>.</p>
<listing number="21-1" file-name="src/main.rs" caption="NasÅ‚uchiwanie przychodzÄ…cych strumieni i wyÅ›wietlanie komunikatu po odebraniu strumienia">
<pre class="playground"><code class="language-rust no_run edition2024">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!("Connection established!");
    }
}</code></pre>
</listing>
<p>UÅ¼ywajÄ…c <code>TcpListener</code>, moÅ¼emy nasÅ‚uchiwaÄ‡ poÅ‚Ä…czeÅ„ TCP pod adresem <code>127.0.0.1:7878</code>. W adresie, sekcja przed dwukropkiem to adres IP reprezentujÄ…cy twÃ³j komputer (jest taki sam na kaÅ¼dym komputerze i nie reprezentuje konkretnie komputera autorÃ³w), a <code>7878</code> to port. WybraliÅ›my ten port z dwÃ³ch powodÃ³w: HTTP nie jest zwykle akceptowany na tym porcie, wiÄ™c nasz serwer raczej nie bÄ™dzie kolidowaÅ‚ z Å¼adnym innym serwerem WWW, ktÃ³ry moÅ¼esz mieÄ‡ uruchomiony na swojej maszynie, a 7878 to <em>rust</em> wpisane na telefonie.</p>
<p>Funkcja <code>bind</code> w tym scenariuszu dziaÅ‚a jak funkcja <code>new</code> w tym sensie, Å¼e zwrÃ³ci nowÄ… instancjÄ™ <code>TcpListener</code>. Funkcja nazywa siÄ™ <code>bind</code>, poniewaÅ¼ w sieciach poÅ‚Ä…czenie z portem w celu nasÅ‚uchiwania jest znane jako â€wiÄ…zanie siÄ™ z portemâ€.</p>
<p>Funkcja <code>bind</code> zwraca <code>Result&lt;T, E&gt;</code>, co wskazuje, Å¼e wiÄ…zanie moÅ¼e siÄ™ nie powieÅ›Ä‡, na przykÅ‚ad, gdybyÅ›my uruchomili dwie instancje naszego programu i tym samym mieli dwa programy nasÅ‚uchujÄ…ce na tym samym porcie. PoniewaÅ¼ piszemy podstawowy serwer wyÅ‚Ä…cznie w celach edukacyjnych, nie bÄ™dziemy martwiÄ‡ siÄ™ o obsÅ‚ugÄ™ tego typu bÅ‚Ä™dÃ³w; zamiast tego uÅ¼ywamy <code>unwrap</code>, aby zatrzymaÄ‡ program, jeÅ›li wystÄ…piÄ… bÅ‚Ä™dy.</p>
<p>Metoda <code>incoming</code> na <code>TcpListener</code> zwraca iterator, ktÃ³ry dostarcza nam sekwencjÄ™ strumieni (dokÅ‚adniej, strumieni typu <code>TcpStream</code>). Pojedynczy <em>strumieÅ„</em> reprezentuje otwarte poÅ‚Ä…czenie miÄ™dzy klientem a serwerem. <em>PoÅ‚Ä…czenie</em> to nazwa peÅ‚nego procesu Å¼Ä…danie-odpowiedÅº, w ktÃ³rym klient Å‚Ä…czy siÄ™ z serwerem, serwer generuje odpowiedÅº i serwer zamyka poÅ‚Ä…czenie. W zwiÄ…zku z tym bÄ™dziemy czytaÄ‡ z <code>TcpStream</code>, aby zobaczyÄ‡, co klient wysÅ‚aÅ‚, a nastÄ™pnie zapiszemy naszÄ… odpowiedÅº do strumienia, aby wysÅ‚aÄ‡ dane z powrotem do klienta. OgÃ³lnie rzecz biorÄ…c, ta pÄ™tla <code>for</code> bÄ™dzie przetwarzaÄ‡ kaÅ¼de poÅ‚Ä…czenie po kolei i generowaÄ‡ seriÄ™ strumieni, ktÃ³re bÄ™dziemy obsÅ‚ugiwaÄ‡.</p>
<p>Na razie nasza obsÅ‚uga strumienia polega na wywoÅ‚aniu <code>unwrap</code>, aby zakoÅ„czyÄ‡ program, jeÅ›li strumieÅ„ ma jakieÅ› bÅ‚Ä™dy; jeÅ›li bÅ‚Ä™dÃ³w nie ma, program wyÅ›wietla komunikat. W nastÄ™pnym listingu dodamy wiÄ™cej funkcjonalnoÅ›ci dla przypadku sukcesu. Powodem, dla ktÃ³rego moÅ¼emy otrzymaÄ‡ bÅ‚Ä™dy z metody <code>incoming</code>, gdy klient Å‚Ä…czy siÄ™ z serwerem, jest to, Å¼e nie iterujemy faktycznie po poÅ‚Ä…czeniach. Zamiast tego iterujemy po <em>prÃ³bach poÅ‚Ä…czenia</em>. PoÅ‚Ä…czenie moÅ¼e siÄ™ nie powieÅ›Ä‡ z wielu powodÃ³w, z ktÃ³rych wiele jest specyficznych dla systemu operacyjnego. Na przykÅ‚ad, wiele systemÃ³w operacyjnych ma limit liczby jednoczesnych otwartych poÅ‚Ä…czeÅ„, ktÃ³re mogÄ… obsÅ‚ugiwaÄ‡; nowe prÃ³by poÅ‚Ä…czenia powyÅ¼ej tej liczby bÄ™dÄ… generowaÄ‡ bÅ‚Ä…d, dopÃ³ki niektÃ³re z otwartych poÅ‚Ä…czeÅ„ nie zostanÄ… zamkniÄ™te.</p>
<p>SprÃ³bujmy uruchomiÄ‡ ten kod! WywoÅ‚aj <code>cargo run</code> w terminalu, a nastÄ™pnie zaÅ‚aduj <em>127.0.0.1:7878</em> w przeglÄ…darce internetowej. PrzeglÄ…darka powinna wyÅ›wietliÄ‡ komunikat o bÅ‚Ä™dzie, taki jak â€Connection resetâ€, poniewaÅ¼ serwer obecnie nie wysyÅ‚a Å¼adnych danych. Ale kiedy spojrzysz na swÃ³j terminal, powinieneÅ› zobaczyÄ‡ kilka komunikatÃ³w, ktÃ³re zostaÅ‚y wydrukowane, gdy przeglÄ…darka poÅ‚Ä…czyÅ‚a siÄ™ z serwerem!</p>
<pre><code class="language-text">     Uruchamianie `target/debug/hello`
PoÅ‚Ä…czenie nawiÄ…zane!
PoÅ‚Ä…czenie nawiÄ…zane!
PoÅ‚Ä…czenie nawiÄ…zane!
</code></pre>
<p>Czasami zobaczysz wiele komunikatÃ³w wydrukowanych dla jednego Å¼Ä…dania przeglÄ…darki; powodem moÅ¼e byÄ‡ to, Å¼e przeglÄ…darka wysyÅ‚a Å¼Ä…danie o stronÄ™, a takÅ¼e Å¼Ä…danie o inne zasoby, takie jak ikona <em>favicon.ico</em>, ktÃ³ra pojawia siÄ™ w zakÅ‚adce przeglÄ…darki.</p>
<p>MoÅ¼e siÄ™ rÃ³wnieÅ¼ zdarzyÄ‡, Å¼e przeglÄ…darka prÃ³buje poÅ‚Ä…czyÄ‡ siÄ™ z serwerem wielokrotnie, poniewaÅ¼ serwer nie odpowiada Å¼adnymi danymi. Gdy <code>stream</code> wychodzi poza zakres i jest porzucony na koÅ„cu pÄ™tli, poÅ‚Ä…czenie jest zamykane w ramach implementacji <code>drop</code>. PrzeglÄ…darki czasami radzÄ… sobie z zamkniÄ™tymi poÅ‚Ä…czeniami, ponawiajÄ…c prÃ³bÄ™, poniewaÅ¼ problem moÅ¼e byÄ‡ tymczasowy.</p>
<p>PrzeglÄ…darki czasami otwierajÄ… rÃ³wnieÅ¼ wiele poÅ‚Ä…czeÅ„ z serwerem bez wysyÅ‚ania Å¼adnych Å¼Ä…daÅ„, aby w przypadku pÃ³Åºniejszego wysÅ‚ania Å¼Ä…daÅ„, te Å¼Ä…dania mogÅ‚y nastÄ…piÄ‡ szybciej. Kiedy to nastÄ…pi, nasz serwer zobaczy kaÅ¼de poÅ‚Ä…czenie, niezaleÅ¼nie od tego, czy istniejÄ… jakiekolwiek Å¼Ä…dania przez to poÅ‚Ä…czenie. Robi tak wiele wersji przeglÄ…darek opartych na Chrome, na przykÅ‚ad; moÅ¼esz wyÅ‚Ä…czyÄ‡ tÄ™ optymalizacjÄ™, uÅ¼ywajÄ…c trybu przeglÄ…dania prywatnego lub innej przeglÄ…darki.</p>
<p>WaÅ¼nym czynnikiem jest to, Å¼e z powodzeniem uzyskaliÅ›my uchwyt do poÅ‚Ä…czenia TCP!</p>
<p>PamiÄ™taj, aby zatrzymaÄ‡ program, naciskajÄ…c <kbd>ctrl</kbd>-<kbd>C</kbd>, gdy skoÅ„czysz uruchamiaÄ‡ okreÅ›lonÄ… wersjÄ™ kodu. NastÄ™pnie uruchom program ponownie, wywoÅ‚ujÄ…c polecenie <code>cargo run</code> po wprowadzeniu kaÅ¼dej serii zmian w kodzie, aby upewniÄ‡ siÄ™, Å¼e uruchamiasz najnowszy kod.</p>
<h3 id="odczytywanie-Å¼Ä…dania"><a class="header" href="#odczytywanie-Å¼Ä…dania">Odczytywanie Å¼Ä…dania</a></h3>
<p>Zaimplementujmy funkcjonalnoÅ›Ä‡ do odczytywania Å¼Ä…dania z przeglÄ…darki! Aby oddzieliÄ‡ kwestie nawiÄ…zania poÅ‚Ä…czenia od wykonania jakiejÅ› akcji z nim zwiÄ…zanej, rozpoczniemy nowÄ… funkcjÄ™ do przetwarzania poÅ‚Ä…czeÅ„. W tej nowej funkcji <code>handle_connection</code> bÄ™dziemy czytaÄ‡ dane ze strumienia TCP i drukowaÄ‡ je, abyÅ›my mogli zobaczyÄ‡ dane wysyÅ‚ane z przeglÄ…darki. ZmieÅ„ kod, aby wyglÄ…daÅ‚ jak na Listingu 21-2.</p>
<listing number="21-2" file-name="src/main.rs" caption="Odczytywanie ze strumienia `TcpStream` i drukowanie danych">
<pre class="playground"><code class="language-rust no_run edition2024">use std::{
    io::{BufReader, prelude::*},
    net::{TcpListener, TcpStream},
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    println!("Å»Ä…danie: {http_request:#?}");
}</code></pre>
</listing>
<p>Wprowadzamy <code>std::io::BufReader</code> i <code>std::io::prelude</code> do zakresu, aby uzyskaÄ‡ dostÄ™p do cech i typÃ³w, ktÃ³re pozwalajÄ… nam czytaÄ‡ i zapisywaÄ‡ do strumienia. W pÄ™tli <code>for</code> w funkcji <code>main</code>, zamiast wyÅ›wietlaÄ‡ komunikat informujÄ…cy o nawiÄ…zaniu poÅ‚Ä…czenia, wywoÅ‚ujemy teraz nowÄ… funkcjÄ™ <code>handle_connection</code> i przekazujemy jej <code>stream</code>.</p>
<p>W funkcji <code>handle_connection</code> tworzymy nowÄ… instancjÄ™ <code>BufReader</code>, ktÃ³ra opakowuje referencjÄ™ do <code>stream</code>. <code>BufReader</code> dodaje buforowanie, zarzÄ…dzajÄ…c za nas wywoÅ‚aniami metod cechy <code>std::io::Read</code>.</p>
<p>Tworzymy zmiennÄ… o nazwie <code>http_request</code>, aby zbieraÄ‡ linie Å¼Ä…dania, ktÃ³re przeglÄ…darka wysyÅ‚a do naszego serwera. Wskazujemy, Å¼e chcemy zebraÄ‡ te linie w wektorze, dodajÄ…c adnotacjÄ™ typu <code>Vec&lt;_&gt;</code>.</p>
<p><code>BufReader</code> implementuje cechÄ™ <code>std::io::BufRead</code>, ktÃ³ra dostarcza metodÄ™ <code>lines</code>. Metoda <code>lines</code> zwraca iterator <code>Result&lt;String, std::io::Error&gt;</code>, dzielÄ…c strumieÅ„ danych za kaÅ¼dym razem, gdy zobaczy znak nowej linii. Aby uzyskaÄ‡ kaÅ¼dy <code>String</code>, <code>map</code>ujemy i <code>unwrap</code>ujemy kaÅ¼dy <code>Result</code>. <code>Result</code> moÅ¼e byÄ‡ bÅ‚Ä™dem, jeÅ›li dane nie sÄ… prawidÅ‚owym UTF-8 lub jeÅ›li wystÄ…piÅ‚ problem podczas czytania ze strumienia. Ponownie, program produkcyjny powinien obsÅ‚ugiwaÄ‡ te bÅ‚Ä™dy bardziej elegancko, ale my decydujemy siÄ™ na zatrzymanie programu w przypadku bÅ‚Ä™du dla uproszczenia.</p>
<p>PrzeglÄ…darka sygnalizuje koniec Å¼Ä…dania HTTP, wysyÅ‚ajÄ…c dwa znaki nowej linii z rzÄ™du, wiÄ™c aby uzyskaÄ‡ jedno Å¼Ä…danie ze strumienia, pobieramy linie, dopÃ³ki nie otrzymamy linii, ktÃ³ra jest pustym ciÄ…giem znakÃ³w. Po zebraniu linii do wektora, drukujemy je, uÅ¼ywajÄ…c Å‚adnego formatowania debugowania, abyÅ›my mogli przyjrzeÄ‡ siÄ™ instrukcjom, ktÃ³re przeglÄ…darka internetowa wysyÅ‚a do naszego serwera.</p>
<p>SprÃ³bujmy tego kodu! Uruchom program i ponownie wyÅ›lij Å¼Ä…danie w przeglÄ…darce internetowej. ZauwaÅ¼, Å¼e nadal otrzymamy stronÄ™ bÅ‚Ä™du w przeglÄ…darce, ale wynik naszego programu w terminalu bÄ™dzie teraz wyglÄ…daÅ‚ podobnie do tego:</p>
<!-- manual-regeneration
cd listings/ch21-web-server/listing-21-02
cargo run
wyÅ›lij Å¼Ä…danie na 127.0.0.1:7878
Nie moÅ¼na zautomatyzowaÄ‡, poniewaÅ¼ wynik zaleÅ¼y od wysyÅ‚ania Å¼Ä…daÅ„
-->
<pre><code class="language-console">$ cargo run
   Kompilowanie hello v0.1.0 (file:///projects/hello)
    ZakoÅ„czono `dev` profil [nieoptymalny + debuginfo] cel(e) w 0.42s
     Uruchamianie `target/debug/hello`
Å»Ä…danie: [
    "GET / HTTP/1.1",
    "Host: 127.0.0.1:7878",
    "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0",
    "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
    "Accept-Language: en-US,en;q=0.5",
    "Accept-Encoding: gzip, deflate, br",
    "DNT: 1",
    "Connection: keep-alive",
    "Upgrade-Insecure-Requests: 1",
    "Sec-Fetch-Dest: document",
    "Sec-Fetch-Mode: navigate",
    "Sec-Fetch-Site: none",
    "Sec-Fetch-User: ?1",
    "Cache-Control: max-age=0",
]
</code></pre>
<p>W zaleÅ¼noÅ›ci od przeglÄ…darki, moÅ¼esz otrzymaÄ‡ nieco inny wynik. Teraz, gdy drukujemy dane Å¼Ä…dania, moÅ¼emy zobaczyÄ‡, dlaczego otrzymujemy wiele poÅ‚Ä…czeÅ„ z jednego Å¼Ä…dania przeglÄ…darki, patrzÄ…c na Å›cieÅ¼kÄ™ po <code>GET</code> w pierwszej linii Å¼Ä…dania. JeÅ›li powtarzajÄ…ce siÄ™ poÅ‚Ä…czenia wszystkie Å¼Ä…dajÄ… <em>/</em>, wiemy, Å¼e przeglÄ…darka prÃ³buje wielokrotnie pobraÄ‡ <em>/</em>, poniewaÅ¼ nie otrzymuje odpowiedzi z naszego programu.</p>
<p>Przeanalizujmy te dane Å¼Ä…dania, aby zrozumieÄ‡, o co przeglÄ…darka prosi nasz program.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="a-closer-look-at-an-http-request"></a>
<a id="looking-closer-at-an-http-request"></a></p>
<h3 id="bliÅ¼sze-spojrzenie-na-Å¼Ä…danie-http"><a class="header" href="#bliÅ¼sze-spojrzenie-na-Å¼Ä…danie-http">BliÅ¼sze spojrzenie na Å¼Ä…danie HTTP</a></h3>
<p>HTTP to protokÃ³Å‚ tekstowy, a Å¼Ä…danie ma nastÄ™pujÄ…cy format:</p>
<pre><code class="language-text">Metoda Identyfikator-Å¼Ä…dania Wersja-HTTP CRLF
nagÅ‚Ã³wki CRLF
ciaÅ‚o-wiadomoÅ›ci
</code></pre>
<p>Pierwsza linia to <em>linia Å¼Ä…dania</em>, ktÃ³ra zawiera informacje o tym, czego klient Å¼Ä…da. Pierwsza czÄ™Å›Ä‡ linii Å¼Ä…dania wskazuje uÅ¼ywanÄ… metodÄ™, takÄ… jak <code>GET</code> lub <code>POST</code>, ktÃ³ra opisuje, w jaki sposÃ³b klient wysyÅ‚a to Å¼Ä…danie. Nasz klient uÅ¼yÅ‚ Å¼Ä…dania <code>GET</code>, co oznacza, Å¼e prosi o informacje.</p>
<p>NastÄ™pnÄ… czÄ™Å›ciÄ… linii Å¼Ä…dania jest <em>/</em>, ktÃ³ra wskazuje <em>uniform resource identifier</em> <em>(URI)</em>, o ktÃ³ry prosi klient: URI jest prawie, ale niezupeÅ‚nie, tym samym co <em>uniform resource locator</em> <em>(URL)</em>. RÃ³Å¼nica miÄ™dzy URI a URL nie jest istotna dla naszych celÃ³w w tym rozdziale, ale specyfikacja HTTP uÅ¼ywa terminu <em>URI</em>, wiÄ™c moÅ¼emy tutaj po prostu mentalnie zastÄ…piÄ‡ <em>URL</em> przez <em>URI</em>.</p>
<p>OstatniÄ… czÄ™Å›ciÄ… jest wersja HTTP uÅ¼ywana przez klienta, a nastÄ™pnie linia Å¼Ä…dania koÅ„czy siÄ™ sekwencjÄ… CRLF. (CRLF to skrÃ³t od <em>carriage return</em> i <em>line feed</em>, co sÄ… terminami z czasÃ³w maszyn do pisania!) SekwencjÄ™ CRLF moÅ¼na rÃ³wnieÅ¼ zapisaÄ‡ jako <code>\r\n</code>, gdzie <code>\r</code> to znak powrotu karetki, a <code>\n</code> to znak nowej linii. <em>Sekwencja CRLF</em> oddziela liniÄ™ Å¼Ä…dania od reszty danych Å¼Ä…dania. ZauwaÅ¼, Å¼e gdy CRLF jest drukowane, widzimy poczÄ…tek nowej linii, a nie <code>\r\n</code>.</p>
<p>PatrzÄ…c na dane linii Å¼Ä…dania, ktÃ³re otrzymaliÅ›my po uruchomieniu naszego programu, widzimy, Å¼e <code>GET</code> to metoda, <em>/</em> to URI Å¼Ä…dania, a <code>HTTP/1.1</code> to wersja.</p>
<p>Po linii Å¼Ä…dania, pozostaÅ‚e linie zaczynajÄ…ce siÄ™ od <code>Host:</code> to nagÅ‚Ã³wki. Å»Ä…dania <code>GET</code> nie majÄ… ciaÅ‚a.</p>
<p>SprÃ³buj wysÅ‚aÄ‡ Å¼Ä…danie z innej przeglÄ…darki lub poprosiÄ‡ o inny adres, na przykÅ‚ad <em>127.0.0.1:7878/test</em>, aby zobaczyÄ‡, jak zmieniajÄ… siÄ™ dane Å¼Ä…dania.</p>
<p>Teraz, gdy wiemy, o co prosi przeglÄ…darka, wyÅ›lijmy z powrotem jakieÅ› dane!</p>
<h3 id="pisanie-odpowiedzi"><a class="header" href="#pisanie-odpowiedzi">Pisanie odpowiedzi</a></h3>
<p>Zaimplementujemy wysyÅ‚anie danych w odpowiedzi na Å¼Ä…danie klienta. Odpowiedzi majÄ… nastÄ™pujÄ…cy format:</p>
<pre><code class="language-text">Wersja-HTTP Kod-statusu Fraza-powodowa CRLF
nagÅ‚Ã³wki CRLF
ciaÅ‚o-wiadomoÅ›ci
</code></pre>
<p>Pierwsza linia to <em>linia statusu</em>, ktÃ³ra zawiera wersjÄ™ HTTP uÅ¼ywanÄ… w odpowiedzi, numeryczny kod statusu, ktÃ³ry podsumowuje wynik Å¼Ä…dania, oraz frazÄ™ powodowÄ…, ktÃ³ra zawiera tekstowy opis kodu statusu. Po sekwencji CRLF nastÄ™pujÄ… nagÅ‚Ã³wki, kolejna sekwencja CRLF i treÅ›Ä‡ odpowiedzi.</p>
<p>PoniÅ¼ej znajduje siÄ™ przykÅ‚adowa odpowiedÅº, ktÃ³ra uÅ¼ywa protokoÅ‚u HTTP w wersji 1.1 i ma kod statusu 200, frazÄ™ â€OKâ€, brak nagÅ‚Ã³wkÃ³w i brak treÅ›ci:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>Kod statusu 200 to standardowa odpowiedÅº sukcesu. Tekst to maÅ‚a, udana odpowiedÅº HTTP. Zapiszmy to do strumienia jako naszÄ… odpowiedÅº na udane Å¼Ä…danie! Z funkcji <code>handle_connection</code> usuÅ„ <code>println!</code>, ktÃ³re drukowaÅ‚o dane Å¼Ä…dania, i zastÄ…p je kodem z Listingu 21-3.</p>
<listing number="21-3" file-name="src/main.rs" caption="Zapisywanie krÃ³tkiej, udanej odpowiedzi HTTP do strumienia">
<pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">use std::{
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let response = "HTTP/1.1 200 OK\r\n\r\n";

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre>
</listing>
<p>Pierwsza nowa linia definiuje zmiennÄ… <code>response</code>, ktÃ³ra przechowuje dane wiadomoÅ›ci o sukcesie. NastÄ™pnie wywoÅ‚ujemy <code>as_bytes</code> na naszym <code>response</code>, aby przekonwertowaÄ‡ dane ciÄ…gu na bajty. Metoda <code>write_all</code> na <code>stream</code> przyjmuje <code>&amp;[u8]</code> i wysyÅ‚a te bajty bezpoÅ›rednio przez poÅ‚Ä…czenie. PoniewaÅ¼ operacja <code>write_all</code> moÅ¼e zakoÅ„czyÄ‡ siÄ™ niepowodzeniem, uÅ¼ywamy <code>unwrap</code> dla kaÅ¼dego wyniku bÅ‚Ä™du, tak jak poprzednio. Ponownie, w prawdziwej aplikacji, naleÅ¼aÅ‚oby tutaj dodaÄ‡ obsÅ‚ugÄ™ bÅ‚Ä™dÃ³w.</p>
<p>DziÄ™ki tym zmianom, uruchommy nasz kod i wyÅ›lijmy Å¼Ä…danie. Nie drukujemy juÅ¼ Å¼adnych danych do terminala, wiÄ™c nie zobaczymy Å¼adnego wyniku poza danymi z Cargo. Gdy zaÅ‚adujesz <em>127.0.0.1:7878</em> w przeglÄ…darce internetowej, powinieneÅ› otrzymaÄ‡ pustÄ… stronÄ™ zamiast bÅ‚Ä™du. WÅ‚aÅ›nie rÄ™cznie zakodowaÅ‚eÅ› odbieranie Å¼Ä…dania HTTP i wysyÅ‚anie odpowiedzi!</p>
<h3 id="zwracanie-prawdziwego-kodu-html"><a class="header" href="#zwracanie-prawdziwego-kodu-html">Zwracanie prawdziwego kodu HTML</a></h3>
<p>Zaimplementujmy funkcjonalnoÅ›Ä‡ zwracania czegoÅ› wiÄ™cej niÅ¼ pustej strony. UtwÃ³rz nowy plik <em>hello.html</em> w katalogu gÅ‚Ã³wnym swojego projektu, a nie w katalogu <em>src</em>. MoÅ¼esz wpisaÄ‡ dowolny kod HTML; Listing 21-4 pokazuje jednÄ… z moÅ¼liwoÅ›ci.</p>
<listing number="21-4" file-name="hello.html" caption="PrzykÅ‚adowy plik HTML do zwrÃ³cenia w odpowiedzi">
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Witaj!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Witaj!&lt;/h1&gt;
    &lt;p&gt;CzeÅ›Ä‡ z Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
</listing>
<p>Jest to minimalny dokument HTML5 z nagÅ‚Ã³wkiem i tekstem. Aby zwrÃ³ciÄ‡ go z serwera po otrzymaniu Å¼Ä…dania, zmodyfikujemy <code>handle_connection</code>, jak pokazano na Listingu 21-5, aby odczytaÄ‡ plik HTML, dodaÄ‡ go do odpowiedzi jako ciaÅ‚o i wysÅ‚aÄ‡.</p>
<listing number="21-5" file-name="src/main.rs" caption="WysyÅ‚anie zawartoÅ›ci *hello.html* jako treÅ›ci odpowiedzi">
<pre class="playground"><code class="language-rust no_run edition2024">use std::{
    fs,
    io::{BufReader, prelude::*},
    net::{TcpListener, TcpStream},
};
// --snip--

<span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let status_line = "HTTP/1.1 200 OK";
    let contents = fs::read_to_string("hello.html").unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre>
</listing>
<p>DodaliÅ›my <code>fs</code> do instrukcji <code>use</code>, aby wprowadziÄ‡ moduÅ‚ systemu plikÃ³w biblioteki standardowej do zakresu. Kod do odczytywania zawartoÅ›ci pliku do ciÄ…gu znakÃ³w powinien wyglÄ…daÄ‡ znajomo; uÅ¼yliÅ›my go, gdy czytaliÅ›my zawartoÅ›Ä‡ pliku dla naszego projektu I/O w Listingu 12-4.</p>
<p>NastÄ™pnie uÅ¼ywamy <code>format!</code> do dodania zawartoÅ›ci pliku jako treÅ›ci odpowiedzi sukcesu. Aby zapewniÄ‡ prawidÅ‚owÄ… odpowiedÅº HTTP, dodajemy nagÅ‚Ã³wek <code>Content-Length</code>, ktÃ³ry jest ustawiony na rozmiar naszej treÅ›ci odpowiedzi â€“ w tym przypadku, rozmiar <code>hello.html</code>.</p>
<p>Uruchom ten kod za pomocÄ… <code>cargo run</code> i zaÅ‚aduj <em>127.0.0.1:7878</em> w swojej przeglÄ…darce; powinieneÅ› zobaczyÄ‡ wyrenderowany HTML!</p>
<p>Obecnie ignorujemy dane Å¼Ä…dania w <code>http_request</code> i po prostu bezwarunkowo wysyÅ‚amy z powrotem zawartoÅ›Ä‡ pliku HTML. Oznacza to, Å¼e jeÅ›li sprÃ³bujesz zaÅ¼Ä…daÄ‡ <em>127.0.0.1:7878/cos-innego</em> w przeglÄ…darce, nadal otrzymasz tÄ™ samÄ… odpowiedÅº HTML. W tej chwili nasz serwer jest bardzo ograniczony i nie robi tego, co robi wiÄ™kszoÅ›Ä‡ serwerÃ³w WWW. Chcemy dostosowaÄ‡ nasze odpowiedzi w zaleÅ¼noÅ›ci od Å¼Ä…dania i wysyÅ‚aÄ‡ plik HTML tylko dla dobrze sformuÅ‚owanego Å¼Ä…dania do <em>/</em>.</p>
<h3 id="walidacja-Å¼Ä…dania-i-selektywne-odpowiadanie"><a class="header" href="#walidacja-Å¼Ä…dania-i-selektywne-odpowiadanie">Walidacja Å¼Ä…dania i selektywne odpowiadanie</a></h3>
<p>W tej chwili nasz serwer WWW zwrÃ³ci HTML w pliku niezaleÅ¼nie od tego, co klient zaÅ¼Ä…daÅ‚. Dodajmy funkcjonalnoÅ›Ä‡, aby sprawdziÄ‡, czy przeglÄ…darka Å¼Ä…da <em>/</em> przed zwrÃ³ceniem pliku HTML i aby zwrÃ³ciÄ‡ bÅ‚Ä…d, jeÅ›li przeglÄ…darka zaÅ¼Ä…da czegoÅ› innego. W tym celu musimy zmodyfikowaÄ‡ <code>handle_connection</code>, jak pokazano na Listingu 21-6. Ten nowy kod sprawdza zawartoÅ›Ä‡ otrzymanego Å¼Ä…dania w porÃ³wnaniu z tym, jak wyglÄ…da Å¼Ä…danie do <em>/</em>, i dodaje bloki <code>if</code> i <code>else</code>, aby traktowaÄ‡ Å¼Ä…dania inaczej.</p>
<listing number="21-6" file-name="src/main.rs" caption="ObsÅ‚uga Å¼Ä…daÅ„ do */* inaczej niÅ¼ innych Å¼Ä…daÅ„">
<pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    if request_line == "GET / HTTP/1.1" {
        let status_line = "HTTP/1.1 200 OK";
        let contents = fs::read_to_string("hello.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    } else {
        // inne Å¼Ä…danie
    }
}</code></pre>
</listing>
<p>BÄ™dziemy tylko patrzeÄ‡ na pierwszÄ… liniÄ™ Å¼Ä…dania HTTP, wiÄ™c zamiast odczytywaÄ‡ caÅ‚e Å¼Ä…danie do wektora, wywoÅ‚ujemy <code>next</code>, aby pobraÄ‡ pierwszy element z iteratora. Pierwszy <code>unwrap</code> zajmuje siÄ™ <code>Option</code> i zatrzymuje program, jeÅ›li iterator nie ma Å¼adnych elementÃ³w. Drugi <code>unwrap</code> obsÅ‚uguje <code>Result</code> i ma taki sam efekt jak <code>unwrap</code>, ktÃ³ry zostaÅ‚ dodany w <code>map</code> w Listingu 21-2.</p>
<p>NastÄ™pnie sprawdzamy <code>request_line</code>, aby zobaczyÄ‡, czy jest rÃ³wna linii Å¼Ä…dania GET do Å›cieÅ¼ki <em>/</em>. JeÅ›li tak, blok <code>if</code> zwraca zawartoÅ›Ä‡ naszego pliku HTML.</p>
<p>JeÅ›li <code>request_line</code> <em>nie</em> jest rÃ³wne Å¼Ä…daniu GET do Å›cieÅ¼ki <em>/</em>, oznacza to, Å¼e otrzymaliÅ›my jakieÅ› inne Å¼Ä…danie. Za chwilÄ™ dodamy kod do bloku <code>else</code>, aby odpowiedzieÄ‡ na wszystkie inne Å¼Ä…dania.</p>
<p>Uruchom ten kod teraz i zaÅ¼Ä…daj <em>127.0.0.1:7878</em>; powinieneÅ› otrzymaÄ‡ HTML z <em>hello.html</em>. JeÅ›li wyÅ›lesz jakiekolwiek inne Å¼Ä…danie, takie jak <em>127.0.0.1:7878/cos-innego</em>, otrzymasz bÅ‚Ä…d poÅ‚Ä…czenia, podobny do tych, ktÃ³re widziaÅ‚eÅ›, uruchamiajÄ…c kod z Listingu 21-1 i Listingu 21-2.</p>
<p>Teraz dodajmy kod z Listingu 21-7 do bloku <code>else</code>, aby zwrÃ³ciÄ‡ odpowiedÅº z kodem statusu 404, ktÃ³ry sygnalizuje, Å¼e zawartoÅ›Ä‡ dla Å¼Ä…dania nie zostaÅ‚a znaleziona. ZwrÃ³cimy rÃ³wnieÅ¼ kod HTML dla strony, aby przeglÄ…darka mogÅ‚a jÄ… wyrenderowaÄ‡, wskazujÄ…c odpowiedÅº uÅ¼ytkownikowi koÅ„cowemu.</p>
<listing number="21-7" file-name="src/main.rs" caption="OdpowiedÅº z kodem statusu 404 i stronÄ… bÅ‚Ä™du, jeÅ›li zaÅ¼Ä…dano czegoÅ› innego niÅ¼ */*">
<pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    if request_line == "GET / HTTP/1.1" {
</span><span class="boring">        let status_line = "HTTP/1.1 200 OK";
</span><span class="boring">        let contents = fs::read_to_string("hello.html").unwrap();
</span><span class="boring">        let length = contents.len();
</span><span class="boring">
</span><span class="boring">        let response = format!(
</span><span class="boring">            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        stream.write_all(response.as_bytes()).unwrap();
</span>    // --snip--
    } else {
        let status_line = "HTTP/1.1 404 NOT FOUND";
        let contents = fs::read_to_string("404.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    }
<span class="boring">}</span></code></pre>
</listing>
<p>Tutaj nasza odpowiedÅº zawiera liniÄ™ statusu z kodem statusu 404 i frazÄ… powodu <code>NOT FOUND</code>. CiaÅ‚em odpowiedzi bÄ™dzie HTML z pliku <em>404.html</em>. BÄ™dziesz musiaÅ‚ utworzyÄ‡ plik <em>404.html</em> obok <em>hello.html</em> dla strony bÅ‚Ä™du; ponownie, moÅ¼esz uÅ¼yÄ‡ dowolnego kodu HTML, jaki chcesz, lub uÅ¼yÄ‡ przykÅ‚adowego kodu HTML z Listingu 21-8.</p>
<listing number="21-8" file-name="404.html" caption="PrzykÅ‚adowa zawartoÅ›Ä‡ strony do odesÅ‚ania z dowolnÄ… odpowiedziÄ… 404">
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Witaj!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Ups!&lt;/h1&gt;
    &lt;p&gt;Przepraszam, nie wiem, o co prosisz.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
</listing>
<p>DziÄ™ki tym zmianom uruchom ponownie swÃ³j serwer. Å»Ä…danie <em>127.0.0.1:7878</em> powinno zwrÃ³ciÄ‡ zawartoÅ›Ä‡ pliku <em>hello.html</em>, a kaÅ¼de inne Å¼Ä…danie, takie jak <em>127.0.0.1:7878/foo</em>, powinno zwrÃ³ciÄ‡ kod HTML bÅ‚Ä™du z <em>404.html</em>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="a-touch-of-refactoring"></a></p>
<h3 id="refaktoryzacja"><a class="header" href="#refaktoryzacja">Refaktoryzacja</a></h3>
<p>W tej chwili bloki <code>if</code> i <code>else</code> majÄ… wiele powtÃ³rzeÅ„: oba odczytujÄ… pliki i zapisujÄ… zawartoÅ›Ä‡ plikÃ³w do strumienia. Jedyne rÃ³Å¼nice to linia statusu i nazwa pliku. UczyÅ„my kod bardziej zwiÄ™zÅ‚ym, wyodrÄ™bniajÄ…c te rÃ³Å¼nice w osobne linie <code>if</code> i <code>else</code>, ktÃ³re przypiszÄ… wartoÅ›ci linii statusu i nazwy pliku do zmiennych; moÅ¼emy nastÄ™pnie uÅ¼yÄ‡ tych zmiennych bezwarunkowo w kodzie do odczytu pliku i zapisu odpowiedzi. Listing 21-9 pokazuje wynikowy kod po zastÄ…pieniu duÅ¼ych blokÃ³w <code>if</code> i <code>else</code>.</p>
<listing number="21-9" file-name="src/main.rs" caption="Refaktoryzacja blokÃ³w `if` i `else`, aby zawieraÅ‚y tylko kod, ktÃ³ry rÃ³Å¼ni siÄ™ miÄ™dzy dwoma przypadkami">
<pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--
<span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span>
    let (status_line, filename) = if request_line == "GET / HTTP/1.1" {
        ("HTTP/1.1 200 OK", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre>
</listing>
<p>Teraz bloki <code>if</code> i <code>else</code> zwracajÄ… tylko odpowiednie wartoÅ›ci dla linii statusu i nazwy pliku w krotce; nastÄ™pnie uÅ¼ywamy dekompozycji do przypisania tych dwÃ³ch wartoÅ›ci do <code>status_line</code> i <code>filename</code> za pomocÄ… wzorca w instrukcji <code>let</code>, jak omÃ³wiono w Rozdziale 19.</p>
<p>Poprzednio zduplikowany kod znajduje siÄ™ teraz poza blokami <code>if</code> i <code>else</code> i uÅ¼ywa zmiennych <code>status_line</code> i <code>filename</code>. UÅ‚atwia to dostrzeÅ¼enie rÃ³Å¼nicy miÄ™dzy dwoma przypadkami, a takÅ¼e oznacza, Å¼e mamy tylko jedno miejsce do aktualizacji kodu, jeÅ›li chcemy zmieniÄ‡ sposÃ³b dziaÅ‚ania odczytu plikÃ³w i zapisu odpowiedzi. Zachowanie kodu z Listingu 21-9 bÄ™dzie takie samo jak z Listingu 21-7.</p>
<p>Åšwietnie! Mamy teraz prosty serwer WWW w okoÅ‚o 40 liniach kodu Rust, ktÃ³ry odpowiada na jedno Å¼Ä…danie stronÄ… treÅ›ci i na wszystkie inne Å¼Ä…dania odpowiedziÄ… 404.</p>
<p>Obecnie nasz serwer dziaÅ‚a w jednym wÄ…tku, co oznacza, Å¼e moÅ¼e obsÅ‚ugiwaÄ‡ tylko jedno Å¼Ä…danie na raz. Zbadajmy, jak to moÅ¼e byÄ‡ problemem, symulujÄ…c kilka wolnych Å¼Ä…daÅ„. NastÄ™pnie naprawimy to, aby nasz serwer mÃ³gÅ‚ obsÅ‚ugiwaÄ‡ wiele Å¼Ä…daÅ„ jednoczeÅ›nie.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="od-serwera-jednowÄ…tkowego-do-wielowÄ…tkowego-1"><a href="#od-serwera-jednowÄ…tkowego-do-wielowÄ…tkowego-1" class="header">Od serwera jednowÄ…tkowego do wielowÄ…tkowego</a></h1>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="turning-our-single-threaded-server-into-a-multithreaded-server"></a>
<a id="from-single-threaded-to-multithreaded-server"></a></p>
<h2 id="od-serwera-jednowÄ…tkowego-do-wielowÄ…tkowego"><a class="header" href="#od-serwera-jednowÄ…tkowego-do-wielowÄ…tkowego">Od serwera jednowÄ…tkowego do wielowÄ…tkowego</a></h2>
<p>Obecnie serwer bÄ™dzie przetwarzaÅ‚ kaÅ¼de Å¼Ä…danie po kolei, co oznacza, Å¼e nie przetworzy drugiego poÅ‚Ä…czenia, dopÃ³ki pierwsze poÅ‚Ä…czenie nie zostanie zakoÅ„czone. Gdyby serwer otrzymywaÅ‚ coraz wiÄ™cej Å¼Ä…daÅ„, to wykonanie sekwencyjne byÅ‚oby coraz mniej optymalne. JeÅ›li serwer otrzyma Å¼Ä…danie, ktÃ³rego przetwarzanie zajmuje duÅ¼o czasu, kolejne Å¼Ä…dania bÄ™dÄ… musiaÅ‚y czekaÄ‡, aÅ¼ dÅ‚ugie Å¼Ä…danie zostanie zakoÅ„czone, nawet jeÅ›li nowe Å¼Ä…dania mogÄ… byÄ‡ przetworzone szybko. BÄ™dziemy musieli to naprawiÄ‡, ale najpierw przyjrzymy siÄ™ problemowi w dziaÅ‚aniu.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="simulating-a-slow-request-in-the-current-server-implementation"></a></p>
<h3 id="symulacja-wolnego-Å¼Ä…dania"><a class="header" href="#symulacja-wolnego-Å¼Ä…dania">Symulacja wolnego Å¼Ä…dania</a></h3>
<p>Przyjrzymy siÄ™, jak wolno przetwarzane Å¼Ä…danie moÅ¼e wpÅ‚ywaÄ‡ na inne Å¼Ä…dania wysyÅ‚ane do naszej obecnej implementacji serwera. Listing 21-10 implementuje obsÅ‚ugÄ™ Å¼Ä…dania do <em>/sleep</em> z symulowanÄ… wolnÄ… odpowiedziÄ…, ktÃ³ra spowoduje, Å¼e serwer bÄ™dzie spaÅ‚ przez piÄ™Ä‡ sekund przed odpowiedziÄ….</p>
<listing number="21-10" file-name="src/main.rs" caption="Symulacja wolnego Å¼Ä…dania poprzez uÅ›pienie na piÄ™Ä‡ sekund">
<pre class="playground"><code class="language-rust no_run edition2024">use std::{
    fs,
    io::{BufReader, prelude::*},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn handle_connection(mut stream: TcpStream) {
    // --snip--

<span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span>    let (status_line, filename) = match &amp;request_line[..] {
        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
        "GET /sleep HTTP/1.1" =&gt; {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    // --snip--
<span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span>}</code></pre>
</listing>
<p>PrzeÅ‚Ä…czyliÅ›my siÄ™ z <code>if</code> na <code>match</code>, poniewaÅ¼ mamy teraz trzy przypadki. Musimy jawnie dopasowaÄ‡ do wycinka <code>request_line</code>, aby dopasowaÄ‡ wzorce do wartoÅ›ci literaÅ‚Ã³w ciÄ…gÃ³w znakÃ³w; <code>match</code> nie wykonuje automatycznego referencjonowania i dereferencjonowania, tak jak to robi metoda rÃ³wnoÅ›ci.</p>
<p>Pierwsze ramiÄ™ jest takie samo jak blok <code>if</code> z Listingu 21-9. Drugie ramiÄ™ pasuje do Å¼Ä…dania do <em>/sleep</em>. Po odebraniu tego Å¼Ä…dania serwer bÄ™dzie spaÅ‚ przez piÄ™Ä‡ sekund przed renderowaniem pomyÅ›lnej strony HTML. Trzecie ramiÄ™ jest takie samo jak blok <code>else</code> z Listingu 21-9.</p>
<p>MoÅ¼esz zobaczyÄ‡, jak prymitywny jest nasz serwer: prawdziwe biblioteki obsÅ‚ugiwaÅ‚yby rozpoznawanie wielu Å¼Ä…daÅ„ w znacznie mniej obszerny sposÃ³b!</p>
<p>Uruchom serwer za pomocÄ… <code>cargo run</code>. NastÄ™pnie otwÃ³rz dwa okna przeglÄ…darki: jedno dla <em>http://127.0.0.1:7878</em> i drugie dla <em>http://127.0.0.1:7878/sleep</em>. JeÅ›li wprowadzisz URI <em>/</em> kilka razy, jak poprzednio, zobaczysz, Å¼e odpowiada szybko. Ale jeÅ›li wprowadzisz <em>/sleep</em>, a nastÄ™pnie zaÅ‚adujesz <em>/</em>, zobaczysz, Å¼e <em>/</em> czeka, aÅ¼ <code>sleep</code> zakoÅ„czy swÃ³j peÅ‚ny piÄ™ciosekundowy czas, zanim zostanie zaÅ‚adowane.</p>
<p>Istnieje wiele technik, ktÃ³rych moglibyÅ›my uÅ¼yÄ‡, aby uniknÄ…Ä‡ kumulowania siÄ™ Å¼Ä…daÅ„ za wolnym Å¼Ä…daniem, w tym uÅ¼ycie async, jak zrobiliÅ›my to w Rozdziale 17; ta, ktÃ³rÄ… zaimplementujemy, to pula wÄ…tkÃ³w.</p>
<h3 id="zwiÄ™kszanie-przepustowoÅ›ci-za-pomocÄ…-puli-wÄ…tkÃ³w"><a class="header" href="#zwiÄ™kszanie-przepustowoÅ›ci-za-pomocÄ…-puli-wÄ…tkÃ³w">ZwiÄ™kszanie przepustowoÅ›ci za pomocÄ… puli wÄ…tkÃ³w</a></h3>
<p><em>Pula wÄ…tkÃ³w</em> to grupa uruchomionych wÄ…tkÃ³w, ktÃ³re sÄ… gotowe i czekajÄ… na obsÅ‚ugÄ™ zadania. Kiedy program otrzymuje nowe zadanie, przypisuje jeden z wÄ…tkÃ³w w puli do tego zadania, a ten wÄ…tek bÄ™dzie przetwarzaÅ‚ zadanie. PozostaÅ‚e wÄ…tki w puli sÄ… dostÄ™pne do obsÅ‚ugi wszelkich innych zadaÅ„, ktÃ³re nadejdÄ…, podczas gdy pierwszy wÄ…tek przetwarza. Kiedy pierwszy wÄ…tek zakoÅ„czy przetwarzanie swojego zadania, zostaje on zwrÃ³cony do puli bezczynnych wÄ…tkÃ³w, gotowy do obsÅ‚ugi nowego zadania. Pula wÄ…tkÃ³w pozwala na wspÃ³Å‚bieÅ¼ne przetwarzanie poÅ‚Ä…czeÅ„, zwiÄ™kszajÄ…c przepustowoÅ›Ä‡ serwera.</p>
<p>Ograniczymy liczbÄ™ wÄ…tkÃ³w w puli do niewielkiej liczby, aby chroniÄ‡ siÄ™ przed atakami DoS; gdyby nasz program tworzyÅ‚ nowy wÄ…tek dla kaÅ¼dego Å¼Ä…dania, gdy ono nadejdzie, ktoÅ›, kto wykona 10 milionÃ³w Å¼Ä…daÅ„ do naszego serwera, mÃ³gÅ‚by spowodowaÄ‡ chaos, zuÅ¼ywajÄ…c wszystkie zasoby naszego serwera i zatrzymujÄ…c przetwarzanie Å¼Ä…daÅ„.</p>
<p>Zamiast tworzyÄ‡ nieograniczonÄ… liczbÄ™ wÄ…tkÃ³w, bÄ™dziemy mieÄ‡ staÅ‚Ä… liczbÄ™ wÄ…tkÃ³w oczekujÄ…cych w puli. Å»Ä…dania, ktÃ³re nadejdÄ…, sÄ… wysyÅ‚ane do puli do przetworzenia. Pula bÄ™dzie utrzymywaÄ‡ kolejkÄ™ przychodzÄ…cych Å¼Ä…daÅ„. KaÅ¼dy z wÄ…tkÃ³w w puli pobierze Å¼Ä…danie z tej kolejki, obsÅ‚uÅ¼y je, a nastÄ™pnie poprosi kolejkÄ™ o kolejne Å¼Ä…danie. DziÄ™ki tej konstrukcji moÅ¼emy przetwarzaÄ‡ do <em><code>N</code></em> Å¼Ä…daÅ„ wspÃ³Å‚bieÅ¼nie, gdzie <em><code>N</code></em> to liczba wÄ…tkÃ³w. JeÅ›li kaÅ¼dy wÄ…tek odpowiada na dÅ‚ugotrwaÅ‚e Å¼Ä…danie, kolejne Å¼Ä…dania mogÄ… nadal gromadziÄ‡ siÄ™ w kolejce, ale zwiÄ™kszyliÅ›my liczbÄ™ dÅ‚ugotrwaÅ‚ych Å¼Ä…daÅ„, ktÃ³re moÅ¼emy obsÅ‚uÅ¼yÄ‡, zanim osiÄ…gniemy ten punkt.</p>
<p>Ta technika to tylko jeden z wielu sposobÃ³w na zwiÄ™kszenie przepustowoÅ›ci serwera WWW. Inne opcje, ktÃ³re moÅ¼esz zbadaÄ‡, to model fork/join, jednowÄ…tkowy model asynchronicznego I/O oraz wielowÄ…tkowy model asynchronicznego I/O. JeÅ›li interesuje CiÄ™ ten temat, moÅ¼esz poczytaÄ‡ wiÄ™cej o innych rozwiÄ…zaniach i sprÃ³bowaÄ‡ je zaimplementowaÄ‡; w jÄ™zyku niskiego poziomu, takim jak Rust, wszystkie te opcje sÄ… moÅ¼liwe.</p>
<p>Zanim zaczniemy implementowaÄ‡ pulÄ™ wÄ…tkÃ³w, porozmawiajmy o tym, jak powinno wyglÄ…daÄ‡ uÅ¼ycie puli. Kiedy prÃ³bujesz zaprojektowaÄ‡ kod, najpierw napisanie interfejsu klienta moÅ¼e pomÃ³c w kierowaniu twoim projektem. Napisz API kodu tak, aby byÅ‚o ono ustrukturyzowane w sposÃ³b, w jaki chcesz je wywoÅ‚aÄ‡; nastÄ™pnie zaimplementuj funkcjonalnoÅ›Ä‡ w ramach tej struktury, zamiast implementowaÄ‡ funkcjonalnoÅ›Ä‡, a nastÄ™pnie projektowaÄ‡ publiczne API.</p>
<p>Podobnie jak w Rozdziale 12 stosowaliÅ›my rozwÃ³j sterowany testami, tutaj zastosujemy rozwÃ³j sterowany kompilatorem. Napiszemy kod, ktÃ³ry wywoÅ‚uje poÅ¼Ä…dane funkcje, a nastÄ™pnie bÄ™dziemy analizowaÄ‡ bÅ‚Ä™dy kompilatora, aby okreÅ›liÄ‡, co powinniÅ›my zmieniÄ‡, aby kod zadziaÅ‚aÅ‚. Zanim to jednak zrobimy, zbadamy technikÄ™, ktÃ³rej nie bÄ™dziemy uÅ¼ywaÄ‡ jako punktu wyjÅ›cia.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="code-structure-if-we-could-spawn-a-thread-for-each-request"></a></p>
<h4 id="struktura-kodu-gdybyÅ›my-mogli-tworzyÄ‡-wÄ…tek-dla-kaÅ¼dego-Å¼Ä…dania"><a class="header" href="#struktura-kodu-gdybyÅ›my-mogli-tworzyÄ‡-wÄ…tek-dla-kaÅ¼dego-Å¼Ä…dania">Struktura kodu, gdybyÅ›my mogli tworzyÄ‡ wÄ…tek dla kaÅ¼dego Å¼Ä…dania</a></h4>
<p>Najpierw zbadajmy, jak nasz kod mÃ³gÅ‚by wyglÄ…daÄ‡, gdyby tworzyÅ‚ nowy wÄ…tek dla kaÅ¼dego poÅ‚Ä…czenia. Jak wspomniano wczeÅ›niej, nie jest to nasz ostateczny plan ze wzglÄ™du na problemy z potencjalnym tworzeniem nieograniczonej liczby wÄ…tkÃ³w, ale jest to punkt wyjÅ›cia do uzyskania najpierw dziaÅ‚ajÄ…cego serwera wielowÄ…tkowego. NastÄ™pnie dodamy pulÄ™ wÄ…tkÃ³w jako ulepszenie, a kontrastowanie obu rozwiÄ…zaÅ„ bÄ™dzie Å‚atwiejsze.</p>
<p>Listing 21-11 pokazuje zmiany, ktÃ³re naleÅ¼y wprowadziÄ‡ w funkcji <code>main</code>, aby utworzyÄ‡ nowy wÄ…tek do obsÅ‚ugi kaÅ¼dego strumienia w pÄ™tli <code>for</code>.</p>
<listing number="21-11" file-name="src/main.rs" caption="Tworzenie nowego wÄ…tku dla kaÅ¼dego strumienia">
<pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
</listing>
<p>Jak nauczyÅ‚eÅ› siÄ™ w Rozdziale 16, <code>thread::spawn</code> utworzy nowy wÄ…tek, a nastÄ™pnie uruchomi kod w zamkniÄ™ciu w nowym wÄ…tku. JeÅ›li uruchomisz ten kod i zaÅ‚adujesz <em>/sleep</em> w przeglÄ…darce, a nastÄ™pnie <em>/</em> w dwÃ³ch kolejnych zakÅ‚adkach przeglÄ…darki, faktycznie zobaczysz, Å¼e Å¼Ä…dania do <em>/</em> nie muszÄ… czekaÄ‡ na zakoÅ„czenie <em>/sleep</em>. Jednak, jak wspomnieliÅ›my, ostatecznie to przeciÄ…Å¼y system, poniewaÅ¼ tworzyÅ‚byÅ› nowe wÄ…tki bez Å¼adnego limitu.</p>
<p>MoÅ¼esz rÃ³wnieÅ¼ pamiÄ™taÄ‡ z RozdziaÅ‚u 17, Å¼e to jest dokÅ‚adnie ten rodzaj sytuacji, w ktÃ³rej async i await naprawdÄ™ bÅ‚yszczÄ…! Miej to na uwadze, gdy budujemy pulÄ™ wÄ…tkÃ³w i zastanawiamy siÄ™, jak wyglÄ…daÅ‚yby rzeczy inaczej lub tak samo z async.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-a-similar-interface-for-a-finite-number-of-threads"></a></p>
<h4 id="tworzenie-skoÅ„czonej-liczby-wÄ…tkÃ³w"><a class="header" href="#tworzenie-skoÅ„czonej-liczby-wÄ…tkÃ³w">Tworzenie skoÅ„czonej liczby wÄ…tkÃ³w</a></h4>
<p>Chcemy, aby nasza pula wÄ…tkÃ³w dziaÅ‚aÅ‚a w podobny, znajomy sposÃ³b, tak aby przejÅ›cie z wÄ…tkÃ³w na pulÄ™ wÄ…tkÃ³w nie wymagaÅ‚o duÅ¼ych zmian w kodzie, ktÃ³ry uÅ¼ywa naszego API. Listing 21-12 przedstawia hipotetyczny interfejs struktury <code>ThreadPool</code>, ktÃ³rej chcemy uÅ¼yÄ‡ zamiast <code>thread::spawn</code>.</p>
<listing number="21-12" file-name="src/main.rs" caption="Nasz idealny interfejs `ThreadPool`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
</listing>
<p>UÅ¼ywamy <code>ThreadPool::new</code> do utworzenia nowej puli wÄ…tkÃ³w z konfigurowalnÄ… liczbÄ… wÄ…tkÃ³w, w tym przypadku czterech. NastÄ™pnie, w pÄ™tli <code>for</code>, <code>pool.execute</code> ma podobny interfejs do <code>thread::spawn</code> w tym sensie, Å¼e przyjmuje zamkniÄ™cie, ktÃ³re pula powinna uruchomiÄ‡ dla kaÅ¼dego strumienia. Musimy zaimplementowaÄ‡ <code>pool.execute</code> tak, aby przyjmowaÅ‚ zamkniÄ™cie i przekazywaÅ‚ je do wÄ…tku w puli do uruchomienia. Ten kod jeszcze siÄ™ nie skompiluje, ale sprÃ³bujemy, aby kompilator mÃ³gÅ‚ nas poprowadziÄ‡, jak go naprawiÄ‡.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="building-the-threadpool-struct-using-compiler-driven-development"></a></p>
<h4 id="budowanie-threadpool-za-pomocÄ…-rozwoju-sterowanego-kompilatorem"><a class="header" href="#budowanie-threadpool-za-pomocÄ…-rozwoju-sterowanego-kompilatorem">Budowanie <code>ThreadPool</code> za pomocÄ… rozwoju sterowanego kompilatorem</a></h4>
<p>WprowadÅº zmiany z Listingu 21-12 do <em>src/main.rs</em>, a nastÄ™pnie uÅ¼yjmy bÅ‚Ä™dÃ³w kompilatora z <code>cargo check</code>, aby kierowaÄ‡ naszym rozwojem. Oto pierwszy bÅ‚Ä…d, ktÃ³ry otrzymujemy:</p>
<pre><code class="language-console">$ cargo check
    Sprawdzanie hello v0.1.0 (file:///projects/hello)
error[E0433]: nie udaÅ‚o siÄ™ rozwiÄ…zaÄ‡: uÅ¼ycie niezadeklarowanego typu `ThreadPool`
  --&gt; src/main.rs:11:16
   |
11 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ uÅ¼ycie niezadeklarowanego typu `ThreadPool`

WiÄ™cej informacji o tym bÅ‚Ä™dzie znajdziesz, uÅ¼ywajÄ…c `rustc --explain E0433`.
error: nie udaÅ‚o siÄ™ skompilowaÄ‡ `hello` (bin "hello") z powodu 1 poprzedniego bÅ‚Ä™du
</code></pre>
<p>Åšwietnie! Ten bÅ‚Ä…d mÃ³wi nam, Å¼e potrzebujemy typu lub moduÅ‚u <code>ThreadPool</code>, wiÄ™c teraz go zbudujemy. Nasza implementacja <code>ThreadPool</code> bÄ™dzie niezaleÅ¼na od rodzaju pracy, jakÄ… wykonuje nasz serwer WWW. Zatem, zmieÅ„my skrzynkÄ™ <code>hello</code> z skrzynki binarnej na skrzynkÄ™ biblioteki, aby przechowywaÄ‡ naszÄ… implementacjÄ™ <code>ThreadPool</code>. Po zmianie na skrzynkÄ™ biblioteki, moglibyÅ›my rÃ³wnieÅ¼ uÅ¼ywaÄ‡ oddzielnej biblioteki puli wÄ…tkÃ³w do dowolnej pracy, ktÃ³rÄ… chcemy wykonaÄ‡ za pomocÄ… puli wÄ…tkÃ³w, a nie tylko do obsÅ‚ugi Å¼Ä…daÅ„ WWW.</p>
<p>UtwÃ³rz plik <em>src/lib.rs</em> zawierajÄ…cy nastÄ™pujÄ…cÄ…, najprostszÄ… definicjÄ™ struktury <code>ThreadPool</code>, jakÄ… moÅ¼emy na razie mieÄ‡:</p>
<listing file-name="src/lib.rs">
<pre><code class="language-rust noplayground">pub struct ThreadPool;</code></pre>
</listing>
<p>NastÄ™pnie edytuj plik <em>main.rs</em>, aby wprowadziÄ‡ <code>ThreadPool</code> do zakresu z skrzynki biblioteki, dodajÄ…c nastÄ™pujÄ…cy kod na poczÄ…tku <em>src/main.rs</em>:</p>
<listing file-name="src/main.rs">
<pre><code class="language-rust ignore">use hello::ThreadPool;
<span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">    let pool = ThreadPool::new(4);
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        pool.execute(|| {
</span><span class="boring">            handle_connection(stream);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
</listing>
<p>Ten kod nadal nie bÄ™dzie dziaÅ‚aÄ‡, ale sprawdÅºmy go ponownie, aby otrzymaÄ‡ nastÄ™pny bÅ‚Ä…d, ktÃ³rym musimy siÄ™ zajÄ…Ä‡:</p>
<pre><code class="language-console">$ cargo check
    Sprawdzanie hello v0.1.0 (file:///projects/hello)
error[E0599]: nie znaleziono funkcji ani elementu stowarzyszonego o nazwie `new` dla struktury `ThreadPool` w bieÅ¼Ä…cym zakresie
  --&gt; src/main.rs:12:28
   |
12 |     let pool = ThreadPool::new(4);
   |                            ^^^ nie znaleziono funkcji ani elementu stowarzyszonego w `ThreadPool`

WiÄ™cej informacji o tym bÅ‚Ä™dzie znajdziesz, uÅ¼ywajÄ…c `rustc --explain E0599`.
error: nie udaÅ‚o siÄ™ skompilowaÄ‡ `hello` (bin "hello") z powodu 1 poprzedniego bÅ‚Ä™du
</code></pre>
<p>Ten bÅ‚Ä…d wskazuje, Å¼e nastÄ™pnym krokiem jest utworzenie stowarzyszonej funkcji o nazwie <code>new</code> dla <code>ThreadPool</code>. Wiemy rÃ³wnieÅ¼, Å¼e <code>new</code> musi mieÄ‡ jeden parametr, ktÃ³ry moÅ¼e przyjÄ…Ä‡ <code>4</code> jako argument i powinien zwracaÄ‡ instancjÄ™ <code>ThreadPool</code>. Zaimplementujmy najprostszÄ… funkcjÄ™ <code>new</code>, ktÃ³ra bÄ™dzie miaÅ‚a te cechy:</p>
<listing file-name="src/lib.rs">
<pre><code class="language-rust noplayground">pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}</code></pre>
</listing>
<p>WybraliÅ›my <code>usize</code> jako typ parametru <code>size</code>, poniewaÅ¼ wiemy, Å¼e ujemna liczba wÄ…tkÃ³w nie ma sensu. Wiemy rÃ³wnieÅ¼, Å¼e uÅ¼yjemy tej <code>4</code> jako liczby elementÃ³w w kolekcji wÄ…tkÃ³w, do czego sÅ‚uÅ¼y typ <code>usize</code>, jak omÃ³wiono w sekcji <a href="#integer-types">â€Typy caÅ‚kowiteâ€</a><!-- ignore --> w Rozdziale 3.</p>
<p>SprawdÅºmy ponownie kod:</p>
<pre><code class="language-console">$ cargo check
    Sprawdzanie hello v0.1.0 (file:///projects/hello)
error[E0599]: nie znaleziono metody o nazwie `execute` dla struktury `ThreadPool` w bieÅ¼Ä…cym zakresie
  --&gt; src/main.rs:17:14
   |
17 |         pool.execute(|| {
   |         -----^^^^^^^ nie znaleziono metody w `ThreadPool`

WiÄ™cej informacji o tym bÅ‚Ä™dzie znajdziesz, uÅ¼ywajÄ…c `rustc --explain E0599`.
error: nie udaÅ‚o siÄ™ skompilowaÄ‡ `hello` (bin "hello") z powodu 1 poprzedniego bÅ‚Ä™du
</code></pre>
<p>Teraz bÅ‚Ä…d wystÄ™puje, poniewaÅ¼ nie mamy metody <code>execute</code> na <code>ThreadPool</code>. Przypomnij sobie z sekcji <a href="#creating-a-finite-number-of-threads">â€Tworzenie skoÅ„czonej liczby wÄ…tkÃ³wâ€</a><!-- ignore -->, Å¼e zdecydowaliÅ›my, iÅ¼ nasza pula wÄ…tkÃ³w powinna mieÄ‡ interfejs podobny do <code>thread::spawn</code>. Ponadto, zaimplementujemy funkcjÄ™ <code>execute</code> tak, aby pobieraÅ‚a przekazane jej zamkniÄ™cie i oddawaÅ‚a je bezczynnemu wÄ…tkowi w puli do uruchomienia.</p>
<p>Zdefiniujemy metodÄ™ <code>execute</code> na <code>ThreadPool</code>, aby przyjmowaÅ‚a zamkniÄ™cie jako parametr. Przypomnij sobie z sekcji <a href="#moving-captured-values-out-of-closures">â€Przenoszenie przechwyconych wartoÅ›ci poza zamkniÄ™ciaâ€</a><!-- ignore --> w Rozdziale 13, Å¼e moÅ¼emy przyjmowaÄ‡ zamkniÄ™cia jako parametry z trzema rÃ³Å¼nymi cechami: <code>Fn</code>, <code>FnMut</code> i <code>FnOnce</code>. Musimy zdecydowaÄ‡, jaki rodzaj zamkniÄ™cia uÅ¼yÄ‡ tutaj. Wiemy, Å¼e skoÅ„czymy robiÄ…c coÅ› podobnego do implementacji <code>thread::spawn</code> z biblioteki standardowej, wiÄ™c moÅ¼emy spojrzeÄ‡ na ograniczenia, jakie ma sygnatura <code>thread::spawn</code> na swoim parametrze. Dokumentacja pokazuje nam nastÄ™pujÄ…ce:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p>Parametr typu <code>F</code> jest tym, ktÃ³ry nas tutaj interesuje; parametr typu <code>T</code> jest zwiÄ…zany z wartoÅ›ciÄ… zwracanÄ…, a tym siÄ™ nie zajmujemy. Widzimy, Å¼e <code>spawn</code> uÅ¼ywa <code>FnOnce</code> jako ograniczenia cechy dla <code>F</code>. To prawdopodobnie to, czego chcemy, poniewaÅ¼ ostatecznie przekaÅ¼emy argument, ktÃ³ry otrzymamy w <code>execute</code>, do <code>spawn</code>. MoÅ¼emy byÄ‡ jeszcze bardziej pewni, Å¼e <code>FnOnce</code> to cecha, ktÃ³rej chcemy uÅ¼yÄ‡, poniewaÅ¼ wÄ…tek do uruchomienia Å¼Ä…dania wykona zamkniÄ™cie tego Å¼Ä…dania tylko raz, co pasuje do <code>Once</code> w <code>FnOnce</code>.</p>
<p>Parametr typu <code>F</code> ma rÃ³wnieÅ¼ ograniczenie cechy <code>Send</code> i ograniczenie czasu Å¼ycia <code>'static</code>, ktÃ³re sÄ… przydatne w naszej sytuacji: potrzebujemy <code>Send</code> do przeniesienia zamkniÄ™cia z jednego wÄ…tku do drugiego oraz <code>'static</code>, poniewaÅ¼ nie wiemy, jak dÅ‚ugo wÄ…tek bÄ™dzie wykonywaÅ‚. StwÃ³rzmy metodÄ™ <code>execute</code> na <code>ThreadPool</code>, ktÃ³ra bÄ™dzie przyjmowaÄ‡ parametr generyczny typu <code>F</code> z tymi ograniczeniami:</p>
<listing file-name="src/lib.rs">
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        ThreadPool
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}</code></pre>
</listing>
<p>Nadal uÅ¼ywamy <code>()</code> po <code>FnOnce</code>, poniewaÅ¼ to <code>FnOnce</code> reprezentuje zamkniÄ™cie, ktÃ³re nie przyjmuje Å¼adnych parametrÃ³w i zwraca typ jednostkowy <code>()</code>. Podobnie jak w definicjach funkcji, typ zwracany moÅ¼e byÄ‡ pominiÄ™ty z sygnatury, ale nawet jeÅ›li nie mamy parametrÃ³w, nadal potrzebujemy nawiasÃ³w.</p>
<p>PowoÅ‚ujÄ…c siÄ™ na to, jest to najprostsza implementacja metody <code>execute</code>: nic nie robi, ale staramy siÄ™ tylko, aby nasz kod siÄ™ skompilowaÅ‚. SprawdÅºmy to ponownie:</p>
<pre><code class="language-console">$ cargo check
    Sprawdzanie hello v0.1.0 (file:///projects/hello)
    ZakoÅ„czono `dev` profil [nieoptymalny + debuginfo] cel(e) w 0.24s
</code></pre>
<p>Kompiluje siÄ™! Ale zwrÃ³Ä‡ uwagÄ™, Å¼e jeÅ›li sprÃ³bujesz <code>cargo run</code> i wyÅ›lesz Å¼Ä…danie w przeglÄ…darce, zobaczysz bÅ‚Ä™dy w przeglÄ…darce, ktÃ³re widzieliÅ›my na poczÄ…tku rozdziaÅ‚u. Nasza biblioteka jeszcze nie wywoÅ‚uje zamkniÄ™cia przekazanego do <code>execute</code>!</p>
<blockquote>
<p>Uwaga: Powiedzenie, ktÃ³re moÅ¼esz usÅ‚yszeÄ‡ o jÄ™zykach z rygorystycznymi kompilatorami, takich jak Haskell i Rust, brzmi: â€JeÅ›li kod siÄ™ kompiluje, to dziaÅ‚aâ€. Ale to powiedzenie nie jest uniwersalnie prawdziwe. Nasz projekt siÄ™ kompiluje, ale absolutnie nic nie robi! GdybyÅ›my budowali prawdziwy, kompletny projekt, byÅ‚by to dobry moment, aby zaczÄ…Ä‡ pisaÄ‡ testy jednostkowe, aby sprawdziÄ‡, czy kod siÄ™ kompiluje <em>i</em> ma poÅ¼Ä…dane zachowanie.</p>
</blockquote>
<p>ZastanÃ³w siÄ™: co byÅ‚oby tu inne, gdybyÅ›my zamiast zamkniÄ™cia wykonywali przyszÅ‚oÅ›Ä‡?</p>
<h4 id="walidacja-liczby-wÄ…tkÃ³w-w-new"><a class="header" href="#walidacja-liczby-wÄ…tkÃ³w-w-new">Walidacja liczby wÄ…tkÃ³w w <code>new</code></a></h4>
<p>Nic nie robimy z parametrami <code>new</code> i <code>execute</code>. Zaimplementujmy ciaÅ‚a tych funkcji z poÅ¼Ä…danym zachowaniem. Na poczÄ…tek pomyÅ›lmy o <code>new</code>. WczeÅ›niej wybraliÅ›my typ bez znaku dla parametru <code>size</code>, poniewaÅ¼ pula z ujemnÄ… liczbÄ… wÄ…tkÃ³w nie ma sensu. Jednak pula z zerowÄ… liczbÄ… wÄ…tkÃ³w rÃ³wnieÅ¼ nie ma sensu, a zero jest jak najbardziej prawidÅ‚owym <code>usize</code>. Dodamy kod, ktÃ³ry sprawdzi, czy <code>size</code> jest wiÄ™ksze od zera, zanim zwrÃ³cimy instancjÄ™ <code>ThreadPool</code>, i spowodujemy panikÄ™ programu, jeÅ›li otrzyma zero, uÅ¼ywajÄ…c makra <code>assert!</code>, jak pokazano na Listingu 21-13.</p>
<listing number="21-13" file-name="src/lib.rs" caption="Implementacja `ThreadPool::new` w celu paniki, jeÅ›li `size` wynosi zero">
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.
    ///
    /// `size` to liczba wÄ…tkÃ³w w puli.
    ///
    /// # Panics
    ///
    /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --snip--
<span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
</listing>
<p>DodaliÅ›my rÃ³wnieÅ¼ dokumentacjÄ™ dla naszego <code>ThreadPool</code> za pomocÄ… komentarzy doc. ZauwaÅ¼, Å¼e zastosowaliÅ›my dobre praktyki dokumentacyjne, dodajÄ…c sekcjÄ™, ktÃ³ra wskazuje sytuacje, w ktÃ³rych nasza funkcja moÅ¼e spowodowaÄ‡ panikÄ™, jak omÃ³wiono w Rozdziale 14. SprÃ³buj uruchomiÄ‡ <code>cargo doc --open</code> i kliknÄ…Ä‡ strukturÄ™ <code>ThreadPool</code>, aby zobaczyÄ‡, jak wyglÄ…dajÄ… wygenerowane dokumenty dla <code>new</code>!</p>
<p>Zamiast dodawaÄ‡ makro <code>assert!</code>, jak to zrobiliÅ›my tutaj, moglibyÅ›my zmieniÄ‡ <code>new</code> na <code>build</code> i zwrÃ³ciÄ‡ <code>Result</code>, tak jak zrobiliÅ›my to z <code>Config::build</code> w projekcie I/O w Listingu 12-9. Ale w tym przypadku zdecydowaliÅ›my, Å¼e prÃ³ba utworzenia puli wÄ…tkÃ³w bez Å¼adnych wÄ…tkÃ³w powinna byÄ‡ nieodwracalnym bÅ‚Ä™dem. JeÅ›li czujesz siÄ™ ambitny, sprÃ³buj napisaÄ‡ funkcjÄ™ o nazwie <code>build</code> z nastÄ™pujÄ…cÄ… sygnaturÄ…, aby porÃ³wnaÄ‡ jÄ… z funkcjÄ… <code>new</code>:</p>
<pre><code class="language-rust ignore">pub fn build(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {</code></pre>
<h4 id="tworzenie-miejsca-na-przechowywanie-wÄ…tkÃ³w"><a class="header" href="#tworzenie-miejsca-na-przechowywanie-wÄ…tkÃ³w">Tworzenie miejsca na przechowywanie wÄ…tkÃ³w</a></h4>
<p>Teraz, gdy wiemy, Å¼e mamy prawidÅ‚owÄ… liczbÄ™ wÄ…tkÃ³w do przechowywania w puli, moÅ¼emy utworzyÄ‡ te wÄ…tki i przechowywaÄ‡ je w strukturze <code>ThreadPool</code> przed zwrÃ³ceniem tej struktury. Ale jak â€przechowujemyâ€ wÄ…tek? SpÃ³jrzmy jeszcze raz na sygnaturÄ™ <code>thread::spawn</code>:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p>Funkcja <code>spawn</code> zwraca <code>JoinHandle&lt;T&gt;</code>, gdzie <code>T</code> to typ, ktÃ³ry zwraca zamkniÄ™cie. SprÃ³bujmy uÅ¼yÄ‡ <code>JoinHandle</code> i zobaczmy, co siÄ™ stanie. W naszym przypadku zamkniÄ™cia, ktÃ³re przekazujemy do puli wÄ…tkÃ³w, bÄ™dÄ… obsÅ‚ugiwaÄ‡ poÅ‚Ä…czenie i nic nie zwracaÄ‡, wiÄ™c <code>T</code> bÄ™dzie typem jednostkowym <code>()</code>.</p>
<p>Kod z Listingu 21-14 skompiluje siÄ™, ale jeszcze nie tworzy Å¼adnych wÄ…tkÃ³w. ZmieniliÅ›my definicjÄ™ <code>ThreadPool</code>, aby przechowywaÅ‚a wektor instancji <code>thread::JoinHandle&lt;()&gt;</code>, zainicjalizowaliÅ›my wektor o pojemnoÅ›ci <code>size</code>, skonfigurowaliÅ›my pÄ™tlÄ™ <code>for</code>, ktÃ³ra uruchomi kod do tworzenia wÄ…tkÃ³w, i zwrÃ³ciÅ‚a instancjÄ™ <code>ThreadPool</code> zawierajÄ…cÄ… je.</p>
<listing number="21-14" file-name="src/lib.rs" caption="Tworzenie wektora dla `ThreadPool` do przechowywania wÄ…tkÃ³w">
<pre><code class="language-rust ignore not_desired_behavior">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --snip--
<span class="boring">    /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.
</span><span class="boring">    ///
</span><span class="boring">    /// `size` to liczba wÄ…tkÃ³w w puli.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // utwÃ³rz kilka wÄ…tkÃ³w i zapisz je w wektorze
        }

        ThreadPool { threads }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
</listing>
<p>WprowadziliÅ›my <code>std::thread</code> do zakresu w skrzynce biblioteki, poniewaÅ¼ uÅ¼ywamy <code>thread::JoinHandle</code> jako typu elementÃ³w w wektorze w <code>ThreadPool</code>.</p>
<p>Po otrzymaniu prawidÅ‚owego rozmiaru, nasz <code>ThreadPool</code> tworzy nowy wektor, ktÃ³ry moÅ¼e przechowywaÄ‡ <code>size</code> elementÃ³w. Funkcja <code>with_capacity</code> wykonuje to samo zadanie co <code>Vec::new</code>, ale z waÅ¼nÄ… rÃ³Å¼nicÄ…: wstÄ™pnie alokuje miejsce w wektorze. PoniewaÅ¼ wiemy, Å¼e musimy przechowywaÄ‡ <code>size</code> elementÃ³w w wektorze, wykonanie tej alokacji z gÃ³ry jest nieco bardziej wydajne niÅ¼ uÅ¼ycie <code>Vec::new</code>, ktÃ³ry zmienia rozmiar w miarÄ™ wstawiania elementÃ³w.</p>
<p>Po ponownym uruchomieniu <code>cargo check</code> powinno siÄ™ udaÄ‡.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread"></a></p>
<h4 id="wysyÅ‚anie-kodu-z-threadpool-do-wÄ…tku"><a class="header" href="#wysyÅ‚anie-kodu-z-threadpool-do-wÄ…tku">WysyÅ‚anie kodu z <code>ThreadPool</code> do wÄ…tku</a></h4>
<p>ZostawiliÅ›my komentarz w pÄ™tli <code>for</code> w Listingu 21-14 dotyczÄ…cy tworzenia wÄ…tkÃ³w. Tutaj przyjrzymy siÄ™, jak faktycznie tworzymy wÄ…tki. Biblioteka standardowa zapewnia <code>thread::spawn</code> jako sposÃ³b tworzenia wÄ…tkÃ³w, a <code>thread::spawn</code> oczekuje kodu, ktÃ³ry wÄ…tek powinien uruchomiÄ‡ natychmiast po utworzeniu wÄ…tku. Jednak w naszym przypadku chcemy utworzyÄ‡ wÄ…tki i sprawiÄ‡, by <em>czekaÅ‚y</em> na kod, ktÃ³ry wyÅ›lemy pÃ³Åºniej. Implementacja wÄ…tkÃ³w w bibliotece standardowej nie zawiera sposobu, aby to zrobiÄ‡; musimy to zaimplementowaÄ‡ rÄ™cznie.</p>
<p>Zaimplementujemy to zachowanie, wprowadzajÄ…c nowÄ… strukturÄ™ danych miÄ™dzy <code>ThreadPool</code> a wÄ…tkami, ktÃ³ra bÄ™dzie zarzÄ…dzaÄ‡ tym nowym zachowaniem. Nazwiemy tÄ™ strukturÄ™ danych <em>Worker</em>, co jest powszechnym terminem w implementacjach puli. <code>Worker</code> pobiera kod, ktÃ³ry musi zostaÄ‡ uruchomiony, i uruchamia go w swoim wÄ…tku.</p>
<p>PomyÅ›l o ludziach pracujÄ…cych w kuchni w restauracji: pracownicy czekajÄ…, aÅ¼ przyjdÄ… zamÃ³wienia od klientÃ³w, a nastÄ™pnie sÄ… odpowiedzialni za przyjÄ™cie tych zamÃ³wieÅ„ i ich zrealizowanie.</p>
<p>Zamiast przechowywaÄ‡ wektor instancji <code>JoinHandle&lt;()&gt;</code> w puli wÄ…tkÃ³w, bÄ™dziemy przechowywaÄ‡ instancje struktury <code>Worker</code>. KaÅ¼dy <code>Worker</code> bÄ™dzie przechowywaÅ‚ pojedynczÄ… instancjÄ™ <code>JoinHandle&lt;()&gt;</code>. NastÄ™pnie zaimplementujemy metodÄ™ w <code>Worker</code>, ktÃ³ra przyjmie zamkniÄ™cie kodu do uruchomienia i wyÅ›le je do juÅ¼ dziaÅ‚ajÄ…cego wÄ…tku do wykonania. KaÅ¼demu <code>Workerowi</code> nadamy rÃ³wnieÅ¼ <code>id</code>, abyÅ›my mogli odrÃ³Å¼niÄ‡ rÃ³Å¼ne instancje <code>Worker</code> w puli podczas logowania lub debugowania.</p>
<p>Oto nowy proces, ktÃ³ry nastÄ…pi po utworzeniu <code>ThreadPool</code>. Kod, ktÃ³ry wysyÅ‚a zamkniÄ™cie do wÄ…tku, zaimplementujemy po skonfigurowaniu <code>Worker</code> w ten sposÃ³b:</p>
<ol>
<li>Zdefiniuj strukturÄ™ <code>Worker</code>, ktÃ³ra zawiera <code>id</code> i <code>JoinHandle&lt;()&gt;</code>.</li>
<li>ZmieÅ„ <code>ThreadPool</code>, aby zawieraÅ‚ wektor instancji <code>Worker</code>.</li>
<li>Zdefiniuj funkcjÄ™ <code>Worker::new</code>, ktÃ³ra przyjmuje numer <code>id</code> i zwraca instancjÄ™ <code>Worker</code> zawierajÄ…cÄ… <code>id</code> i wÄ…tek uruchomiony z pustym zamkniÄ™ciem.</li>
<li>W <code>ThreadPool::new</code> uÅ¼yj licznika pÄ™tli <code>for</code> do wygenerowania <code>id</code>, utwÃ³rz nowego <code>Worker</code> z tym <code>id</code> i przechowuj <code>Worker</code> w wektorze.</li>
</ol>
<p>JeÅ›li jesteÅ› gotowy na wyzwanie, sprÃ³buj samodzielnie zaimplementowaÄ‡ te zmiany, zanim spojrzysz na kod w Listingu 21-15.</p>
<p>Gotowy? Oto Listing 21-15 z jednym ze sposobÃ³w wprowadzenia powyÅ¼szych modyfikacji.</p>
<listing number="21-15" file-name="src/lib.rs" caption="Modyfikacja `ThreadPool` w celu przechowywania instancji `Worker` zamiast bezpoÅ›redniego przechowywania wÄ…tkÃ³w">
<pre><code class="language-rust noplayground">use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --snip--
<span class="boring">    /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.
</span><span class="boring">    ///
</span><span class="boring">    /// `size` to liczba wÄ…tkÃ³w w puli.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}</code></pre>
</listing>
<p>ZmieniliÅ›my nazwÄ™ pola w <code>ThreadPool</code> z <code>threads</code> na <code>workers</code>, poniewaÅ¼ teraz przechowuje ono instancje <code>Worker</code> zamiast instancji <code>JoinHandle&lt;()&gt;</code>. UÅ¼ywamy licznika w pÄ™tli <code>for</code> jako argumentu do <code>Worker::new</code> i przechowujemy kaÅ¼dego nowego <code>Worker</code> w wektorze o nazwie <code>workers</code>.</p>
<p>ZewnÄ™trzny kod (taki jak nasz serwer w <em>src/main.rs</em>) nie musi znaÄ‡ szczegÃ³Å‚Ã³w implementacji dotyczÄ…cych uÅ¼ywania struktury <code>Worker</code> w <code>ThreadPool</code>, dlatego sprawiamy, Å¼e struktura <code>Worker</code> i jej funkcja <code>new</code> sÄ… prywatne. Funkcja <code>Worker::new</code> uÅ¼ywa podanego przez nas <code>id</code> i przechowuje instancjÄ™ <code>JoinHandle&lt;()&gt;</code>, ktÃ³ra jest tworzona poprzez uruchomienie nowego wÄ…tku za pomocÄ… pustego zamkniÄ™cia.</p>
<blockquote>
<p>Uwaga: JeÅ›li system operacyjny nie moÅ¼e utworzyÄ‡ wÄ…tku z powodu niewystarczajÄ…cych zasobÃ³w systemowych, <code>thread::spawn</code> spowoduje panikÄ™. To spowoduje panikÄ™ caÅ‚ego naszego serwera, nawet jeÅ›li utworzenie niektÃ³rych wÄ…tkÃ³w moÅ¼e siÄ™ powieÅ›Ä‡. Dla uproszczenia, takie zachowanie jest w porzÄ…dku, ale w produkcyjnej implementacji puli wÄ…tkÃ³w prawdopodobnie chciaÅ‚byÅ› uÅ¼yÄ‡ <a href="../std/thread/struct.Builder.html"><code>std::thread::Builder</code></a><!-- ignore --> i jego metody <a href="../std/thread/struct.Builder.html#method.spawn"><code>spawn</code></a><!-- ignore -->, ktÃ³ra zamiast tego zwraca <code>Result</code>.</p>
</blockquote>
<p>Ten kod skompiluje siÄ™ i przechowuje liczbÄ™ instancji <code>Worker</code>, ktÃ³rÄ… okreÅ›liliÅ›my jako argument do <code>ThreadPool::new</code>. Ale <em>nadal</em> nie przetwarzamy zamkniÄ™cia, ktÃ³re otrzymujemy w <code>execute</code>. Przyjrzyjmy siÄ™, jak to zrobiÄ‡ w nastÄ™pnej kolejnoÅ›ci.</p>
<h4 id="wysyÅ‚anie-Å¼Ä…daÅ„-do-wÄ…tkÃ³w-za-poÅ›rednictwem-kanaÅ‚Ã³w"><a class="header" href="#wysyÅ‚anie-Å¼Ä…daÅ„-do-wÄ…tkÃ³w-za-poÅ›rednictwem-kanaÅ‚Ã³w">WysyÅ‚anie Å¼Ä…daÅ„ do wÄ…tkÃ³w za poÅ›rednictwem kanaÅ‚Ã³w</a></h4>
<p>NastÄ™pny problem, ktÃ³rym siÄ™ zajmiemy, to fakt, Å¼e zamkniÄ™cia przekazane do <code>thread::spawn</code> absolutnie nic nie robiÄ…. Obecnie zamkniÄ™cie, ktÃ³re chcemy wykonaÄ‡, otrzymujemy w metodzie <code>execute</code>. Ale musimy przekazaÄ‡ <code>thread::spawn</code> zamkniÄ™cie do uruchomienia, gdy tworzymy kaÅ¼dego <code>Worker</code> podczas tworzenia <code>ThreadPool</code>.</p>
<p>Chcemy, aby struktury <code>Worker</code>, ktÃ³re wÅ‚aÅ›nie utworzyliÅ›my, pobieraÅ‚y kod do uruchomienia z kolejki przechowywanej w <code>ThreadPool</code> i wysyÅ‚aÅ‚y ten kod do swojego wÄ…tku do wykonania.</p>
<p>KanaÅ‚y, o ktÃ³rych dowiedzieliÅ›my siÄ™ w Rozdziale 16 â€“ prosty sposÃ³b komunikacji miÄ™dzy dwoma wÄ…tkami â€“ byÅ‚yby idealne do tego zastosowania. UÅ¼yjemy kanaÅ‚u do peÅ‚nienia funkcji kolejki zadaÅ„, a <code>execute</code> wyÅ›le zadanie z <code>ThreadPool</code> do instancji <code>Worker</code>, ktÃ³re wyÅ›lÄ… zadanie do swojego wÄ…tku. Oto plan:</p>
<ol>
<li><code>ThreadPool</code> utworzy kanaÅ‚ i bÄ™dzie trzymaÄ‡ siÄ™ nadawcy.</li>
<li>KaÅ¼dy <code>Worker</code> bÄ™dzie trzymaÄ‡ siÄ™ odbiorcy.</li>
<li>Utworzymy nowÄ… strukturÄ™ <code>Job</code>, ktÃ³ra bÄ™dzie przechowywaÄ‡ zamkniÄ™cia, ktÃ³re chcemy wysÅ‚aÄ‡ kanaÅ‚em.</li>
<li>Metoda <code>execute</code> wyÅ›le zadanie, ktÃ³re chce wykonaÄ‡, za poÅ›rednictwem nadawcy.</li>
<li>W swoim wÄ…tku, <code>Worker</code> bÄ™dzie iterowaÅ‚ po swoim odbiorniku i wykonywaÅ‚ zamkniÄ™cia wszystkich otrzymanych zadaÅ„.</li>
</ol>
<p>Zacznijmy od utworzenia kanaÅ‚u w <code>ThreadPool::new</code> i przechowywania nadawcy w instancji <code>ThreadPool</code>, jak pokazano na Listingu 21-16. Struktura <code>Job</code> na razie nic nie przechowuje, ale bÄ™dzie typem elementu, ktÃ³ry wysyÅ‚amy kanaÅ‚em.</p>
<listing number="21-16" file-name="src/lib.rs" caption="Modyfikacja `ThreadPool` w celu przechowywania nadawcy kanaÅ‚u, ktÃ³ry przesyÅ‚a instancje `Job`">
<pre><code class="language-rust noplayground">use std::{sync::mpsc, thread};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --snip--
<span class="boring">    /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.
</span><span class="boring">    ///
</span><span class="boring">    /// `size` to liczba wÄ…tkÃ³w w puli.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</listing>
<p>W <code>ThreadPool::new</code> tworzymy nasz nowy kanaÅ‚ i sprawiamy, Å¼e pula przechowuje nadawcÄ™. To siÄ™ pomyÅ›lnie skompiluje.</p>
<p>SprÃ³bujmy przekazaÄ‡ odbiornik kanaÅ‚u do kaÅ¼dego <code>Worker</code>â€™a, gdy pula wÄ…tkÃ³w tworzy kanaÅ‚. Wiemy, Å¼e chcemy uÅ¼yÄ‡ odbiornika w wÄ…tku, ktÃ³ry uruchamiajÄ… instancje <code>Worker</code>, wiÄ™c odwoÅ‚amy siÄ™ do parametru <code>receiver</code> w zamkniÄ™ciu. Kod z Listingu 21-17 jeszcze siÄ™ nie skompiluje.</p>
<listing number="21-17" file-name="src/lib.rs" caption="Przekazywanie odbiornika do kaÅ¼dego `Worker`a">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{sync::mpsc, thread};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.
</span><span class="boring">    ///
</span><span class="boring">    /// `size` to liczba wÄ…tkÃ³w w puli.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}</code></pre>
</listing>
<p>WprowadziliÅ›my kilka maÅ‚ych i prostych zmian: przekazujemy odbiornik do <code>Worker::new</code>, a nastÄ™pnie uÅ¼ywamy go wewnÄ…trz zamkniÄ™cia.</p>
<p>Kiedy prÃ³bujemy sprawdziÄ‡ ten kod, otrzymujemy nastÄ™pujÄ…cy bÅ‚Ä…d:</p>
<pre><code class="language-console">$ cargo check
    Sprawdzanie hello v0.1.0 (file:///projects/hello)
error[E0382]: uÅ¼ycie przeniesionej wartoÅ›ci: `receiver`
  --&gt; src/lib.rs:26:42
   |
21 |         let (sender, receiver) = mpsc::channel();
   |                      -------- nastÄ™puje przeniesienie, poniewaÅ¼ `receiver` ma typ `std::sync::mpsc::Receiver&lt;Job&gt;`, ktÃ³ry nie implementuje cechy `Copy`
...
25 |         for id in 0..size {
   |         ----------------- wewnÄ…trz tej pÄ™tli
26 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ wartoÅ›Ä‡ przeniesiona tutaj, w poprzedniej iteracji pÄ™tli
   |
note: rozwaÅ¼ zmianÄ™ typu tego parametru w metodzie `new` na poÅ¼yczanie, jeÅ›li posiadanie wartoÅ›ci nie jest konieczne
  --&gt; src/lib.rs:47:33
   |
47 |     fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
   |        --- w tej metodzie       ^^^^^^^^^^^^^^^^^^^ ten parametr przejmuje wÅ‚asnoÅ›Ä‡ wartoÅ›ci
help: rozwaÅ¼ przeniesienie wyraÅ¼enia poza pÄ™tlÄ™, aby byÅ‚o przeniesione tylko raz
   |
25 ~         let mut value = Worker::new(id, receiver);
26 ~         for id in 0..size {
27 ~             workers.push(value);
   |

WiÄ™cej informacji o tym bÅ‚Ä™dzie znajdziesz, uÅ¼ywajÄ…c `rustc --explain E0382`.
error: nie udaÅ‚o siÄ™ skompilowaÄ‡ `hello` (lib) z powodu 1 poprzedniego bÅ‚Ä™du
</code></pre>
<p>Kod prÃ³buje przekazaÄ‡ <code>receiver</code> do wielu instancji <code>Worker</code>. To nie zadziaÅ‚a, jak pamiÄ™tacie z RozdziaÅ‚u 16: implementacja kanaÅ‚u dostarczana przez Rusta to kanaÅ‚ wielu <em>producentÃ³w</em>, jednego <em>konsumenta</em>. Oznacza to, Å¼e nie moÅ¼emy po prostu sklonowaÄ‡ koÅ„ca konsumujÄ…cego kanaÅ‚u, aby naprawiÄ‡ ten kod. Nie chcemy rÃ³wnieÅ¼ wysyÅ‚aÄ‡ wiadomoÅ›ci wielokrotnie do wielu konsumentÃ³w; chcemy jednej listy wiadomoÅ›ci z wieloma instancjami <code>Worker</code>, tak aby kaÅ¼da wiadomoÅ›Ä‡ byÅ‚a przetwarzana raz.</p>
<p>Dodatkowo, pobieranie zadania z kolejki kanaÅ‚u wiÄ…Å¼e siÄ™ z mutacjÄ… <code>receiver</code>, wiÄ™c wÄ…tki potrzebujÄ… bezpiecznego sposobu na wspÃ³Å‚dzielenie i modyfikowanie <code>receiver</code>; w przeciwnym razie mogÄ… wystÄ…piÄ‡ warunki wyÅ›cigu (omÃ³wione w Rozdziale 16).</p>
<p>Przypomnij sobie inteligentne wskaÅºniki bezpieczne dla wÄ…tkÃ³w omÃ³wione w Rozdziale 16: Aby wspÃ³Å‚dzieliÄ‡ wÅ‚asnoÅ›Ä‡ miÄ™dzy wieloma wÄ…tkami i umoÅ¼liwiÄ‡ wÄ…tkom mutacjÄ™ wartoÅ›ci, musimy uÅ¼yÄ‡ <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. Typ <code>Arc</code> pozwoli wielu instancjom <code>Worker</code> posiadaÄ‡ odbiornik, a <code>Mutex</code> zapewni, Å¼e tylko jeden <code>Worker</code> pobierze zadanie z odbiornika na raz. Listing 21-18 pokazuje zmiany, ktÃ³re musimy wprowadziÄ‡.</p>
<listing number="21-18" file-name="src/lib.rs" caption="WspÃ³Å‚dzielenie odbiornika miÄ™dzy instancjami `Worker` za pomocÄ… `Arc` i `Mutex`">
<pre><code class="language-rust noplayground">use std::{
    sync::{Arc, Mutex, mpsc},
    thread,
};
// --snip--

<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.
</span><span class="boring">    ///
</span><span class="boring">    /// `size` to liczba wÄ…tkÃ³w w puli.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--
<span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span>    }
}</code></pre>
</listing>
<p>W <code>ThreadPool::new</code> umieszczamy odbiornik w <code>Arc</code> i <code>Mutex</code>. Dla kaÅ¼dego nowego <code>Worker</code>, klonujemy <code>Arc</code>, aby zwiÄ™kszyÄ‡ licznik referencji, tak aby instancje <code>Worker</code> mogÅ‚y wspÃ³Å‚dzieliÄ‡ wÅ‚asnoÅ›Ä‡ odbiornika.</p>
<p>DziÄ™ki tym zmianom kod siÄ™ kompiluje! Coraz bliÅ¼ej!</p>
<h4 id="implementacja-metody-execute"><a class="header" href="#implementacja-metody-execute">Implementacja metody <code>execute</code></a></h4>
<p>Zaimplementujmy w koÅ„cu metodÄ™ <code>execute</code> na <code>ThreadPool</code>. Zmienimy rÃ³wnieÅ¼ <code>Job</code> ze struktury na alias typu dla obiektu cechy, ktÃ³ry przechowuje typ zamkniÄ™cia, ktÃ³ry otrzymuje <code>execute</code>. Jak omÃ³wiono w sekcji <a href="#type-synonyms-and-type-aliases">â€Synonimy typÃ³w i aliasy typÃ³wâ€</a><!-- ignore --> w Rozdziale 20, aliasy typÃ³w pozwalajÄ… nam skracaÄ‡ dÅ‚ugie typy dla uÅ‚atwienia uÅ¼ytkowania. SpÃ³jrz na Listing 21-19.</p>
<listing number="21-19" file-name="src/lib.rs" caption="Tworzenie aliasu typu `Job` dla `Box`a, ktÃ³ry przechowuje kaÅ¼de zamkniÄ™cie, a nastÄ™pnie wysyÅ‚anie zadania kanaÅ‚em">
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{Arc, Mutex, mpsc},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --snip--
<span class="boring">    /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.
</span><span class="boring">    ///
</span><span class="boring">    /// `size` to liczba wÄ…tkÃ³w w puli.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span>
    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</listing>
<p>Po utworzeniu nowej instancji <code>Job</code> za pomocÄ… zamkniÄ™cia, ktÃ³re otrzymujemy w <code>execute</code>, wysyÅ‚amy to zadanie przez koniec wysyÅ‚ajÄ…cy kanaÅ‚u. WywoÅ‚ujemy <code>unwrap</code> na <code>send</code> w przypadku, gdy wysyÅ‚anie siÄ™ nie powiedzie. MoÅ¼e siÄ™ to zdarzyÄ‡, jeÅ›li na przykÅ‚ad zatrzymamy wszystkie nasze wÄ…tki od wykonywania, co oznacza, Å¼e koniec odbierajÄ…cy przestaÅ‚ odbieraÄ‡ nowe wiadomoÅ›ci. W tej chwili nie moÅ¼emy zatrzymaÄ‡ naszych wÄ…tkÃ³w od wykonywania: nasze wÄ…tki kontynuujÄ… wykonywanie tak dÅ‚ugo, jak dÅ‚ugo istnieje pula. Powodem, dla ktÃ³rego uÅ¼ywamy <code>unwrap</code>, jest to, Å¼e wiemy, Å¼e przypadek bÅ‚Ä™du siÄ™ nie zdarzy, ale kompilator tego nie wie.</p>
<p>Ale jeszcze nie skoÅ„czyliÅ›my! W <code>Worker</code>, nasze zamkniÄ™cie przekazywane do <code>thread::spawn</code> nadal tylko <em>referuje</em> koniec odbiorczy kanaÅ‚u. Zamiast tego, potrzebujemy, aby zamkniÄ™cie zapÄ™tlaÅ‚o siÄ™ w nieskoÅ„czonoÅ›Ä‡, proszÄ…c koniec odbiorczy kanaÅ‚u o zadanie i uruchamiajÄ…c zadanie, gdy je otrzyma. WprowadÅºmy zmianÄ™ pokazanÄ… na Listingu 21-20 w <code>Worker::new</code>.</p>
<listing number="21-20" file-name="src/lib.rs" caption="Odbieranie i wykonywanie zadaÅ„ w wÄ…tku instancji `Worker`">
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{Arc, Mutex, mpsc},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.
</span><span class="boring">    ///
</span><span class="boring">    /// `size` to liczba wÄ…tkÃ³w w puli.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let job = receiver.lock().unwrap().recv().unwrap();

                println!("Worker {id} otrzymaÅ‚ zadanie; wykonujÄ™.");

                job();
            }
        });

        Worker { id, thread }
    }
}</code></pre>
</listing>
<p>Tutaj najpierw wywoÅ‚ujemy <code>lock</code> na <code>receiver</code>, aby uzyskaÄ‡ muteks, a nastÄ™pnie wywoÅ‚ujemy <code>unwrap</code>, aby spowodowaÄ‡ panikÄ™ w przypadku bÅ‚Ä™dÃ³w. Uzyskanie blokady moÅ¼e zakoÅ„czyÄ‡ siÄ™ niepowodzeniem, jeÅ›li muteks jest w stanie <em>zatrucia</em>, co moÅ¼e siÄ™ zdarzyÄ‡, jeÅ›li jakiÅ› inny wÄ…tek panikowaÅ‚, trzymajÄ…c blokadÄ™, zamiast jÄ… zwolniÄ‡. W tej sytuacji wywoÅ‚anie <code>unwrap</code> w celu spowodowania paniki tego wÄ…tku jest prawidÅ‚owym dziaÅ‚aniem. MoÅ¼esz zmieniÄ‡ to <code>unwrap</code> na <code>expect</code> z komunikatem o bÅ‚Ä™dzie, ktÃ³ry jest dla ciebie sensowny.</p>
<p>JeÅ›li uzyskamy blokadÄ™ na muteksie, wywoÅ‚ujemy <code>recv</code>, aby otrzymaÄ‡ <code>Job</code> z kanaÅ‚u. Ostateczny <code>unwrap</code> rÃ³wnieÅ¼ tutaj pomija wszelkie bÅ‚Ä™dy, ktÃ³re mogÄ… wystÄ…piÄ‡, jeÅ›li wÄ…tek posiadajÄ…cy nadawcÄ™ zostaÅ‚ zamkniÄ™ty, podobnie jak metoda <code>send</code> zwraca <code>Err</code>, jeÅ›li odbiornik zostanie zamkniÄ™ty.</p>
<p>WywoÅ‚anie <code>recv</code> blokuje, wiÄ™c jeÅ›li nie ma jeszcze zadania, bieÅ¼Ä…cy wÄ…tek bÄ™dzie czekaÅ‚, aÅ¼ zadanie stanie siÄ™ dostÄ™pne. <code>Mutex&lt;T&gt;</code> zapewnia, Å¼e tylko jeden wÄ…tek <code>Worker</code> w danym momencie prÃ³buje zaÅ¼Ä…daÄ‡ zadania.</p>
<p>Nasza pula wÄ…tkÃ³w jest teraz w stanie dziaÅ‚ajÄ…cym! Uruchom jÄ… za pomocÄ… <code>cargo run</code> i wyÅ›lij kilka Å¼Ä…daÅ„:</p>
<!-- manual-regeneration
cd listings/ch21-web-server/listing-21-20
cargo run
wyÅ›lij kilka Å¼Ä…daÅ„ na 127.0.0.1:7878
Nie moÅ¼na zautomatyzowaÄ‡, poniewaÅ¼ wynik zaleÅ¼y od wysyÅ‚ania Å¼Ä…daÅ„
-->
<pre><code class="language-console">$ cargo run
   Kompilowanie hello v0.1.0 (file:///projects/hello)
warning: pole `workers` nigdy nie jest odczytywane
 --&gt; src/lib.rs:7:5
  |
6 | pub struct ThreadPool {
  |            ---------- pole w tej strukturze
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^
  |
  = note: `#[warn(dead_code)]` domyÅ›lnie wÅ‚Ä…czone

warning: pola `id` i `thread` nigdy nie sÄ… odczytywane
  --&gt; src/lib.rs:48:5
   |
47 | struct Worker {
   |        ------ pola w tej strukturze
48 |     id: usize,
   |     ^^
49 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^

warning: `hello` (lib) wygenerowaÅ‚o 2 ostrzeÅ¼enia
    ZakoÅ„czono `dev` profil [nieoptymalny + debuginfo] cel(e) w 4.91s
     Uruchamianie `target/debug/hello`
Worker 0 otrzymaÅ‚ zadanie; wykonujÄ™.
Worker 2 otrzymaÅ‚ zadanie; wykonujÄ™.
Worker 1 otrzymaÅ‚ zadanie; wykonujÄ™.
Worker 3 otrzymaÅ‚ zadanie; wykonujÄ™.
Worker 0 otrzymaÅ‚ zadanie; wykonujÄ™.
Worker 2 otrzymaÅ‚ zadanie; wykonujÄ™.
Worker 1 otrzymaÅ‚ zadanie; wykonujÄ™.
Worker 3 otrzymaÅ‚ zadanie; wykonujÄ™.
Worker 0 otrzymaÅ‚ zadanie; wykonujÄ™.
Worker 2 otrzymaÅ‚ zadanie; wykonujÄ™.
</code></pre>
<p>Sukces! Mamy teraz pulÄ™ wÄ…tkÃ³w, ktÃ³ra wykonuje poÅ‚Ä…czenia asynchronicznie. Nigdy nie jest tworzonych wiÄ™cej niÅ¼ cztery wÄ…tki, wiÄ™c nasz system nie zostanie przeciÄ…Å¼ony, jeÅ›li serwer otrzyma wiele Å¼Ä…daÅ„. JeÅ›li wyÅ›lemy Å¼Ä…danie do <em>/sleep</em>, serwer bÄ™dzie mÃ³gÅ‚ obsÅ‚uÅ¼yÄ‡ inne Å¼Ä…dania, zlecajÄ…c je innym wÄ…tkom.</p>
<blockquote>
<p>Uwaga: JeÅ›li otworzysz <em>/sleep</em> w wielu oknach przeglÄ…darki jednoczeÅ›nie, mogÄ… siÄ™ Å‚adowaÄ‡ po kolei w piÄ™ciosekundowych odstÄ™pach. NiektÃ³re przeglÄ…darki internetowe wykonujÄ… wiele instancji tego samego Å¼Ä…dania sekwencyjnie z powodÃ³w buforowania. To ograniczenie nie jest spowodowane przez nasz serwer WWW.</p>
</blockquote>
<p>To dobry moment, aby zatrzymaÄ‡ siÄ™ i zastanowiÄ‡, jak kod z ListingÃ³w 21-18, 21-19 i 21-20 rÃ³Å¼niÅ‚by siÄ™, gdybyÅ›my uÅ¼ywali przyszÅ‚oÅ›ci zamiast zamkniÄ™cia dla wykonywanej pracy. Jakie typy ulegÅ‚yby zmianie? Jak rÃ³Å¼niÅ‚yby siÄ™ sygnatury metod, jeÅ›li w ogÃ³le? Jakie czÄ™Å›ci kodu pozostaÅ‚yby takie same?</p>
<p>Po zapoznaniu siÄ™ z pÄ™tlÄ… <code>while let</code> w Rozdziale 17 i Rozdziale 19, moÅ¼esz siÄ™ zastanawiaÄ‡, dlaczego nie napisaliÅ›my kodu wÄ…tku <code>Worker</code>, jak pokazano na Listingu 21-21.</p>
<listing number="21-21" file-name="src/lib.rs" caption="Alternatywna implementacja `Worker::new` za pomocÄ… `while let`">
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{Arc, Mutex, mpsc},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.
</span><span class="boring">    ///
</span><span class="boring">    /// `size` to liczba wÄ…tkÃ³w w puli.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span>// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!("Worker {id} otrzymaÅ‚ zadanie; wykonujÄ™.");

                job();
            }
        });

        Worker { id, thread }
    }
}</code></pre>
</listing>
<p>Ten kod kompiluje siÄ™ i dziaÅ‚a, ale nie prowadzi do poÅ¼Ä…danego zachowania wÄ…tkowoÅ›ci: wolne Å¼Ä…danie nadal bÄ™dzie powodowaÄ‡, Å¼e inne Å¼Ä…dania bÄ™dÄ… czekaÄ‡ na przetworzenie. PowÃ³d jest nieco subtelny: struktura <code>Mutex</code> nie ma publicznej metody <code>unlock</code>, poniewaÅ¼ wÅ‚asnoÅ›Ä‡ blokady opiera siÄ™ na czasie Å¼ycia <code>MutexGuard&lt;T&gt;</code> wewnÄ…trz <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code>, ktÃ³re zwraca metoda <code>lock</code>. W czasie kompilacji, checker poÅ¼yczeÅ„ moÅ¼e wymusiÄ‡ zasadÄ™, Å¼e zasÃ³b chroniony przez <code>Mutex</code> nie moÅ¼e byÄ‡ dostÄ™pny, chyba Å¼e posiadamy blokadÄ™. Jednak ta implementacja moÅ¼e rÃ³wnieÅ¼ spowodowaÄ‡, Å¼e blokada bÄ™dzie utrzymywana dÅ‚uÅ¼ej niÅ¼ zamierzono, jeÅ›li nie bÄ™dziemy pamiÄ™taÄ‡ o czasie Å¼ycia <code>MutexGuard&lt;T&gt;</code>.</p>
<p>Kod z Listingu 21-20, ktÃ³ry uÅ¼ywa <code>let job = receiver.lock().unwrap().recv().unwrap();</code> dziaÅ‚a, poniewaÅ¼ w przypadku <code>let</code>, wszelkie tymczasowe wartoÅ›ci uÅ¼yte w wyraÅ¼eniu po prawej stronie znaku rÃ³wnoÅ›ci sÄ… natychmiast usuwane, gdy koÅ„czy siÄ™ instrukcja <code>let</code>. Jednak <code>while let</code> (oraz <code>if let</code> i <code>match</code>) nie usuwa tymczasowych wartoÅ›ci aÅ¼ do koÅ„ca powiÄ…zanego bloku. W Listingu 21-21 blokada pozostaje w posiadaniu przez caÅ‚y czas trwania wywoÅ‚ania <code>job()</code>, co oznacza, Å¼e inne instancje <code>Worker</code> nie mogÄ… odbieraÄ‡ zadaÅ„.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="delikatne-zamykanie-i-sprzÄ…tanie-1"><a href="#delikatne-zamykanie-i-sprzÄ…tanie-1" class="header">Delikatne zamykanie i sprzÄ…tanie</a></h1>
<h2 id="delikatne-zamykanie-i-sprzÄ…tanie"><a class="header" href="#delikatne-zamykanie-i-sprzÄ…tanie">Delikatne zamykanie i sprzÄ…tanie</a></h2>
<p>Kod z Listingu 21-20 odpowiada na Å¼Ä…dania asynchronicznie, uÅ¼ywajÄ…c puli wÄ…tkÃ³w, tak jak zamierzaliÅ›my. Otrzymujemy kilka ostrzeÅ¼eÅ„ o polach <code>workers</code>, <code>id</code> i <code>thread</code>, ktÃ³rych nie uÅ¼ywamy w bezpoÅ›redni sposÃ³b, co przypomina nam, Å¼e nic nie sprzÄ…tamy. Gdy uÅ¼yjemy mniej eleganckiej metody <kbd>ctrl</kbd>-<kbd>C</kbd> do zatrzymania gÅ‚Ã³wnego wÄ…tku, wszystkie inne wÄ…tki sÄ… natychmiast zatrzymywane, nawet jeÅ›li sÄ… w trakcie obsÅ‚ugi Å¼Ä…dania.</p>
<p>NastÄ™pnie zaimplementujemy cechÄ™ <code>Drop</code>, aby wywoÅ‚aÄ‡ <code>join</code> dla kaÅ¼dego z wÄ…tkÃ³w w puli, aby mogÅ‚y zakoÅ„czyÄ‡ pracÄ™ nad Å¼Ä…daniami, zanim siÄ™ zamknÄ…. NastÄ™pnie zaimplementujemy sposÃ³b, aby poinformowaÄ‡ wÄ…tki, Å¼e powinny przestaÄ‡ akceptowaÄ‡ nowe Å¼Ä…dania i zamknÄ…Ä‡ siÄ™. Aby zobaczyÄ‡ ten kod w akcji, zmodyfikujemy nasz serwer, aby akceptowaÅ‚ tylko dwa Å¼Ä…dania przed delikatnym zamkniÄ™ciem puli wÄ…tkÃ³w.</p>
<p>Jedna rzecz do zauwaÅ¼enia, gdy bÄ™dziemy postÄ™powaÄ‡: nic z tego nie wpÅ‚ywa na czÄ™Å›ci kodu, ktÃ³re obsÅ‚ugujÄ… wykonywanie zamkniÄ™Ä‡, wiÄ™c wszystko tutaj byÅ‚oby takie samo, gdybyÅ›my uÅ¼ywali puli wÄ…tkÃ³w do asynchronicznego Å›rodowiska uruchomieniowego.</p>
<h3 id="implementacja-cechy-drop-dla-threadpool"><a class="header" href="#implementacja-cechy-drop-dla-threadpool">Implementacja cechy <code>Drop</code> dla <code>ThreadPool</code></a></h3>
<p>Zacznijmy od zaimplementowania <code>Drop</code> dla naszej puli wÄ…tkÃ³w. Kiedy pula zostanie zrzucona, wszystkie nasze wÄ…tki powinny siÄ™ poÅ‚Ä…czyÄ‡, aby upewniÄ‡ siÄ™, Å¼e zakoÅ„czyÅ‚y swojÄ… pracÄ™. Listing 21-22 pokazuje pierwszÄ… prÃ³bÄ™ implementacji <code>Drop</code>; ten kod jeszcze nie bÄ™dzie dziaÅ‚aÅ‚ poprawnie.</p>
<listing number="21-22" file-name="src/lib.rs" caption="ÅÄ…czenie kaÅ¼dego wÄ…tku, gdy pula wÄ…tkÃ³w wychodzi poza zakres">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{Arc, Mutex, mpsc},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.
</span><span class="boring">    ///
</span><span class="boring">    /// `size` to liczba wÄ…tkÃ³w w puli.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!("Zamykanie wÄ…tku roboczego {}", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || {
</span><span class="boring">            loop {
</span><span class="boring">                let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">                println!("Worker {id} otrzymaÅ‚ zadanie; wykonujÄ™.");
</span><span class="boring">
</span><span class="boring">                job();
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</listing>
<p>Najpierw przechodzimy przez kaÅ¼dego z <code>workerÃ³w</code> puli wÄ…tkÃ³w. UÅ¼ywamy <code>&amp;mut</code> do tego, poniewaÅ¼ <code>self</code> jest mutowalnÄ… referencjÄ…, a my musimy rÃ³wnieÅ¼ byÄ‡ w stanie mutowaÄ‡ <code>worker</code>. Dla kaÅ¼dego <code>worker</code>a, drukujemy komunikat informujÄ…cy, Å¼e ta konkretna instancja <code>Worker</code> jest zamykana, a nastÄ™pnie wywoÅ‚ujemy <code>join</code> na wÄ…tku tej instancji <code>Worker</code>. JeÅ›li wywoÅ‚anie <code>join</code> zakoÅ„czy siÄ™ niepowodzeniem, uÅ¼ywamy <code>unwrap</code>, aby Rust panikowaÅ‚ i przeszedÅ‚ w stan nieÅ‚askawego zamkniÄ™cia.</p>
<p>Oto bÅ‚Ä…d, ktÃ³ry otrzymujemy podczas kompilacji tego kodu:</p>
<pre><code class="language-console">$ cargo check
    Sprawdzanie hello v0.1.0 (file:///projects/hello)
error[E0507]: nie moÅ¼na przenieÅ›Ä‡ z `worker.thread`, ktÃ³ry znajduje siÄ™ za mutowalnÄ… referencjÄ…
  --&gt; src/lib.rs:52:13
   |
52 |             worker.thread.join().unwrap();
   |             ^^^^^^^^^^^^^ ------ `worker.thread` przeniesiony z powodu wywoÅ‚ania tej metody
   |             |
   |             przeniesienie nastÄ™puje, poniewaÅ¼ `worker.thread` ma typ `JoinHandle&lt;()&gt;`, ktÃ³ry nie implementuje cechy `Copy`
   |
note: `JoinHandle::&lt;T&gt;::join` przejmuje wÅ‚asnoÅ›Ä‡ odbiornika `self`, co przenosi `worker.thread`
  --&gt; /rustc/1159e78c4747b02ef996e55082b704c09b970588/library/std/src/thread/mod.rs:1921:17

WiÄ™cej informacji o tym bÅ‚Ä™dzie znajdziesz, uÅ¼ywajÄ…c `rustc --explain E0507`.
error: nie udaÅ‚o siÄ™ skompilowaÄ‡ `hello` (lib) z powodu 1 poprzedniego bÅ‚Ä™du
</code></pre>
<p>BÅ‚Ä…d mÃ³wi nam, Å¼e nie moÅ¼emy wywoÅ‚aÄ‡ <code>join</code>, poniewaÅ¼ mamy tylko mutowalne poÅ¼yczenie kaÅ¼dego <code>worker</code>a, a <code>join</code> przejmuje wÅ‚asnoÅ›Ä‡ swojego argumentu. Aby rozwiÄ…zaÄ‡ ten problem, musimy przenieÅ›Ä‡ wÄ…tek z instancji <code>Worker</code>, ktÃ³ra jest wÅ‚aÅ›cicielem <code>thread</code>, tak aby <code>join</code> mogÅ‚o zuÅ¼yÄ‡ wÄ…tek. Jednym ze sposobÃ³w jest zastosowanie tego samego podejÅ›cia, ktÃ³re przyjÄ™liÅ›my w Listingu 18-15. Gdyby <code>Worker</code> zawieraÅ‚ <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code>, moglibyÅ›my wywoÅ‚aÄ‡ metodÄ™ <code>take</code> na <code>Option</code>, aby przenieÅ›Ä‡ wartoÅ›Ä‡ z wariantu <code>Some</code> i pozostawiÄ‡ wariant <code>None</code> na jego miejscu. Innymi sÅ‚owy, dziaÅ‚ajÄ…cy <code>Worker</code> miaÅ‚by wariant <code>Some</code> w <code>thread</code>, a gdybyÅ›my chcieli posprzÄ…taÄ‡ <code>Worker</code>a, zastÄ…pilibyÅ›my <code>Some</code> przez <code>None</code>, aby <code>Worker</code> nie miaÅ‚ wÄ…tku do uruchomienia.</p>
<p>JednakÅ¼e, <em>jedynym</em> momentem, kiedy to by siÄ™ pojawiÅ‚o, byÅ‚oby zrzucanie <code>Worker</code>a. W zamian, musielibyÅ›my radziÄ‡ sobie z <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code> wszÄ™dzie, gdzie uzyskiwaliÅ›my dostÄ™p do <code>worker.thread</code>. Idiomatyczny Rust czÄ™sto uÅ¼ywa <code>Option</code>, ale gdy zauwaÅ¼ysz, Å¼e opakowujesz coÅ›, co wiesz, Å¼e zawsze bÄ™dzie obecne, w <code>Option</code> jako obejÅ›cie, to dobrym pomysÅ‚em jest poszukanie alternatywnych podejÅ›Ä‡, aby uczyniÄ‡ kod czystszym i mniej podatnym na bÅ‚Ä™dy.</p>
<p>W tym przypadku istnieje lepsza alternatywa: metoda <code>Vec::drain</code>. Akceptuje parametr zakresu, aby okreÅ›liÄ‡, ktÃ³re elementy usunÄ…Ä‡ z wektora i zwraca iterator tych elementÃ³w. Przekazanie skÅ‚adni zakresu <code>..</code> usunie <em>wszystkie</em> wartoÅ›ci z wektora.</p>
<p>Zatem musimy zaktualizowaÄ‡ implementacjÄ™ <code>drop</code> w <code>ThreadPool</code> w nastÄ™pujÄ…cy sposÃ³b:</p>
<listing file-name="src/lib.rs">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{
</span><span class="boring">    sync::{Arc, Mutex, mpsc},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.
</span><span class="boring">    ///
</span><span class="boring">    /// `size` to liczba wÄ…tkÃ³w w puli.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in self.workers.drain(..) {
            println!("Zamykanie wÄ…tku roboczego {}", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || {
</span><span class="boring">            loop {
</span><span class="boring">                let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">                println!("Worker {id} otrzymaÅ‚ zadanie; wykonujÄ™.");
</span><span class="boring">
</span><span class="boring">                job();
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre>
</listing>
<p>To rozwiÄ…zuje bÅ‚Ä…d kompilatora i nie wymaga Å¼adnych innych zmian w naszym kodzie. ZauwaÅ¼, Å¼e poniewaÅ¼ <code>drop</code> moÅ¼e byÄ‡ wywoÅ‚any podczas paniki, <code>unwrap</code> rÃ³wnieÅ¼ moÅ¼e spowodowaÄ‡ panikÄ™ i doprowadziÄ‡ do podwÃ³jnej paniki, co natychmiastowo crashuje program i koÅ„czy wszelkie trwajÄ…ce sprzÄ…tanie. Jest to w porzÄ…dku dla przykÅ‚adowego programu, ale nie jest zalecane dla kodu produkcyjnego.</p>
<h3 id="sygnalizowanie-wÄ…tkom-aby-przestaÅ‚y-nasÅ‚uchiwaÄ‡-zadaÅ„"><a class="header" href="#sygnalizowanie-wÄ…tkom-aby-przestaÅ‚y-nasÅ‚uchiwaÄ‡-zadaÅ„">Sygnalizowanie wÄ…tkom, aby przestaÅ‚y nasÅ‚uchiwaÄ‡ zadaÅ„</a></h3>
<p>DziÄ™ki wszystkim zmianom, ktÃ³re wprowadziliÅ›my, nasz kod kompiluje siÄ™ bez Å¼adnych ostrzeÅ¼eÅ„. Niestety, ten kod nie dziaÅ‚a tak, jak byÅ›my chcieli. Klucz leÅ¼y w logice zamkniÄ™Ä‡ uruchamianych przez wÄ…tki instancji <code>Worker</code>: obecnie wywoÅ‚ujemy <code>join</code>, ale to nie spowoduje zamkniÄ™cia wÄ…tkÃ³w, poniewaÅ¼ one <code>loop</code> w nieskoÅ„czonoÅ›Ä‡, szukajÄ…c zadaÅ„. JeÅ›li sprÃ³bujemy zrzuciÄ‡ nasz <code>ThreadPool</code> z naszÄ… obecnÄ… implementacjÄ… <code>drop</code>, gÅ‚Ã³wny wÄ…tek bÄ™dzie blokowaÅ‚ siÄ™ w nieskoÅ„czonoÅ›Ä‡, czekajÄ…c na zakoÅ„czenie pierwszego wÄ…tku.</p>
<p>Aby rozwiÄ…zaÄ‡ ten problem, bÄ™dziemy potrzebowaÄ‡ zmiany w implementacji <code>drop</code> dla <code>ThreadPool</code>, a nastÄ™pnie zmiany w pÄ™tli <code>Worker</code>.</p>
<p>Najpierw zmienimy implementacjÄ™ <code>drop</code> w <code>ThreadPool</code> tak, aby jawnie zrzuciÄ‡ <code>sender</code> przed oczekiwaniem na zakoÅ„czenie wÄ…tkÃ³w. Listing 21-23 pokazuje zmiany w <code>ThreadPool</code> w celu jawnego zrzucenia <code>sender</code>. W przeciwieÅ„stwie do wÄ…tku, tutaj <em>musimy</em> uÅ¼yÄ‡ <code>Option</code>, aby mÃ³c przenieÅ›Ä‡ <code>sender</code> z <code>ThreadPool</code> za pomocÄ… <code>Option::take</code>.</p>
<listing number="21-23" file-name="src/lib.rs" caption="Jawne zrzucanie `sender` przed doÅ‚Ä…czeniem wÄ…tkÃ³w `Worker`">
<pre><code class="language-rust noplayground not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{Arc, Mutex, mpsc},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span>pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}
// --snip--
<span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span>impl ThreadPool {
<span class="boring">    /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.
</span><span class="boring">    ///
</span><span class="boring">    /// `size` to liczba wÄ…tkÃ³w w puli.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        // --snip--

<span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span>        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in self.workers.drain(..) {
            println!("Zamykanie wÄ…tku roboczego {}", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || {
</span><span class="boring">            loop {
</span><span class="boring">                let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">                println!("Worker {id} otrzymaÅ‚ zadanie; wykonujÄ™.");
</span><span class="boring">
</span><span class="boring">                job();
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</listing>
<p>Zrzucenie <code>sender</code> zamyka kanaÅ‚, co oznacza, Å¼e wiÄ™cej wiadomoÅ›ci nie zostanie wysÅ‚anych. Kiedy to nastÄ…pi, wszystkie wywoÅ‚ania <code>recv</code>, ktÃ³re instancje <code>Worker</code> wykonujÄ… w nieskoÅ„czonej pÄ™tli, zwrÃ³cÄ… bÅ‚Ä…d. W Listingu 21-24 zmieniamy pÄ™tlÄ™ <code>Worker</code> tak, aby w tym przypadku elegancko wychodziÅ‚a z pÄ™tli, co oznacza, Å¼e wÄ…tki zakoÅ„czÄ… dziaÅ‚anie, gdy implementacja <code>drop</code> w <code>ThreadPool</code> wywoÅ‚a na nich <code>join</code>.</p>
<listing number="21-24" file-name="src/lib.rs" caption="Jawne wyjÅ›cie z pÄ™tli, gdy `recv` zwraca bÅ‚Ä…d">
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{Arc, Mutex, mpsc},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.
</span><span class="boring">    ///
</span><span class="boring">    /// `size` to liczba wÄ…tkÃ³w w puli.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool {
</span><span class="boring">            workers,
</span><span class="boring">            sender: Some(sender),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.as_ref().unwrap().send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        drop(self.sender.take());
</span><span class="boring">
</span><span class="boring">        for worker in self.workers.drain(..) {
</span><span class="boring">            println!("Zamykanie wÄ…tku roboczego {}", worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let message = receiver.lock().unwrap().recv();

                match message {
                    Ok(job) =&gt; {
                        println!("Worker {id} otrzymaÅ‚ zadanie; wykonujÄ™.");

                        job();
                    }
                    Err(_) =&gt; {
                        println!("Worker {id} rozÅ‚Ä…czyÅ‚ siÄ™; zamykam.");
                        break;
                    }
                }
            }
        });

        Worker { id, thread }
    }
}</code></pre>
</listing>
<p>Aby zobaczyÄ‡ ten kod w akcji, zmodyfikujmy <code>main</code>, aby akceptowaÅ‚ tylko dwa Å¼Ä…dania przed delikatnym zamkniÄ™ciem serwera, jak pokazano na Listingu 21-25.</p>
<listing number="21-25" file-name="src/main.rs" caption="Zamykanie serwera po obsÅ‚uÅ¼eniu dwÃ³ch Å¼Ä…daÅ„ poprzez wyjÅ›cie z pÄ™tli">
<pre><code class="language-rust ignore"><span class="boring">use hello::ThreadPool;
</span><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Zamykam.");
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
</listing>
<p>Nie chciaÅ‚byÅ›, aby prawdziwy serwer WWW zamykaÅ‚ siÄ™ po obsÅ‚uÅ¼eniu zaledwie dwÃ³ch Å¼Ä…daÅ„. Ten kod jedynie demonstruje, Å¼e delikatne zamykanie i sprzÄ…tanie dziaÅ‚a poprawnie.</p>
<p>Metoda <code>take</code> jest zdefiniowana w ceche <code>Iterator</code> i ogranicza iteracjÄ™ do maksymalnie dwÃ³ch pierwszych elementÃ³w. <code>ThreadPool</code> wyjdzie poza zakres na koÅ„cu <code>main</code>, a implementacja <code>drop</code> zostanie uruchomiona.</p>
<p>Uruchom serwer za pomocÄ… <code>cargo run</code> i wyÅ›lij trzy Å¼Ä…dania. Trzecie Å¼Ä…danie powinno zakoÅ„czyÄ‡ siÄ™ bÅ‚Ä™dem, a w terminalu powinieneÅ› zobaczyÄ‡ wynik podobny do tego:</p>
<!-- manual-regeneration
cd listings/ch21-web-server/listing-21-25
cargo run
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
trzecie Å¼Ä…danie zakoÅ„czy siÄ™ bÅ‚Ä™dem, poniewaÅ¼ serwer zostanie zamkniÄ™ty
skopiuj wyjÅ›cie poniÅ¼ej
Nie moÅ¼na zautomatyzowaÄ‡, poniewaÅ¼ wynik zaleÅ¼y od wysyÅ‚ania Å¼Ä…daÅ„
-->
<pre><code class="language-console">$ cargo run
   Kompilowanie hello v0.1.0 (file:///projects/hello)
    ZakoÅ„czono `dev` profil [nieoptymalny + debuginfo] cel(e) w 0.41s
     Uruchamianie `target/debug/hello`
Worker 0 otrzymaÅ‚ zadanie; wykonujÄ™.
Zamykam.
Zamykanie wÄ…tku roboczego 0
Worker 3 otrzymaÅ‚ zadanie; wykonujÄ™.
Worker 1 rozÅ‚Ä…czyÅ‚ siÄ™; zamykam.
Worker 2 rozÅ‚Ä…czyÅ‚ siÄ™; zamykam.
Worker 3 rozÅ‚Ä…czyÅ‚ siÄ™; zamykam.
Worker 0 rozÅ‚Ä…czyÅ‚ siÄ™; zamykam.
Zamykanie wÄ…tku roboczego 1
Zamykanie wÄ…tku roboczego 2
Zamykanie wÄ…tku roboczego 3
</code></pre>
<p>MoÅ¼esz zobaczyÄ‡ innÄ… kolejnoÅ›Ä‡ identyfikatorÃ³w <code>Worker</code> i wydrukowanych komunikatÃ³w. Z komunikatÃ³w widzimy, jak dziaÅ‚a ten kod: instancje <code>Worker</code> 0 i 3 otrzymaÅ‚y pierwsze dwa Å¼Ä…dania. Serwer przestaÅ‚ akceptowaÄ‡ poÅ‚Ä…czenia po drugim poÅ‚Ä…czeniu, a implementacja <code>Drop</code> w <code>ThreadPool</code> zaczyna siÄ™ wykonywaÄ‡, zanim <code>Worker 3</code> nawet rozpocznie swoje zadanie. Zrzucone <code>sender</code> odÅ‚Ä…cza wszystkie instancje <code>Worker</code> i informuje je o zamkniÄ™ciu. Instancje <code>Worker</code> drukujÄ… komunikat, gdy siÄ™ odÅ‚Ä…czajÄ…, a nastÄ™pnie pula wÄ…tkÃ³w wywoÅ‚uje <code>join</code>, aby poczekaÄ‡, aÅ¼ kaÅ¼dy wÄ…tek <code>Worker</code> zakoÅ„czy dziaÅ‚anie.</p>
<p>ZauwaÅ¼ jeden ciekawy aspekt tego konkretnego wykonania: <code>ThreadPool</code> zrzuciÅ‚ <code>sender</code>, a zanim ktÃ³rykolwiek <code>Worker</code> otrzymaÅ‚ bÅ‚Ä…d, prÃ³bowaliÅ›my doÅ‚Ä…czyÄ‡ <code>Worker 0</code>. <code>Worker 0</code> nie otrzymaÅ‚ jeszcze bÅ‚Ä™du z <code>recv</code>, wiÄ™c gÅ‚Ã³wny wÄ…tek zablokowaÅ‚ siÄ™, czekajÄ…c na zakoÅ„czenie <code>Worker 0</code>. W miÄ™dzyczasie <code>Worker 3</code> otrzymaÅ‚ zadanie, a nastÄ™pnie wszystkie wÄ…tki otrzymaÅ‚y bÅ‚Ä…d. Gdy <code>Worker 0</code> zakoÅ„czyÅ‚ dziaÅ‚anie, gÅ‚Ã³wny wÄ…tek czekaÅ‚ na zakoÅ„czenie pozostaÅ‚ych instancji <code>Worker</code>. W tym momencie wszystkie one wyszÅ‚y ze swoich pÄ™tli i zatrzymaÅ‚y siÄ™.</p>
<p>Gratulacje! WÅ‚aÅ›nie zakoÅ„czyliÅ›my nasz projekt; mamy podstawowy serwer WWW, ktÃ³ry uÅ¼ywa puli wÄ…tkÃ³w do asynchronicznej odpowiedzi. JesteÅ›my w stanie wykonaÄ‡ delikatne zamkniÄ™cie serwera, ktÃ³re czyÅ›ci wszystkie wÄ…tki w puli.</p>
<p>PoniÅ¼ej znajduje siÄ™ caÅ‚y kod dla odniesienia:</p>
<listing file-name="src/main.rs">
<pre><code class="language-rust ignore">use hello::ThreadPool;
use std::{
    fs,
    io::{BufReader, prelude::*},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Zamykam.");
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    let (status_line, filename) = match &amp;request_line[..] {
        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
        "GET /sleep HTTP/1.1" =&gt; {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre>
</listing>
<listing file-name="src/lib.rs">
<pre><code class="language-rust noplayground">use std::{
    sync::{Arc, Mutex, mpsc},
    thread,
};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    /// Tworzy nowÄ… pulÄ™ wÄ…tkÃ³w.
    ///
    /// `size` to liczba wÄ…tkÃ³w w puli.
    ///
    /// # Panics
    ///
    /// Funkcja `new` spowoduje panikÄ™, jeÅ›li `size` wynosi zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!("Zamykanie wÄ…tku roboczego {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let message = receiver.lock().unwrap().recv();

                match message {
                    Ok(job) =&gt; {
                        println!("Worker {id} otrzymaÅ‚ zadanie; wykonujÄ™.");

                        job();
                    }
                    Err(_) =&gt; {
                        println!("Worker {id} rozÅ‚Ä…czyÅ‚ siÄ™; zamykam.");
                        break;
                    }
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}</code></pre>
</listing>
<p>MoÅ¼na by tu zrobiÄ‡ wiÄ™cej! JeÅ›li chcesz kontynuowaÄ‡ ulepszanie tego projektu, oto kilka pomysÅ‚Ã³w:</p>
<ul>
<li>Dodaj wiÄ™cej dokumentacji do <code>ThreadPool</code> i jego publicznych metod.</li>
<li>Dodaj testy funkcjonalnoÅ›ci biblioteki.</li>
<li>ZmieÅ„ wywoÅ‚ania <code>unwrap</code> na bardziej solidnÄ… obsÅ‚ugÄ™ bÅ‚Ä™dÃ³w.</li>
<li>UÅ¼yj <code>ThreadPool</code> do wykonania innego zadania niÅ¼ obsÅ‚uga Å¼Ä…daÅ„ WWW.</li>
<li>ZnajdÅº skrzynkÄ™ puli wÄ…tkÃ³w na <a href="https://crates.io/">crates.io</a> i zaimplementuj podobny serwer WWW, uÅ¼ywajÄ…c zamiast tego tej skrzynki. NastÄ™pnie porÃ³wnaj jej API i solidnoÅ›Ä‡ z zaimplementowanÄ… przez nas pulÄ… wÄ…tkÃ³w.</li>
</ul>
<h2 id="podsumowanie-20"><a class="header" href="#podsumowanie-20">Podsumowanie</a></h2>
<p>Åšwietnie! DotarÅ‚eÅ› do koÅ„ca ksiÄ…Å¼ki! Chcemy podziÄ™kowaÄ‡ za doÅ‚Ä…czenie do nas w tej podrÃ³Å¼y po Rust. JesteÅ› teraz gotowy, aby zaimplementowaÄ‡ wÅ‚asne projekty Rust i pomagaÄ‡ w projektach innych ludzi. PamiÄ™taj, Å¼e istnieje goÅ›cinna spoÅ‚ecznoÅ›Ä‡ innych Rustaceans, ktÃ³rzy z przyjemnoÅ›ciÄ… pomogÄ… ci w wszelkich wyzwaniach, ktÃ³re napotkasz w swojej podrÃ³Å¼y z Rustem.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dodatek"><a class="header" href="#dodatek">Dodatek</a></h1>
<p>PoniÅ¼sze sekcje zawierajÄ… materiaÅ‚y referencyjne, ktÃ³re mogÄ… okazaÄ‡ siÄ™ przydatne w Twojej podrÃ³Å¼y z Rustem.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="a---sÅ‚owa-kluczowe"><a href="#a---sÅ‚owa-kluczowe" class="header">A - SÅ‚owa kluczowe</a></h1>
<h2 id="dodatek-a-sÅ‚owa-kluczowe"><a class="header" href="#dodatek-a-sÅ‚owa-kluczowe">Dodatek A: SÅ‚owa kluczowe</a></h2>
<p>PoniÅ¼sze listy zawierajÄ… sÅ‚owa kluczowe, ktÃ³re sÄ… zarezerwowane do obecnego lub przyszÅ‚ego uÅ¼ytku przez jÄ™zyk Rust. W zwiÄ…zku z tym nie mogÄ… byÄ‡ uÅ¼ywane jako identyfikatory (z wyjÄ…tkiem surowych identyfikatorÃ³w, jak omawiamy w sekcji <a href="#raw-identifiers">â€Surowe identyfikatoryâ€</a><!-- ignore -->). <em>Identyfikatory</em> to nazwy funkcji, zmiennych, parametrÃ³w, pÃ³l struktur, moduÅ‚Ã³w, skrzynek, staÅ‚ych, makr, wartoÅ›ci statycznych, atrybutÃ³w, typÃ³w, cech lub czasÃ³w Å¼ycia.</p>
<h3 id="sÅ‚owa-kluczowe-obecnie-w-uÅ¼yciu"><a class="header" href="#sÅ‚owa-kluczowe-obecnie-w-uÅ¼yciu">SÅ‚owa kluczowe obecnie w uÅ¼yciu</a></h3>
<p>PoniÅ¼ej znajduje siÄ™ lista sÅ‚Ã³w kluczowych obecnie uÅ¼ywanych, z opisem ich funkcjonalnoÅ›ci.</p>
<ul>
<li><strong><code>as</code></strong>: Wykonuje prymitywnÄ… konwersjÄ™ typÃ³w, rozrÃ³Å¼nia konkretnÄ… cechÄ™ zawierajÄ…cÄ… element lub zmienia nazwy elementÃ³w w instrukcjach <code>use</code>.</li>
<li><strong><code>async</code></strong>: Zwraca <code>Future</code> zamiast blokowania bieÅ¼Ä…cego wÄ…tku.</li>
<li><strong><code>await</code></strong>: Zawiesza wykonywanie, dopÃ³ki wynik <code>Future</code> nie bÄ™dzie gotowy.</li>
<li><strong><code>break</code></strong>: Natychmiast wychodzi z pÄ™tli.</li>
<li><strong><code>const</code></strong>: Definiuje staÅ‚e elementy lub staÅ‚e surowe wskaÅºniki.</li>
<li><strong><code>continue</code></strong>: Przechodzi do nastÄ™pnej iteracji pÄ™tli.</li>
<li><strong><code>crate</code></strong>: W Å›cieÅ¼ce moduÅ‚u odnosi siÄ™ do katalogu gÅ‚Ã³wnego skrzynki (crate).</li>
<li><strong><code>dyn</code></strong>: Dynamiczne wysyÅ‚anie do obiektu cechy.</li>
<li><strong><code>else</code></strong>: Alternatywa dla konstrukcji sterujÄ…cych <code>if</code> i <code>if let</code>.</li>
<li><strong><code>enum</code></strong>: Definiuje wyliczenie.</li>
<li><strong><code>extern</code></strong>: ÅÄ…czy funkcjÄ™ lub zmiennÄ… zewnÄ™trznÄ….</li>
<li><strong><code>false</code></strong>: LiteraÅ‚ boolowski faÅ‚sz.</li>
<li><strong><code>fn</code></strong>: Definiuje funkcjÄ™ lub typ wskaÅºnika na funkcjÄ™.</li>
<li><strong><code>for</code></strong>: Iteruje po elementach z iteratora, implementuje cechÄ™ lub okreÅ›la czas Å¼ycia wyÅ¼szego rzÄ™du.</li>
<li><strong><code>if</code></strong>: RozgaÅ‚Ä™zia kod na podstawie wyniku wyraÅ¼enia warunkowego.</li>
<li><strong><code>impl</code></strong>: Implementuje wbudowanÄ… lub cechowÄ… funkcjonalnoÅ›Ä‡.</li>
<li><strong><code>in</code></strong>: CzÄ™Å›Ä‡ skÅ‚adni pÄ™tli <code>for</code>.</li>
<li><strong><code>let</code></strong>: WiÄ…Å¼e zmiennÄ….</li>
<li><strong><code>loop</code></strong>: PÄ™tla bezwarunkowa.</li>
<li><strong><code>match</code></strong>: Dopasowuje wartoÅ›Ä‡ do wzorcÃ³w.</li>
<li><strong><code>mod</code></strong>: Definiuje moduÅ‚.</li>
<li><strong><code>move</code></strong>: Sprawia, Å¼e zamkniÄ™cie przejmuje wÅ‚asnoÅ›Ä‡ wszystkich swoich przechwyconych wartoÅ›ci.</li>
<li><strong><code>mut</code></strong>: Oznacza zmiennoÅ›Ä‡ w referencjach, surowych wskaÅºnikach lub wiÄ…zaniach wzorcowych.</li>
<li><strong><code>pub</code></strong>: Oznacza publicznÄ… widocznoÅ›Ä‡ w polach struktur, blokach <code>impl</code> lub moduÅ‚ach.</li>
<li><strong><code>ref</code></strong>: WiÄ…Å¼e przez referencjÄ™.</li>
<li><strong><code>return</code></strong>: Zwraca z funkcji.</li>
<li><strong><code>Self</code></strong>: Alias typu dla definiowanego lub implementowanego typu.</li>
<li><strong><code>self</code></strong>: Podmiot metody lub bieÅ¼Ä…cy moduÅ‚.</li>
<li><strong><code>static</code></strong>: Zmienna globalna lub czas Å¼ycia trwajÄ…cy przez caÅ‚e wykonanie programu.</li>
<li><strong><code>struct</code></strong>: Definiuje strukturÄ™.</li>
<li><strong><code>super</code></strong>: ModuÅ‚ nadrzÄ™dny bieÅ¼Ä…cego moduÅ‚u.</li>
<li><strong><code>trait</code></strong>: Definiuje cechÄ™.</li>
<li><strong><code>true</code></strong>: LiteraÅ‚ boolowski prawda.</li>
<li><strong><code>type</code></strong>: Definiuje alias typu lub stowarzyszony typ.</li>
<li><strong><code>union</code></strong>: Definiuje <a href="../reference/items/unions.html">uniÄ™</a><!-- ignore -->; jest sÅ‚owem kluczowym tylko wtedy, gdy uÅ¼ywane w deklaracji unii.</li>
<li><strong><code>unsafe</code></strong>: Oznacza niebezpieczny kod, funkcje, cechy lub implementacje.</li>
<li><strong><code>use</code></strong>: Wprowadza symbole do zakresu.</li>
<li><strong><code>where</code></strong>: Oznacza klauzule, ktÃ³re ograniczajÄ… typ.</li>
<li><strong><code>while</code></strong>: PÄ™tla warunkowa na podstawie wyniku wyraÅ¼enia.</li>
</ul>
<h3 id="sÅ‚owa-kluczowe-zarezerwowane-do-przyszÅ‚ego-uÅ¼ytku"><a class="header" href="#sÅ‚owa-kluczowe-zarezerwowane-do-przyszÅ‚ego-uÅ¼ytku">SÅ‚owa kluczowe zarezerwowane do przyszÅ‚ego uÅ¼ytku</a></h3>
<p>PoniÅ¼sze sÅ‚owa kluczowe nie majÄ… jeszcze Å¼adnej funkcjonalnoÅ›ci, ale sÄ… zarezerwowane przez Rust do potencjalnego przyszÅ‚ego uÅ¼ytku:</p>
<ul>
<li><code>abstract</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>gen</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h3 id="surowe-identyfikatory"><a class="header" href="#surowe-identyfikatory">Surowe identyfikatory</a></h3>
<p><em>Surowe identyfikatory</em> to skÅ‚adnia, ktÃ³ra pozwala uÅ¼ywaÄ‡ sÅ‚Ã³w kluczowych tam, gdzie normalnie nie byÅ‚oby to dozwolone. Surowy identyfikator uÅ¼ywasz, poprzedzajÄ…c sÅ‚owo kluczowe <code>r#</code>.</p>
<p>Na przykÅ‚ad, <code>match</code> jest sÅ‚owem kluczowym. JeÅ›li sprÃ³bujesz skompilowaÄ‡ nastÄ™pujÄ…cÄ… funkcjÄ™, ktÃ³ra uÅ¼ywa <code>match</code> jako swojej nazwy:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}</code></pre>
<p>otrzymasz nastÄ™pujÄ…cy bÅ‚Ä…d:</p>
<pre><code class="language-text">bÅ‚Ä…d: oczekiwano identyfikatora, znaleziono sÅ‚owo kluczowe `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ oczekiwano identyfikatora, znaleziono sÅ‚owo kluczowe
</code></pre>
<p>BÅ‚Ä…d pokazuje, Å¼e nie moÅ¼esz uÅ¼yÄ‡ sÅ‚owa kluczowego <code>match</code> jako identyfikatora funkcji. Aby uÅ¼yÄ‡ <code>match</code> jako nazwy funkcji, musisz uÅ¼yÄ‡ skÅ‚adni surowego identyfikatora, tak jak tutaj:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}</code></pre>
<p>Ten kod skompiluje siÄ™ bez Å¼adnych bÅ‚Ä™dÃ³w. ZwrÃ³Ä‡ uwagÄ™ na prefiks <code>r#</code> w nazwie funkcji w jej definicji, a takÅ¼e tam, gdzie funkcja jest wywoÅ‚ywana w <code>main</code>.</p>
<p>Surowe identyfikatory pozwalajÄ… uÅ¼ywaÄ‡ dowolnego sÅ‚owa jako identyfikatora, nawet jeÅ›li to sÅ‚owo jest zarezerwowanym sÅ‚owem kluczowym. Daje to nam wiÄ™kszÄ… swobodÄ™ w wyborze nazw identyfikatorÃ³w, a takÅ¼e umoÅ¼liwia integracjÄ™ z programami napisanymi w jÄ™zyku, w ktÃ³rym te sÅ‚owa nie sÄ… sÅ‚owami kluczowymi. Ponadto, surowe identyfikatory pozwalajÄ… uÅ¼ywaÄ‡ bibliotek napisanych w innej edycji Rust niÅ¼ ta, ktÃ³rej uÅ¼ywa twoja skrzynka. Na przykÅ‚ad, <code>try</code> nie jest sÅ‚owem kluczowym w edycji 2015, ale jest w edycjach 2018, 2021 i 2024. JeÅ›li zaleÅ¼y Ci na bibliotece napisanej w edycji 2015 i ma ona funkcjÄ™ <code>try</code>, bÄ™dziesz musiaÅ‚ uÅ¼yÄ‡ skÅ‚adni surowego identyfikatora, w tym przypadku <code>r#try</code>, aby wywoÅ‚aÄ‡ tÄ™ funkcjÄ™ z kodu w pÃ³Åºniejszych edycjach. WiÄ™cej informacji na temat edycji znajdziesz w <a href="#e---edycje">Dodatku E</a><!-- ignore -->.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="b---operatory-i-symbole"><a href="#b---operatory-i-symbole" class="header">B - Operatory i symbole</a></h1>
<h2 id="dodatek-b-operatory-i-symbole"><a class="header" href="#dodatek-b-operatory-i-symbole">Dodatek B: Operatory i symbole</a></h2>
<p>Ten dodatek zawiera sÅ‚ownik skÅ‚adni Rust, w tym operatory i inne symbole, ktÃ³re pojawiajÄ… siÄ™ samodzielnie lub w kontekÅ›cie Å›cieÅ¼ek, typÃ³w generycznych, ograniczeÅ„ cech, makr, atrybutÃ³w, komentarzy, krotek i nawiasÃ³w.</p>
<h3 id="operatory"><a class="header" href="#operatory">Operatory</a></h3>
<p>Tabela B-1 zawiera operatory w Rust, przykÅ‚ad, jak operator pojawiÅ‚by siÄ™ w kontekÅ›cie, krÃ³tkie wyjaÅ›nienie i informacjÄ™, czy operator jest przeciÄ…Å¼alny. JeÅ›li operator jest przeciÄ…Å¼alny, wymieniona jest odpowiednia cecha do uÅ¼ycia w celu przeciÄ…Å¼enia tego operatora.</p>
<p><span class="caption">Tabela B-1: Operatory</span></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>PrzykÅ‚ad</th><th>WyjaÅ›nienie</th><th>PrzeciÄ…Å¼alny?</th></tr>
</thead>
<tbody>
<tr><td><code>!</code></td><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>RozwiniÄ™cie makra</td><td></td></tr>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>Bitowa lub logiczna negacja</td><td><code>Not</code></td></tr>
<tr><td><code>!=</code></td><td><code>expr != expr</code></td><td>PorÃ³wnanie nierÃ³wnoÅ›ci</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>Reszta z dzielenia arytmetycznego</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>Reszta z dzielenia arytmetycznego i przypisanie</td><td><code>RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;expr</code>, <code>&amp;mut expr</code></td><td>PoÅ¼yczenie</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td><td>Typ wskaÅºnika poÅ¼yczonego</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>Bitowe AND</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>var &amp;= expr</code></td><td>Bitowe AND i przypisanie</td><td><code>BitAndAssign</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>KrÃ³tkookresowe logiczne AND</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>MnoÅ¼enie arytmetyczne</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>MnoÅ¼enie arytmetyczne i przypisanie</td><td><code>MulAssign</code></td></tr>
<tr><td><code>*</code></td><td><code>*expr</code></td><td>Dereferencja</td><td><code>Deref</code></td></tr>
<tr><td><code>*</code></td><td><code>*const type</code>, <code>*mut type</code></td><td>Surowy wskaÅºnik</td><td></td></tr>
<tr><td><code>+</code></td><td><code>trait + trait</code>, <code>'a + trait</code></td><td>Ograniczenie typu zÅ‚oÅ¼onego</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>Dodawanie arytmetyczne</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>Dodawanie arytmetyczne i przypisanie</td><td><code>AddAssign</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>Separator argumentÃ³w i elementÃ³w</td><td></td></tr>
<tr><td><code>-</code></td><td><code>- expr</code></td><td>Negacja arytmetyczna</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>Odejmowanie arytmetyczne</td><td><code>Sub</code></td></tr>
<tr><td><code>-=</code></td><td><code>var -= expr</code></td><td>Odejmowanie arytmetyczne i przypisanie</td><td><code>SubAssign</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; type</code>, <code>|â€¦| -&gt; type</code></td><td>Typ zwracany funkcji i zamkniÄ™cia</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>DostÄ™p do pola</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident(expr, ...)</code></td><td>WywoÅ‚anie metody</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.0</code>, <code>expr.1</code>, i tak dalej</td><td>Indeksowanie krotek</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td><td>LiteraÅ‚ zakresu wyÅ‚Ä…czajÄ…cego prawÄ… stronÄ™</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..=</code></td><td><code>..=expr</code>, <code>expr..=expr</code></td><td>LiteraÅ‚ zakresu wÅ‚Ä…czajÄ…cego prawÄ… stronÄ™</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..</code></td><td><code>..expr</code></td><td>SkÅ‚adnia aktualizacji literaÅ‚u struktury</td><td></td></tr>
<tr><td><code>..</code></td><td><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td><td>WiÄ…zanie wzorca â€i resztaâ€</td><td></td></tr>
<tr><td><code>...</code></td><td><code>expr...expr</code></td><td>(PrzestarzaÅ‚e, uÅ¼yj <code>..=</code> zamiast) We wzorcu: wzorzec zakresu wÅ‚Ä…czajÄ…cego</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>Dzielenie arytmetyczne</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>Dzielenie arytmetyczne i przypisanie</td><td><code>DivAssign</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>Ograniczenia</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>Inicjalizator pola struktury</td><td></td></tr>
<tr><td><code>:</code></td><td><code>'a: loop {...}</code></td><td>Etykieta pÄ™tli</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>Terminator instrukcji i elementu</td><td></td></tr>
<tr><td><code>;</code></td><td><code>[...; len]</code></td><td>CzÄ™Å›Ä‡ skÅ‚adni tablicy o staÅ‚ym rozmiarze</td><td></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>expr &lt;&lt; expr</code></td><td>PrzesuniÄ™cie w lewo</td><td><code>Shl</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>var &lt;&lt;= expr</code></td><td>PrzesuniÄ™cie w lewo i przypisanie</td><td><code>ShlAssign</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>PorÃ³wnanie â€mniejsze niÅ¼â€</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>PorÃ³wnanie â€mniejsze niÅ¼ lub rÃ³wneâ€</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code>, <code>ident = type</code></td><td>Przypisanie/rÃ³wnowaÅ¼noÅ›Ä‡</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>PorÃ³wnanie rÃ³wnoÅ›ci</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>CzÄ™Å›Ä‡ skÅ‚adni ramienia dopasowania</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>PorÃ³wnanie â€wiÄ™ksze niÅ¼â€</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>PorÃ³wnanie â€wiÄ™ksze niÅ¼ lub rÃ³wneâ€</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>expr &gt;&gt; expr</code></td><td>PrzesuniÄ™cie w prawo</td><td><code>Shr</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>var &gt;&gt;= expr</code></td><td>PrzesuniÄ™cie w prawo i przypisanie</td><td><code>ShrAssign</code></td></tr>
<tr><td><code>@</code></td><td><code>ident @ pat</code></td><td>WiÄ…zanie wzorca</td><td></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>Bitowe OR wyÅ‚Ä…czne</td><td><code>BitXor</code></td></tr>
<tr><td><code>^=</code></td><td><code>var ^= expr</code></td><td>Bitowe OR wyÅ‚Ä…czne i przypisanie</td><td><code>BitXorAssign</code></td></tr>
<tr><td><code>|</code></td><td><code>pat | pat</code></td><td>Alternatywy wzorcÃ³w</td><td></td></tr>
<tr><td><code>|</code></td><td><code>expr | expr</code></td><td>Bitowe OR</td><td><code>BitOr</code></td></tr>
<tr><td><code>|=</code></td><td><code>var |= expr</code></td><td>Bitowe OR i przypisanie</td><td><code>BitOrAssign</code></td></tr>
<tr><td><code>||</code></td><td><code>expr || expr</code></td><td>KrÃ³tkookresowe logiczne OR</td><td></td></tr>
<tr><td><code>?</code></td><td><code>expr?</code></td><td>Propagacja bÅ‚Ä™du</td><td></td></tr>
</tbody>
</table>
</div>
<h3 id="symbole-niebÄ™dÄ…ce-operatorami"><a class="header" href="#symbole-niebÄ™dÄ…ce-operatorami">Symbole niebÄ™dÄ…ce operatorami</a></h3>
<p>PoniÅ¼sze tabele zawierajÄ… wszystkie symbole, ktÃ³re nie peÅ‚niÄ… funkcji operatorÃ³w; to znaczy, nie zachowujÄ… siÄ™ jak wywoÅ‚anie funkcji lub metody.</p>
<p>Tabela B-2 przedstawia symbole, ktÃ³re wystÄ™pujÄ… samodzielnie i sÄ… waÅ¼ne w rÃ³Å¼nych miejscach.</p>
<p><span class="caption">Tabela B-2: SkÅ‚adnia samodzielna</span></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Symbol</th><th>WyjaÅ›nienie</th></tr>
</thead>
<tbody>
<tr><td><code>'ident</code></td><td>Nazwane Å¼ycie lub etykieta pÄ™tli</td></tr>
<tr><td>Cyfry natychmiastowo poprzedzone <code>u8</code>, <code>i32</code>, <code>f64</code>, <code>usize</code> itd.</td><td>LiteraÅ‚ numeryczny okreÅ›lonego typu</td></tr>
<tr><td><code>"..."</code></td><td>LiteraÅ‚ ciÄ…gu znakÃ³w</td></tr>
<tr><td><code>r"..."</code>, <code>r#"..."#</code>, <code>r##"..."##</code> itd.</td><td>Surowy literaÅ‚ ciÄ…gu znakÃ³w; znaki ucieczki nie sÄ… przetwarzane</td></tr>
<tr><td><code>b"..."</code></td><td>LiteraÅ‚ ciÄ…gu bajtÃ³w; konstruuje tablicÄ™ bajtÃ³w zamiast ciÄ…gu znakÃ³w</td></tr>
<tr><td><code>br"..."</code>, <code>br#"..."#</code>, <code>br##"..."##</code> itd.</td><td>Surowy literaÅ‚ ciÄ…gu bajtÃ³w; poÅ‚Ä…czenie surowego i bajtowego literaÅ‚u</td></tr>
<tr><td><code>'...'</code></td><td>LiteraÅ‚ znaku</td></tr>
<tr><td><code>b'...'</code></td><td>LiteraÅ‚ bajtu ASCII</td></tr>
<tr><td><code>|â€¦| expr</code></td><td>ZamkniÄ™cie (closure)</td></tr>
<tr><td><code>!</code></td><td>Zawsze pusty typ dolny dla funkcji rozbieÅ¼nych</td></tr>
<tr><td><code>_</code></td><td>WiÄ…zanie wzorca â€ignorowaneâ€; uÅ¼ywane rÃ³wnieÅ¼ do czytelnoÅ›ci literaÅ‚Ã³w caÅ‚kowitych</td></tr>
</tbody>
</table>
</div>
<p>Tabela B-3 przedstawia symbole, ktÃ³re pojawiajÄ… siÄ™ w kontekÅ›cie Å›cieÅ¼ki przez hierarchiÄ™ moduÅ‚Ã³w do elementu.</p>
<p><span class="caption">Tabela B-3: SkÅ‚adnia zwiÄ…zana ze Å›cieÅ¼kami</span></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Symbol</th><th>WyjaÅ›nienie</th></tr>
</thead>
<tbody>
<tr><td><code>ident::ident</code></td><td>ÅšcieÅ¼ka przestrzeni nazw</td></tr>
<tr><td><code>::path</code></td><td>ÅšcieÅ¼ka wzglÄ™dna do katalogu gÅ‚Ã³wnego skrzynki (tj. jawnie Å›cieÅ¼ka bezwzglÄ™dna)</td></tr>
<tr><td><code>self::path</code></td><td>ÅšcieÅ¼ka wzglÄ™dna do bieÅ¼Ä…cego moduÅ‚u (tj. jawnie Å›cieÅ¼ka wzglÄ™dna)</td></tr>
<tr><td><code>super::path</code></td><td>ÅšcieÅ¼ka wzglÄ™dna do nadrzÄ™dnego moduÅ‚u bieÅ¼Ä…cego moduÅ‚u</td></tr>
<tr><td><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code></td><td>Stowarzyszone staÅ‚e, funkcje i typy</td></tr>
<tr><td><code>&lt;type&gt;::...</code></td><td>Stowarzyszony element dla typu, ktÃ³rego nie moÅ¼na bezpoÅ›rednio nazwaÄ‡ (na przykÅ‚ad <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;::...</code> itd.)</td></tr>
<tr><td><code>trait::method(...)</code></td><td>RozrÃ³Å¼nianie wywoÅ‚ania metody przez nazwanie cechy, ktÃ³ra jÄ… definiuje</td></tr>
<tr><td><code>type::method(...)</code></td><td>RozrÃ³Å¼nianie wywoÅ‚ania metody przez nazwanie typu, dla ktÃ³rego jest zdefiniowana</td></tr>
<tr><td><code>&lt;type as trait&gt;::method(...)</code></td><td>RozrÃ³Å¼nianie wywoÅ‚ania metody przez nazwanie cechy i typu</td></tr>
</tbody>
</table>
</div>
<p>Tabela B-4 przedstawia symbole, ktÃ³re pojawiajÄ… siÄ™ w kontekÅ›cie uÅ¼ywania generycznych parametrÃ³w typu.</p>
<p><span class="caption">Tabela B-4: Typy generyczne</span></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Symbol</th><th>WyjaÅ›nienie</th></tr>
</thead>
<tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>OkreÅ›la parametry dla typu generycznego w typie (np. <code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>OkreÅ›la parametry dla typu, funkcji lub metody generycznej w wyraÅ¼eniu; czÄ™sto okreÅ›lane jako <em>turbofish</em> (np. <code>"42".parse::&lt;i32&gt;()</code>)</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>Definiuje funkcjÄ™ generycznÄ…</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>Definiuje strukturÄ™ generycznÄ…</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>Definiuje wyliczenie generyczne</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>Definiuje implementacjÄ™ generycznÄ…</td></tr>
<tr><td><code>for&lt;...&gt; type</code></td><td>Ograniczenia czasu Å¼ycia wyÅ¼szego rzÄ™du</td></tr>
<tr><td><code>type&lt;ident=type&gt;</code></td><td>Typ generyczny, w ktÃ³rym jeden lub wiÄ™cej stowarzyszonych typÃ³w ma okreÅ›lone przypisania (np. <code>Iterator&lt;Item=T&gt;</code>)</td></tr>
</tbody>
</table>
</div>
<p>Tabela B-5 przedstawia symbole, ktÃ³re pojawiajÄ… siÄ™ w kontekÅ›cie ograniczania generycznych parametrÃ³w typu za pomocÄ… ograniczeÅ„ cech.</p>
<p><span class="caption">Tabela B-5: Ograniczenia cech</span></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Symbol</th><th>WyjaÅ›nienie</th></tr>
</thead>
<tbody>
<tr><td><code>T: U</code></td><td>Parametr generyczny <code>T</code> ograniczony do typÃ³w, ktÃ³re implementujÄ… <code>U</code></td></tr>
<tr><td><code>T: 'a</code></td><td>Typ generyczny <code>T</code> musi przetrwaÄ‡ czas Å¼ycia <code>'a</code> (co oznacza, Å¼e typ nie moÅ¼e przejÅ›ciowo zawieraÄ‡ Å¼adnych referencji o krÃ³tszych czasach Å¼ycia niÅ¼ <code>'a</code>)</td></tr>
<tr><td><code>T: 'static</code></td><td>Typ generyczny <code>T</code> nie zawiera Å¼adnych poÅ¼yczonych referencji innych niÅ¼ te <code>'static</code></td></tr>
<tr><td><code>'b: 'a</code></td><td>Generyczny czas Å¼ycia <code>'b</code> musi przetrwaÄ‡ czas Å¼ycia <code>'a</code></td></tr>
<tr><td><code>T: ?Sized</code></td><td>Zezwala parametrowi typu generycznego na bycie typem o dynamicznym rozmiarze</td></tr>
<tr><td><code>'a + trait</code>, <code>trait + trait</code></td><td>Ograniczenie typu zÅ‚oÅ¼onego</td></tr>
</tbody>
</table>
</div>
<p>Tabela B-6 przedstawia symbole, ktÃ³re pojawiajÄ… siÄ™ w kontekÅ›cie wywoÅ‚ywania lub definiowania makr oraz okreÅ›lania atrybutÃ³w dla elementu.</p>
<p><span class="caption">Tabela B-6: Makra i atrybuty</span></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Symbol</th><th>WyjaÅ›nienie</th></tr>
</thead>
<tbody>
<tr><td><code>#[meta]</code></td><td>Atrybut zewnÄ™trzny</td></tr>
<tr><td><code>#![meta]</code></td><td>Atrybut wewnÄ™trzny</td></tr>
<tr><td><code>$ident</code></td><td>Podstawienie makra</td></tr>
<tr><td><code>$ident:kind</code></td><td>Metazmienna makra</td></tr>
<tr><td><code>$(...)...</code></td><td>PowtÃ³rzenie makra</td></tr>
<tr><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>WywoÅ‚anie makra</td></tr>
</tbody>
</table>
</div>
<p>Tabela B-7 przedstawia symbole tworzÄ…ce komentarze.</p>
<p><span class="caption">Tabela B-7: Komentarze</span></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Symbol</th><th>WyjaÅ›nienie</th></tr>
</thead>
<tbody>
<tr><td><code>//</code></td><td>Komentarz liniowy</td></tr>
<tr><td><code>//!</code></td><td>WewnÄ™trzny komentarz doc. liniowy</td></tr>
<tr><td><code>///</code></td><td>ZewnÄ™trzny komentarz doc. liniowy</td></tr>
<tr><td><code>/*...*/</code></td><td>Komentarz blokowy</td></tr>
<tr><td><code>/*!...*/</code></td><td>WewnÄ™trzny komentarz doc. blokowy</td></tr>
<tr><td><code>/**...*/</code></td><td>ZewnÄ™trzny komentarz doc. blokowy</td></tr>
</tbody>
</table>
</div>
<p>Tabela B-8 przedstawia konteksty, w ktÃ³rych uÅ¼ywane sÄ… nawiasy.</p>
<p><span class="caption">Tabela B-8: Nawiasy</span></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Symbol</th><th>WyjaÅ›nienie</th></tr>
</thead>
<tbody>
<tr><td><code>()</code></td><td>Pusta krotka (aka jednostka), zarÃ³wno literaÅ‚, jak i typ</td></tr>
<tr><td><code>(expr)</code></td><td>WyraÅ¼enie w nawiasach</td></tr>
<tr><td><code>(expr,)</code></td><td>WyraÅ¼enie krotki z jednym elementem</td></tr>
<tr><td><code>(type,)</code></td><td>Typ krotki z jednym elementem</td></tr>
<tr><td><code>(expr, ...)</code></td><td>WyraÅ¼enie krotki</td></tr>
<tr><td><code>(type, ...)</code></td><td>Typ krotki</td></tr>
<tr><td><code>expr(expr, ...)</code></td><td>WyraÅ¼enie wywoÅ‚ania funkcji; uÅ¼ywane rÃ³wnieÅ¼ do inicjalizacji struktur krotek i wariantÃ³w enum krotek</td></tr>
</tbody>
</table>
</div>
<p>Tabela B-9 przedstawia konteksty, w ktÃ³rych uÅ¼ywane sÄ… nawiasy klamrowe.</p>
<p><span class="caption">Tabela B-9: Nawiasy klamrowe</span></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Kontekst</th><th>WyjaÅ›nienie</th></tr>
</thead>
<tbody>
<tr><td><code>{...}</code></td><td>WyraÅ¼enie bloku</td></tr>
<tr><td><code>Type {...}</code></td><td>LiteraÅ‚ struktury</td></tr>
</tbody>
</table>
</div>
<p>Tabela B-10 przedstawia konteksty, w ktÃ³rych uÅ¼ywane sÄ… nawiasy kwadratowe.</p>
<p><span class="caption">Tabela B-10: Nawiasy kwadratowe</span></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Kontekst</th><th>WyjaÅ›nienie</th></tr>
</thead>
<tbody>
<tr><td><code>[...]</code></td><td>LiteraÅ‚ tablicy</td></tr>
<tr><td><code>[expr; len]</code></td><td>LiteraÅ‚ tablicy zawierajÄ…cy <code>len</code> kopii <code>expr</code></td></tr>
<tr><td><code>[type; len]</code></td><td>Typ tablicy zawierajÄ…cy <code>len</code> instancji <code>type</code></td></tr>
<tr><td><code>expr[expr]</code></td><td>Indeksowanie kolekcji; przeciÄ…Å¼alne (<code>Index</code>, <code>IndexMut</code>)</td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code></td><td>Indeksowanie kolekcji udajÄ…ce wycinanie kolekcji, uÅ¼ywajÄ…ce <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code> lub <code>RangeFull</code> jako â€indeksuâ€</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="c---cechy-dziedziczne"><a href="#c---cechy-dziedziczne" class="header">C - Cechy dziedziczne</a></h1>
<h2 id="dodatek-c-cechy-dziedziczne-derivable-traits"><a class="header" href="#dodatek-c-cechy-dziedziczne-derivable-traits">Dodatek C: Cechy dziedziczne (Derivable Traits)</a></h2>
<p>W rÃ³Å¼nych miejscach w ksiÄ…Å¼ce omawialiÅ›my atrybut <code>derive</code>, ktÃ³ry moÅ¼na zastosowaÄ‡ do definicji struktury lub wyliczenia. Atrybut <code>derive</code> generuje kod, ktÃ³ry zaimplementuje cechÄ™ z wÅ‚asnÄ… domyÅ›lnÄ… implementacjÄ… dla typu, ktÃ³ry opatrzyÅ‚eÅ› skÅ‚adniÄ… <code>derive</code>.</p>
<p>W tym dodatku przedstawiamy odniesienie do wszystkich cech w bibliotece standardowej, ktÃ³rych moÅ¼esz uÅ¼ywaÄ‡ z <code>derive</code>. KaÅ¼da sekcja obejmuje:</p>
<ul>
<li>Jakie operatory i metody umoÅ¼liwi dziedziczenie tej cechy.</li>
<li>Co robi implementacja cechy dostarczana przez <code>derive</code>.</li>
<li>Co implementacja cechy oznacza dla typu.</li>
<li>Warunki, w ktÃ³rych dozwolone lub niedozwolone jest implementowanie cechy.</li>
<li>PrzykÅ‚ady operacji, ktÃ³re wymagajÄ… tej cechy.</li>
</ul>
<p>JeÅ›li chcesz innego zachowania niÅ¼ to, ktÃ³re zapewnia atrybut <code>derive</code>, zapoznaj siÄ™ z <a href="../std/index.html">dokumentacjÄ… biblioteki standardowej</a><!-- ignore --> dla kaÅ¼dej cechy, aby uzyskaÄ‡ szczegÃ³Å‚owe informacje na temat rÄ™cznej ich implementacji.</p>
<p>Cechy wymienione tutaj sÄ… jedynymi zdefiniowanymi przez bibliotekÄ™ standardowÄ…, ktÃ³re mogÄ… byÄ‡ implementowane na twoich typach za pomocÄ… <code>derive</code>. Inne cechy zdefiniowane w bibliotece standardowej nie majÄ… sensownego domyÅ›lnego zachowania, wiÄ™c to od ciebie zaleÅ¼y, jak je zaimplementujesz, aby miaÅ‚y sens dla tego, co prÃ³bujesz osiÄ…gnÄ…Ä‡.</p>
<p>PrzykÅ‚adem cechy, ktÃ³rej nie moÅ¼na dziedziczyÄ‡, jest <code>Display</code>, ktÃ³ra obsÅ‚uguje formatowanie dla uÅ¼ytkownikÃ³w koÅ„cowych. Zawsze powinieneÅ› rozwaÅ¼yÄ‡ odpowiedni sposÃ³b wyÅ›wietlania typu uÅ¼ytkownikowi koÅ„cowemu. Jakie czÄ™Å›ci typu powinny byÄ‡ widoczne dla uÅ¼ytkownika koÅ„cowego? Jakie czÄ™Å›ci byÅ‚yby dla nich istotne? Jaki format danych byÅ‚by dla nich najbardziej istotny? Kompilator Rusta nie ma tej wiedzy, wiÄ™c nie moÅ¼e zapewniÄ‡ odpowiedniego domyÅ›lnego zachowania.</p>
<p>Lista cech dziedzicznych podana w tym dodatku nie jest wyczerpujÄ…ca: biblioteki mogÄ… implementowaÄ‡ <code>derive</code> dla wÅ‚asnych cech, co sprawia, Å¼e lista cech, z ktÃ³rymi moÅ¼na uÅ¼ywaÄ‡ <code>derive</code>, jest naprawdÄ™ otwarta. Implementacja <code>derive</code> wiÄ…Å¼e siÄ™ z uÅ¼yciem makra proceduralnego, co zostaÅ‚o omÃ³wione w sekcji <a href="#custom-derive-macros">â€Niestandardowe makra <code>derive</code>â€</a><!-- ignore --> w Rozdziale 20.</p>
<h3 id="debug-dla-wyjÅ›cia-programisty"><a class="header" href="#debug-dla-wyjÅ›cia-programisty"><code>Debug</code> dla wyjÅ›cia programisty</a></h3>
<p>Cecha <code>Debug</code> umoÅ¼liwia formatowanie debugowania w ciÄ…gach formatujÄ…cych, co sygnalizujesz, dodajÄ…c <code>:?</code> wewnÄ…trz symboli zastÄ™pczych <code>{}</code>.</p>
<p>Cecha <code>Debug</code> pozwala na drukowanie instancji typu w celach debugowania, dziÄ™ki czemu ty i inni programiÅ›ci uÅ¼ywajÄ…cy twojego typu moÅ¼ecie sprawdziÄ‡ instancjÄ™ w okreÅ›lonym punkcie wykonania programu.</p>
<p>Cecha <code>Debug</code> jest wymagana, na przykÅ‚ad, przy uÅ¼yciu makra <code>assert_eq!</code>. To makro drukuje wartoÅ›ci instancji podanych jako argumenty, jeÅ›li twierdzenie o rÃ³wnoÅ›ci zawiedzie, tak aby programiÅ›ci mogli zobaczyÄ‡, dlaczego dwie instancje nie byÅ‚y rÃ³wne.</p>
<h3 id="partialeq-i-eq-dla-porÃ³wnaÅ„-rÃ³wnoÅ›ci"><a class="header" href="#partialeq-i-eq-dla-porÃ³wnaÅ„-rÃ³wnoÅ›ci"><code>PartialEq</code> i <code>Eq</code> dla porÃ³wnaÅ„ rÃ³wnoÅ›ci</a></h3>
<p>Cecha <code>PartialEq</code> pozwala porÃ³wnywaÄ‡ instancje typu pod kÄ…tem rÃ³wnoÅ›ci i umoÅ¼liwia uÅ¼ycie operatorÃ³w <code>==</code> i <code>!=</code>.</p>
<p>Dziedziczenie <code>PartialEq</code> implementuje metodÄ™ <code>eq</code>. Gdy <code>PartialEq</code> jest dziedziczone w strukturach, dwie instancje sÄ… rÃ³wne tylko wtedy, gdy <em>wszystkie</em> pola sÄ… rÃ³wne, i nie sÄ… rÃ³wne, jeÅ›li <em>ktÃ³rekolwiek</em> pola nie sÄ… rÃ³wne. Gdy dziedziczone w wyliczeniach, kaÅ¼dy wariant jest rÃ³wny sam sobie i nierÃ³wny innym wariantom.</p>
<p>Cecha <code>PartialEq</code> jest wymagana, na przykÅ‚ad, przy uÅ¼yciu makra <code>assert_eq!</code>, ktÃ³re musi byÄ‡ w stanie porÃ³wnaÄ‡ dwie instancje typu pod kÄ…tem rÃ³wnoÅ›ci.</p>
<p>Cecha <code>Eq</code> nie ma Å¼adnych metod. Jej celem jest sygnalizowanie, Å¼e dla kaÅ¼dej wartoÅ›ci typu oznaczonego, wartoÅ›Ä‡ jest rÃ³wna sobie. Cecha <code>Eq</code> moÅ¼e byÄ‡ zastosowana tylko do typÃ³w, ktÃ³re rÃ³wnieÅ¼ implementujÄ… <code>PartialEq</code>, chociaÅ¼ nie wszystkie typy, ktÃ³re implementujÄ… <code>PartialEq</code>, mogÄ… implementowaÄ‡ <code>Eq</code>. Jednym z przykÅ‚adÃ³w sÄ… typy liczb zmiennoprzecinkowych: implementacja liczb zmiennoprzecinkowych mÃ³wi, Å¼e dwie instancje wartoÅ›ci not-a-number (<code>NaN</code>) nie sÄ… sobie rÃ³wne.</p>
<p>PrzykÅ‚adem, kiedy wymagana jest cecha <code>Eq</code>, jest uÅ¼ycie kluczy w <code>HashMap&lt;K, V&gt;</code>, aby <code>HashMap&lt;K, V&gt;</code> mogÅ‚o stwierdziÄ‡, czy dwa klucze sÄ… takie same.</p>
<h3 id="partialord-i-ord-dla-porÃ³wnaÅ„-porzÄ…dkowania"><a class="header" href="#partialord-i-ord-dla-porÃ³wnaÅ„-porzÄ…dkowania"><code>PartialOrd</code> i <code>Ord</code> dla porÃ³wnaÅ„ porzÄ…dkowania</a></h3>
<p>Cecha <code>PartialOrd</code> pozwala porÃ³wnywaÄ‡ instancje typu w celach sortowania. Typ, ktÃ³ry implementuje <code>PartialOrd</code>, moÅ¼e byÄ‡ uÅ¼ywany z operatorami <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, i <code>&gt;=</code>. CechÄ™ <code>PartialOrd</code> moÅ¼na zastosowaÄ‡ tylko do typÃ³w, ktÃ³re rÃ³wnieÅ¼ implementujÄ… <code>PartialEq</code>.</p>
<p>Dziedziczenie <code>PartialOrd</code> implementuje metodÄ™ <code>partial_cmp</code>, ktÃ³ra zwraca <code>Option&lt;Ordering&gt;</code>, ktÃ³ra bÄ™dzie <code>None</code>, gdy podane wartoÅ›ci nie dajÄ… porzÄ…dku. PrzykÅ‚adem wartoÅ›ci, ktÃ³ra nie daje porzÄ…dku, nawet jeÅ›li wiÄ™kszoÅ›Ä‡ wartoÅ›ci tego typu moÅ¼na porÃ³wnaÄ‡, jest wartoÅ›Ä‡ zmiennoprzecinkowa <code>NaN</code>. WywoÅ‚anie <code>partial_cmp</code> z dowolnÄ… liczbÄ… zmiennoprzecinkowÄ… i wartoÅ›ciÄ… zmiennoprzecinkowÄ… <code>NaN</code> zwrÃ³ci <code>None</code>.</p>
<p>DziedziczÄ…c w strukturach, <code>PartialOrd</code> porÃ³wnuje dwie instancje, porÃ³wnujÄ…c wartoÅ›Ä‡ w kaÅ¼dym polu w kolejnoÅ›ci, w jakiej pola pojawiajÄ… siÄ™ w definicji struktury. DziedziczÄ…c w wyliczeniach, warianty wyliczenia zadeklarowane wczeÅ›niej w definicji wyliczenia sÄ… uwaÅ¼ane za mniejsze niÅ¼ warianty wymienione pÃ³Åºniej.</p>
<p>Cecha <code>PartialOrd</code> jest wymagana, na przykÅ‚ad, dla metody <code>gen_range</code> z crate <code>rand</code>, ktÃ³ra generuje losowÄ… wartoÅ›Ä‡ w zakresie okreÅ›lonym przez wyraÅ¼enie zakresowe.</p>
<p>Cecha <code>Ord</code> pozwala wiedzieÄ‡, Å¼e dla dowolnych dwÃ³ch wartoÅ›ci typu opisanego adnotacjÄ…, zawsze bÄ™dzie istniaÅ‚o prawidÅ‚owe uporzÄ…dkowanie. Cecha <code>Ord</code> implementuje metodÄ™ <code>cmp</code>, ktÃ³ra zwraca <code>Ordering</code> zamiast <code>Option&lt;Ordering&gt;</code>, poniewaÅ¼ prawidÅ‚owe uporzÄ…dkowanie zawsze bÄ™dzie moÅ¼liwe. CechÄ™ <code>Ord</code> moÅ¼na zastosowaÄ‡ tylko do typÃ³w, ktÃ³re rÃ³wnieÅ¼ implementujÄ… <code>PartialOrd</code> i <code>Eq</code> (a <code>Eq</code> wymaga <code>PartialEq</code>). DziedziczÄ…c w strukturach i wyliczeniach, <code>cmp</code> zachowuje siÄ™ tak samo jak zaimplementowane <code>partial_cmp</code> w <code>PartialOrd</code>.</p>
<p>PrzykÅ‚adem, kiedy wymagana jest cecha <code>Ord</code>, jest przechowywanie wartoÅ›ci w <code>BTreeSet&lt;T&gt;</code>, strukturze danych, ktÃ³ra przechowuje dane na podstawie kolejnoÅ›ci sortowania wartoÅ›ci.</p>
<h3 id="clone-i-copy-do-duplikowania-wartoÅ›ci"><a class="header" href="#clone-i-copy-do-duplikowania-wartoÅ›ci"><code>Clone</code> i <code>Copy</code> do duplikowania wartoÅ›ci</a></h3>
<p>Cecha <code>Clone</code> pozwala jawnie utworzyÄ‡ gÅ‚Ä™bokÄ… kopiÄ™ wartoÅ›ci, a proces duplikacji moÅ¼e obejmowaÄ‡ uruchomienie dowolnego kodu i kopiowanie danych na stercie. Aby uzyskaÄ‡ wiÄ™cej informacji na temat <code>Clone</code>, zobacz sekcjÄ™ <a href="#variables-and-data-interacting-with-clone">â€Zmienne i dane wspÃ³Å‚dziaÅ‚ajÄ…ce z Cloneâ€</a><!-- ignore --> w Rozdziale 4.</p>
<p>Dziedziczenie <code>Clone</code> implementuje metodÄ™ <code>clone</code>, ktÃ³ra, zaimplementowana dla caÅ‚ego typu, wywoÅ‚uje <code>clone</code> na kaÅ¼dej z czÄ™Å›ci typu. Oznacza to, Å¼e wszystkie pola lub wartoÅ›ci w typie muszÄ… rÃ³wnieÅ¼ implementowaÄ‡ <code>Clone</code>, aby dziedziczyÄ‡ <code>Clone</code>.</p>
<p>PrzykÅ‚adem, kiedy wymagana jest cecha <code>Clone</code>, jest wywoÅ‚anie metody <code>to_vec</code> na wycinku. Wycinek nie jest wÅ‚aÅ›cicielem instancji typÃ³w, ktÃ³re zawiera, ale wektor zwrÃ³cony z <code>to_vec</code> bÄ™dzie musiaÅ‚ byÄ‡ wÅ‚aÅ›cicielem swoich instancji, wiÄ™c <code>to_vec</code> wywoÅ‚uje <code>clone</code> na kaÅ¼dym elemencie. W ten sposÃ³b typ przechowywany w wycinku musi implementowaÄ‡ <code>Clone</code>.</p>
<p>Cecha <code>Copy</code> pozwala duplikowaÄ‡ wartoÅ›Ä‡ tylko poprzez kopiowanie bitÃ³w przechowywanych na stosie; nie jest potrzebny Å¼aden arbitralny kod. WiÄ™cej informacji na temat <code>Copy</code> znajdziesz w sekcji <a href="#stack-only-data-copy">â€Dane tylko na stosie: Copyâ€</a><!-- ignore --> w Rozdziale 4.</p>
<p>Cecha <code>Copy</code> nie definiuje Å¼adnych metod, aby zapobiec przeciÄ…Å¼aniu tych metod przez programistÃ³w i naruszaniu zaÅ‚oÅ¼enia, Å¼e Å¼aden arbitralny kod nie jest wykonywany. W ten sposÃ³b wszyscy programiÅ›ci mogÄ… zakÅ‚adaÄ‡, Å¼e kopiowanie wartoÅ›ci bÄ™dzie bardzo szybkie.</p>
<p>MoÅ¼esz dziedziczyÄ‡ <code>Copy</code> na dowolnym typie, ktÃ³rego wszystkie czÄ™Å›ci implementujÄ… <code>Copy</code>. Typ, ktÃ³ry implementuje <code>Copy</code>, musi rÃ³wnieÅ¼ implementowaÄ‡ <code>Clone</code>, poniewaÅ¼ typ, ktÃ³ry implementuje <code>Copy</code>, ma trywialnÄ… implementacjÄ™ <code>Clone</code>, ktÃ³ra wykonuje to samo zadanie co <code>Copy</code>.</p>
<p>Cecha <code>Copy</code> jest rzadko wymagana; typy, ktÃ³re implementujÄ… <code>Copy</code>, majÄ… dostÄ™pne optymalizacje, co oznacza, Å¼e nie musisz wywoÅ‚ywaÄ‡ <code>clone</code>, co sprawia, Å¼e kod jest bardziej zwiÄ™zÅ‚y.</p>
<p>Wszystko, co jest moÅ¼liwe z <code>Copy</code>, moÅ¼na rÃ³wnieÅ¼ osiÄ…gnÄ…Ä‡ z <code>Clone</code>, ale kod moÅ¼e byÄ‡ wolniejszy lub musi uÅ¼ywaÄ‡ <code>clone</code> w niektÃ³rych miejscach.</p>
<h3 id="hash-do-mapowania-wartoÅ›ci-na-wartoÅ›Ä‡-o-staÅ‚ym-rozmiarze"><a class="header" href="#hash-do-mapowania-wartoÅ›ci-na-wartoÅ›Ä‡-o-staÅ‚ym-rozmiarze"><code>Hash</code> do mapowania wartoÅ›ci na wartoÅ›Ä‡ o staÅ‚ym rozmiarze</a></h3>
<p>Cecha <code>Hash</code> pozwala na pobranie instancji typu o dowolnym rozmiarze i zmapowanie jej na wartoÅ›Ä‡ o staÅ‚ym rozmiarze za pomocÄ… funkcji haszujÄ…cej. Dziedziczenie <code>Hash</code> implementuje metodÄ™ <code>hash</code>. Zaimplementowana metoda <code>hash</code> Å‚Ä…czy wynik wywoÅ‚ania <code>hash</code> na kaÅ¼dej z czÄ™Å›ci typu, co oznacza, Å¼e wszystkie pola lub wartoÅ›ci muszÄ… rÃ³wnieÅ¼ implementowaÄ‡ <code>Hash</code>, aby dziedziczyÄ‡ <code>Hash</code>.</p>
<p>PrzykÅ‚adem, kiedy wymagana jest cecha <code>Hash</code>, jest przechowywanie kluczy w <code>HashMap&lt;K, V&gt;</code> w celu efektywnego przechowywania danych.</p>
<h3 id="default-dla-wartoÅ›ci-domyÅ›lnych"><a class="header" href="#default-dla-wartoÅ›ci-domyÅ›lnych"><code>Default</code> dla wartoÅ›ci domyÅ›lnych</a></h3>
<p>Cecha <code>Default</code> pozwala utworzyÄ‡ domyÅ›lnÄ… wartoÅ›Ä‡ dla typu. Dziedziczenie <code>Default</code> implementuje funkcjÄ™ <code>default</code>. Dziedziczona implementacja funkcji <code>default</code> wywoÅ‚uje funkcjÄ™ <code>default</code> dla kaÅ¼dej czÄ™Å›ci typu, co oznacza, Å¼e wszystkie pola lub wartoÅ›ci w typie muszÄ… rÃ³wnieÅ¼ implementowaÄ‡ <code>Default</code>, aby dziedziczyÄ‡ <code>Default</code>.</p>
<p>Funkcja <code>Default::default</code> jest powszechnie uÅ¼ywana w poÅ‚Ä…czeniu ze skÅ‚adniÄ… aktualizacji struktury omÃ³wionÄ… w sekcji <a href="#creating-instances-from-other-instances-with-struct-update-syntax">â€Tworzenie instancji z innych instancji za pomocÄ… skÅ‚adni aktualizacji strukturâ€</a><!-- ignore --> w Rozdziale 5. MoÅ¼esz dostosowaÄ‡ kilka pÃ³l struktury, a nastÄ™pnie ustawiÄ‡ i uÅ¼yÄ‡ domyÅ›lnej wartoÅ›ci dla pozostaÅ‚ych pÃ³l, uÅ¼ywajÄ…c <code>..Default::default()</code>.</p>
<p>Cecha <code>Default</code> jest wymagana, gdy uÅ¼ywasz metody <code>unwrap_or_default</code> na instancjach <code>Option&lt;T&gt;</code>, na przykÅ‚ad. JeÅ›li <code>Option&lt;T&gt;</code> jest <code>None</code>, metoda <code>unwrap_or_default</code> zwrÃ³ci wynik <code>Default::default</code> dla typu <code>T</code> przechowywanego w <code>Option&lt;T&gt;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="d---przydatne-narzÄ™dzia-deweloperskie"><a href="#d---przydatne-narzÄ™dzia-deweloperskie" class="header">D - Przydatne narzÄ™dzia deweloperskie</a></h1>
<h2 id="dodatek-d-przydatne-narzÄ™dzia-deweloperskie"><a class="header" href="#dodatek-d-przydatne-narzÄ™dzia-deweloperskie">Dodatek D: Przydatne narzÄ™dzia deweloperskie</a></h2>
<p>W tym dodatku omÃ³wimy kilka przydatnych narzÄ™dzi deweloperskich, ktÃ³re udostÄ™pnia projekt Rust. Przyjrzymy siÄ™ automatycznemu formatowaniu, szybkim sposobom stosowania poprawek ostrzeÅ¼eÅ„, linterowi oraz integracji z IDE.</p>
<h3 id="automatyczne-formatowanie-z-rustfmt"><a class="header" href="#automatyczne-formatowanie-z-rustfmt">Automatyczne formatowanie z <code>rustfmt</code></a></h3>
<p>NarzÄ™dzie <code>rustfmt</code> formatuje twÃ³j kod zgodnie ze spoÅ‚ecznoÅ›ciowym stylem kodu. Wiele projektÃ³w wspÃ³Å‚pracujÄ…cych uÅ¼ywa <code>rustfmt</code>, aby zapobiec sporom o to, jaki styl zastosowaÄ‡ podczas pisania w Rust: kaÅ¼dy formatuje swÃ³j kod za pomocÄ… narzÄ™dzia.</p>
<p>Instalacje Rust domyÅ›lnie zawierajÄ… <code>rustfmt</code>, wiÄ™c powinieneÅ› juÅ¼ mieÄ‡ programy <code>rustfmt</code> i <code>cargo-fmt</code> w swoim systemie. Te dwa polecenia sÄ… analogiczne do <code>rustc</code> i <code>cargo</code> w tym sensie, Å¼e <code>rustfmt</code> pozwala na bardziej szczegÃ³Å‚owÄ… kontrolÄ™, a <code>cargo-fmt</code> rozumie konwencje projektu uÅ¼ywajÄ…cego Cargo. Aby sformatowaÄ‡ dowolny projekt Cargo, wpisz nastÄ™pujÄ…ce polecenie:</p>
<pre><code class="language-console">$ cargo fmt
</code></pre>
<p>Uruchomienie tego polecenia formatuje caÅ‚y kod Rust w bieÅ¼Ä…cej skrzynce. Powinno to zmieniÄ‡ tylko styl kodu, a nie semantykÄ™ kodu. Aby uzyskaÄ‡ wiÄ™cej informacji o <code>rustfmt</code>, zobacz <a href="https://github.com/rust-lang/rustfmt">jego dokumentacjÄ™</a>.</p>
<h3 id="napraw-swÃ³j-kod-za-pomocÄ…-rustfix"><a class="header" href="#napraw-swÃ³j-kod-za-pomocÄ…-rustfix">Napraw swÃ³j kod za pomocÄ… <code>rustfix</code></a></h3>
<p>NarzÄ™dzie <code>rustfix</code> jest doÅ‚Ä…czone do instalacji Rust i moÅ¼e automatycznie naprawiaÄ‡ ostrzeÅ¼enia kompilatora, ktÃ³re majÄ… jasny sposÃ³b rozwiÄ…zania problemu, ktÃ³ry jest prawdopodobnie tym, czego chcesz. Prawdopodobnie widziaÅ‚eÅ› juÅ¼ ostrzeÅ¼enia kompilatora. Na przykÅ‚ad, rozwaÅ¼ ten kod:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut x = 42;
    println!("{x}");
}</code></pre>
<p>Tutaj definiujemy zmiennÄ… <code>x</code> jako zmiennÄ…, ale nigdy jej faktycznie nie modyfikujemy. Rust ostrzega nas o tym:</p>
<pre><code class="language-console">$ cargo build
   Kompilowanie myprogram v0.1.0 (file:///projects/myprogram)
warning: zmienna nie musi byÄ‡ mutowalna
 --&gt; src/main.rs:2:9
  |
2 |     let mut x = 0;
  |         ----^
  |         |
  |         pomoc: usuÅ„ to `mut`
  |
  = note: `#[warn(unused_mut)]` domyÅ›lnie wÅ‚Ä…czone
</code></pre>
<p>OstrzeÅ¼enie sugeruje, aby usunÄ…Ä‡ sÅ‚owo kluczowe <code>mut</code>. MoÅ¼emy automatycznie zastosowaÄ‡ tÄ™ sugestiÄ™ za pomocÄ… narzÄ™dzia <code>rustfix</code>, uruchamiajÄ…c polecenie <code>cargo fix</code>:</p>
<pre><code class="language-console">$ cargo fix
    Sprawdzanie myprogram v0.1.0 (file:///projects/myprogram)
      Naprawianie src/main.rs (1 poprawka)
    ZakoÅ„czono dev [nieoptymalny + debuginfo] cel(e) w 0.59s
</code></pre>
<p>Kiedy ponownie spojrzymy na <em>src/main.rs</em>, zobaczymy, Å¼e <code>cargo fix</code> zmieniÅ‚ kod:</p>
<p><span class="filename">Nazwa pliku: src/main.rs</span></p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 42;
    println!("{x}");
}</code></pre>
<p>Zmienna <code>x</code> jest teraz niezmienna, a ostrzeÅ¼enie juÅ¼ siÄ™ nie pojawia.</p>
<p>MoÅ¼esz rÃ³wnieÅ¼ uÅ¼yÄ‡ polecenia <code>cargo fix</code>, aby przetransformowaÄ‡ swÃ³j kod miÄ™dzy rÃ³Å¼nymi edycjami Rust. Edycje sÄ… omÃ³wione w <a href="#e---edycje">Dodatku E</a><!-- ignore -->.</p>
<h3 id="wiÄ™cej-lintÃ³w-z-clippy"><a class="header" href="#wiÄ™cej-lintÃ³w-z-clippy">WiÄ™cej lintÃ³w z Clippy</a></h3>
<p>NarzÄ™dzie Clippy to zbiÃ³r lintÃ³w do analizowania kodu, dziÄ™ki czemu moÅ¼esz wyÅ‚apaÄ‡ typowe bÅ‚Ä™dy i ulepszyÄ‡ swÃ³j kod w Rust. Clippy jest doÅ‚Ä…czone do standardowych instalacji Rust.</p>
<p>Aby uruchomiÄ‡ lintery Clippy w dowolnym projekcie Cargo, wpisz nastÄ™pujÄ…ce polecenie:</p>
<pre><code class="language-console">$ cargo clippy
</code></pre>
<p>Na przykÅ‚ad, powiedzmy, Å¼e piszesz program, ktÃ³ry uÅ¼ywa przybliÅ¼enia staÅ‚ej matematycznej, takiej jak pi, jak ten program:</p>
<listing file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!("powierzchnia koÅ‚a wynosi {}", x * r * r);
}</code></pre>
</listing>
<p>Uruchomienie <code>cargo clippy</code> w tym projekcie powoduje nastÄ™pujÄ…cy bÅ‚Ä…d:</p>
<pre><code class="language-text">bÅ‚Ä…d: znaleziono przybliÅ¼onÄ… wartoÅ›Ä‡ `f{32, 64}::consts::PI`
 --&gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: `#[deny(clippy::approx_constant)]` domyÅ›lnie wÅ‚Ä…czone
  = help: rozwaÅ¼ uÅ¼ycie staÅ‚ej bezpoÅ›rednio
  = help: wiÄ™cej informacji znajdziesz na https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<p>Ten bÅ‚Ä…d informuje, Å¼e Rust ma juÅ¼ zdefiniowanÄ… bardziej precyzyjnÄ… staÅ‚Ä… <code>PI</code>, i Å¼e twÃ³j program byÅ‚by bardziej poprawny, gdybyÅ› zamiast tego uÅ¼yÅ‚ tej staÅ‚ej. NastÄ™pnie zmieniÅ‚byÅ› swÃ³j kod, aby uÅ¼ywaÄ‡ staÅ‚ej <code>PI</code>.</p>
<p>PoniÅ¼szy kod nie powoduje Å¼adnych bÅ‚Ä™dÃ³w ani ostrzeÅ¼eÅ„ z Clippy:</p>
<listing file-name="src/main.rs">
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!("powierzchnia koÅ‚a wynosi {}", x * r * r);
}</code></pre>
</listing>
<p>Aby uzyskaÄ‡ wiÄ™cej informacji o Clippy, zobacz <a href="https://github.com/rust-lang/rust-clippy">jego dokumentacjÄ™</a>.</p>
<h3 id="integracja-z-ide-za-pomocÄ…-rust-analyzer"><a class="header" href="#integracja-z-ide-za-pomocÄ…-rust-analyzer">Integracja z IDE za pomocÄ… <code>rust-analyzer</code></a></h3>
<p>Aby pomÃ³c w integracji z IDE, spoÅ‚ecznoÅ›Ä‡ Rust zaleca uÅ¼ywanie <a href="https://rust-analyzer.github.io"><code>rust-analyzer</code></a><!-- ignore -->. To narzÄ™dzie to zestaw narzÄ™dzi zorientowanych na kompilator, ktÃ³re komunikujÄ… siÄ™ za pomocÄ… <a href="http://langserver.org/">Language Server Protocol</a><!-- ignore -->, czyli specyfikacji komunikacji miÄ™dzy IDE a jÄ™zykami programowania. RÃ³Å¼ni klienci mogÄ… uÅ¼ywaÄ‡ <code>rust-analyzer</code>, np. <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">wtyczka Rust analyzer dla Visual Studio Code</a>.</p>
<p>OdwiedÅº <a href="https://rust-analyzer.github.io">stronÄ™ gÅ‚Ã³wnÄ…</a><!-- ignore --> projektu <code>rust-analyzer</code>, aby zapoznaÄ‡ siÄ™ z instrukcjami instalacji, a nastÄ™pnie zainstaluj obsÅ‚ugÄ™ serwera jÄ™zyka w swoim IDE. Twoje IDE zyska takie moÅ¼liwoÅ›ci jak autouzupeÅ‚nianie, skok do definicji i wbudowane bÅ‚Ä™dy.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="e---edycje"><a href="#e---edycje" class="header">E - Edycje</a></h1>
<h2 id="dodatek-e-edycje"><a class="header" href="#dodatek-e-edycje">Dodatek E: Edycje</a></h2>
<p>W Rozdziale 1 widziaÅ‚eÅ›, Å¼e <code>cargo new</code> dodaje nieco metadanych do pliku <em>Cargo.toml</em> dotyczÄ…cych edycji. Ten dodatek opowiada o tym, co to oznacza!</p>
<p>JÄ™zyk i kompilator Rust majÄ… szeÅ›ciotygodniowy cykl wydawniczy, co oznacza, Å¼e uÅ¼ytkownicy otrzymujÄ… staÅ‚y strumieÅ„ nowych funkcji. Inne jÄ™zyki programowania rzadziej wydajÄ… wiÄ™ksze zmiany; Rust czÄ™Å›ciej wydaje mniejsze aktualizacje. Po pewnym czasie wszystkie te drobne zmiany sumujÄ… siÄ™. Ale z wydania na wydanie trudno jest spojrzeÄ‡ wstecz i powiedzieÄ‡: â€Wow, miÄ™dzy Rustem 1.10 a Rustem 1.31 Rust bardzo siÄ™ zmieniÅ‚!â€</p>
<p>Co okoÅ‚o trzy lata zespÃ³Å‚ Rust tworzy nowÄ… <em>edycjÄ™</em> Rust. KaÅ¼da edycja Å‚Ä…czy funkcje, ktÃ³re wylÄ…dowaÅ‚y, w przejrzysty pakiet z w peÅ‚ni zaktualizowanÄ… dokumentacjÄ… i narzÄ™dziami. Nowe edycje sÄ… dostarczane w ramach zwykÅ‚ego szeÅ›ciotygodniowego procesu wydawniczego.</p>
<p>Edycje sÅ‚uÅ¼Ä… rÃ³Å¼nym celom dla rÃ³Å¼nych ludzi:</p>
<ul>
<li>Dla aktywnych uÅ¼ytkownikÃ³w Rusta, nowa edycja Å‚Ä…czy stopniowe zmiany w Å‚atwy do zrozumienia pakiet.</li>
<li>Dla nie-uÅ¼ytkownikÃ³w, nowa edycja sygnalizuje, Å¼e nastÄ…piÅ‚y pewne powaÅ¼ne postÄ™py, co moÅ¼e sprawiÄ‡, Å¼e Rust bÄ™dzie wart ponownego rozwaÅ¼enia.</li>
<li>Dla tych, ktÃ³rzy rozwijajÄ… Rusta, nowa edycja stanowi punkt zborny dla caÅ‚ego projektu.</li>
</ul>
<p>W chwili pisania tego tekstu dostÄ™pne sÄ… cztery edycje Rusta: Rust 2015, Rust 2018, Rust 2021 i Rust 2024. Ta ksiÄ…Å¼ka jest napisana z uÅ¼yciem idiomÃ³w edycji Rust 2024.</p>
<p>Klucz <code>edition</code> w <em>Cargo.toml</em> wskazuje, ktÃ³rej edycji kompilator powinien uÅ¼ywaÄ‡ dla twojego kodu. JeÅ›li klucz nie istnieje, Rust uÅ¼ywa <code>2015</code> jako wartoÅ›ci edycji z powodu kompatybilnoÅ›ci wstecznej.</p>
<p>KaÅ¼dy projekt moÅ¼e zdecydowaÄ‡ siÄ™ na edycjÄ™ innÄ… niÅ¼ domyÅ›lna edycja 2015. Edycje mogÄ… zawieraÄ‡ niekompatybilne zmiany, takie jak wÅ‚Ä…czenie nowego sÅ‚owa kluczowego, ktÃ³re koliduje z identyfikatorami w kodzie. Jednak, jeÅ›li nie zdecydujesz siÄ™ na te zmiany, twÃ³j kod bÄ™dzie nadal kompilowaÄ‡ siÄ™, nawet jeÅ›li zaktualizujesz wersjÄ™ kompilatora Rust, ktÃ³rej uÅ¼ywasz.</p>
<p>Wszystkie wersje kompilatora Rust obsÅ‚ugujÄ… kaÅ¼dÄ… edycjÄ™, ktÃ³ra istniaÅ‚a przed wydaniem tego kompilatora, i mogÄ… Å‚Ä…czyÄ‡ skrzynki z dowolnych obsÅ‚ugiwanych edycji. Zmiany edycji wpÅ‚ywajÄ… tylko na sposÃ³b, w jaki kompilator poczÄ…tkowo parsuje kod. Dlatego, jeÅ›li uÅ¼ywasz Rust 2015, a jedna z twoich zaleÅ¼noÅ›ci uÅ¼ywa Rust 2018, twÃ³j projekt skompiluje siÄ™ i bÄ™dzie mÃ³gÅ‚ uÅ¼ywaÄ‡ tej zaleÅ¼noÅ›ci. Sytuacja odwrotna, w ktÃ³rej twÃ³j projekt uÅ¼ywa Rust 2018, a zaleÅ¼noÅ›Ä‡ uÅ¼ywa Rust 2015, rÃ³wnieÅ¼ dziaÅ‚a.</p>
<p>Aby byÅ‚o jasne: wiÄ™kszoÅ›Ä‡ funkcji bÄ™dzie dostÄ™pna we wszystkich edycjach. ProgramiÅ›ci uÅ¼ywajÄ…cy dowolnej edycji Rust nadal bÄ™dÄ… widzieÄ‡ ulepszenia w miarÄ™ pojawiania siÄ™ nowych stabilnych wydaÅ„. Jednak w niektÃ³rych przypadkach, gÅ‚Ã³wnie gdy dodawane sÄ… nowe sÅ‚owa kluczowe, niektÃ³re nowe funkcje mogÄ… byÄ‡ dostÄ™pne tylko w pÃ³Åºniejszych edycjach. BÄ™dziesz musiaÅ‚ zmieniÄ‡ edycjÄ™, jeÅ›li chcesz skorzystaÄ‡ z takich funkcji.</p>
<p>WiÄ™cej szczegÃ³Å‚Ã³w znajdziesz w <a href="https://doc.rust-lang.org/stable/edition-guide"><em>Przewodniku po Edycjach Rust</em></a>. Jest to kompletna ksiÄ…Å¼ka, ktÃ³ra wylicza rÃ³Å¼nice miÄ™dzy edycjami i wyjaÅ›nia, jak automatycznie zaktualizowaÄ‡ kod do nowej edycji za pomocÄ… <code>cargo fix</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="f---tÅ‚umaczenia-ksiÄ…Å¼ki"><a href="#f---tÅ‚umaczenia-ksiÄ…Å¼ki" class="header">F - TÅ‚umaczenia ksiÄ…Å¼ki</a></h1>
<h2 id="dodatek-f-tÅ‚umaczenia-ksiÄ…Å¼ki"><a class="header" href="#dodatek-f-tÅ‚umaczenia-ksiÄ…Å¼ki">Dodatek F: TÅ‚umaczenia ksiÄ…Å¼ki</a></h2>
<p>Dla zasobÃ³w w jÄ™zykach innych niÅ¼ angielski. WiÄ™kszoÅ›Ä‡ z nich jest nadal w toku; zobacz <a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">etykietÄ™ TÅ‚umaczenia</a>, aby pomÃ³c lub daÄ‡ nam znaÄ‡ o nowym tÅ‚umaczeniu!</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">PortuguÃªs</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">PortuguÃªs</a> (PT)</li>
<li>ç®€ä½“ä¸­æ–‡: <a href="https://github.com/KaiserY/trpl-zh-cn">KaiserY/trpl-zh-cn</a>, <a href="https://github.com/gnu4cn/rust-lang-Zh_CN">gnu4cn/rust-lang-Zh_CN</a></li>
<li><a href="https://github.com/rust-tw/book-tw">æ­£é«”ä¸­æ–‡</a></li>
<li><a href="https://rust-lang-ua.github.io/rustbook_ukrainian">Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ°</a></li>
<li><a href="https://github.com/thecodix/book">EspaÃ±ol</a>, <a href="https://github.com/ManRR/rust-book-es">alternatywna</a>, <a href="https://github.com/RustLangES/rust-book-es">EspaÃ±ol by RustLangES</a></li>
<li><a href="https://github.com/rust-lang-ru/book">Ğ ÑƒÑÑĞºĞ¸Ğ¹</a></li>
<li><a href="https://github.com/rust-kr/doc.rust-kr.org">í•œêµ­ì–´</a></li>
<li><a href="https://github.com/rust-lang-ja/book-ja">æ—¥æœ¬èª</a></li>
<li><a href="https://github.com/Jimskapt/rust-book-fr">FranÃ§ais</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
<li><a href="https://github.com/psychoslave/Rust-libro">Esperanto</a></li>
<li><a href="https://github.com/TChatzigiannakis/rust-book-greek">ÎµÎ»Î»Î·Î½Î¹ÎºÎ®</a></li>
<li><a href="https://github.com/sebras/book">Svenska</a></li>
<li><a href="https://github.com/RustFarsi/book">Farsi</a>, <a href="https://github.com/persian-rust/book">Persian (FA)</a></li>
<li><a href="https://github.com/rust-lang-de/rustbook-de">Deutsch</a></li>
<li><a href="https://github.com/venkatarun95/rust-book-hindi">à¤¹à¤¿à¤‚à¤¦à¥€</a></li>
<li><a href="https://github.com/rust-lang-th/book-th">à¹„à¸—à¸¢</a></li>
<li><a href="https://github.com/DanKHansen/book-dk">Danske</a></li>
<li><a href="https://github.com/rust-lang-uz/book">Oâ€™zbek</a></li>
<li><a href="https://github.com/tuanemdev/rust-book-vn">Tiáº¿ng Viá»‡t</a></li>
<li><a href="https://nixxo.github.io/rust-lang-book-it/">Italiano</a></li>
<li><a href="https://github.com/IsmailHosenIsmailJames/rust-book-bn">à¦¬à¦¾à¦‚à¦²à¦¾</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="g---jak-powstaje-rust-i-nightly-rust"><a href="#g---jak-powstaje-rust-i-nightly-rust" class="header">G - Jak powstaje Rust i â€Nightly Rustâ€</a></h1>
<h2 id="dodatek-g---jak-powstaje-rust-i-nightly-rust"><a class="header" href="#dodatek-g---jak-powstaje-rust-i-nightly-rust">Dodatek G - Jak powstaje Rust i â€Nightly Rustâ€</a></h2>
<p>Ten dodatek opisuje, jak powstaje Rust i jak to wpÅ‚ywa na Ciebie jako dewelopera Rust.</p>
<h3 id="stabilnoÅ›Ä‡-bez-stagnacji"><a class="header" href="#stabilnoÅ›Ä‡-bez-stagnacji">StabilnoÅ›Ä‡ bez stagnacji</a></h3>
<p>Jako jÄ™zyk, Rust <em>bardzo</em> dba o stabilnoÅ›Ä‡ Twojego kodu. Chcemy, aby Rust byÅ‚ solidnym fundamentem, na ktÃ³rym moÅ¼esz budowaÄ‡, a gdyby rzeczy ciÄ…gle siÄ™ zmieniaÅ‚y, byÅ‚oby to niemoÅ¼liwe. JednoczeÅ›nie, jeÅ›li nie bÄ™dziemy mogli eksperymentowaÄ‡ z nowymi funkcjami, moÅ¼emy nie odkryÄ‡ waÅ¼nych wad aÅ¼ do momentu ich wydania, kiedy to nie bÄ™dziemy juÅ¼ w stanie nic zmieniÄ‡.</p>
<p>Naszym rozwiÄ…zaniem tego problemu jest to, co nazywamy â€stabilnoÅ›ciÄ… bez stagnacjiâ€, a nasza przewodnia zasada brzmi: nigdy nie powinieneÅ› obawiaÄ‡ siÄ™ aktualizacji do nowej wersji stabilnego Rusta. KaÅ¼da aktualizacja powinna byÄ‡ bezbolesna, ale takÅ¼e przynosiÄ‡ nowe funkcje, mniej bÅ‚Ä™dÃ³w i szybszy czas kompilacji.</p>
<h3 id="ciuch-ciuch-kanaÅ‚y-wydaÅ„-i-jazda-pociÄ…gami"><a class="header" href="#ciuch-ciuch-kanaÅ‚y-wydaÅ„-i-jazda-pociÄ…gami">Ciuch, ciuch! KanaÅ‚y wydaÅ„ i jazda pociÄ…gami</a></h3>
<p>RozwÃ³j Rusta odbywa siÄ™ wedÅ‚ug <em>rozkÅ‚adu jazdy pociÄ…gÃ³w</em>. Oznacza to, Å¼e caÅ‚y rozwÃ³j odbywa siÄ™ w gÅ‚Ã³wnej gaÅ‚Ä™zi repozytorium Rusta. Wydania sÄ… zgodne z modelem pociÄ…gu wydaÅ„ oprogramowania, ktÃ³ry byÅ‚ uÅ¼ywany przez Cisco IOS i inne projekty. IstniejÄ… trzy <em>kanaÅ‚y wydaÅ„</em> Rusta:</p>
<ul>
<li>Nightly</li>
<li>Beta</li>
<li>Stabilny</li>
</ul>
<p>WiÄ™kszoÅ›Ä‡ deweloperÃ³w Rusta uÅ¼ywa gÅ‚Ã³wnie kanaÅ‚u stabilnego, ale ci, ktÃ³rzy chcÄ… wyprÃ³bowaÄ‡ eksperymentalne nowe funkcje, mogÄ… uÅ¼ywaÄ‡ nightly lub beta.</p>
<p>Oto przykÅ‚ad, jak dziaÅ‚a proces rozwoju i wydawania: zaÅ‚Ã³Å¼my, Å¼e zespÃ³Å‚ Rusta pracuje nad wydaniem Rust 1.5. To wydanie miaÅ‚o miejsce w grudniu 2015 roku, ale dostarczy nam realistycznych numerÃ³w wersji. Do Rusta dodawana jest nowa funkcja: nowy commit lÄ…duje w gÅ‚Ã³wnej gaÅ‚Ä™zi. KaÅ¼dej nocy tworzona jest nowa wersja nightly Rusta. KaÅ¼dy dzieÅ„ jest dniem wydania, a te wydania sÄ… tworzone automatycznie przez naszÄ… infrastrukturÄ™ wydawniczÄ…. Tak wiÄ™c z biegiem czasu nasze wydania wyglÄ…dajÄ… tak, raz na noc:</p>
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<p>Co szeÅ›Ä‡ tygodni nadchodzi czas na przygotowanie nowego wydania! GaÅ‚Ä…Åº <code>beta</code> repozytorium Rusta rozgaÅ‚Ä™zia siÄ™ od gÅ‚Ã³wnej gaÅ‚Ä™zi uÅ¼ywanej przez nightly. Teraz istniejÄ… dwa wydania:</p>
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<p>WiÄ™kszoÅ›Ä‡ uÅ¼ytkownikÃ³w Rusta nie uÅ¼ywa aktywnie wydaÅ„ beta, ale testuje je w swoich systemach CI, aby pomÃ³c Rustowi odkryÄ‡ moÅ¼liwe regresje. W miÄ™dzyczasie, kaÅ¼dej nocy nadal pojawia siÄ™ wydanie nightly:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<p>Powiedzmy, Å¼e znaleziono regresjÄ™. Dobrze, Å¼e mieliÅ›my trochÄ™ czasu na przetestowanie wydania beta, zanim regresja wkradÅ‚a siÄ™ do stabilnego wydania! Poprawka jest stosowana do gÅ‚Ã³wnej gaÅ‚Ä™zi, tak aby nightly zostaÅ‚o naprawione, a nastÄ™pnie poprawka jest przenoszona do gaÅ‚Ä™zi <code>beta</code>, i tworzone jest nowe wydanie beta:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<p>SzeÅ›Ä‡ tygodni po stworzeniu pierwszej bety, nadszedÅ‚ czas na stabilne wydanie! GaÅ‚Ä…Åº <code>stable</code> jest tworzona z gaÅ‚Ä™zi <code>beta</code>:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<p>Hura! Rust 1.5 jest gotowy! ZapomnieliÅ›my jednak o jednej rzeczy: poniewaÅ¼ minÄ™Å‚o szeÅ›Ä‡ tygodni, potrzebujemy rÃ³wnieÅ¼ nowej bety <em>nastÄ™pnej</em> wersji Rusta, 1.6. Tak wiÄ™c po tym, jak <code>stable</code> rozgaÅ‚Ä™zia siÄ™ od <code>beta</code>, nastÄ™pna wersja <code>beta</code> ponownie rozgaÅ‚Ä™zia siÄ™ od <code>nightly</code>:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<p>Nazywa siÄ™ to â€modelem pociÄ…guâ€, poniewaÅ¼ co szeÅ›Ä‡ tygodni wydanie â€opuszcza stacjÄ™â€, ale nadal musi odbyÄ‡ podrÃ³Å¼ przez kanaÅ‚ beta, zanim dotrze jako stabilne wydanie.</p>
<p>Rust wydaje siÄ™ co szeÅ›Ä‡ tygodni, jak w zegarku. JeÅ›li znasz datÄ™ jednego wydania Rusta, moÅ¼esz poznaÄ‡ datÄ™ nastÄ™pnego: to szeÅ›Ä‡ tygodni pÃ³Åºniej. MiÅ‚ym aspektem harmonogramu wydaÅ„ co szeÅ›Ä‡ tygodni jest to, Å¼e nastÄ™pny pociÄ…g nadjedzie wkrÃ³tce. JeÅ›li jakaÅ› funkcja przypadkowo ominie konkretne wydanie, nie ma powodu do obaw: kolejne pojawi siÄ™ w krÃ³tkim czasie! Pomaga to zmniejszyÄ‡ presjÄ™ na dodawanie niedopracowanych funkcji tuÅ¼ przed terminem wydania.</p>
<p>DziÄ™ki temu procesowi zawsze moÅ¼esz sprawdziÄ‡ nastÄ™pnÄ… kompilacjÄ™ Rusta i samodzielnie zweryfikowaÄ‡, Å¼e Å‚atwo jest jÄ… zaktualizowaÄ‡: jeÅ›li wydanie beta nie dziaÅ‚a zgodnie z oczekiwaniami, moÅ¼esz zgÅ‚osiÄ‡ to zespoÅ‚owi i uzyskaÄ‡ poprawkÄ™ przed wydaniem kolejnej stabilnej wersji! Awarie w wydaniu beta sÄ… stosunkowo rzadkie, ale <code>rustc</code> to nadal oprogramowanie, i bÅ‚Ä™dy istniejÄ….</p>
<h3 id="czas-wsparcia"><a class="header" href="#czas-wsparcia">Czas wsparcia</a></h3>
<p>Projekt Rust wspiera najnowszÄ… stabilnÄ… wersjÄ™. Gdy nowa stabilna wersja zostanie wydana, stara wersja osiÄ…ga koniec swojego Å¼ycia (EOL). Oznacza to, Å¼e kaÅ¼da wersja jest wspierana przez szeÅ›Ä‡ tygodni.</p>
<h3 id="funkcje-niestabilne"><a class="header" href="#funkcje-niestabilne">Funkcje niestabilne</a></h3>
<p>W tym modelu wydaÅ„ jest jeszcze jedna kwestia: funkcje niestabilne. Rust uÅ¼ywa techniki zwanej â€flagami funkcjiâ€ do okreÅ›lania, ktÃ³re funkcje sÄ… wÅ‚Ä…czone w danym wydaniu. JeÅ›li nowa funkcja jest w trakcie aktywnego rozwoju, trafia ona do gÅ‚Ã³wnej gaÅ‚Ä™zi, a zatem do nightly, ale za <em>flagÄ… funkcji</em>. JeÅ›li jako uÅ¼ytkownik chcesz wyprÃ³bowaÄ‡ funkcjÄ™ bÄ™dÄ…cÄ… w fazie rozwoju, moÅ¼esz to zrobiÄ‡, ale musisz uÅ¼ywaÄ‡ wydania nightly Rusta i opatrzyÄ‡ swÃ³j kod ÅºrÃ³dÅ‚owy odpowiedniÄ… flagÄ…, aby jÄ… wÅ‚Ä…czyÄ‡.</p>
<p>JeÅ›li uÅ¼ywasz wydania beta lub stabilnego Rusta, nie moÅ¼esz uÅ¼ywaÄ‡ Å¼adnych flag funkcji. To jest klucz, ktÃ³ry pozwala nam praktycznie korzystaÄ‡ z nowych funkcji, zanim ogÅ‚osimy je na zawsze stabilnymi. Ci, ktÃ³rzy chcÄ… wyprÃ³bowaÄ‡ najnowsze rozwiÄ…zania, mogÄ… to zrobiÄ‡, a ci, ktÃ³rzy chcÄ… solidnego doÅ›wiadczenia, mogÄ… pozostaÄ‡ przy stabilnej wersji i wiedzieÄ‡, Å¼e ich kod nie zostanie zepsuty. StabilnoÅ›Ä‡ bez stagnacji.</p>
<p>Ta ksiÄ…Å¼ka zawiera informacje wyÅ‚Ä…cznie o stabilnych funkcjach, poniewaÅ¼ funkcje w trakcie rozwoju wciÄ…Å¼ siÄ™ zmieniajÄ…, i z pewnoÅ›ciÄ… bÄ™dÄ… siÄ™ rÃ³Å¼niÄ‡ miÄ™dzy czasem, gdy ta ksiÄ…Å¼ka zostaÅ‚a napisana, a momentem, gdy zostanÄ… wÅ‚Ä…czone w stabilnych kompilacjach. DokumentacjÄ™ funkcji dostÄ™pnych tylko w nightly moÅ¼na znaleÅºÄ‡ online.</p>
<h3 id="rustup-i-rola-rust-nightly"><a class="header" href="#rustup-i-rola-rust-nightly">Rustup i rola Rust Nightly</a></h3>
<p>Rustup uÅ‚atwia przeÅ‚Ä…czanie siÄ™ miÄ™dzy rÃ³Å¼nymi kanaÅ‚ami wydaÅ„ Rusta, globalnie lub na zasadzie projektu. DomyÅ›lnie bÄ™dziesz mieÄ‡ zainstalowanego stabilnego Rusta. Aby zainstalowaÄ‡ nightly, na przykÅ‚ad:</p>
<pre><code class="language-console">$ rustup toolchain install nightly
</code></pre>
<p>MoÅ¼esz rÃ³wnieÅ¼ zobaczyÄ‡ wszystkie <em>Å‚aÅ„cuchy narzÄ™dzi</em> (wydania Rusta i powiÄ…zane komponenty), ktÃ³re zainstalowaÅ‚eÅ› za pomocÄ… <code>rustup</code>. Oto przykÅ‚ad na komputerze z systemem Windows jednego z autorÃ³w:</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<p>Jak widaÄ‡, stabilny Å‚aÅ„cuch narzÄ™dzi jest domyÅ›lny. WiÄ™kszoÅ›Ä‡ uÅ¼ytkownikÃ³w Rusta uÅ¼ywa stabilnej wersji przez wiÄ™kszoÅ›Ä‡ czasu. MoÅ¼esz chcieÄ‡ uÅ¼ywaÄ‡ stabilnej wersji przez wiÄ™kszoÅ›Ä‡ czasu, ale uÅ¼ywaÄ‡ nightly w konkretnym projekcie, poniewaÅ¼ zaleÅ¼y Ci na najnowszej funkcji. Aby to zrobiÄ‡, moÅ¼esz uÅ¼yÄ‡ <code>rustup override</code> w katalogu tego projektu, aby ustawiÄ‡ Å‚aÅ„cuch narzÄ™dzi nightly jako ten, ktÃ³rego <code>rustup</code> powinien uÅ¼ywaÄ‡, gdy znajdujesz siÄ™ w tym katalogu:</p>
<pre><code class="language-console">$ cd ~/projects/needs-nightly
$ rustup override set nightly
</code></pre>
<p>Teraz, za kaÅ¼dym razem, gdy wywoÅ‚asz <code>rustc</code> lub <code>cargo</code> w katalogu <em>~/projects/needs-nightly</em>, <code>rustup</code> upewni siÄ™, Å¼e uÅ¼ywasz Rusta nightly, zamiast domyÅ›lnego stabilnego Rusta. Jest to przydatne, gdy masz wiele projektÃ³w Rust!</p>
<h3 id="proces-rfc-i-zespoÅ‚y"><a class="header" href="#proces-rfc-i-zespoÅ‚y">Proces RFC i zespoÅ‚y</a></h3>
<p>Jak wiÄ™c dowiedzieÄ‡ siÄ™ o tych nowych funkcjach? Model rozwoju Rusta opiera siÄ™ na <em>procesie Request For Comments (RFC)</em>. JeÅ›li chcesz wprowadziÄ‡ ulepszenie w Rust, moÅ¼esz napisaÄ‡ propozycjÄ™, zwanÄ… RFC.</p>
<p>KaÅ¼dy moÅ¼e pisaÄ‡ RFC, aby ulepszyÄ‡ Rusta, a propozycje sÄ… recenzowane i dyskutowane przez zespÃ³Å‚ Rusta, ktÃ³ry skÅ‚ada siÄ™ z wielu podzespoÅ‚Ã³w tematycznych. PeÅ‚nÄ… listÄ™ zespoÅ‚Ã³w moÅ¼na znaleÅºÄ‡ <a href="https://www.rust-lang.org/governance">na stronie Rusta</a>, ktÃ³ra obejmuje zespoÅ‚y dla kaÅ¼dego obszaru projektu: projektowanie jÄ™zyka, implementacja kompilatora, infrastruktura, dokumentacja i wiele innych. Odpowiedni zespÃ³Å‚ czyta propozycjÄ™ i komentarze, pisze wÅ‚asne komentarze, a ostatecznie osiÄ…ga siÄ™ konsensus w sprawie zaakceptowania lub odrzucenia funkcji.</p>
<p>JeÅ›li funkcja zostanie zaakceptowana, otwierane jest zgÅ‚oszenie w repozytorium Rusta i ktoÅ› moÅ¼e jÄ… zaimplementowaÄ‡. Osoba, ktÃ³ra jÄ… zaimplementuje, bardzo dobrze moÅ¼e nie byÄ‡ osobÄ…, ktÃ³ra pierwotnie zaproponowaÅ‚a tÄ™ funkcjÄ™! Kiedy implementacja jest gotowa, trafia do gÅ‚Ã³wnej gaÅ‚Ä™zi za bramÄ… funkcji, tak jak omÃ³wiliÅ›my w sekcji <a href="#unstable-features">â€Funkcje niestabilneâ€</a><!-- ignore -->.</p>
<p>Po pewnym czasie, gdy deweloperzy Rusta korzystajÄ…cy z wydaÅ„ nightly bÄ™dÄ… mogli wyprÃ³bowaÄ‡ nowÄ… funkcjÄ™, czÅ‚onkowie zespoÅ‚u przedyskutujÄ… tÄ™ funkcjÄ™, jak sprawdziÅ‚a siÄ™ w nightly, i zdecydujÄ…, czy powinna trafiÄ‡ do stabilnego Rusta, czy nie. JeÅ›li decyzja zostanie podjÄ™ta o kontynuowaniu, brama funkcji zostaje usuniÄ™ta, a funkcja jest teraz uwaÅ¼ana za stabilnÄ…! Trafia ona pociÄ…gami do nowego stabilnego wydania Rusta.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris-2317480c.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
