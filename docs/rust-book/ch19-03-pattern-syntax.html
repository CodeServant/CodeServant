<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Składnia Wzorców - Język programowania Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris-d33b75bf.css">
        <link rel="stylesheet" href="theme/2018-edition-4e126c62.css">
        <link rel="stylesheet" href="theme/semantic-notes-9b5766c0.css">
        <link rel="stylesheet" href="theme/listing-cab26221.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-773dca2f.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-039e37ba.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Język programowania Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h2 id="składnia-wzorców"><a class="header" href="#składnia-wzorców">Składnia Wzorców</a></h2>
<p>W tej sekcji zbieramy całą składnię, która jest prawidłowa we wzorcach, i omawiamy, dlaczego i kiedy warto używać każdej z nich.</p>
<h3 id="dopasowywanie-literałów"><a class="header" href="#dopasowywanie-literałów">Dopasowywanie Literałów</a></h3>
<p>Jak widziałeś w Rozdziale 6, możesz dopasowywać wzorce bezpośrednio do literałów. Poniższy kod przedstawia kilka przykładów:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!("one"),
        2 =&gt; println!("two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
<span class="boring">}</span></code></pre>
<p>Ten kod wypisuje <code>one</code>, ponieważ wartość w <code>x</code> wynosi <code>1</code>. Ta składnia jest użyteczna, gdy chcesz, aby Twój kod podjął działanie, jeśli otrzyma konkretną wartość.</p>
<h3 id="dopasowywanie-nazwanych-zmiennych"><a class="header" href="#dopasowywanie-nazwanych-zmiennych">Dopasowywanie Nazwanych Zmiennych</a></h3>
<p>Nazwane zmienne to nieodrzucalne wzorce, które pasują do dowolnej wartości, i używaliśmy ich wiele razy w tej książce. Jednakże, pojawia się komplikacja, gdy używasz nazwanych zmiennych w wyrażeniach <code>match</code>, <code>if let</code> lub <code>while let</code>. Ponieważ każdy z tych rodzajów wyrażeń rozpoczyna nowy zakres, zmienne zadeklarowane jako część wzorca wewnątrz tych wyrażeń będą zasłaniać te o tej samej nazwie poza konstrukcjami, tak jak to ma miejsce w przypadku wszystkich zmiennych. Na Liście 19-11 deklarujemy zmienną <code>x</code> o wartości <code>Some(5)</code> i zmienną <code>y</code> o wartości <code>10</code>. Następnie tworzymy wyrażenie <code>match</code> na wartości <code>x</code>. Spójrz na wzorce w ramionach <code>match</code> i <code>println!</code> na końcu, a spróbuj odgadnąć, co kod wydrukuje, zanim uruchomisz ten kod lub przeczytasz dalej.</p>
<figure class="listing" id="listing-19-11">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(y) =&gt; println!("Matched, y = {y}"),
        _ =&gt; println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-11">Lista 19-11</a>: Wyrażenie <code>match</code> z ramieniem, które wprowadza nową zmienną, która zasłania istniejącą zmienną <code>y</code></figcaption>
</figure>
<p>Przeanalizujmy, co dzieje się, gdy uruchamia się wyrażenie <code>match</code>. Wzorzec w pierwszym ramieniu <code>match</code> nie pasuje do zdefiniowanej wartości <code>x</code>, więc kod kontynuuje działanie.</p>
<p>Wzorzec w drugim ramieniu <code>match</code> wprowadza nową zmienną o nazwie <code>y</code>, która będzie pasować do dowolnej wartości wewnątrz wartości <code>Some</code>. Ponieważ jesteśmy w nowym zakresie wewnątrz wyrażenia <code>match</code>, jest to nowa zmienna <code>y</code>, a nie <code>y</code>, którą zadeklarowaliśmy na początku z wartością <code>10</code>. To nowe powiązanie <code>y</code> będzie pasować do wewnętrznej wartości <code>Some</code> w <code>x</code>. Ta wartość to <code>5</code>, więc wyrażenie dla tego ramienia wykonuje się i wypisuje <code>Matched, y = 5</code>.</p>
<p>Gdyby <code>x</code> było wartością <code>None</code> zamiast <code>Some(5)</code>, wzorce w dwóch pierwszych ramionach nie pasowałyby, więc wartość pasowałaby do podkreślenia. Nie wprowadziliśmy zmiennej <code>x</code> do wzorca ramienia podkreślenia, więc <code>x</code> w wyrażeniu jest nadal zewnętrznym <code>x</code>, które nie zostało zacienione. W tym hipotetycznym przypadku <code>match</code> wypisałby <code>Default case, x = None</code>.</p>
<p>Po zakończeniu wyrażenia <code>match</code>, jego zakres się kończy, podobnie jak zakres wewnętrznego <code>y</code>. Ostatnie <code>println!</code> wypisuje <code>at the end: x = Some(5), y = 10</code>.</p>
<p>Aby stworzyć wyrażenie <code>match</code>, które porównuje wartości zewnętrznych <code>x</code> i <code>y</code>, zamiast wprowadzać nową zmienną, która zasłania istniejącą zmienną <code>y</code>, musielibyśmy użyć warunkowego ograniczenia dopasowania. O match guardach porozmawiamy później w sekcji <a href="#adding-conditionals-with-match-guards">„Dodawanie warunków za pomocą match guardów”</a><!-- ignore -->.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="multiple-patterns"></a></p>
<h3 id="dopasowywanie-wielu-wzorców"><a class="header" href="#dopasowywanie-wielu-wzorców">Dopasowywanie Wielu Wzorców</a></h3>
<p>W wyrażeniach <code>match</code> możesz dopasowywać wiele wzorców za pomocą składni <code>|</code>, która jest operatorem <em>lub</em> wzorca. Na przykład, w poniższym kodzie dopasowujemy wartość <code>x</code> do ramion <code>match</code>, z których pierwsze ma opcję <em>lub</em>, co oznacza, że jeśli wartość <code>x</code> pasuje do którejkolwiek z wartości w tym ramieniu, kod tego ramienia zostanie uruchomiony:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!("one or two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
<span class="boring">}</span></code></pre>
<p>Ten kod wypisuje <code>one or two</code>.</p>
<h3 id="dopasowywanie-zakresów-wartości-za-pomocą-"><a class="header" href="#dopasowywanie-zakresów-wartości-za-pomocą-">Dopasowywanie Zakresów Wartości za pomocą <code>..=</code></a></h3>
<p>Składnia <code>..=</code> pozwala nam dopasowywać do włącznie zakresu wartości. W poniższym kodzie, gdy wzorzec pasuje do którejkolwiek z wartości w danym zakresie, to ramię zostanie wykonane:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!("one through five"),
        _ =&gt; println!("something else"),
    }
<span class="boring">}</span></code></pre>
<p>Jeśli <code>x</code> wynosi <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code> lub <code>5</code>, pierwsze ramię zostanie dopasowane. Ta składnia jest wygodniejsza dla wielu wartości dopasowania niż używanie operatora <code>|</code> do wyrażenia tej samej idei; gdybyśmy mieli użyć <code>|</code>, musielibyśmy określić <code>1 | 2 | 3 | 4 | 5</code>. Określanie zakresu jest znacznie krótsze, zwłaszcza jeśli chcemy dopasować, powiedzmy, dowolną liczbę od 1 do 1000!</p>
<p>Kompilator sprawdza w czasie kompilacji, czy zakres nie jest pusty, a ponieważ jedynymi typami, dla których Rust może stwierdzić, czy zakres jest pusty, są <code>char</code> i wartości liczbowe, zakresy są dozwolone tylko z wartościami liczbowymi lub <code>char</code>.</p>
<p>Oto przykład użycia zakresów wartości <code>char</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!("early ASCII letter"),
        'k'..='z' =&gt; println!("late ASCII letter"),
        _ =&gt; println!("something else"),
    }
<span class="boring">}</span></code></pre>
<p>Rust może stwierdzić, że <code>'c'</code> znajduje się w zakresie pierwszego wzorca i wypisuje <code>early ASCII letter</code>.</p>
<h3 id="dekonstrukcja-w-celu-rozbicia-wartości"><a class="header" href="#dekonstrukcja-w-celu-rozbicia-wartości">Dekonstrukcja w Celu Rozbicia Wartości</a></h3>
<p>Możemy również używać wzorców do dekonstrukcji struktur, wyliczeń i krotek, aby używać różnych części tych wartości. Przejdźmy przez każdą wartość.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="destructuring-structs"></a></p>
<h4 id="struktury"><a class="header" href="#struktury">Struktury</a></h4>
<p>Lista 19-12 pokazuje strukturę <code>Point</code> z dwoma polami, <code>x</code> i <code>y</code>, które możemy rozdzielić za pomocą wzorca z instrukcją <code>let</code>.</p>
<figure class="listing" id="listing-19-12">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}</code></pre>
<figcaption><a href="#listing-19-12">Lista 19-12</a>: Dekonstrukcja pól struktury na osobne zmienne</figcaption>
</figure>
<p>Ten kod tworzy zmienne <code>a</code> i <code>b</code>, które odpowiadają wartościom pól <code>x</code> i <code>y</code> struktury <code>p</code>. Ten przykład pokazuje, że nazwy zmiennych we wzorcu nie muszą odpowiadać nazwom pól struktury. Jednak często dopasowuje się nazwy zmiennych do nazw pól, aby łatwiej było zapamiętać, które zmienne pochodzą z których pól. Z powodu tego powszechnego użycia i ponieważ pisanie <code>let Point { x: x, y: y } = p;</code> zawiera wiele powtórzeń, Rust ma skrót dla wzorców, które dopasowują pola struktury: wystarczy wymienić nazwę pola struktury, a zmienne utworzone na podstawie wzorca będą miały te same nazwy. Lista 19-13 działa tak samo jak kod z Listy 19-12, ale zmienne utworzone we wzorcu <code>let</code> to <code>x</code> i <code>y</code> zamiast <code>a</code> i <code>b</code>.</p>
<figure class="listing" id="listing-19-13">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}</code></pre>
<figcaption><a href="#listing-19-13">Lista 19-13</a>: Dekonstrukcja pól struktury za pomocą skrótu pól struktury</figcaption>
</figure>
<p>Ten kod tworzy zmienne <code>x</code> i <code>y</code>, które pasują do pól <code>x</code> i <code>y</code> zmiennej <code>p</code>. Wynikiem jest to, że zmienne <code>x</code> i <code>y</code> zawierają wartości ze struktury <code>p</code>.</p>
<p>Możemy również dokonywać dekonstrukcji z użyciem wartości literałowych jako części wzorca struktury, zamiast tworzyć zmienne dla wszystkich pól. Pozwala nam to testować niektóre pola pod kątem określonych wartości, jednocześnie tworząc zmienne do dekonstrukcji pozostałych pól.</p>
<p>Na Liście 19-14 mamy wyrażenie <code>match</code>, które dzieli wartości <code>Point</code> na trzy przypadki: punkty leżące bezpośrednio na osi <code>x</code> (co jest prawdą, gdy <code>y = 0</code>), na osi <code>y</code> (<code>x = 0</code>) lub na żadnej z osi.</p>
<figure class="listing" id="listing-19-14">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!("On the x axis at {x}"),
        Point { x: 0, y } =&gt; println!("On the y axis at {y}"),
        Point { x, y } =&gt; {
            println!("On neither axis: ({x}, {y})");
        }
    }
}</code></pre>
<figcaption><a href="#listing-19-14">Lista 19-14</a>: Dekonstrukcja i dopasowywanie wartości literałowych w jednym wzorcu</figcaption>
</figure>
<p>Pierwsze ramię dopasuje każdy punkt leżący na osi <code>x</code>, określając, że pole <code>y</code> pasuje, jeśli jego wartość odpowiada literałowi <code>0</code>. Wzorzec nadal tworzy zmienną <code>x</code>, której możemy użyć w kodzie dla tego ramienia.</p>
<p>Podobnie, drugie ramię pasuje do każdego punktu na osi <code>y</code>, określając, że pole <code>x</code> pasuje, jeśli jego wartość wynosi <code>0</code>, i tworzy zmienną <code>y</code> dla wartości pola <code>y</code>. Trzecie ramię nie określa żadnych literałów, więc pasuje do każdego innego <code>Point</code> i tworzy zmienne dla pól <code>x</code> i <code>y</code>.</p>
<p>W tym przykładzie wartość <code>p</code> pasuje do drugiego ramienia dzięki temu, że <code>x</code> zawiera <code>0</code>, więc ten kod wypisze <code>On the y axis at 7</code>.</p>
<p>Pamiętaj, że wyrażenie <code>match</code> przestaje sprawdzać ramiona, gdy tylko znajdzie pierwszy pasujący wzorzec, więc nawet jeśli <code>Point { x: 0, y: 0 }</code> znajduje się na osi <code>x</code> i osi <code>y</code>, ten kod wydrukowałby tylko <code>On the x axis at 0</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="destructuring-enums"></a></p>
<h4 id="wyliczenia-enums"><a class="header" href="#wyliczenia-enums">Wyliczenia (Enums)</a></h4>
<p>Dekonstruowaliśmy wyliczenia w tej książce (na przykład Lista 6-5 w Rozdziale 6), ale nie omówiliśmy jeszcze wyraźnie, że wzorzec do dekonstrukcji wyliczenia odpowiada sposobowi definiowania danych przechowywanych w wyliczeniu. Jako przykład, na Liście 19-15 używamy wyliczenia <code>Message</code> z Listy 6-2 i piszemy <code>match</code> z wzorcami, które dekonstruują każdą wewnętrzną wartość.</p>
<figure class="listing" id="listing-19-15">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!("The Quit variant has no data to destructure.");
        }
        Message::Move { x, y } =&gt; {
            println!("Move in the x direction {x} and in the y direction {y}");
        }
        Message::Write(text) =&gt; {
            println!("Text message: {text}");
        }
        Message::ChangeColor(r, g, b) =&gt; {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
    }
}</code></pre>
<figcaption><a href="#listing-19-15">Lista 19-15</a>: Dekonstrukcja wariantów wyliczenia, które zawierają różne rodzaje wartości</figcaption>
</figure>
<p>Ten kod wypisze <code>Change color to red 0, green 160, and blue 255</code>. Spróbuj zmienić wartość <code>msg</code>, aby zobaczyć, jak działa kod z innych ramion.</p>
<p>Dla wariantów wyliczeniowych bez żadnych danych, takich jak <code>Message::Quit</code>, nie możemy dalej dekonstruować wartości. Możemy dopasować tylko literał <code>Message::Quit</code>, a w tym wzorcu nie ma żadnych zmiennych.</p>
<p>Dla wariantów wyliczeń podobnych do struktur, takich jak <code>Message::Move</code>, możemy użyć wzorca podobnego do wzorca, który określamy w celu dopasowania struktur. Po nazwie wariantu umieszczamy nawiasy klamrowe, a następnie wymieniamy pola ze zmiennymi, tak abyśmy rozdzielili elementy do użycia w kodzie dla tego ramienia. Tutaj używamy skróconej formy, tak jak na Liście 19-13.</p>
<p>Dla wariantów wyliczeniowych typu krotka, takich jak <code>Message::Write</code>, które przechowuje krotkę z jednym elementem, oraz <code>Message::ChangeColor</code>, które przechowuje krotkę z trzema elementami, wzorzec jest podobny do wzorca, który określamy, aby dopasować krotki. Liczba zmiennych we wzorcu musi odpowiadać liczbie elementów w wariancie, który dopasowujemy.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="destructuring-nested-structs-and-enums"></a></p>
<h4 id="zagnieżdżone-struktury-i-wyliczenia"><a class="header" href="#zagnieżdżone-struktury-i-wyliczenia">Zagnieżdżone Struktury i Wyliczenia</a></h4>
<p>Do tej pory wszystkie nasze przykłady dotyczyły dopasowywania struktur lub wyliczeń na jednym poziomie, ale dopasowywanie może działać również na zagnieżdżonych elementach! Na przykład, możemy refaktoryzować kod z Listy 19-15, aby obsługiwał kolory RGB i HSV w wiadomości <code>ChangeColor</code>, jak pokazano na Liście 19-16.</p>
<figure class="listing" id="listing-19-16">
<pre class="playground"><code class="language-rust edition2024">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!("Change color to hue {h}, saturation {s}, value {v}");
        }
        _ =&gt; (),
    }
}</code></pre>
<figcaption><a href="#listing-19-16">Lista 19-16</a>: Dopasowywanie zagnieżdżonych wyliczeń</figcaption>
</figure>
<p>Wzorzec pierwszego ramienia w wyrażeniu <code>match</code> pasuje do wariantu wyliczeniowego <code>Message::ChangeColor</code>, który zawiera wariant <code>Color::Rgb</code>; następnie wzorzec wiąże się z trzema wewnętrznymi wartościami <code>i32</code>. Wzorzec drugiego ramienia również pasuje do wariantu wyliczeniowego <code>Message::ChangeColor</code>, ale wewnętrzne wyliczenie pasuje zamiast tego do <code>Color::Hsv</code>. Możemy określić te złożone warunki w jednym wyrażeniu <code>match</code>, mimo że biorą w nim udział dwa wyliczenia.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="destructuring-structs-and-tuples"></a></p>
<h4 id="struktury-i-krotki"><a class="header" href="#struktury-i-krotki">Struktury i Krotki</a></h4>
<p>Możemy mieszać, dopasowywać i zagnieżdżać wzorce dekonstrukcji na jeszcze bardziej złożone sposoby. Poniższy przykład pokazuje skomplikowaną dekonstrukcję, w której zagnieżdżamy struktury i krotki wewnątrz krotki i dekonstruujemy wszystkie wartości pierwotne:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}</span></code></pre>
<p>Ten kod pozwala nam rozbić złożone typy na ich części składowe, abyśmy mogli osobno używać wartości, które nas interesują.</p>
<p>Dekonstrukcja za pomocą wzorców to wygodny sposób na używanie części wartości, takich jak wartość z każdego pola w strukturze, oddzielnie od siebie.</p>
<h3 id="ignorowanie-wartości-we-wzorcu"><a class="header" href="#ignorowanie-wartości-we-wzorcu">Ignorowanie Wartości we Wzorcu</a></h3>
<p>Widziałeś, że czasami przydatne jest ignorowanie wartości we wzorcu, na przykład w ostatnim ramieniu <code>match</code>, aby uzyskać catch-all, który faktycznie nic nie robi, ale uwzględnia wszystkie pozostałe możliwe wartości. Istnieje kilka sposobów ignorowania całych wartości lub części wartości we wzorcu: użycie wzorca <code>_</code> (który już widziałeś), użycie wzorca <code>_</code> w innym wzorcu, użycie nazwy zaczynającej się od podkreślenia lub użycie <code>..</code>, aby zignorować pozostałe części wartości. Przyjrzyjmy się, jak i dlaczego używać każdego z tych wzorców.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="ignoring-an-entire-value-with-_"></a></p>
<h4 id="cała-wartość-za-pomocą-_"><a class="header" href="#cała-wartość-za-pomocą-_">Cała Wartość za pomocą <code>_</code></a></h4>
<p>Używaliśmy podkreślenia jako wzorca wieloznacznego, który będzie pasował do dowolnej wartości, ale nie będzie wiązał się z wartością. Jest to szczególnie przydatne jako ostatnie ramię w wyrażeniu <code>match</code>, ale możemy go również używać w dowolnym wzorcu, w tym w parametrach funkcji, jak pokazano na Liście 19-17.</p>
<figure class="listing" id="listing-19-17">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {y}");
}

fn main() {
    foo(3, 4);
}</code></pre>
<figcaption><a href="#listing-19-17">Lista 19-17</a>: Użycie <code>_</code> w sygnaturze funkcji</figcaption>
</figure>
<p>Ten kod całkowicie zignoruje wartość <code>3</code> przekazaną jako pierwszy argument i wydrukuje <code>This code only uses the y parameter: 4</code>.</p>
<p>W większości przypadków, gdy nie potrzebujesz już konkretnego parametru funkcji, zmieniłbyś sygnaturę tak, aby nie zawierała nieużywanego parametru. Ignorowanie parametru funkcji może być szczególnie przydatne w przypadkach, gdy na przykład implementujesz cechę, gdy potrzebujesz określonej sygnatury typu, ale ciało funkcji w Twojej implementacji nie potrzebuje jednego z parametrów. Wtedy unikasz ostrzeżenia kompilatora o nieużywanych parametrach funkcji, tak jakbyś użył nazwy zamiast.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="ignoring-parts-of-a-value-with-a-nested-_"></a></p>
<h4 id="fragmenty-wartości-z-zagnieżdżonym-_"><a class="header" href="#fragmenty-wartości-z-zagnieżdżonym-_">Fragmenty Wartości z Zagnieżdżonym <code>_</code></a></h4>
<p>Możemy również używać <code>_</code> wewnątrz innego wzorca, aby zignorować tylko część wartości, na przykład, gdy chcemy przetestować tylko część wartości, ale nie mamy zastosowania dla pozostałych części w odpowiadającym kodzie, który chcemy uruchomić. Lista 19-18 pokazuje kod odpowiedzialny za zarządzanie wartością ustawienia. Wymagania biznesowe są takie, że użytkownikowi nie wolno nadpisywać istniejącej dostosowanej wartości ustawienia, ale może anulować ustawienie i nadać mu wartość, jeśli jest ono obecnie niezdefiniowane.</p>
<figure class="listing" id="listing-19-18">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!("Can't overwrite an existing customized value");
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!("setting is {setting_value:?}");
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-18">Lista 19-18</a>: Użycie podkreślenia w wzorcach pasujących do wariantów <code>Some</code>, gdy nie musimy używać wartości wewnątrz <code>Some</code></figcaption>
</figure>
<p>Ten kod wypisze <code>Can't overwrite an existing customized value</code>, a następnie <code>setting is Some(5)</code>. W pierwszym ramieniu <code>match</code> nie musimy dopasowywać ani używać wartości wewnątrz żadnego z wariantów <code>Some</code>, ale musimy sprawdzić przypadek, gdy <code>setting_value</code> i <code>new_setting_value</code> są wariantem <code>Some</code>. W takim przypadku wypisujemy powód, dla którego <code>setting_value</code> nie zostanie zmienione, i nie zostanie ono zmienione.</p>
<p>We wszystkich innych przypadkach (jeśli <code>setting_value</code> lub <code>new_setting_value</code> jest <code>None</code>), wyrażonych wzorcem <code>_</code> w drugim ramieniu, chcemy, aby <code>new_setting_value</code> stało się <code>setting_value</code>.</p>
<p>Możemy również używać podkreśleń w wielu miejscach w jednym wzorcu, aby ignorować określone wartości. Lista 19-19 pokazuje przykład ignorowania drugiej i czwartej wartości w krotce pięciu elementów.</p>
<figure class="listing" id="listing-19-19">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!("Some numbers: {first}, {third}, {fifth}");
        }
    }
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-19">Lista 19-19</a>: Ignorowanie wielu części krotki</figcaption>
</figure>
<p>Ten kod wypisze <code>Some numbers: 2, 8, 32</code>, a wartości <code>4</code> i <code>16</code> zostaną zignorowane.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="ignoring-an-unused-variable-by-starting-its-name-with-_"></a></p>
<h4 id="nieużywana-zmienna-zaczynająca-się-od-_"><a class="header" href="#nieużywana-zmienna-zaczynająca-się-od-_">Nieużywana Zmienna, Zaczynająca Się od <code>_</code></a></h4>
<p>Jeśli utworzysz zmienną, ale nie użyjesz jej nigdzie, Rust zazwyczaj wyświetli ostrzeżenie, ponieważ nieużywana zmienna może być błędem. Czasami jednak przydatne jest stworzenie zmiennej, której jeszcze nie użyjesz, na przykład podczas prototypowania lub rozpoczynania projektu. W tej sytuacji możesz powiedzieć Rust, aby nie ostrzegał Cię o nieużywanej zmiennej, zaczynając nazwę zmiennej od podkreślenia. Na Liście 19-20 tworzymy dwie nieużywane zmienne, ale po skompilowaniu tego kodu powinniśmy otrzymać ostrzeżenie tylko o jednej z nich.</p>
<figure class="listing" id="listing-19-20">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let _x = 5;
    let y = 10;
}</code></pre>
<figcaption><a href="#listing-19-20">Lista 19-20</a>: Rozpoczynanie nazwy zmiennej od podkreślenia w celu uniknięcia ostrzeżeń o nieużywanych zmiennych</figcaption>
</figure>
<p>Tutaj otrzymujemy ostrzeżenie o nieużywaniu zmiennej <code>y</code>, ale nie otrzymujemy ostrzeżenia o nieużywaniu <code>_x</code>.</p>
<p>Zauważ, że istnieje subtelna różnica między używaniem samego <code>_</code> a używaniem nazwy zaczynającej się od podkreślenia. Składnia <code>_x</code> nadal wiąże wartość ze zmienną, podczas gdy <code>_</code> w ogóle nie wiąże. Aby pokazać przypadek, w którym ta różnica ma znaczenie, Lista 19-21 dostarczy nam błędu.</p>
<figure class="listing" id="listing-19-21">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_s) = s {
        println!("found a string");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-21">Lista 19-21</a>: Nieużywana zmienna zaczynająca się od podkreślenia nadal wiąże wartość, co może przejąć własność wartości.</figcaption>
</figure>
<p>Otrzymamy błąd, ponieważ wartość <code>s</code> zostanie nadal przeniesiona do <code>_s</code>, co uniemożliwi nam ponowne użycie <code>s</code>. Jednak użycie samego podkreślenia nigdy nie wiąże się z wartością. Lista 19-22 skompiluje się bez błędów, ponieważ <code>s</code> nie zostanie przeniesione do <code>_</code>.</p>
<figure class="listing" id="listing-19-22">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_) = s {
        println!("found a string");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-22">Lista 19-22</a>: Użycie podkreślenia nie wiąże wartości.</figcaption>
</figure>
<p>Ten kod działa bez zarzutu, ponieważ nigdy nie wiążemy <code>s</code> z niczym; nie zostaje przeniesione.</p>
<p><a id="ignoring-remaining-parts-of-a-value-with-"></a></p>
<h4 id="pozostałe-części-wartości-za-pomocą-"><a class="header" href="#pozostałe-części-wartości-za-pomocą-">Pozostałe Części Wartości za pomocą <code>..</code></a></h4>
<p>W przypadku wartości, które mają wiele części, możemy użyć składni <code>..</code>, aby użyć konkretnych części i zignorować resztę, unikając konieczności wymieniania podkreśleń dla każdej ignorowanej wartości. Wzorzec <code>..</code> ignoruje wszystkie części wartości, których nie dopasowaliśmy jawnie w pozostałej części wzorca. Na Liście 19-23 mamy strukturę <code>Point</code>, która przechowuje współrzędną w trójwymiarowej przestrzeni. W wyrażeniu <code>match</code> chcemy operować tylko na współrzędnej <code>x</code> i ignorować wartości w polach <code>y</code> i <code>z</code>.</p>
<figure class="listing" id="listing-19-23">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!("x is {x}"),
    }
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-23">Lista 19-23</a>: Ignorowanie wszystkich pól <code>Point</code> oprócz <code>x</code> za pomocą <code>..</code></figcaption>
</figure>
<p>Wypisujemy wartość <code>x</code>, a następnie po prostu dodajemy wzorzec <code>..</code>. Jest to szybsze niż konieczność wypisywania <code>y: _</code> i <code>z: _</code>, szczególnie gdy pracujemy ze strukturami, które mają wiele pól w sytuacjach, gdy tylko jedno lub dwa pola są istotne.</p>
<p>Składnia <code>..</code> rozszerzy się do tylu wartości, ile potrzebuje. Lista 19-24 pokazuje, jak używać <code>..</code> z krotką.</p>
<figure class="listing" id="listing-19-24">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!("Some numbers: {first}, {last}");
        }
    }
}</code></pre>
<figcaption><a href="#listing-19-24">Lista 19-24</a>: Dopasowywanie tylko pierwszej i ostatniej wartości w krotce i ignorowanie wszystkich pozostałych wartości</figcaption>
</figure>
<p>W tym kodzie pierwsza i ostatnia wartość są dopasowywane do <code>first</code> i <code>last</code>. <code>..</code> dopasuje i zignoruje wszystko pośrodku.</p>
<p>Jednakże, używanie <code>..</code> musi być jednoznaczne. Jeśli nie jest jasne, które wartości są przeznaczone do dopasowania, a które powinny zostać zignorowane, Rust zgłosi błąd. Lista 19-25 pokazuje przykład niejednoznacznego użycia <code>..</code>, dlatego nie skompiluje się.</p>
<figure class="listing" id="listing-19-25">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!("Some numbers: {second}")
        },
    }
}</code></pre>
<figcaption><a href="#listing-19-25">Lista 19-25</a>: Próba użycia <code>..</code> w sposób niejednoznaczny</figcaption>
</figure>
<p>Kiedy skompilujemy ten przykład, otrzymamy ten błąd:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>Rust nie jest w stanie określić, ile wartości w krotce należy zignorować przed dopasowaniem wartości do <code>second</code>, a następnie ile dalszych wartości należy zignorować. Ten kod mógłby oznaczać, że chcemy zignorować <code>2</code>, powiązać <code>second</code> z <code>4</code>, a następnie zignorować <code>8</code>, <code>16</code> i <code>32</code>; albo że chcemy zignorować <code>2</code> i <code>4</code>, powiązać <code>second</code> z <code>8</code>, a następnie zignorować <code>16</code> i <code>32</code>; i tak dalej. Nazwa zmiennej <code>second</code> nie oznacza niczego specjalnego dla Rust, więc otrzymujemy błąd kompilatora, ponieważ użycie <code>..</code> w dwóch miejscach w ten sposób jest niejednoznaczne.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="extra-conditionals-with-match-guards"></a></p>
<h3 id="dodawanie-warunków-za-pomocą-match-guardów"><a class="header" href="#dodawanie-warunków-za-pomocą-match-guardów">Dodawanie Warunków za pomocą Match Guardów</a></h3>
<p><em>Match guard</em> to dodatkowy warunek <code>if</code>, określony po wzorcu w ramieniu <code>match</code>, który również musi zostać spełniony, aby to ramię zostało wybrane. Match guardy są przydatne do wyrażania bardziej złożonych idei niż sam wzorzec. Zauważ jednak, że są one dostępne tylko w wyrażeniach <code>match</code>, a nie w wyrażeniach <code>if let</code> ani <code>while let</code>.</p>
<p>Warunek może używać zmiennych utworzonych we wzorcu. Lista 19-26 pokazuje <code>match</code>, gdzie pierwsze ramię ma wzorzec <code>Some(x)</code> i dodatkowo match guard <code>if x % 2 == 0</code> (który będzie <code>true</code>, jeśli liczba jest parzysta).</p>
<figure class="listing" id="listing-19-26">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!("The number {x} is even"),
        Some(x) =&gt; println!("The number {x} is odd"),
        None =&gt; (),
    }
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-26">Lista 19-26</a>: Dodawanie match guarda do wzorca</figcaption>
</figure>
<p>Ten przykład wypisze <code>The number 4 is even</code>. Gdy <code>num</code> jest porównywane z wzorcem w pierwszym ramieniu, pasuje, ponieważ <code>Some(4)</code> pasuje do <code>Some(x)</code>. Następnie match guard sprawdza, czy reszta z dzielenia <code>x</code> przez 2 jest równa 0, a ponieważ tak jest, wybrane zostaje pierwsze ramię.</p>
<p>Gdyby <code>num</code> było <code>Some(5)</code> zamiast tego, match guard w pierwszym ramieniu byłby <code>false</code>, ponieważ reszta z dzielenia 5 przez 2 wynosi 1, co nie jest równe 0. Rust następnie przeszedłby do drugiego ramienia, które by pasowało, ponieważ drugie ramię nie ma match guarda i dlatego pasuje do dowolnego wariantu <code>Some</code>.</p>
<p>Nie ma sposobu, aby wyrazić warunek <code>if x % 2 == 0</code> w ramach wzorca, więc match guard daje nam możliwość wyrażenia tej logiki. Wadą tej dodatkowej ekspresywności jest to, że kompilator nie próbuje sprawdzać kompletności, gdy w grę wchodzą wyrażenia match guard.</p>
<p>Podczas omawiania Listy 19-11, wspomnieliśmy, że moglibyśmy użyć match guardów do rozwiązania naszego problemu z zasłanianiem wzorców. Przypomnijmy, że stworzyliśmy nową zmienną wewnątrz wzorca w wyrażeniu <code>match</code> zamiast używać zmiennej poza <code>match</code>. Ta nowa zmienna oznaczała, że nie mogliśmy testować wartości zmiennej zewnętrznej. Lista 19-27 pokazuje, jak możemy użyć match guarda, aby naprawić ten problem.</p>
<figure class="listing" id="listing-19-27">
<span class="file-name">Nazwa pliku: src/main.rs</span>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(n) if n == y =&gt; println!("Matched, n = {n}"),
        _ =&gt; println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
}</code></pre>
<figcaption><a href="#listing-19-27">Lista 19-27</a>: Użycie match guarda do testowania równości z zewnętrzną zmienną</figcaption>
</figure>
<p>Ten kod wydrukuje teraz <code>Default case, x = Some(5)</code>. Wzorzec w drugim ramieniu <code>match</code> nie wprowadza nowej zmiennej <code>y</code>, która zasłaniałaby zewnętrzną <code>y</code>, co oznacza, że możemy użyć zewnętrznej <code>y</code> w match guardzie. Zamiast określać wzorzec jako <code>Some(y)</code>, co zasłoniłoby zewnętrzną <code>y</code>, określamy <code>Some(n)</code>. Tworzy to nową zmienną <code>n</code>, która niczego nie zasłania, ponieważ poza <code>match</code> nie ma zmiennej <code>n</code>.</p>
<p>Match guard <code>if n == y</code> nie jest wzorcem i dlatego nie wprowadza nowych zmiennych. To <code>y</code> <em>jest</em> zewnętrznym <code>y</code>, a nie nowym <code>y</code> je zasłaniającym, i możemy szukać wartości, która ma taką samą wartość jak zewnętrzne <code>y</code>, porównując <code>n</code> z <code>y</code>.</p>
<p>Możesz również użyć operatora <em>lub</em> <code>|</code> w match guardzie, aby określić wiele wzorców; warunek match guarda będzie miał zastosowanie do wszystkich wzorców. Lista 19-28 pokazuje pierwszeństwo przy łączeniu wzorca używającego <code>|</code> z match guardem. Ważną częścią tego przykładu jest to, że match guard <code>if y</code> ma zastosowanie do <code>4</code>, <code>5</code> <em>i</em> <code>6</code>, mimo że może wydawać się, że <code>if y</code> ma zastosowanie tylko do <code>6</code>.</p>
<figure class="listing" id="listing-19-28">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!("yes"),
        _ =&gt; println!("no"),
    }
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-28">Lista 19-28</a>: Łączenie wielu wzorców z match guardem</figcaption>
</figure>
<p>Warunek dopasowania stwierdza, że ramię pasuje tylko wtedy, gdy wartość <code>x</code> jest równa <code>4</code>, <code>5</code> lub <code>6</code> <em>i</em> jeśli <code>y</code> jest <code>true</code>. Kiedy ten kod się uruchamia, wzorzec pierwszego ramienia pasuje, ponieważ <code>x</code> wynosi <code>4</code>, ale match guard <code>if y</code> jest <code>false</code>, więc pierwsze ramię nie zostaje wybrane. Kod przechodzi do drugiego ramienia, które pasuje, a program wypisuje <code>no</code>. Powodem jest to, że warunek <code>if</code> ma zastosowanie do całego wzorca <code>4 | 5 | 6</code>, a nie tylko do ostatniej wartości <code>6</code>. Innymi słowy, pierwszeństwo match guarda w stosunku do wzorca zachowuje się w ten sposób:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>zamiast tego:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>Po uruchomieniu kodu zachowanie pierwszeństwa jest oczywiste: gdyby match guard był stosowany tylko do ostatniej wartości na liście wartości określonych za pomocą operatora <code>|</code>, ramię pasowałoby, a program wydrukowałby <code>yes</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="-bindings"></a></p>
<h3 id="używanie-wiązań-"><a class="header" href="#używanie-wiązań-">Używanie Wiązań <code>@</code></a></h3>
<p>Operator <em>at</em> <code>@</code> pozwala nam utworzyć zmienną, która przechowuje wartość w tym samym czasie, gdy testujemy tę wartość pod kątem dopasowania wzorca. Na Liście 19-29 chcemy sprawdzić, czy pole <code>id</code> w <code>Message::Hello</code> mieści się w zakresie <code>3..=7</code>. Chcemy również powiązać wartość ze zmienną <code>id</code>, aby móc jej użyć w kodzie skojarzonym z ramieniem.</p>
<figure class="listing" id="listing-19-29">
<pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello { id: id @ 3..=7 } =&gt; {
            println!("Found an id in range: {id}")
        }
        Message::Hello { id: 10..=12 } =&gt; {
            println!("Found an id in another range")
        }
        Message::Hello { id } =&gt; println!("Found some other id: {id}"),
    }
<span class="boring">}</span></code></pre>
<figcaption><a href="#listing-19-29">Lista 19-29</a>: Użycie <code>@</code> do związania się z wartością we wzorcu, jednocześnie ją testując</figcaption>
</figure>
<p>Ten przykład wydrukuje <code>Found an id in range: 5</code>. Określając <code>id @</code> przed zakresem <code>3..=7</code>, przechwytujemy dowolną wartość, która pasuje do zakresu, w zmiennej nazwanej <code>id</code>, jednocześnie testując, czy wartość pasuje do wzorca zakresu.</p>
<p>W drugim ramieniu, gdzie we wzorcu mamy określony tylko zakres, kod skojarzony z ramieniem nie ma zmiennej zawierającej faktyczną wartość pola <code>id</code>. Wartość pola <code>id</code> mogła wynosić 10, 11 lub 12, ale kod, który towarzyszy temu wzorcowi, nie wie, która to jest. Kod wzorca nie jest w stanie użyć wartości z pola <code>id</code>, ponieważ nie zapisaliśmy wartości <code>id</code> w zmiennej.</p>
<p>W ostatnim ramieniu, gdzie określiliśmy zmienną bez zakresu, mamy dostępną wartość do użycia w kodzie ramienia w zmiennej o nazwie <code>id</code>. Powodem jest to, że użyliśmy skróconej składni pól struktury. Ale w tym ramieniu nie zastosowaliśmy żadnego testu do wartości w polu <code>id</code>, tak jak zrobiliśmy to w dwóch pierwszych ramionach: dowolna wartość pasowałaby do tego wzorca.</p>
<p>Używanie <code>@</code> pozwala nam testować wartość i zapisywać ją w zmiennej w ramach jednego wzorca.</p>
<h2 id="podsumowanie"><a class="header" href="#podsumowanie">Podsumowanie</a></h2>
<p>Wzorce Rust są bardzo przydatne w rozróżnianiu różnych rodzajów danych. Używane w wyrażeniach <code>match</code>, Rust zapewnia, że Twoje wzorce obejmują każdą możliwą wartość, w przeciwnym razie Twój program się nie skompiluje. Wzorce w instrukcjach <code>let</code> i parametrach funkcji czynią te konstrukcje bardziej użytecznymi, umożliwiając dekonstrukcję wartości na mniejsze części i przypisywanie tych części do zmiennych. Możemy tworzyć proste lub złożone wzorce, aby sprostać naszym potrzebom.</p>
<p>Następnie, w przedostatnim rozdziale książki, przyjrzymy się niektórym zaawansowanym aspektom różnych funkcji Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-02-refutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="ch20-00-advanced-features.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-02-refutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="ch20-00-advanced-features.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris-2317480c.js"></script>



    </div>
    </body>
</html>
